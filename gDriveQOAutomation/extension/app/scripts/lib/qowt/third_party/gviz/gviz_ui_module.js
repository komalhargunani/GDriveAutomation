// Copyright 2014 Google Inc. All Rights Reserved.
/*jsl:ignore*/
define([
  'qowtRoot/third_party/gviz/gviz_default_module',
  'qowtRoot/third_party/gviz/gviz_format_module'
  ], function() {
// INPUT (javascript/closure/dom/tags.js)
goog.dom.tags = {};
goog.dom.tags.VOID_TAGS_ = goog.object.createSet("area base br col command embed hr img input keygen link meta param source track wbr".split(" "));
goog.dom.tags.isVoidTag = function(tagName) {
  return!0 === goog.dom.tags.VOID_TAGS_[tagName];
};
// INPUT (javascript/closure/i18n/bidi.js)
goog.i18n.bidi = {};
goog.i18n.bidi.FORCE_RTL = !1;
goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || ("ar" == goog.LOCALE.substring(0, 2).toLowerCase() || "fa" == goog.LOCALE.substring(0, 2).toLowerCase() || "he" == goog.LOCALE.substring(0, 2).toLowerCase() || "iw" == goog.LOCALE.substring(0, 2).toLowerCase() || "ps" == goog.LOCALE.substring(0, 2).toLowerCase() || "sd" == goog.LOCALE.substring(0, 2).toLowerCase() || "ug" == goog.LOCALE.substring(0, 2).toLowerCase() || "ur" == goog.LOCALE.substring(0, 2).toLowerCase() || "yi" == goog.LOCALE.substring(0, 
2).toLowerCase()) && (2 == goog.LOCALE.length || "-" == goog.LOCALE.substring(2, 3) || "_" == goog.LOCALE.substring(2, 3)) || 3 <= goog.LOCALE.length && "ckb" == goog.LOCALE.substring(0, 3).toLowerCase() && (3 == goog.LOCALE.length || "-" == goog.LOCALE.substring(3, 4) || "_" == goog.LOCALE.substring(3, 4));
goog.i18n.bidi.Format = {LRE:"\u202a", RLE:"\u202b", PDF:"\u202c", LRM:"\u200e", RLM:"\u200f"};
goog.i18n.bidi.Dir = {LTR:1, RTL:-1, NEUTRAL:0, UNKNOWN:0};
goog.i18n.bidi.RIGHT = "right";
goog.i18n.bidi.LEFT = "left";
goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;
goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
goog.i18n.bidi.toDir = function(givenDir, opt_noNeutral) {
  return "number" == typeof givenDir ? 0 < givenDir ? goog.i18n.bidi.Dir.LTR : 0 > givenDir ? goog.i18n.bidi.Dir.RTL : opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL : null == givenDir ? null : givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
};
goog.i18n.bidi.ltrChars_ = "A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff";
goog.i18n.bidi.rtlChars_ = "\u0591-\u07ff\u200f\ufb1d-\ufdff\ufe70-\ufefc";
goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;
goog.i18n.bidi.stripHtmlIfNeeded_ = function(str, opt_isStripNeeded) {
  return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, "") : str;
};
goog.i18n.bidi.rtlCharReg_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "]");
goog.i18n.bidi.ltrCharReg_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "]");
goog.i18n.bidi.hasAnyRtl = function(str, opt_isHtml) {
  return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};
goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;
goog.i18n.bidi.hasAnyLtr = function(str, opt_isHtml) {
  return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};
goog.i18n.bidi.ltrRe_ = new RegExp("^[" + goog.i18n.bidi.ltrChars_ + "]");
goog.i18n.bidi.rtlRe_ = new RegExp("^[" + goog.i18n.bidi.rtlChars_ + "]");
goog.i18n.bidi.isRtlChar = function(str) {
  return goog.i18n.bidi.rtlRe_.test(str);
};
goog.i18n.bidi.isLtrChar = function(str) {
  return goog.i18n.bidi.ltrRe_.test(str);
};
goog.i18n.bidi.isNeutralChar = function(str) {
  return!goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);
};
goog.i18n.bidi.ltrDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.rtlChars_ + "]*[" + goog.i18n.bidi.ltrChars_ + "]");
goog.i18n.bidi.rtlDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.ltrChars_ + "]*[" + goog.i18n.bidi.rtlChars_ + "]");
goog.i18n.bidi.startsWithRtl = function(str, opt_isHtml) {
  return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};
goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;
goog.i18n.bidi.startsWithLtr = function(str, opt_isHtml) {
  return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};
goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;
goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/;
goog.i18n.bidi.isNeutralText = function(str, opt_isHtml) {
  str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);
  return goog.i18n.bidi.isRequiredLtrRe_.test(str) || !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);
};
goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "][^" + goog.i18n.bidi.rtlChars_ + "]*$");
goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "][^" + goog.i18n.bidi.ltrChars_ + "]*$");
goog.i18n.bidi.endsWithLtr = function(str, opt_isHtml) {
  return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};
goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;
goog.i18n.bidi.endsWithRtl = function(str, opt_isHtml) {
  return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};
goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;
goog.i18n.bidi.rtlLocalesRe_ = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Arab|Hebr|Thaa|Nkoo|Tfng))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
goog.i18n.bidi.isRtlLanguage = function(lang) {
  return goog.i18n.bidi.rtlLocalesRe_.test(lang);
};
goog.i18n.bidi.bracketGuardHtmlRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(&lt;.*?(&gt;)+)/g;
goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
goog.i18n.bidi.guardBracketInHtml = function(s, opt_isRtlContext) {
  var useRtl = void 0 === opt_isRtlContext ? goog.i18n.bidi.hasAnyRtl(s) : opt_isRtlContext;
  return useRtl ? s.replace(goog.i18n.bidi.bracketGuardHtmlRe_, "<span dir=rtl>$&</span>") : s.replace(goog.i18n.bidi.bracketGuardHtmlRe_, "<span dir=ltr>$&</span>");
};
goog.i18n.bidi.guardBracketInText = function(s, opt_isRtlContext) {
  var useRtl = void 0 === opt_isRtlContext ? goog.i18n.bidi.hasAnyRtl(s) : opt_isRtlContext, mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;
  return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + "$&" + mark);
};
goog.i18n.bidi.enforceRtlInHtml = function(html) {
  return "<" == html.charAt(0) ? html.replace(/<\w+/, "$& dir=rtl") : "\n<span dir=rtl>" + html + "</span>";
};
goog.i18n.bidi.enforceRtlInText = function(text) {
  return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;
};
goog.i18n.bidi.enforceLtrInHtml = function(html) {
  return "<" == html.charAt(0) ? html.replace(/<\w+/, "$& dir=ltr") : "\n<span dir=ltr>" + html + "</span>";
};
goog.i18n.bidi.enforceLtrInText = function(text) {
  return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;
};
goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;
goog.i18n.bidi.leftRe_ = /left/gi;
goog.i18n.bidi.rightRe_ = /right/gi;
goog.i18n.bidi.tempRe_ = /%%%%/g;
goog.i18n.bidi.mirrorCSS = function(cssStr) {
  return cssStr.replace(goog.i18n.bidi.dimensionsRe_, ":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_, "%%%%").replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
};
goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g;
goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g;
goog.i18n.bidi.normalizeHebrewQuote = function(str) {
  return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, "$1\u05f4").replace(goog.i18n.bidi.singleQuoteSubstituteRe_, "$1\u05f3");
};
goog.i18n.bidi.wordSeparatorRe_ = /\s+/;
goog.i18n.bidi.hasNumeralsRe_ = /\d/;
goog.i18n.bidi.rtlDetectionThreshold_ = .4;
goog.i18n.bidi.estimateDirection = function(str, opt_isHtml) {
  for (var rtlCount = 0, totalCount = 0, hasWeaklyLtr = !1, tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml).split(goog.i18n.bidi.wordSeparatorRe_), i = 0;i < tokens.length;i++) {
    var token = tokens[i];
    goog.i18n.bidi.startsWithRtl(token) ? (rtlCount++, totalCount++) : goog.i18n.bidi.isRequiredLtrRe_.test(token) ? hasWeaklyLtr = !0 : goog.i18n.bidi.hasAnyLtr(token) ? totalCount++ : goog.i18n.bidi.hasNumeralsRe_.test(token) && (hasWeaklyLtr = !0);
  }
  return 0 == totalCount ? hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
};
goog.i18n.bidi.detectRtlDirectionality = function(str, opt_isHtml) {
  return goog.i18n.bidi.estimateDirection(str, opt_isHtml) == goog.i18n.bidi.Dir.RTL;
};
goog.i18n.bidi.setElementDirAndAlign = function(element, dir) {
  element && (dir = goog.i18n.bidi.toDir(dir)) && (element.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, element.dir = dir == goog.i18n.bidi.Dir.RTL ? "rtl" : "ltr");
};
goog.i18n.bidi.DirectionalString = function() {
};
// INPUT (javascript/closure/string/typedstring.js)
goog.string.TypedString = function() {
};
// INPUT (javascript/closure/string/const.js)
goog.string.Const = function() {
  this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ = "";
  this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ = goog.string.Const.TYPE_MARKER_;
};
goog.string.Const.prototype.implementsGoogStringTypedString = !0;
goog.string.Const.prototype.getTypedStringValue = function() {
  return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
};
goog.string.Const.prototype.toString = function() {
  return "Const{" + this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ + "}";
};
goog.string.Const.unwrap = function(stringConst) {
  if (stringConst instanceof goog.string.Const && stringConst.constructor === goog.string.Const && stringConst.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ === goog.string.Const.TYPE_MARKER_) {
    return stringConst.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
  }
  goog.asserts.fail("expected object of type Const, got '" + stringConst + "'");
  return "type_error:Const";
};
goog.string.Const.from = function(s) {
  return goog.string.Const.create__googStringSecurityPrivate_(s);
};
goog.string.Const.TYPE_MARKER_ = {};
goog.string.Const.create__googStringSecurityPrivate_ = function(s) {
  var stringConst = new goog.string.Const;
  stringConst.stringConstValueWithSecurityContract__googStringSecurityPrivate_ = s;
  return stringConst;
};
// INPUT (javascript/closure/html/safestyle.js)
goog.html = {};
goog.html.SafeStyle = function() {
  this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = "";
  this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
};
goog.html.SafeStyle.prototype.implementsGoogStringTypedString = !0;
goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeStyle.fromConstant = function(style) {
  var styleString = goog.string.Const.unwrap(style);
  if (0 === styleString.length) {
    return goog.html.SafeStyle.EMPTY;
  }
  goog.html.SafeStyle.checkStyle_(styleString);
  goog.asserts.assert(goog.string.endsWith(styleString, ";"), "Last character of style string is not ';': " + styleString);
  goog.asserts.assert(goog.string.contains(styleString, ":"), "Style string must contain at least one ':', to specify a \"name: value\" pair: " + styleString);
  return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(styleString);
};
goog.html.SafeStyle.checkStyle_ = function(style) {
  goog.asserts.assert(!/[<>]/.test(style), "Forbidden characters in style string: " + style);
};
goog.html.SafeStyle.prototype.getTypedStringValue = function() {
  return this.privateDoNotAccessOrElseSafeStyleWrappedValue_;
};
goog.DEBUG && (goog.html.SafeStyle.prototype.toString = function() {
  return "SafeStyle{" + this.privateDoNotAccessOrElseSafeStyleWrappedValue_ + "}";
});
goog.html.SafeStyle.unwrap = function(safeStyle) {
  if (safeStyle instanceof goog.html.SafeStyle && safeStyle.constructor === goog.html.SafeStyle && safeStyle.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
    return safeStyle.privateDoNotAccessOrElseSafeStyleWrappedValue_;
  }
  goog.asserts.fail("expected object of type SafeStyle, got '" + safeStyle + "'");
  return "type_error:SafeStyle";
};
goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse = function(style) {
  var safeStyle = new goog.html.SafeStyle;
  safeStyle.privateDoNotAccessOrElseSafeStyleWrappedValue_ = style;
  return safeStyle;
};
goog.html.SafeStyle.EMPTY = goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse("");
goog.html.SafeStyle.INNOCUOUS_STRING = "zClosurez";
goog.html.SafeStyle.create = function(map) {
  var style = "", name;
  for (name in map) {
    if (!/^[-_a-zA-Z0-9]+$/.test(name)) {
      throw Error("Name allows only [-_a-zA-Z0-9], got: " + name);
    }
    var value = map[name];
    null != value && (value instanceof goog.string.Const ? (value = goog.string.Const.unwrap(value), goog.asserts.assert(!/[{;}]/.test(value), "Value does not allow [{;}].")) : goog.html.SafeStyle.VALUE_RE_.test(value) || (goog.asserts.fail("String value allows only [-.%_!# a-zA-Z0-9], got: " + value), value = goog.html.SafeStyle.INNOCUOUS_STRING), style += name + ":" + value + ";");
  }
  if (!style) {
    return goog.html.SafeStyle.EMPTY;
  }
  goog.html.SafeStyle.checkStyle_(style);
  return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style);
};
goog.html.SafeStyle.VALUE_RE_ = /^[-.%_!# a-zA-Z0-9]+$/;
goog.html.SafeStyle.concat = function(var_args) {
  var style = "", addArgument = function(argument) {
    goog.isArray(argument) ? goog.array.forEach(argument, addArgument) : style += goog.html.SafeStyle.unwrap(argument);
  };
  goog.array.forEach(arguments, addArgument);
  return style ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style) : goog.html.SafeStyle.EMPTY;
};
// INPUT (javascript/closure/html/safeurl.js)
goog.html.SafeUrl = function() {
  this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = "";
  this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
};
goog.html.SafeUrl.INNOCUOUS_STRING = "about:invalid#zClosurez";
goog.html.SafeUrl.prototype.implementsGoogStringTypedString = !0;
goog.html.SafeUrl.prototype.getTypedStringValue = function() {
  return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
};
goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString = !0;
goog.html.SafeUrl.prototype.getDirection = function() {
  return goog.i18n.bidi.Dir.LTR;
};
goog.DEBUG && (goog.html.SafeUrl.prototype.toString = function() {
  return "SafeUrl{" + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ + "}";
});
goog.html.SafeUrl.unwrap = function(safeUrl) {
  if (safeUrl instanceof goog.html.SafeUrl && safeUrl.constructor === goog.html.SafeUrl && safeUrl.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
    return safeUrl.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
  }
  goog.asserts.fail("expected object of type SafeUrl, got '" + safeUrl + "'");
  return "type_error:SafeUrl";
};
goog.html.SafeUrl.fromConstant = function(url) {
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(url));
};
goog.html.SAFE_URL_PATTERN_ = /^(?:(?:https?|mailto):|[^&:/?#]*(?:[/?#]|$))/i;
goog.html.SafeUrl.sanitize = function(url) {
  if (url instanceof goog.html.SafeUrl) {
    return url;
  }
  url = url.implementsGoogStringTypedString ? url.getTypedStringValue() : String(url);
  url = goog.html.SAFE_URL_PATTERN_.test(url) ? goog.html.SafeUrl.normalize_(url) : goog.html.SafeUrl.INNOCUOUS_STRING;
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
};
goog.html.SafeUrl.normalize_ = function(url) {
  try {
    var normalized = encodeURI(url);
  } catch (e) {
    return goog.html.SafeUrl.INNOCUOUS_STRING;
  }
  return normalized.replace(goog.html.SafeUrl.NORMALIZE_MATCHER_, function(match) {
    return goog.html.SafeUrl.NORMALIZE_REPLACER_MAP_[match];
  });
};
goog.html.SafeUrl.NORMALIZE_MATCHER_ = /[()']|%5B|%5D|%25/g;
goog.html.SafeUrl.NORMALIZE_REPLACER_MAP_ = {"'":"%27", "(":"%28", ")":"%29", "%5B":"[", "%5D":"]", "%25":"%"};
goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = function(url) {
  var safeUrl = new goog.html.SafeUrl;
  safeUrl.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = url;
  return safeUrl;
};
// INPUT (javascript/closure/html/safehtml.js)
goog.html.SafeHtml = function() {
  this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = "";
  this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  this.dir_ = null;
};
goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString = !0;
goog.html.SafeHtml.prototype.getDirection = function() {
  return this.dir_;
};
goog.html.SafeHtml.prototype.implementsGoogStringTypedString = !0;
goog.html.SafeHtml.prototype.getTypedStringValue = function() {
  return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
};
goog.DEBUG && (goog.html.SafeHtml.prototype.toString = function() {
  return "SafeHtml{" + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ + "}";
});
goog.html.SafeHtml.unwrap = function(safeHtml) {
  if (safeHtml instanceof goog.html.SafeHtml && safeHtml.constructor === goog.html.SafeHtml && safeHtml.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
    return safeHtml.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
  }
  goog.asserts.fail("expected object of type SafeHtml, got '" + safeHtml + "'");
  return "type_error:SafeHtml";
};
goog.html.SafeHtml.htmlEscape = function(textOrHtml) {
  if (textOrHtml instanceof goog.html.SafeHtml) {
    return textOrHtml;
  }
  var dir = null;
  textOrHtml.implementsGoogI18nBidiDirectionalString && (dir = textOrHtml.getDirection());
  var textAsString;
  textAsString = textOrHtml.implementsGoogStringTypedString ? textOrHtml.getTypedStringValue() : String(textOrHtml);
  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.htmlEscape(textAsString), dir);
};
goog.html.SafeHtml.htmlEscapePreservingNewlines = function(textOrHtml) {
  if (textOrHtml instanceof goog.html.SafeHtml) {
    return textOrHtml;
  }
  var html = goog.html.SafeHtml.htmlEscape(textOrHtml);
  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.newLineToBr(goog.html.SafeHtml.unwrap(html)), html.getDirection());
};
goog.html.SafeHtml.from = goog.html.SafeHtml.htmlEscape;
goog.html.SafeHtml.VALID_NAMES_IN_TAG_ = /^[a-zA-Z0-9-]+$/;
goog.html.SafeHtml.URL_ATTRIBUTES_ = goog.object.createSet("action", "cite", "data", "formaction", "href", "manifest", "poster", "src");
goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_ = goog.object.createSet("link", "script", "style");
goog.html.SafeHtml.create = function(tagName, opt_attributes, opt_content) {
  if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(tagName)) {
    throw Error("Invalid tag name <" + tagName + ">.");
  }
  if (tagName.toLowerCase() in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_) {
    throw Error("Tag name <" + tagName + "> is not allowed for SafeHtml.");
  }
  var dir = null, result = "<" + tagName;
  if (opt_attributes) {
    for (var name in opt_attributes) {
      if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(name)) {
        throw Error('Invalid attribute name "' + name + '".');
      }
      var value = opt_attributes[name];
      if (null != value) {
        if (value instanceof goog.string.Const) {
          value = goog.string.Const.unwrap(value);
        } else {
          if ("style" == name.toLowerCase()) {
            value = goog.html.SafeHtml.getStyleValue_(value);
          } else {
            if (/^on/i.test(name)) {
              throw Error('Attribute "' + name + '" requires goog.string.Const value, "' + value + '" given.');
            }
            if (value instanceof goog.html.SafeUrl) {
              value = goog.html.SafeUrl.unwrap(value);
            } else {
              if (name.toLowerCase() in goog.html.SafeHtml.URL_ATTRIBUTES_) {
                throw Error('Attribute "' + name + '" requires goog.string.Const or goog.html.SafeUrl value, "' + value + '" given.');
              }
            }
          }
        }
        goog.asserts.assert(goog.isString(value) || goog.isNumber(value), "String or number value expected, got " + typeof value + " with value: " + value);
        result += " " + name + '="' + goog.string.htmlEscape(String(value)) + '"';
      }
    }
  }
  var content = opt_content;
  goog.isDef(content) ? goog.isArray(content) || (content = [content]) : content = [];
  if (goog.dom.tags.isVoidTag(tagName.toLowerCase())) {
    goog.asserts.assert(!content.length, "Void tag <" + tagName + "> does not allow content."), result += ">";
  } else {
    var html = goog.html.SafeHtml.concat(content), result = result + (">" + goog.html.SafeHtml.unwrap(html) + "</" + tagName + ">"), dir = html.getDirection()
  }
  var dirAttribute = opt_attributes && opt_attributes.dir;
  dirAttribute && (dir = /^(ltr|rtl|auto)$/i.test(dirAttribute) ? goog.i18n.bidi.Dir.NEUTRAL : null);
  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(result, dir);
};
goog.html.SafeHtml.getStyleValue_ = function(value) {
  if (!goog.isObject(value)) {
    throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, ' + typeof value + " given: " + value);
  }
  value instanceof goog.html.SafeStyle || (value = goog.html.SafeStyle.create(value));
  return goog.html.SafeStyle.unwrap(value);
};
goog.html.SafeHtml.createWithDir = function(dir, tagName, opt_attributes, opt_content) {
  var html = goog.html.SafeHtml.create(tagName, opt_attributes, opt_content);
  html.dir_ = dir;
  return html;
};
goog.html.SafeHtml.concat = function(var_args) {
  var dir = goog.i18n.bidi.Dir.NEUTRAL, content = "", addArgument = function(argument) {
    if (goog.isArray(argument)) {
      goog.array.forEach(argument, addArgument);
    } else {
      var html = goog.html.SafeHtml.htmlEscape(argument);
      content += goog.html.SafeHtml.unwrap(html);
      var htmlDir = html.getDirection();
      dir == goog.i18n.bidi.Dir.NEUTRAL ? dir = htmlDir : htmlDir != goog.i18n.bidi.Dir.NEUTRAL && dir != htmlDir && (dir = null);
    }
  };
  goog.array.forEach(arguments, addArgument);
  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(content, dir);
};
goog.html.SafeHtml.concatWithDir = function(dir, var_args) {
  var html = goog.html.SafeHtml.concat(goog.array.slice(arguments, 1));
  html.dir_ = dir;
  return html;
};
goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse = function(html, dir) {
  var safeHtml = new goog.html.SafeHtml;
  safeHtml.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = html;
  safeHtml.dir_ = dir;
  return safeHtml;
};
goog.html.SafeHtml.EMPTY = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("", goog.i18n.bidi.Dir.NEUTRAL);
// INPUT (javascript/closure/dom/safe.js)
goog.dom.safe = {};
goog.dom.safe.setInnerHtml = function(elem, html) {
  elem.innerHTML = goog.html.SafeHtml.unwrap(html);
};
goog.dom.safe.setOuterHtml = function(elem, html) {
  elem.outerHTML = goog.html.SafeHtml.unwrap(html);
};
goog.dom.safe.documentWrite = function(doc, html) {
  doc.write(goog.html.SafeHtml.unwrap(html));
};
goog.dom.safe.setAnchorHref = function(anchor, url) {
  var safeUrl;
  safeUrl = url instanceof goog.html.SafeUrl ? url : goog.html.SafeUrl.sanitize(url);
  anchor.href = goog.html.SafeUrl.unwrap(safeUrl);
};
goog.dom.safe.setLocationHref = function(loc, url) {
  var safeUrl;
  safeUrl = url instanceof goog.html.SafeUrl ? url : goog.html.SafeUrl.sanitize(url);
  loc.href = goog.html.SafeUrl.unwrap(safeUrl);
};
// INPUT (javascript/closure/html/trustedresourceurl.js)
goog.html.TrustedResourceUrl = function() {
  this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = "";
  this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
};
goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString = !0;
goog.html.TrustedResourceUrl.prototype.getTypedStringValue = function() {
  return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;
};
goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString = !0;
goog.html.TrustedResourceUrl.prototype.getDirection = function() {
  return goog.i18n.bidi.Dir.LTR;
};
goog.DEBUG && (goog.html.TrustedResourceUrl.prototype.toString = function() {
  return "TrustedResourceUrl{" + this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + "}";
});
goog.html.TrustedResourceUrl.unwrap = function(trustedResourceUrl) {
  if (trustedResourceUrl instanceof goog.html.TrustedResourceUrl && trustedResourceUrl.constructor === goog.html.TrustedResourceUrl && trustedResourceUrl.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
    return trustedResourceUrl.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;
  }
  goog.asserts.fail("expected object of type TrustedResourceUrl, got '" + trustedResourceUrl + "'");
  return "type_error:TrustedResourceUrl";
};
goog.html.TrustedResourceUrl.fromConstant = function(url) {
  return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(url));
};
goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(url) {
  var trustedResourceUrl = new goog.html.TrustedResourceUrl;
  trustedResourceUrl.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = url;
  return trustedResourceUrl;
};
// INPUT (javascript/closure/html/legacyconversions.js)
goog.html.legacyconversions = {};
goog.html.legacyconversions.ALLOW_LEGACY_CONVERSIONS = !0;
goog.html.legacyconversions.safeHtmlFromString = function(html) {
  goog.html.legacyconversions.throwIfConversionDisallowed_();
  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(html, null);
};
goog.html.legacyconversions.trustedResourceUrlFromString = function(url) {
  goog.html.legacyconversions.throwIfConversionDisallowed_();
  return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(url);
};
goog.html.legacyconversions.safeUrlFromString = function(url) {
  goog.html.legacyconversions.throwIfConversionDisallowed_();
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
};
goog.html.legacyconversions.reportCallback_ = goog.nullFunction;
goog.html.legacyconversions.setReportCallback = function(callback) {
  goog.html.legacyconversions.reportCallback_ = callback;
};
goog.html.legacyconversions.throwIfConversionDisallowed_ = function() {
  if (!goog.html.legacyconversions.ALLOW_LEGACY_CONVERSIONS) {
    throw Error("Error: Legacy conversion from string to goog.html types is disabled");
  }
  goog.html.legacyconversions.reportCallback_();
};
// INPUT (javascript/closure/style/bidi.js)
goog.style.bidi = {};
goog.style.bidi.getScrollLeft = function(element) {
  var isRtl = goog.style.isRightToLeft(element);
  if (isRtl && goog.userAgent.GECKO) {
    return-element.scrollLeft;
  }
  if (isRtl && (!goog.userAgent.IE || !goog.userAgent.isVersionOrHigher("8"))) {
    var overflowX = goog.style.getComputedOverflowX(element);
    if ("visible" != overflowX) {
      return element.scrollWidth - element.clientWidth - element.scrollLeft;
    }
  }
  return element.scrollLeft;
};
goog.style.bidi.getOffsetStart = function(element) {
  var offsetLeftForReal = element.offsetLeft, bestParent = element.offsetParent;
  bestParent || "fixed" != goog.style.getComputedPosition(element) || (bestParent = goog.dom.getOwnerDocument(element).documentElement);
  if (!bestParent) {
    return offsetLeftForReal;
  }
  if (goog.userAgent.GECKO) {
    var borderWidths = goog.style.getBorderBox(bestParent), offsetLeftForReal = offsetLeftForReal + borderWidths.left
  } else {
    goog.userAgent.isDocumentModeOrHigher(8) && !goog.userAgent.isDocumentModeOrHigher(9) && (borderWidths = goog.style.getBorderBox(bestParent), offsetLeftForReal -= borderWidths.left);
  }
  if (goog.style.isRightToLeft(bestParent)) {
    var elementRightOffset = offsetLeftForReal + element.offsetWidth;
    return bestParent.clientWidth - elementRightOffset;
  }
  return offsetLeftForReal;
};
goog.style.bidi.setScrollOffset = function(element, offsetStart) {
  offsetStart = Math.max(offsetStart, 0);
  goog.style.isRightToLeft(element) ? goog.userAgent.GECKO ? element.scrollLeft = -offsetStart : goog.userAgent.IE && goog.userAgent.isVersionOrHigher("8") ? element.scrollLeft = offsetStart : element.scrollLeft = element.scrollWidth - offsetStart - element.clientWidth : element.scrollLeft = offsetStart;
};
goog.style.bidi.setPosition = function(elem, left, top, isRtl) {
  goog.isNull(top) || (elem.style.top = top + "px");
  isRtl ? (elem.style.right = left + "px", elem.style.left = "") : (elem.style.left = left + "px", elem.style.right = "");
};
// INPUT (javascript/closure/positioning/positioning.js)
goog.positioning = {};
goog.positioning.Corner = {TOP_LEFT:0, TOP_RIGHT:2, BOTTOM_LEFT:1, BOTTOM_RIGHT:3, TOP_START:4, TOP_END:6, BOTTOM_START:5, BOTTOM_END:7};
goog.positioning.CornerBit = {BOTTOM:1, RIGHT:2, FLIP_RTL:4};
goog.positioning.Overflow = {IGNORE:0, ADJUST_X:1, FAIL_X:2, ADJUST_Y:4, FAIL_Y:8, RESIZE_WIDTH:16, RESIZE_HEIGHT:32, ADJUST_X_EXCEPT_OFFSCREEN:65, ADJUST_Y_EXCEPT_OFFSCREEN:132};
goog.positioning.OverflowStatus = {NONE:0, ADJUSTED_X:1, ADJUSTED_Y:2, WIDTH_ADJUSTED:4, HEIGHT_ADJUSTED:8, FAILED_LEFT:16, FAILED_RIGHT:32, FAILED_TOP:64, FAILED_BOTTOM:128, FAILED_OUTSIDE_VIEWPORT:256};
goog.positioning.OverflowStatus.FAILED = goog.positioning.OverflowStatus.FAILED_LEFT | goog.positioning.OverflowStatus.FAILED_RIGHT | goog.positioning.OverflowStatus.FAILED_TOP | goog.positioning.OverflowStatus.FAILED_BOTTOM | goog.positioning.OverflowStatus.FAILED_OUTSIDE_VIEWPORT;
goog.positioning.OverflowStatus.FAILED_HORIZONTAL = goog.positioning.OverflowStatus.FAILED_LEFT | goog.positioning.OverflowStatus.FAILED_RIGHT;
goog.positioning.OverflowStatus.FAILED_VERTICAL = goog.positioning.OverflowStatus.FAILED_TOP | goog.positioning.OverflowStatus.FAILED_BOTTOM;
goog.positioning.positionAtAnchor = function(anchorElement, anchorElementCorner, movableElement, movableElementCorner, opt_offset, opt_margin, opt_overflow, opt_preferredSize, opt_viewport) {
  goog.asserts.assert(movableElement);
  var movableParentTopLeft = goog.positioning.getOffsetParentPageOffset(movableElement), anchorRect = goog.positioning.getVisiblePart_(anchorElement);
  goog.style.translateRectForAnotherFrame(anchorRect, goog.dom.getDomHelper(anchorElement), goog.dom.getDomHelper(movableElement));
  var corner = goog.positioning.getEffectiveCorner(anchorElement, anchorElementCorner), absolutePos = new goog.math.Coordinate(corner & goog.positioning.CornerBit.RIGHT ? anchorRect.left + anchorRect.width : anchorRect.left, corner & goog.positioning.CornerBit.BOTTOM ? anchorRect.top + anchorRect.height : anchorRect.top), absolutePos = goog.math.Coordinate.difference(absolutePos, movableParentTopLeft);
  opt_offset && (absolutePos.x += (corner & goog.positioning.CornerBit.RIGHT ? -1 : 1) * opt_offset.x, absolutePos.y += (corner & goog.positioning.CornerBit.BOTTOM ? -1 : 1) * opt_offset.y);
  var viewport;
  if (opt_overflow) {
    if (opt_viewport) {
      viewport = opt_viewport;
    } else {
      if (viewport = goog.style.getVisibleRectForElement(movableElement)) {
        viewport.top -= movableParentTopLeft.y, viewport.right -= movableParentTopLeft.x, viewport.bottom -= movableParentTopLeft.y, viewport.left -= movableParentTopLeft.x;
      }
    }
  }
  return goog.positioning.positionAtCoordinate(absolutePos, movableElement, movableElementCorner, opt_margin, viewport, opt_overflow, opt_preferredSize);
};
goog.positioning.getOffsetParentPageOffset = function(movableElement) {
  var movableParentTopLeft, parent = movableElement.offsetParent;
  if (parent) {
    var isBody = parent.tagName == goog.dom.TagName.HTML || parent.tagName == goog.dom.TagName.BODY;
    isBody && "static" == goog.style.getComputedPosition(parent) || (movableParentTopLeft = goog.style.getPageOffset(parent), isBody || (movableParentTopLeft = goog.math.Coordinate.difference(movableParentTopLeft, new goog.math.Coordinate(goog.style.bidi.getScrollLeft(parent), parent.scrollTop))));
  }
  return movableParentTopLeft || new goog.math.Coordinate;
};
goog.positioning.getVisiblePart_ = function(el) {
  var rect = goog.style.getBounds(el), visibleBox = goog.style.getVisibleRectForElement(el);
  visibleBox && rect.intersection(goog.math.Rect.createFromBox(visibleBox));
  return rect;
};
goog.positioning.positionAtCoordinate = function(absolutePos, movableElement, movableElementCorner, opt_margin, opt_viewport, opt_overflow, opt_preferredSize) {
  absolutePos = absolutePos.clone();
  var corner = goog.positioning.getEffectiveCorner(movableElement, movableElementCorner), elementSize = goog.style.getSize(movableElement), size = opt_preferredSize ? opt_preferredSize.clone() : elementSize.clone(), positionResult = goog.positioning.getPositionAtCoordinate(absolutePos, size, corner, opt_margin, opt_viewport, opt_overflow);
  if (positionResult.status & goog.positioning.OverflowStatus.FAILED) {
    return positionResult.status;
  }
  goog.style.setPosition(movableElement, positionResult.rect.getTopLeft());
  size = positionResult.rect.getSize();
  goog.math.Size.equals(elementSize, size) || goog.style.setBorderBoxSize(movableElement, size);
  return positionResult.status;
};
goog.positioning.getPositionAtCoordinate = function(absolutePos, elementSize, elementCorner, opt_margin, opt_viewport, opt_overflow) {
  absolutePos = absolutePos.clone();
  elementSize = elementSize.clone();
  var status = goog.positioning.OverflowStatus.NONE;
  if (opt_margin || elementCorner != goog.positioning.Corner.TOP_LEFT) {
    elementCorner & goog.positioning.CornerBit.RIGHT ? absolutePos.x -= elementSize.width + (opt_margin ? opt_margin.right : 0) : opt_margin && (absolutePos.x += opt_margin.left), elementCorner & goog.positioning.CornerBit.BOTTOM ? absolutePos.y -= elementSize.height + (opt_margin ? opt_margin.bottom : 0) : opt_margin && (absolutePos.y += opt_margin.top);
  }
  opt_overflow && (status = opt_viewport ? goog.positioning.adjustForViewport_(absolutePos, elementSize, opt_viewport, opt_overflow) : goog.positioning.OverflowStatus.FAILED_OUTSIDE_VIEWPORT);
  var rect = new goog.math.Rect(0, 0, 0, 0);
  rect.left = absolutePos.x;
  rect.top = absolutePos.y;
  rect.width = elementSize.width;
  rect.height = elementSize.height;
  return{rect:rect, status:status};
};
goog.positioning.adjustForViewport_ = function(pos, size, viewport, overflow) {
  var status = goog.positioning.OverflowStatus.NONE, ADJUST_X_EXCEPT_OFFSCREEN = goog.positioning.Overflow.ADJUST_X_EXCEPT_OFFSCREEN, ADJUST_Y_EXCEPT_OFFSCREEN = goog.positioning.Overflow.ADJUST_Y_EXCEPT_OFFSCREEN;
  (overflow & ADJUST_X_EXCEPT_OFFSCREEN) == ADJUST_X_EXCEPT_OFFSCREEN && (pos.x < viewport.left || pos.x >= viewport.right) && (overflow &= ~goog.positioning.Overflow.ADJUST_X);
  (overflow & ADJUST_Y_EXCEPT_OFFSCREEN) == ADJUST_Y_EXCEPT_OFFSCREEN && (pos.y < viewport.top || pos.y >= viewport.bottom) && (overflow &= ~goog.positioning.Overflow.ADJUST_Y);
  pos.x < viewport.left && overflow & goog.positioning.Overflow.ADJUST_X && (pos.x = viewport.left, status |= goog.positioning.OverflowStatus.ADJUSTED_X);
  pos.x < viewport.left && pos.x + size.width > viewport.right && overflow & goog.positioning.Overflow.RESIZE_WIDTH && (size.width = Math.max(size.width - (pos.x + size.width - viewport.right), 0), status |= goog.positioning.OverflowStatus.WIDTH_ADJUSTED);
  pos.x + size.width > viewport.right && overflow & goog.positioning.Overflow.ADJUST_X && (pos.x = Math.max(viewport.right - size.width, viewport.left), status |= goog.positioning.OverflowStatus.ADJUSTED_X);
  overflow & goog.positioning.Overflow.FAIL_X && (status = status | (pos.x < viewport.left ? goog.positioning.OverflowStatus.FAILED_LEFT : 0) | (pos.x + size.width > viewport.right ? goog.positioning.OverflowStatus.FAILED_RIGHT : 0));
  pos.y < viewport.top && overflow & goog.positioning.Overflow.ADJUST_Y && (pos.y = viewport.top, status |= goog.positioning.OverflowStatus.ADJUSTED_Y);
  pos.y <= viewport.top && pos.y + size.height < viewport.bottom && overflow & goog.positioning.Overflow.RESIZE_HEIGHT && (size.height = Math.max(size.height - (viewport.top - pos.y), 0), pos.y = viewport.top, status |= goog.positioning.OverflowStatus.HEIGHT_ADJUSTED);
  pos.y >= viewport.top && pos.y + size.height > viewport.bottom && overflow & goog.positioning.Overflow.RESIZE_HEIGHT && (size.height = Math.max(size.height - (pos.y + size.height - viewport.bottom), 0), status |= goog.positioning.OverflowStatus.HEIGHT_ADJUSTED);
  pos.y + size.height > viewport.bottom && overflow & goog.positioning.Overflow.ADJUST_Y && (pos.y = Math.max(viewport.bottom - size.height, viewport.top), status |= goog.positioning.OverflowStatus.ADJUSTED_Y);
  overflow & goog.positioning.Overflow.FAIL_Y && (status = status | (pos.y < viewport.top ? goog.positioning.OverflowStatus.FAILED_TOP : 0) | (pos.y + size.height > viewport.bottom ? goog.positioning.OverflowStatus.FAILED_BOTTOM : 0));
  return status;
};
goog.positioning.getEffectiveCorner = function(element, corner) {
  return(corner & goog.positioning.CornerBit.FLIP_RTL && goog.style.isRightToLeft(element) ? corner ^ goog.positioning.CornerBit.RIGHT : corner) & ~goog.positioning.CornerBit.FLIP_RTL;
};
goog.positioning.flipCornerHorizontal = function(corner) {
  return corner ^ goog.positioning.CornerBit.RIGHT;
};
goog.positioning.flipCornerVertical = function(corner) {
  return corner ^ goog.positioning.CornerBit.BOTTOM;
};
goog.positioning.flipCorner = function(corner) {
  return corner ^ goog.positioning.CornerBit.BOTTOM ^ goog.positioning.CornerBit.RIGHT;
};
// INPUT (javascript/closure/positioning/abstractposition.js)
goog.positioning.AbstractPosition = function() {
};
goog.positioning.AbstractPosition.prototype.reposition = function() {
};
// INPUT (javascript/closure/positioning/anchoredposition.js)
goog.positioning.AnchoredPosition = function(anchorElement, corner, opt_overflow) {
  this.element = anchorElement;
  this.corner = corner;
  this.overflow_ = opt_overflow;
};
goog.inherits(goog.positioning.AnchoredPosition, goog.positioning.AbstractPosition);
goog.positioning.AnchoredPosition.prototype.reposition = function(movableElement, movableCorner, opt_margin) {
  goog.positioning.positionAtAnchor(this.element, this.corner, movableElement, movableCorner, void 0, opt_margin, this.overflow_);
};
// INPUT (javascript/closure/positioning/viewportposition.js)
goog.positioning.ViewportPosition = function(arg1, opt_arg2) {
  this.coordinate = arg1 instanceof goog.math.Coordinate ? arg1 : new goog.math.Coordinate(arg1, opt_arg2);
};
goog.inherits(goog.positioning.ViewportPosition, goog.positioning.AbstractPosition);
goog.positioning.ViewportPosition.prototype.reposition = function(element, popupCorner, opt_margin, opt_preferredSize) {
  goog.positioning.positionAtAnchor(goog.style.getClientViewportElement(element), goog.positioning.Corner.TOP_LEFT, element, popupCorner, this.coordinate, opt_margin, null, opt_preferredSize);
};
// INPUT (javascript/closure/positioning/absoluteposition.js)
goog.positioning.AbsolutePosition = function(arg1, opt_arg2) {
  this.coordinate = arg1 instanceof goog.math.Coordinate ? arg1 : new goog.math.Coordinate(arg1, opt_arg2);
};
goog.inherits(goog.positioning.AbsolutePosition, goog.positioning.AbstractPosition);
goog.positioning.AbsolutePosition.prototype.reposition = function(movableElement, movableCorner, opt_margin, opt_preferredSize) {
  goog.positioning.positionAtCoordinate(this.coordinate, movableElement, movableCorner, opt_margin, null, null, opt_preferredSize);
};
// INPUT (javascript/closure/positioning/anchoredviewportposition.js)
goog.positioning.AnchoredViewportPosition = function(anchorElement, corner, opt_adjust, opt_overflowConstraint) {
  goog.positioning.AnchoredPosition.call(this, anchorElement, corner);
  this.lastResortOverflow_ = opt_adjust ? goog.positioning.Overflow.ADJUST_X | goog.positioning.Overflow.ADJUST_Y : goog.positioning.Overflow.IGNORE;
  this.overflowConstraint_ = opt_overflowConstraint || void 0;
};
goog.inherits(goog.positioning.AnchoredViewportPosition, goog.positioning.AnchoredPosition);
goog.positioning.AnchoredViewportPosition.prototype.getLastResortOverflow = function() {
  return this.lastResortOverflow_;
};
goog.positioning.AnchoredViewportPosition.prototype.setLastResortOverflow = function(lastResortOverflow) {
  this.lastResortOverflow_ = lastResortOverflow;
};
goog.positioning.AnchoredViewportPosition.prototype.reposition = function(movableElement, movableCorner, opt_margin, opt_preferredSize) {
  var status = goog.positioning.positionAtAnchor(this.element, this.corner, movableElement, movableCorner, null, opt_margin, goog.positioning.Overflow.FAIL_X | goog.positioning.Overflow.FAIL_Y, opt_preferredSize, this.overflowConstraint_);
  if (status & goog.positioning.OverflowStatus.FAILED) {
    var cornerFallback = this.adjustCorner(status, this.corner), movableCornerFallback = this.adjustCorner(status, movableCorner), status = goog.positioning.positionAtAnchor(this.element, cornerFallback, movableElement, movableCornerFallback, null, opt_margin, goog.positioning.Overflow.FAIL_X | goog.positioning.Overflow.FAIL_Y, opt_preferredSize, this.overflowConstraint_);
    status & goog.positioning.OverflowStatus.FAILED && (cornerFallback = this.adjustCorner(status, cornerFallback), movableCornerFallback = this.adjustCorner(status, movableCornerFallback), goog.positioning.positionAtAnchor(this.element, cornerFallback, movableElement, movableCornerFallback, null, opt_margin, this.getLastResortOverflow(), opt_preferredSize, this.overflowConstraint_));
  }
};
goog.positioning.AnchoredViewportPosition.prototype.adjustCorner = function(status, corner) {
  status & goog.positioning.OverflowStatus.FAILED_HORIZONTAL && (corner = goog.positioning.flipCornerHorizontal(corner));
  status & goog.positioning.OverflowStatus.FAILED_VERTICAL && (corner = goog.positioning.flipCornerVertical(corner));
  return corner;
};
// INPUT (javascript/closure/positioning/clientposition.js)
goog.positioning.ClientPosition = function(arg1, opt_arg2) {
  this.coordinate = arg1 instanceof goog.math.Coordinate ? arg1 : new goog.math.Coordinate(arg1, opt_arg2);
};
goog.inherits(goog.positioning.ClientPosition, goog.positioning.AbstractPosition);
goog.positioning.ClientPosition.prototype.reposition = function(movableElement, movableElementCorner, opt_margin, opt_preferredSize) {
  goog.asserts.assert(movableElement);
  var viewportOffset = goog.style.getViewportPageOffset(goog.dom.getOwnerDocument(movableElement)), x = this.coordinate.x + viewportOffset.x, y = this.coordinate.y + viewportOffset.y, movableParentTopLeft = goog.positioning.getOffsetParentPageOffset(movableElement), x = x - movableParentTopLeft.x, y = y - movableParentTopLeft.y;
  goog.positioning.positionAtCoordinate(new goog.math.Coordinate(x, y), movableElement, movableElementCorner, opt_margin, null, null, opt_preferredSize);
};
// INPUT (javascript/closure/positioning/viewportclientposition.js)
goog.positioning.ViewportClientPosition = function(arg1, opt_arg2) {
  goog.positioning.ClientPosition.call(this, arg1, opt_arg2);
};
goog.inherits(goog.positioning.ViewportClientPosition, goog.positioning.ClientPosition);
goog.positioning.ViewportClientPosition.prototype.lastResortOverflow_ = 0;
goog.positioning.ViewportClientPosition.prototype.setLastResortOverflow = function(overflow) {
  this.lastResortOverflow_ = overflow;
};
goog.positioning.ViewportClientPosition.prototype.reposition = function(element, popupCorner, opt_margin, opt_preferredSize) {
  var viewportElt = goog.style.getClientViewportElement(element), viewport = goog.style.getVisibleRectForElement(viewportElt), scrollEl = goog.dom.getDomHelper(element).getDocumentScrollElement(), clientPos = new goog.math.Coordinate(this.coordinate.x + scrollEl.scrollLeft, this.coordinate.y + scrollEl.scrollTop), failXY = goog.positioning.Overflow.FAIL_X | goog.positioning.Overflow.FAIL_Y, corner = popupCorner, status = goog.positioning.positionAtCoordinate(clientPos, element, corner, opt_margin, 
  viewport, failXY, opt_preferredSize);
  if (0 != (status & goog.positioning.OverflowStatus.FAILED)) {
    if (status & goog.positioning.OverflowStatus.FAILED_LEFT || status & goog.positioning.OverflowStatus.FAILED_RIGHT) {
      corner = goog.positioning.flipCornerHorizontal(corner);
    }
    if (status & goog.positioning.OverflowStatus.FAILED_TOP || status & goog.positioning.OverflowStatus.FAILED_BOTTOM) {
      corner = goog.positioning.flipCornerVertical(corner);
    }
    status = goog.positioning.positionAtCoordinate(clientPos, element, corner, opt_margin, viewport, failXY, opt_preferredSize);
    0 != (status & goog.positioning.OverflowStatus.FAILED) && goog.positioning.positionAtCoordinate(clientPos, element, popupCorner, opt_margin, viewport, this.lastResortOverflow_, opt_preferredSize);
  }
};
// INPUT (javascript/closure/events/keycodes.js)
goog.events.KeyCodes = {WIN_KEY_FF_LINUX:0, MAC_ENTER:3, BACKSPACE:8, TAB:9, NUM_CENTER:12, ENTER:13, SHIFT:16, CTRL:17, ALT:18, PAUSE:19, CAPS_LOCK:20, ESC:27, SPACE:32, PAGE_UP:33, PAGE_DOWN:34, END:35, HOME:36, LEFT:37, UP:38, RIGHT:39, DOWN:40, PRINT_SCREEN:44, INSERT:45, DELETE:46, ZERO:48, ONE:49, TWO:50, THREE:51, FOUR:52, FIVE:53, SIX:54, SEVEN:55, EIGHT:56, NINE:57, FF_SEMICOLON:59, FF_EQUALS:61, FF_DASH:173, QUESTION_MARK:63, A:65, B:66, C:67, D:68, E:69, F:70, G:71, H:72, I:73, J:74, K:75, 
L:76, M:77, N:78, O:79, P:80, Q:81, R:82, S:83, T:84, U:85, V:86, W:87, X:88, Y:89, Z:90, META:91, WIN_KEY_RIGHT:92, CONTEXT_MENU:93, NUM_ZERO:96, NUM_ONE:97, NUM_TWO:98, NUM_THREE:99, NUM_FOUR:100, NUM_FIVE:101, NUM_SIX:102, NUM_SEVEN:103, NUM_EIGHT:104, NUM_NINE:105, NUM_MULTIPLY:106, NUM_PLUS:107, NUM_MINUS:109, NUM_PERIOD:110, NUM_DIVISION:111, F1:112, F2:113, F3:114, F4:115, F5:116, F6:117, F7:118, F8:119, F9:120, F10:121, F11:122, F12:123, NUMLOCK:144, SCROLL_LOCK:145, FIRST_MEDIA_KEY:166, 
LAST_MEDIA_KEY:183, SEMICOLON:186, DASH:189, EQUALS:187, COMMA:188, PERIOD:190, SLASH:191, APOSTROPHE:192, TILDE:192, SINGLE_QUOTE:222, OPEN_SQUARE_BRACKET:219, BACKSLASH:220, CLOSE_SQUARE_BRACKET:221, WIN_KEY:224, MAC_FF_META:224, MAC_WK_CMD_LEFT:91, MAC_WK_CMD_RIGHT:93, WIN_IME:229, PHANTOM:255};
goog.events.KeyCodes.isTextModifyingKeyEvent = function(e) {
  if (e.altKey && !e.ctrlKey || e.metaKey || e.keyCode >= goog.events.KeyCodes.F1 && e.keyCode <= goog.events.KeyCodes.F12) {
    return!1;
  }
  switch(e.keyCode) {
    case goog.events.KeyCodes.ALT:
    ;
    case goog.events.KeyCodes.CAPS_LOCK:
    ;
    case goog.events.KeyCodes.CONTEXT_MENU:
    ;
    case goog.events.KeyCodes.CTRL:
    ;
    case goog.events.KeyCodes.DOWN:
    ;
    case goog.events.KeyCodes.END:
    ;
    case goog.events.KeyCodes.ESC:
    ;
    case goog.events.KeyCodes.HOME:
    ;
    case goog.events.KeyCodes.INSERT:
    ;
    case goog.events.KeyCodes.LEFT:
    ;
    case goog.events.KeyCodes.MAC_FF_META:
    ;
    case goog.events.KeyCodes.META:
    ;
    case goog.events.KeyCodes.NUMLOCK:
    ;
    case goog.events.KeyCodes.NUM_CENTER:
    ;
    case goog.events.KeyCodes.PAGE_DOWN:
    ;
    case goog.events.KeyCodes.PAGE_UP:
    ;
    case goog.events.KeyCodes.PAUSE:
    ;
    case goog.events.KeyCodes.PHANTOM:
    ;
    case goog.events.KeyCodes.PRINT_SCREEN:
    ;
    case goog.events.KeyCodes.RIGHT:
    ;
    case goog.events.KeyCodes.SCROLL_LOCK:
    ;
    case goog.events.KeyCodes.SHIFT:
    ;
    case goog.events.KeyCodes.UP:
    ;
    case goog.events.KeyCodes.WIN_KEY:
    ;
    case goog.events.KeyCodes.WIN_KEY_RIGHT:
      return!1;
    case goog.events.KeyCodes.WIN_KEY_FF_LINUX:
      return!goog.userAgent.GECKO;
    default:
      return e.keyCode < goog.events.KeyCodes.FIRST_MEDIA_KEY || e.keyCode > goog.events.KeyCodes.LAST_MEDIA_KEY;
  }
};
goog.events.KeyCodes.firesKeyPressEvent = function(keyCode, opt_heldKeyCode, opt_shiftKey, opt_ctrlKey, opt_altKey) {
  if (!(goog.userAgent.IE || goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher("525"))) {
    return!0;
  }
  if (goog.userAgent.MAC && opt_altKey) {
    return goog.events.KeyCodes.isCharacterKey(keyCode);
  }
  if (opt_altKey && !opt_ctrlKey) {
    return!1;
  }
  goog.isNumber(opt_heldKeyCode) && (opt_heldKeyCode = goog.events.KeyCodes.normalizeKeyCode(opt_heldKeyCode));
  if (!opt_shiftKey && (opt_heldKeyCode == goog.events.KeyCodes.CTRL || opt_heldKeyCode == goog.events.KeyCodes.ALT || goog.userAgent.MAC && opt_heldKeyCode == goog.events.KeyCodes.META)) {
    return!1;
  }
  if (goog.userAgent.WEBKIT && opt_ctrlKey && opt_shiftKey) {
    switch(keyCode) {
      case goog.events.KeyCodes.BACKSLASH:
      ;
      case goog.events.KeyCodes.OPEN_SQUARE_BRACKET:
      ;
      case goog.events.KeyCodes.CLOSE_SQUARE_BRACKET:
      ;
      case goog.events.KeyCodes.TILDE:
      ;
      case goog.events.KeyCodes.SEMICOLON:
      ;
      case goog.events.KeyCodes.DASH:
      ;
      case goog.events.KeyCodes.EQUALS:
      ;
      case goog.events.KeyCodes.COMMA:
      ;
      case goog.events.KeyCodes.PERIOD:
      ;
      case goog.events.KeyCodes.SLASH:
      ;
      case goog.events.KeyCodes.APOSTROPHE:
      ;
      case goog.events.KeyCodes.SINGLE_QUOTE:
        return!1;
    }
  }
  if (goog.userAgent.IE && opt_ctrlKey && opt_heldKeyCode == keyCode) {
    return!1;
  }
  switch(keyCode) {
    case goog.events.KeyCodes.ENTER:
      return!0;
    case goog.events.KeyCodes.ESC:
      return!goog.userAgent.WEBKIT;
  }
  return goog.events.KeyCodes.isCharacterKey(keyCode);
};
goog.events.KeyCodes.isCharacterKey = function(keyCode) {
  if (keyCode >= goog.events.KeyCodes.ZERO && keyCode <= goog.events.KeyCodes.NINE || keyCode >= goog.events.KeyCodes.NUM_ZERO && keyCode <= goog.events.KeyCodes.NUM_MULTIPLY || keyCode >= goog.events.KeyCodes.A && keyCode <= goog.events.KeyCodes.Z || goog.userAgent.WEBKIT && 0 == keyCode) {
    return!0;
  }
  switch(keyCode) {
    case goog.events.KeyCodes.SPACE:
    ;
    case goog.events.KeyCodes.QUESTION_MARK:
    ;
    case goog.events.KeyCodes.NUM_PLUS:
    ;
    case goog.events.KeyCodes.NUM_MINUS:
    ;
    case goog.events.KeyCodes.NUM_PERIOD:
    ;
    case goog.events.KeyCodes.NUM_DIVISION:
    ;
    case goog.events.KeyCodes.SEMICOLON:
    ;
    case goog.events.KeyCodes.FF_SEMICOLON:
    ;
    case goog.events.KeyCodes.DASH:
    ;
    case goog.events.KeyCodes.EQUALS:
    ;
    case goog.events.KeyCodes.FF_EQUALS:
    ;
    case goog.events.KeyCodes.COMMA:
    ;
    case goog.events.KeyCodes.PERIOD:
    ;
    case goog.events.KeyCodes.SLASH:
    ;
    case goog.events.KeyCodes.APOSTROPHE:
    ;
    case goog.events.KeyCodes.SINGLE_QUOTE:
    ;
    case goog.events.KeyCodes.OPEN_SQUARE_BRACKET:
    ;
    case goog.events.KeyCodes.BACKSLASH:
    ;
    case goog.events.KeyCodes.CLOSE_SQUARE_BRACKET:
      return!0;
    default:
      return!1;
  }
};
goog.events.KeyCodes.normalizeKeyCode = function(keyCode) {
  return goog.userAgent.GECKO ? goog.events.KeyCodes.normalizeGeckoKeyCode(keyCode) : goog.userAgent.MAC && goog.userAgent.WEBKIT ? goog.events.KeyCodes.normalizeMacWebKitKeyCode(keyCode) : keyCode;
};
goog.events.KeyCodes.normalizeGeckoKeyCode = function(keyCode) {
  switch(keyCode) {
    case goog.events.KeyCodes.FF_EQUALS:
      return goog.events.KeyCodes.EQUALS;
    case goog.events.KeyCodes.FF_SEMICOLON:
      return goog.events.KeyCodes.SEMICOLON;
    case goog.events.KeyCodes.FF_DASH:
      return goog.events.KeyCodes.DASH;
    case goog.events.KeyCodes.MAC_FF_META:
      return goog.events.KeyCodes.META;
    case goog.events.KeyCodes.WIN_KEY_FF_LINUX:
      return goog.events.KeyCodes.WIN_KEY;
    default:
      return keyCode;
  }
};
goog.events.KeyCodes.normalizeMacWebKitKeyCode = function(keyCode) {
  switch(keyCode) {
    case goog.events.KeyCodes.MAC_WK_CMD_RIGHT:
      return goog.events.KeyCodes.META;
    default:
      return keyCode;
  }
};
// INPUT (javascript/closure/fx/transition.js)
goog.fx = {};
goog.fx.Transition = function() {
};
goog.fx.Transition.EventType = {PLAY:"play", BEGIN:"begin", RESUME:"resume", END:"end", STOP:"stop", FINISH:"finish", PAUSE:"pause"};
// INPUT (javascript/closure/ui/popupbase.js)
goog.ui = {};
goog.ui.PopupBase = function(opt_element, opt_type) {
  goog.events.EventTarget.call(this);
  this.handler_ = new goog.events.EventHandler(this);
  this.setElement(opt_element || null);
  opt_type && this.setType(opt_type);
};
goog.inherits(goog.ui.PopupBase, goog.events.EventTarget);
goog.tagUnsealableClass(goog.ui.PopupBase);
goog.ui.PopupBase.Type = {TOGGLE_DISPLAY:"toggle_display", MOVE_OFFSCREEN:"move_offscreen"};
goog.ui.PopupBase.prototype.element_ = null;
goog.ui.PopupBase.prototype.autoHide_ = !0;
goog.ui.PopupBase.prototype.autoHidePartners_ = null;
goog.ui.PopupBase.prototype.autoHideRegion_ = null;
goog.ui.PopupBase.prototype.isVisible_ = !1;
goog.ui.PopupBase.prototype.shouldHideAsync_ = !1;
goog.ui.PopupBase.prototype.lastShowTime_ = -1;
goog.ui.PopupBase.prototype.hideOnEscape_ = !1;
goog.ui.PopupBase.prototype.enableCrossIframeDismissal_ = !0;
goog.ui.PopupBase.prototype.type_ = goog.ui.PopupBase.Type.TOGGLE_DISPLAY;
goog.ui.PopupBase.EventType = {BEFORE_SHOW:"beforeshow", SHOW:"show", BEFORE_HIDE:"beforehide", HIDE:"hide"};
goog.ui.PopupBase.DEBOUNCE_DELAY_MS = 150;
goog.ui.PopupBase.prototype.getType = function() {
  return this.type_;
};
goog.ui.PopupBase.prototype.setType = function(type) {
  this.type_ = type;
};
goog.ui.PopupBase.prototype.getElement = function() {
  return this.element_;
};
goog.ui.PopupBase.prototype.setElement = function(elt) {
  this.ensureNotVisible_();
  this.element_ = elt;
};
goog.ui.PopupBase.prototype.setAutoHide = function(autoHide) {
  this.ensureNotVisible_();
  this.autoHide_ = autoHide;
};
goog.ui.PopupBase.prototype.setTransition = function(opt_showTransition, opt_hideTransition) {
  this.showTransition_ = opt_showTransition;
  this.hideTransition_ = opt_hideTransition;
};
goog.ui.PopupBase.prototype.getHandler = function() {
  return this.handler_;
};
goog.ui.PopupBase.prototype.ensureNotVisible_ = function() {
  if (this.isVisible_) {
    throw Error("Can not change this state of the popup while showing.");
  }
};
goog.ui.PopupBase.prototype.isVisible = function() {
  return this.isVisible_;
};
goog.ui.PopupBase.prototype.setVisible = function(visible) {
  this.showTransition_ && this.showTransition_.stop();
  this.hideTransition_ && this.hideTransition_.stop();
  visible ? this.show_() : this.hide_();
};
goog.ui.PopupBase.prototype.reposition = goog.nullFunction;
goog.ui.PopupBase.prototype.show_ = function() {
  if (!this.isVisible_ && this.onBeforeShow()) {
    if (!this.element_) {
      throw Error("Caller must call setElement before trying to show the popup");
    }
    this.reposition();
    var doc = goog.dom.getOwnerDocument(this.element_);
    this.hideOnEscape_ && this.handler_.listen(doc, goog.events.EventType.KEYDOWN, this.onDocumentKeyDown_, !0);
    if (this.autoHide_) {
      if (this.handler_.listen(doc, goog.events.EventType.MOUSEDOWN, this.onDocumentMouseDown_, !0), goog.userAgent.IE) {
        var activeElement;
        try {
          activeElement = doc.activeElement;
        } catch (e) {
        }
        for (;activeElement && "IFRAME" == activeElement.nodeName;) {
          try {
            var tempDoc = goog.dom.getFrameContentDocument(activeElement);
          } catch (e$$0) {
            break;
          }
          doc = tempDoc;
          activeElement = doc.activeElement;
        }
        this.handler_.listen(doc, goog.events.EventType.MOUSEDOWN, this.onDocumentMouseDown_, !0);
        this.handler_.listen(doc, goog.events.EventType.DEACTIVATE, this.onDocumentBlur_);
      } else {
        this.handler_.listen(doc, goog.events.EventType.BLUR, this.onDocumentBlur_);
      }
    }
    this.type_ == goog.ui.PopupBase.Type.TOGGLE_DISPLAY ? this.showPopupElement() : this.type_ == goog.ui.PopupBase.Type.MOVE_OFFSCREEN && this.reposition();
    this.isVisible_ = !0;
    this.lastShowTime_ = goog.now();
    if (this.showTransition_) {
      goog.events.listenOnce(this.showTransition_, goog.fx.Transition.EventType.END, this.onShow_, !1, this), this.showTransition_.play();
    } else {
      this.onShow_();
    }
  }
};
goog.ui.PopupBase.prototype.hide_ = function(opt_target) {
  if (!this.isVisible_ || !this.onBeforeHide_(opt_target)) {
    return!1;
  }
  this.handler_ && this.handler_.removeAll();
  this.isVisible_ = !1;
  goog.now();
  this.hideTransition_ ? (goog.events.listenOnce(this.hideTransition_, goog.fx.Transition.EventType.END, goog.partial(this.continueHidingPopup_, opt_target), !1, this), this.hideTransition_.play()) : this.continueHidingPopup_(opt_target);
  return!0;
};
goog.ui.PopupBase.prototype.continueHidingPopup_ = function(opt_target) {
  this.type_ == goog.ui.PopupBase.Type.TOGGLE_DISPLAY ? this.shouldHideAsync_ ? goog.Timer.callOnce(this.hidePopupElement, 0, this) : this.hidePopupElement() : this.type_ == goog.ui.PopupBase.Type.MOVE_OFFSCREEN && this.moveOffscreen_();
  this.onHide_(opt_target);
};
goog.ui.PopupBase.prototype.showPopupElement = function() {
  this.element_.style.visibility = "visible";
  goog.style.setElementShown(this.element_, !0);
};
goog.ui.PopupBase.prototype.hidePopupElement = function() {
  this.element_.style.visibility = "hidden";
  goog.style.setElementShown(this.element_, !1);
};
goog.ui.PopupBase.prototype.moveOffscreen_ = function() {
  this.element_.style.top = "-10000px";
};
goog.ui.PopupBase.prototype.onBeforeShow = function() {
  return this.dispatchEvent(goog.ui.PopupBase.EventType.BEFORE_SHOW);
};
goog.ui.PopupBase.prototype.onShow_ = function() {
  this.dispatchEvent(goog.ui.PopupBase.EventType.SHOW);
};
goog.ui.PopupBase.prototype.onBeforeHide_ = function(opt_target) {
  return this.dispatchEvent({type:goog.ui.PopupBase.EventType.BEFORE_HIDE, target:opt_target});
};
goog.ui.PopupBase.prototype.onHide_ = function(opt_target) {
  this.dispatchEvent({type:goog.ui.PopupBase.EventType.HIDE, target:opt_target});
};
goog.ui.PopupBase.prototype.onDocumentMouseDown_ = function(e) {
  var target = e.target;
  goog.dom.contains(this.element_, target) || this.isOrWithinAutoHidePartner_(target) || !this.isWithinAutoHideRegion_(target) || this.shouldDebounce_() || this.hide_(target);
};
goog.ui.PopupBase.prototype.onDocumentKeyDown_ = function(e) {
  e.keyCode == goog.events.KeyCodes.ESC && this.hide_(e.target) && (e.preventDefault(), e.stopPropagation());
};
goog.ui.PopupBase.prototype.onDocumentBlur_ = function(e) {
  if (this.enableCrossIframeDismissal_) {
    var doc = goog.dom.getOwnerDocument(this.element_);
    if ("undefined" != typeof document.activeElement) {
      var activeElement = doc.activeElement;
      if (!activeElement || goog.dom.contains(this.element_, activeElement) || "BODY" == activeElement.tagName) {
        return;
      }
    } else {
      if (e.target != doc) {
        return;
      }
    }
    this.shouldDebounce_() || this.hide_();
  }
};
goog.ui.PopupBase.prototype.isOrWithinAutoHidePartner_ = function(element) {
  return goog.array.some(this.autoHidePartners_ || [], function(partner) {
    return element === partner || goog.dom.contains(partner, element);
  });
};
goog.ui.PopupBase.prototype.isWithinAutoHideRegion_ = function(element) {
  return this.autoHideRegion_ ? goog.dom.contains(this.autoHideRegion_, element) : !0;
};
goog.ui.PopupBase.prototype.shouldDebounce_ = function() {
  return goog.now() - this.lastShowTime_ < goog.ui.PopupBase.DEBOUNCE_DELAY_MS;
};
goog.ui.PopupBase.prototype.disposeInternal = function() {
  goog.ui.PopupBase.superClass_.disposeInternal.call(this);
  this.handler_.dispose();
  goog.dispose(this.showTransition_);
  goog.dispose(this.hideTransition_);
  delete this.element_;
  delete this.handler_;
  delete this.autoHidePartners_;
};
// INPUT (javascript/closure/ui/popup.js)
goog.ui.Popup = function(opt_element, opt_position) {
  this.popupCorner_ = goog.positioning.Corner.TOP_START;
  this.position_ = opt_position || void 0;
  goog.ui.PopupBase.call(this, opt_element);
};
goog.inherits(goog.ui.Popup, goog.ui.PopupBase);
goog.tagUnsealableClass(goog.ui.Popup);
goog.ui.Popup.Corner = goog.positioning.Corner;
goog.ui.Popup.Overflow = goog.positioning.Overflow;
goog.ui.Popup.prototype.setPinnedCorner = function(corner) {
  this.popupCorner_ = corner;
  this.isVisible() && this.reposition();
};
goog.ui.Popup.prototype.getPosition = function() {
  return this.position_ || null;
};
goog.ui.Popup.prototype.setPosition = function(position) {
  this.position_ = position || void 0;
  this.isVisible() && this.reposition();
};
goog.ui.Popup.prototype.reposition = function() {
  if (this.position_) {
    var hideForPositioning = !this.isVisible() && this.getType() != goog.ui.PopupBase.Type.MOVE_OFFSCREEN, el = this.getElement();
    hideForPositioning && (el.style.visibility = "hidden", goog.style.setElementShown(el, !0));
    this.position_.reposition(el, this.popupCorner_, this.margin_);
    hideForPositioning && goog.style.setElementShown(el, !1);
  }
};
goog.ui.Popup.AnchoredPosition = goog.positioning.AnchoredPosition;
goog.ui.Popup.AnchoredViewPortPosition = goog.positioning.AnchoredViewportPosition;
goog.ui.Popup.AbsolutePosition = goog.positioning.AbsolutePosition;
goog.ui.Popup.ViewPortPosition = goog.positioning.ViewportPosition;
goog.ui.Popup.ClientPosition = goog.positioning.ClientPosition;
goog.ui.Popup.ViewPortClientPosition = goog.positioning.ViewportClientPosition;
// INPUT (javascript/closure/ui/tooltip.js)
goog.ui.Tooltip = function(opt_el, opt_str, opt_domHelper) {
  this.dom_ = opt_domHelper || (opt_el ? goog.dom.getDomHelper(goog.dom.getElement(opt_el)) : goog.dom.getDomHelper());
  goog.ui.Popup.call(this, this.dom_.createDom("div", {style:"position:absolute;display:none;"}));
  this.cursorPosition = new goog.math.Coordinate(1, 1);
  this.elements_ = new goog.structs.Set;
  opt_el && this.attach(opt_el);
  null != opt_str && this.setText(opt_str);
};
goog.inherits(goog.ui.Tooltip, goog.ui.Popup);
goog.tagUnsealableClass(goog.ui.Tooltip);
goog.ui.Tooltip.activeInstances_ = [];
goog.ui.Tooltip.prototype.activeEl_ = null;
goog.ui.Tooltip.prototype.className = "aAAaGVIZSENTINELaAAa-tooltip";
goog.ui.Tooltip.prototype.showDelayMs_ = 500;
goog.ui.Tooltip.prototype.hideDelayMs_ = 0;
goog.ui.Tooltip.State = {INACTIVE:0, WAITING_TO_SHOW:1, SHOWING:2, WAITING_TO_HIDE:3, UPDATING:4};
goog.ui.Tooltip.Activation = {CURSOR:0, FOCUS:1};
goog.ui.Tooltip.prototype.getDomHelper = function() {
  return this.dom_;
};
goog.ui.Tooltip.prototype.attach = function(el) {
  el = goog.dom.getElement(el);
  this.elements_.add(el);
  goog.events.listen(el, goog.events.EventType.MOUSEOVER, this.handleMouseOver, !1, this);
  goog.events.listen(el, goog.events.EventType.MOUSEOUT, this.handleMouseOutAndBlur, !1, this);
  goog.events.listen(el, goog.events.EventType.MOUSEMOVE, this.handleMouseMove, !1, this);
  goog.events.listen(el, goog.events.EventType.FOCUS, this.handleFocus, !1, this);
  goog.events.listen(el, goog.events.EventType.BLUR, this.handleMouseOutAndBlur, !1, this);
};
goog.ui.Tooltip.prototype.detach = function(opt_el) {
  if (opt_el) {
    var el = goog.dom.getElement(opt_el);
    this.detachElement_(el);
    this.elements_.remove(el);
  } else {
    for (var a = this.elements_.getValues(), i = 0;el = a[i];i++) {
      this.detachElement_(el);
    }
    this.elements_.clear();
  }
};
goog.ui.Tooltip.prototype.detachElement_ = function(el) {
  goog.events.unlisten(el, goog.events.EventType.MOUSEOVER, this.handleMouseOver, !1, this);
  goog.events.unlisten(el, goog.events.EventType.MOUSEOUT, this.handleMouseOutAndBlur, !1, this);
  goog.events.unlisten(el, goog.events.EventType.MOUSEMOVE, this.handleMouseMove, !1, this);
  goog.events.unlisten(el, goog.events.EventType.FOCUS, this.handleFocus, !1, this);
  goog.events.unlisten(el, goog.events.EventType.BLUR, this.handleMouseOutAndBlur, !1, this);
};
goog.ui.Tooltip.prototype.setShowDelayMs = function(delay) {
  this.showDelayMs_ = delay;
};
goog.ui.Tooltip.prototype.setHideDelayMs = function(delay) {
  this.hideDelayMs_ = delay;
};
goog.ui.Tooltip.prototype.getHideDelayMs = function() {
  return this.hideDelayMs_;
};
goog.ui.Tooltip.prototype.setText = function(str) {
  goog.dom.setTextContent(this.getElement(), str);
};
goog.ui.Tooltip.prototype.setHtml = function(str) {
  this.setSafeHtml(goog.html.legacyconversions.safeHtmlFromString(str));
};
goog.ui.Tooltip.prototype.setSafeHtml = function(html) {
  var element = this.getElement();
  element && goog.dom.safe.setInnerHtml(element, html);
};
goog.ui.Tooltip.prototype.setElement = function(el) {
  var oldElement = this.getElement();
  oldElement && goog.dom.removeNode(oldElement);
  goog.ui.Tooltip.superClass_.setElement.call(this, el);
  if (el) {
    var body = this.dom_.getDocument().body;
    body.insertBefore(el, body.lastChild);
  }
};
goog.ui.Tooltip.prototype.getText = function() {
  return goog.dom.getTextContent(this.getElement());
};
goog.ui.Tooltip.prototype.getHtml = function() {
  return this.getElement().innerHTML;
};
goog.ui.Tooltip.prototype.getState = function() {
  return this.showTimer ? this.isVisible() ? goog.ui.Tooltip.State.UPDATING : goog.ui.Tooltip.State.WAITING_TO_SHOW : this.hideTimer ? goog.ui.Tooltip.State.WAITING_TO_HIDE : this.isVisible() ? goog.ui.Tooltip.State.SHOWING : goog.ui.Tooltip.State.INACTIVE;
};
goog.ui.Tooltip.prototype.onBeforeShow = function() {
  if (!goog.ui.PopupBase.prototype.onBeforeShow.call(this)) {
    return!1;
  }
  if (this.anchor) {
    for (var tt, i = 0;tt = goog.ui.Tooltip.activeInstances_[i];i++) {
      goog.dom.contains(tt.getElement(), this.anchor) || tt.setVisible(!1);
    }
  }
  goog.array.insert(goog.ui.Tooltip.activeInstances_, this);
  var element = this.getElement();
  element.className = this.className;
  this.clearHideTimer();
  goog.events.listen(element, goog.events.EventType.MOUSEOVER, this.handleTooltipMouseOver, !1, this);
  goog.events.listen(element, goog.events.EventType.MOUSEOUT, this.handleTooltipMouseOut, !1, this);
  this.clearShowTimer();
  return!0;
};
goog.ui.Tooltip.prototype.onHide_ = function() {
  goog.array.remove(goog.ui.Tooltip.activeInstances_, this);
  for (var element = this.getElement(), tt, i = 0;tt = goog.ui.Tooltip.activeInstances_[i];i++) {
    tt.anchor && goog.dom.contains(element, tt.anchor) && tt.setVisible(!1);
  }
  this.parentTooltip_ && this.parentTooltip_.startHideTimer();
  goog.events.unlisten(element, goog.events.EventType.MOUSEOVER, this.handleTooltipMouseOver, !1, this);
  goog.events.unlisten(element, goog.events.EventType.MOUSEOUT, this.handleTooltipMouseOut, !1, this);
  this.anchor = void 0;
  this.getState() == goog.ui.Tooltip.State.INACTIVE && (this.seenInteraction_ = !1);
  goog.ui.PopupBase.prototype.onHide_.call(this);
};
goog.ui.Tooltip.prototype.maybeShow = function(el, opt_pos) {
  this.anchor == el && this.elements_.contains(this.anchor) && (this.seenInteraction_ || !this.requireInteraction_ ? (this.setVisible(!1), this.isVisible() || this.positionAndShow_(el, opt_pos)) : this.anchor = void 0);
  this.showTimer = void 0;
};
goog.ui.Tooltip.prototype.getElements = function() {
  return this.elements_;
};
goog.ui.Tooltip.prototype.getActiveElement = function() {
  return this.activeEl_;
};
goog.ui.Tooltip.prototype.showForElement = function(el, opt_pos) {
  this.attach(el);
  this.activeEl_ = el;
  this.positionAndShow_(el, opt_pos);
};
goog.ui.Tooltip.prototype.positionAndShow_ = function(el, opt_pos) {
  this.anchor = el;
  this.setPosition(opt_pos || this.getPositioningStrategy(goog.ui.Tooltip.Activation.CURSOR));
  this.setVisible(!0);
};
goog.ui.Tooltip.prototype.maybeHide = function(el) {
  this.hideTimer = void 0;
  el == this.anchor && (null != this.activeEl_ && (this.activeEl_ == this.getElement() || this.elements_.contains(this.activeEl_)) || this.hasActiveChild() || this.setVisible(!1));
};
goog.ui.Tooltip.prototype.hasActiveChild = function() {
  return!(!this.childTooltip_ || !this.childTooltip_.activeEl_);
};
goog.ui.Tooltip.prototype.saveCursorPosition_ = function(event) {
  var scroll = this.dom_.getDocumentScroll();
  this.cursorPosition.x = event.clientX + scroll.x;
  this.cursorPosition.y = event.clientY + scroll.y;
};
goog.ui.Tooltip.prototype.handleMouseOver = function(event) {
  var el = this.getAnchorFromElement(event.target);
  this.activeEl_ = el;
  this.clearHideTimer();
  el != this.anchor && (this.anchor = el, this.startShowTimer(el), this.checkForParentTooltip_(), this.saveCursorPosition_(event));
};
goog.ui.Tooltip.prototype.getAnchorFromElement = function(el) {
  try {
    for (;el && !this.elements_.contains(el);) {
      el = el.parentNode;
    }
    return el;
  } catch (e) {
    return null;
  }
};
goog.ui.Tooltip.prototype.handleMouseMove = function(event) {
  this.saveCursorPosition_(event);
  this.seenInteraction_ = !0;
};
goog.ui.Tooltip.prototype.handleFocus = function(event) {
  var el = this.getAnchorFromElement(event.target);
  this.activeEl_ = el;
  this.seenInteraction_ = !0;
  if (this.anchor != el) {
    this.anchor = el;
    var pos = this.getPositioningStrategy(goog.ui.Tooltip.Activation.FOCUS);
    this.clearHideTimer();
    this.startShowTimer(el, pos);
    this.checkForParentTooltip_();
  }
};
goog.ui.Tooltip.prototype.getPositioningStrategy = function(activationType) {
  if (activationType == goog.ui.Tooltip.Activation.CURSOR) {
    var coord = this.cursorPosition.clone();
    return new goog.ui.Tooltip.CursorTooltipPosition(coord);
  }
  return new goog.ui.Tooltip.ElementTooltipPosition(this.activeEl_);
};
goog.ui.Tooltip.prototype.checkForParentTooltip_ = function() {
  if (this.anchor) {
    for (var tt, i = 0;tt = goog.ui.Tooltip.activeInstances_[i];i++) {
      goog.dom.contains(tt.getElement(), this.anchor) && (tt.childTooltip_ = this, this.parentTooltip_ = tt);
    }
  }
};
goog.ui.Tooltip.prototype.handleMouseOutAndBlur = function(event) {
  var el = this.getAnchorFromElement(event.target), elTo = this.getAnchorFromElement(event.relatedTarget);
  el != elTo && (el == this.activeEl_ && (this.activeEl_ = null), this.clearShowTimer(), this.seenInteraction_ = !1, !this.isVisible() || event.relatedTarget && goog.dom.contains(this.getElement(), event.relatedTarget) ? this.anchor = void 0 : this.startHideTimer());
};
goog.ui.Tooltip.prototype.handleTooltipMouseOver = function() {
  var element = this.getElement();
  this.activeEl_ != element && (this.clearHideTimer(), this.activeEl_ = element);
};
goog.ui.Tooltip.prototype.handleTooltipMouseOut = function(event) {
  var element = this.getElement();
  this.activeEl_ != element || event.relatedTarget && goog.dom.contains(element, event.relatedTarget) || (this.activeEl_ = null, this.startHideTimer());
};
goog.ui.Tooltip.prototype.startShowTimer = function(el, opt_pos) {
  this.showTimer || (this.showTimer = goog.Timer.callOnce(goog.bind(this.maybeShow, this, el, opt_pos), this.showDelayMs_));
};
goog.ui.Tooltip.prototype.clearShowTimer = function() {
  this.showTimer && (goog.Timer.clear(this.showTimer), this.showTimer = void 0);
};
goog.ui.Tooltip.prototype.startHideTimer = function() {
  this.getState() == goog.ui.Tooltip.State.SHOWING && (this.hideTimer = goog.Timer.callOnce(goog.bind(this.maybeHide, this, this.anchor), this.getHideDelayMs()));
};
goog.ui.Tooltip.prototype.clearHideTimer = function() {
  this.hideTimer && (goog.Timer.clear(this.hideTimer), this.hideTimer = void 0);
};
goog.ui.Tooltip.prototype.disposeInternal = function() {
  this.setVisible(!1);
  this.clearShowTimer();
  this.detach();
  this.getElement() && goog.dom.removeNode(this.getElement());
  this.activeEl_ = null;
  delete this.dom_;
  goog.ui.Tooltip.superClass_.disposeInternal.call(this);
};
goog.ui.Tooltip.CursorTooltipPosition = function(arg1, opt_arg2) {
  goog.positioning.ViewportPosition.call(this, arg1, opt_arg2);
};
goog.inherits(goog.ui.Tooltip.CursorTooltipPosition, goog.positioning.ViewportPosition);
goog.ui.Tooltip.CursorTooltipPosition.prototype.reposition = function(element, popupCorner, opt_margin) {
  var viewportElt = goog.style.getClientViewportElement(element), viewport = goog.style.getVisibleRectForElement(viewportElt), margin = opt_margin ? new goog.math.Box(opt_margin.top + 10, opt_margin.right, opt_margin.bottom, opt_margin.left + 10) : new goog.math.Box(10, 0, 0, 10);
  goog.positioning.positionAtCoordinate(this.coordinate, element, goog.positioning.Corner.TOP_START, margin, viewport, goog.positioning.Overflow.ADJUST_X | goog.positioning.Overflow.FAIL_Y) & goog.positioning.OverflowStatus.FAILED && goog.positioning.positionAtCoordinate(this.coordinate, element, goog.positioning.Corner.TOP_START, margin, viewport, goog.positioning.Overflow.ADJUST_X | goog.positioning.Overflow.ADJUST_Y);
};
goog.ui.Tooltip.ElementTooltipPosition = function(element) {
  goog.positioning.AnchoredPosition.call(this, element, goog.positioning.Corner.BOTTOM_RIGHT);
};
goog.inherits(goog.ui.Tooltip.ElementTooltipPosition, goog.positioning.AnchoredPosition);
goog.ui.Tooltip.ElementTooltipPosition.prototype.reposition = function(element, popupCorner, opt_margin) {
  var offset = new goog.math.Coordinate(10, 0);
  goog.positioning.positionAtAnchor(this.element, this.corner, element, popupCorner, offset, opt_margin, goog.positioning.Overflow.ADJUST_X | goog.positioning.Overflow.FAIL_Y) & goog.positioning.OverflowStatus.FAILED && goog.positioning.positionAtAnchor(this.element, goog.positioning.Corner.TOP_RIGHT, element, goog.positioning.Corner.BOTTOM_LEFT, offset, opt_margin, goog.positioning.Overflow.ADJUST_X | goog.positioning.Overflow.ADJUST_Y);
};
// INPUT (javascript/gviz/devel/graphics/drawing-group.js)
gviz.graphics.DrawingGroup = function(elementOrCreateGroupFunc) {
  var createGroup = null, element = null;
  goog.isFunction(elementOrCreateGroupFunc) ? createGroup = elementOrCreateGroupFunc : element = elementOrCreateGroupFunc;
  this.createGroup_ = createGroup;
  this.element_ = element;
  this.logicalName_ = null;
};
gviz.graphics.DrawingGroup.prototype.setLogicalName = function(name) {
  this.logicalName_ = name;
  this.isElementCreated() && gviz.graphics.logicalname.setLogicalName(this.element_, name);
};
gviz.graphics.DrawingGroup.prototype.getLogicalName = function() {
  return this.isElementCreated() ? gviz.graphics.logicalname.getLogicalName(this.element_) : this.logicalName_;
};
gviz.graphics.DrawingGroup.prototype.getElement = function() {
  this.element_ || (this.element_ = this.createGroup_(), goog.isNull(this.logicalName_) || gviz.graphics.logicalname.setLogicalName(this.element_, this.logicalName_));
  return this.element_;
};
gviz.graphics.DrawingGroup.prototype.isElementCreated = function() {
  return!!this.element_;
};
// INPUT (javascript/gviz/devel/graphics/path-segments.js)
gviz.graphics.PathSegments = function() {
  this.segments = [];
};
gviz.graphics.PathSegments.SegmentType = {MOVE:"move", LINE:"line", CURVE:"curve", CLOSE:"close", ARC:"arc"};
gviz.graphics.PathSegments.prototype.addSegment = function(segment) {
  goog.array.isEmpty(this.segments) && goog.asserts.assert(segment.type == gviz.graphics.PathSegments.SegmentType.MOVE);
  this.segments.push(segment);
};
gviz.graphics.PathSegments.prototype.move = function(x, y) {
  var segment = gviz.graphics.PathSegments.createMoveSegment(x, y);
  this.addSegment(segment);
};
gviz.graphics.PathSegments.prototype.addLine = function(x, y) {
  var segment = gviz.graphics.PathSegments.createLineSegment(x, y);
  this.addSegment(segment);
};
gviz.graphics.PathSegments.prototype.addCurve = function(x1, y1, x2, y2, x, y) {
  var segment = gviz.graphics.PathSegments.createCurveSegment(x1, y1, x2, y2, x, y);
  this.addSegment(segment);
};
gviz.graphics.PathSegments.prototype.addArc = function(cx, cy, rx, ry, fromAngle, toAngle, isClockwise) {
  var segment = gviz.graphics.PathSegments.createArcSegment(cx, cy, rx, ry, fromAngle, toAngle, isClockwise);
  this.addSegment(segment);
};
gviz.graphics.PathSegments.prototype.extendFromVertices = function(vertices, opt_controlPoints) {
  if (0 != vertices.length) {
    if (0 == this.segments.length ? this.move(vertices[0].x, vertices[0].y) : this.addLine(vertices[0].x, vertices[0].y), opt_controlPoints) {
      for (var i = 1;i < vertices.length;++i) {
        this.addCurve(opt_controlPoints[i - 1][1].x, opt_controlPoints[i - 1][1].y, opt_controlPoints[i][0].x, opt_controlPoints[i][0].y, vertices[i].x, vertices[i].y);
      }
    } else {
      for (i = 1;i < vertices.length;++i) {
        this.addLine(vertices[i].x, vertices[i].y);
      }
    }
  }
};
gviz.graphics.PathSegments.prototype.close = function() {
  var segment = gviz.graphics.PathSegments.createCloseSegment();
  this.addSegment(segment);
};
gviz.graphics.PathSegments.createMoveSegment = function(x, y) {
  var segment = {type:gviz.graphics.PathSegments.SegmentType.MOVE, data:{x:x, y:y}};
  return segment;
};
gviz.graphics.PathSegments.createLineSegment = function(x, y) {
  var segment = {type:gviz.graphics.PathSegments.SegmentType.LINE, data:{x:x, y:y}};
  return segment;
};
gviz.graphics.PathSegments.createCurveSegment = function(x1, y1, x2, y2, x, y) {
  var segment = {type:gviz.graphics.PathSegments.SegmentType.CURVE, data:{x1:x1, y1:y1, x2:x2, y2:y2, x:x, y:y}};
  return segment;
};
gviz.graphics.PathSegments.createArcSegment = function(cx, cy, rx, ry, fromAngle, toAngle, isClockwise) {
  var segment = {type:gviz.graphics.PathSegments.SegmentType.ARC, data:{cx:cx, cy:cy, rx:rx, ry:ry, fromAngle:fromAngle, toAngle:toAngle, isClockwise:isClockwise}};
  return segment;
};
gviz.graphics.PathSegments.createCloseSegment = function() {
  var segment = {type:gviz.graphics.PathSegments.SegmentType.CLOSE, data:null};
  return segment;
};
gviz.graphics.PathSegments.fromVertices = function(vertices, opt_isOpen) {
  var path = new gviz.graphics.PathSegments;
  0 < vertices.length && (path.extendFromVertices(vertices), opt_isOpen || path.close());
  return path;
};
// INPUT (javascript/gviz/devel/graphics/text-align.js)
gviz.graphics.TextAlign = {START:"start", CENTER:"center", END:"end"};
gviz.graphics.TextAlign.getAbsoluteCoordinates = function(coordinate, length, align, opt_rtl) {
  opt_rtl && (align = align === gviz.graphics.TextAlign.START ? gviz.graphics.TextAlign.END : align === gviz.graphics.TextAlign.END ? gviz.graphics.TextAlign.START : align);
  var start, end;
  switch(align) {
    case gviz.graphics.TextAlign.START:
      start = coordinate;
      end = coordinate + length;
      break;
    case gviz.graphics.TextAlign.END:
      start = coordinate - length;
      end = coordinate;
      break;
    case gviz.graphics.TextAlign.CENTER:
      start = coordinate - length / 2;
      end = coordinate + length / 2;
      break;
    default:
      start = end = NaN, goog.asserts.fail('Invalid TextAlign: "' + align + '"');
  }
  return{start:start, end:end};
};
gviz.graphics.TextAlign.getRelativeCoordinate = function(start, end, align, opt_rtl) {
  opt_rtl && (align = align === gviz.graphics.TextAlign.START ? gviz.graphics.TextAlign.END : align === gviz.graphics.TextAlign.END ? gviz.graphics.TextAlign.START : align);
  switch(align) {
    case gviz.graphics.TextAlign.END:
      return end;
    case gviz.graphics.TextAlign.CENTER:
      return goog.math.average(start, end);
    default:
      return start;
  }
};
// INPUT (javascript/gviz/devel/graphics/abstract-renderer.js)
gviz.graphics.AbstractRenderer = function(container, textMeasurementDiv) {
  goog.Disposable.call(this);
  this.container = container;
  this.textMeasurementDiv = textMeasurementDiv;
  this.mainCanvasGroup = null;
  this.getTextSize = goog.memoize(goog.bind(function(text, textStyle, opt_rotation) {
    return this.getTextSizeInternal(text, textStyle, opt_rotation);
  }, this), function(functionUid, args) {
    var signatureTokens = [functionUid, args[0]];
    goog.object.forEach(args[1], function(key, value) {
      signatureTokens.push(key);
      signatureTokens.push(value);
    });
    signatureTokens.push(+args[2]);
    return signatureTokens.join("_");
  });
  this.scrollBarSize = null;
};
goog.inherits(gviz.graphics.AbstractRenderer, goog.Disposable);
gviz.graphics.AbstractRenderer.ID_PREFIX = "_ABSTRACT_RENDERER_ID_";
gviz.graphics.AbstractRenderer.ELEMENTS_COUNTER_NAME_ = "__googleVisualizationAbstractRendererElementsCount__";
gviz.graphics.AbstractRenderer.newUniqueId = function() {
  var counterName = gviz.graphics.AbstractRenderer.ELEMENTS_COUNTER_NAME_;
  goog.global[counterName] = goog.global[counterName] || 0;
  var id = gviz.graphics.AbstractRenderer.ID_PREFIX + goog.global[counterName].toString();
  goog.global[counterName]++;
  return id;
};
gviz.graphics.AbstractRenderer.prototype.width = 0;
gviz.graphics.AbstractRenderer.prototype.height = 0;
gviz.graphics.AbstractRenderer.prototype.createCanvas = function(width, height) {
  var mainCanvasGroup = this.createCanvasInternal(width, height);
  mainCanvasGroup.setLogicalName(gviz.graphics.logicalname.DEFAULT_NAME);
  return this.mainCanvasGroup = mainCanvasGroup;
};
gviz.graphics.AbstractRenderer.prototype.getCanvas = function() {
  return this.mainCanvasGroup;
};
gviz.graphics.AbstractRenderer.prototype.deleteContents = function(opt_markForFlush) {
  this.deleteContentsInternal(opt_markForFlush);
};
gviz.graphics.AbstractRenderer.prototype.flush = function() {
};
gviz.graphics.AbstractRenderer.prototype.clear = function() {
  this.clearInternal();
};
gviz.graphics.AbstractRenderer.prototype.clearInternal = function() {
  this.mainCanvasGroup = null;
};
gviz.graphics.AbstractRenderer.prototype.disposeInternal = function() {
  this.clearInternal();
  gviz.graphics.AbstractRenderer.superClass_.disposeInternal.call(this);
};
gviz.graphics.AbstractRenderer.prototype.getContainer = function() {
  return this.container;
};
gviz.graphics.AbstractRenderer.prototype.setLogicalName = function(elementOrGroup, name) {
  if (elementOrGroup) {
    if (elementOrGroup.constructor == gviz.graphics.DrawingGroup) {
      var group = elementOrGroup;
      group.setLogicalName(name);
    } else {
      var element = elementOrGroup;
      gviz.graphics.logicalname.setLogicalName(element, name);
    }
  }
};
gviz.graphics.AbstractRenderer.prototype.getLogicalName = function(element) {
  return gviz.graphics.logicalname.getLogicalName(element);
};
gviz.graphics.AbstractRenderer.prototype.appendChild = function(parent, child) {
  if (child) {
    var childElement;
    if (child.constructor == gviz.graphics.DrawingGroup) {
      var group = child;
      if (!group.isElementCreated()) {
        return;
      }
      childElement = group.getElement();
    } else {
      childElement = child;
    }
    var parentElement = parent.getElement();
    parentElement.appendChild(childElement);
    this.didAppendChild(parentElement.uid, childElement.uid);
  }
};
gviz.graphics.AbstractRenderer.prototype.didAppendChild = function() {
};
gviz.graphics.AbstractRenderer.prototype.removeFromParent = function(element) {
  element instanceof gviz.graphics.DrawingGroup && (element = element.getElement());
  for (var child;child = element.firstChild;) {
    this.removeFromParent(child);
  }
  var parent = element.parentElement, removedElement = parent.removeChild(element);
  removedElement === element && this.didRemove(parent.uid, element.uid);
};
gviz.graphics.AbstractRenderer.prototype.didRemove = function() {
};
gviz.graphics.AbstractRenderer.prototype.replaceChild = function(parent, newChild, oldChild) {
  var parentElement = parent.getElement();
  parentElement.replaceChild(newChild, oldChild);
  this.didReplaceChild(parentElement.uid, newChild.uid, oldChild.uid);
};
gviz.graphics.AbstractRenderer.prototype.didReplaceChild = function() {
};
gviz.graphics.AbstractRenderer.prototype.removeChildren = function(group) {
  group.isElementCreated() && (this.removeChildrenFromElement_(group.getElement()), this.didRemoveChildren(group.getElement().uid));
};
gviz.graphics.AbstractRenderer.prototype.didRemoveChildren = function() {
};
gviz.graphics.AbstractRenderer.prototype.createGroup = function(opt_allowLazy) {
  var allowLazy = goog.isDefAndNotNull(opt_allowLazy) ? opt_allowLazy : !1, drawingGroup = new gviz.graphics.DrawingGroup(goog.bind(this.createGroupInternal, this));
  allowLazy || drawingGroup.getElement();
  return drawingGroup;
};
gviz.graphics.AbstractRenderer.prototype.describeClipRegion = function() {
};
gviz.graphics.AbstractRenderer.prototype.disableClipping = function() {
  return null;
};
gviz.graphics.AbstractRenderer.prototype.createLine = function(x1, y1, x2, y2, brush) {
  var pathSegments = new gviz.graphics.PathSegments;
  pathSegments.move(x1, y1);
  pathSegments.addLine(x2, y2);
  return this.createPath(pathSegments, brush);
};
gviz.graphics.AbstractRenderer.prototype.createPath = function(pathSegments, brush) {
  var path = this.buildPath_(pathSegments);
  return this.createPathInternal(path, brush);
};
gviz.graphics.AbstractRenderer.prototype.drawCircle = function(cx, cy, r, brush, group) {
  var circle = this.createCircle(cx, cy, r, brush);
  this.appendChild(group, circle);
  return circle;
};
gviz.graphics.AbstractRenderer.prototype.drawEllipse = function(cx, cy, rx, ry, brush, group) {
  var ellipse = this.createEllipse(cx, cy, rx, ry, brush);
  this.appendChild(group, ellipse);
  return ellipse;
};
gviz.graphics.AbstractRenderer.prototype.drawRect = function(x, y, width, height, brush, group) {
  var rect = this.createRect(x, y, width, height, brush);
  this.appendChild(group, rect);
  return rect;
};
gviz.graphics.AbstractRenderer.prototype.drawLine = function(x1, y1, x2, y2, brush, group) {
  var line = this.createLine(x1, y1, x2, y2, brush);
  this.appendChild(group, line);
  return line;
};
gviz.graphics.AbstractRenderer.prototype.drawPath = function(pathSegments, brush, group) {
  var path = this.createPath(pathSegments, brush);
  this.appendChild(group, path);
  return path;
};
gviz.graphics.AbstractRenderer.prototype.drawText = function(text, x, y, width, horizAlign, vertAlign, textStyle, group, opt_rtl) {
  var textElement = this.createText(text, x, y, width, horizAlign, vertAlign, textStyle, opt_rtl);
  this.appendChild(group, textElement);
  return textElement;
};
gviz.graphics.AbstractRenderer.prototype.drawTextOnLine = function(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle, group, opt_rtl) {
  var textElement = this.createTextOnLine(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle, opt_rtl);
  this.appendChild(group, textElement);
  return textElement;
};
gviz.graphics.AbstractRenderer.prototype.drawTextOnLineByAngle = function(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, group, opt_rtl) {
  var textElement = this.createTextOnLineByAngle(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, opt_rtl);
  this.appendChild(group, textElement);
  return textElement;
};
gviz.graphics.AbstractRenderer.prototype.getTextWidth = function(text, textStyle) {
  return this.getTextSize(text, textStyle).width;
};
gviz.graphics.AbstractRenderer.prototype.getTextHeight = function(text, textStyle) {
  return this.getTextSize(text, textStyle).height;
};
gviz.graphics.AbstractRenderer.prototype.isSlowRenderer = function() {
  return!1;
};
gviz.graphics.AbstractRenderer.prototype.addSegmentToPath_ = function(path, segment) {
  switch(segment.type) {
    case gviz.graphics.PathSegments.SegmentType.MOVE:
      var pos = segment.data;
      this.addPathMove(path, pos.x, pos.y);
      break;
    case gviz.graphics.PathSegments.SegmentType.LINE:
      pos = segment.data;
      this.addPathLine(path, pos.x, pos.y);
      break;
    case gviz.graphics.PathSegments.SegmentType.CURVE:
      var curve = segment.data;
      goog.asserts.assert(curve);
      this.addPathCurve(path, curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y);
      break;
    case gviz.graphics.PathSegments.SegmentType.ARC:
      var arc = segment.data;
      goog.asserts.assert(arc);
      this.addPathArc(path, arc.cx, arc.cy, arc.rx, arc.ry, arc.fromAngle, arc.toAngle, arc.isClockwise);
      break;
    case gviz.graphics.PathSegments.SegmentType.CLOSE:
      this.addPathClose(path);
  }
};
gviz.graphics.AbstractRenderer.prototype.buildPath_ = function(pathSegments) {
  for (var path = [], i = 0;i < pathSegments.segments.length;i++) {
    var segment = pathSegments.segments[i];
    this.addSegmentToPath_(path, segment);
  }
  return path;
};
gviz.graphics.AbstractRenderer.prototype.flushRenderingCommands = function() {
};
gviz.graphics.AbstractRenderer.prototype.createAccessibilityContainer = goog.functions.NULL;
// INPUT (javascript/gviz/devel/graphics/cursor-position.js)
gviz.graphics.cursorposition = {};
gviz.graphics.cursorposition.REFERENCE_POINT_ATTRIBUTE = "referencepoint";
gviz.graphics.cursorposition.setReferencePoint = function(element) {
  element && (element[gviz.graphics.cursorposition.REFERENCE_POINT_ATTRIBUTE] = !0);
};
gviz.graphics.cursorposition.getReferencePoint = function(element$$0) {
  return goog.dom.getAncestor(element$$0, function(element) {
    return element[gviz.graphics.cursorposition.REFERENCE_POINT_ATTRIBUTE];
  }, !0);
};
gviz.graphics.cursorposition.getCursorPosition = function(event) {
  var referencePoint = gviz.graphics.cursorposition.getReferencePoint(event.target);
  goog.asserts.assert(referencePoint);
  return goog.style.getRelativePosition(event, referencePoint);
};
// INPUT (javascript/gviz/devel/graphics/browser-renderer.js)
gviz.graphics.BrowserRenderer = function(container, textMeasurementDiv) {
  gviz.graphics.AbstractRenderer.call(this, container, textMeasurementDiv);
  this.domHelper = goog.dom.getDomHelper(container);
  this.doc = this.domHelper.getDocument();
  this.tooltips = [];
  this.eventHandler_ = new goog.events.EventHandler;
};
goog.inherits(gviz.graphics.BrowserRenderer, gviz.graphics.AbstractRenderer);
gviz.graphics.BrowserRenderer.prototype.addTooltip = function(element, text, cssStyle) {
  var tooltip = new goog.ui.Tooltip(element), elementDiv = this.domHelper.createDom("div"), parts = text.split("\n");
  elementDiv.appendChild(this.domHelper.createTextNode(parts[0]));
  for (var i = 1;i < parts.length;++i) {
    elementDiv.appendChild(this.domHelper.createDom("br")), elementDiv.appendChild(this.domHelper.createTextNode(parts[i]));
  }
  goog.style.setStyle(elementDiv, cssStyle);
  tooltip.getElement().appendChild(elementDiv);
  tooltip.setShowDelayMs(100);
  tooltip.setHideDelayMs(100);
  this.tooltips.push(tooltip);
  return tooltip;
};
gviz.graphics.BrowserRenderer.prototype.removeChildrenFromElement_ = function(element) {
  this.domHelper.removeChildren(element);
};
gviz.graphics.BrowserRenderer.prototype.removeElement = function(element) {
  this.domHelper.removeNode(element);
  goog.events.removeAll(element);
};
gviz.graphics.BrowserRenderer.prototype.clear = function() {
  this.eventHandler_.removeAll();
  goog.dispose(this.eventHandler_);
  this.eventHandler_ = new goog.events.EventHandler;
  gviz.graphics.BrowserRenderer.superClass_.clear.call(this);
};
gviz.graphics.BrowserRenderer.prototype.clearInternal = function() {
  gviz.graphics.BrowserRenderer.superClass_.clearInternal.call(this);
  goog.array.forEach(this.tooltips, function(tooltip) {
    goog.dispose(tooltip);
  });
  goog.array.clear(this.tooltips);
  this.removeChildrenFromElement_(this.container);
  this.eventHandler_.removeAll();
  goog.dispose(this.eventHandler_);
};
gviz.graphics.BrowserRenderer.prototype.getBoundingBox = function(element) {
  var referencePoint = gviz.graphics.cursorposition.getReferencePoint(element);
  if (referencePoint) {
    var relativePosition = goog.style.getRelativePosition(element, referencePoint), size = goog.style.getSize(element);
    return new goog.math.Box(relativePosition.y, relativePosition.x + size.width, relativePosition.y + size.height, relativePosition.x);
  }
  return null;
};
gviz.graphics.BrowserRenderer.prototype.getCursorPosition = function(event) {
  return gviz.graphics.cursorposition.getCursorPosition(event);
};
gviz.graphics.BrowserRenderer.prototype.setEventHandler = function(element, eventType, listener) {
  element.constructor == gviz.graphics.DrawingGroup && (element = element.getElement());
  this.eventHandler_.listen(element, eventType, listener);
};
gviz.graphics.BrowserRenderer.prototype.replaceChild = function(parent, newChild, oldChild) {
  gviz.graphics.BrowserRenderer.superClass_.replaceChild.call(this, parent, newChild, oldChild);
  goog.events.removeAll(oldChild);
};
// INPUT (javascript/closure/math/line.js)
goog.math.Line = function(x0, y0, x1, y1) {
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
};
goog.math.Line.prototype.clone = function() {
  return new goog.math.Line(this.x0, this.y0, this.x1, this.y1);
};
goog.math.Line.prototype.equals = function(other) {
  return this.x0 == other.x0 && this.y0 == other.y0 && this.x1 == other.x1 && this.y1 == other.y1;
};
goog.math.Line.prototype.getSegmentLengthSquared = function() {
  var xdist = this.x1 - this.x0, ydist = this.y1 - this.y0;
  return xdist * xdist + ydist * ydist;
};
goog.math.Line.prototype.getSegmentLength = function() {
  return Math.sqrt(this.getSegmentLengthSquared());
};
goog.math.Line.prototype.getInterpolatedPoint = function(t) {
  return new goog.math.Coordinate(goog.math.lerp(this.x0, this.x1, t), goog.math.lerp(this.y0, this.y1, t));
};
// INPUT (javascript/closure/math/vec2.js)
goog.math.Vec2 = function(x, y) {
  this.x = x;
  this.y = y;
};
goog.inherits(goog.math.Vec2, goog.math.Coordinate);
goog.math.Vec2.randomUnit = function() {
  var angle = Math.random() * Math.PI * 2;
  return new goog.math.Vec2(Math.cos(angle), Math.sin(angle));
};
goog.math.Vec2.random = function() {
  var mag = Math.sqrt(Math.random()), angle = Math.random() * Math.PI * 2;
  return new goog.math.Vec2(Math.cos(angle) * mag, Math.sin(angle) * mag);
};
goog.math.Vec2.fromCoordinate = function(a) {
  return new goog.math.Vec2(a.x, a.y);
};
goog.math.Vec2.prototype.clone = function() {
  return new goog.math.Vec2(this.x, this.y);
};
goog.math.Vec2.prototype.magnitude = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y);
};
goog.math.Vec2.prototype.squaredMagnitude = function() {
  return this.x * this.x + this.y * this.y;
};
goog.math.Vec2.prototype.scale = goog.math.Coordinate.prototype.scale;
goog.math.Vec2.prototype.invert = function() {
  this.x = -this.x;
  this.y = -this.y;
  return this;
};
goog.math.Vec2.prototype.normalize = function() {
  return this.scale(1 / this.magnitude());
};
goog.math.Vec2.prototype.add = function(b) {
  this.x += b.x;
  this.y += b.y;
  return this;
};
goog.math.Vec2.prototype.subtract = function(b) {
  this.x -= b.x;
  this.y -= b.y;
  return this;
};
goog.math.Vec2.prototype.rotate = function(angle) {
  var cos = Math.cos(angle), sin = Math.sin(angle), newX = this.x * cos - this.y * sin, newY = this.y * cos + this.x * sin;
  this.x = newX;
  this.y = newY;
  return this;
};
goog.math.Vec2.rotateAroundPoint = function(v, axisPoint, angle) {
  var res = v.clone();
  return res.subtract(axisPoint).rotate(angle).add(axisPoint);
};
goog.math.Vec2.prototype.equals = function(b) {
  return this == b || !!b && this.x == b.x && this.y == b.y;
};
goog.math.Vec2.distance = goog.math.Coordinate.distance;
goog.math.Vec2.squaredDistance = goog.math.Coordinate.squaredDistance;
goog.math.Vec2.equals = goog.math.Coordinate.equals;
goog.math.Vec2.sum = function(a, b) {
  return new goog.math.Vec2(a.x + b.x, a.y + b.y);
};
goog.math.Vec2.difference = function(a, b) {
  return new goog.math.Vec2(a.x - b.x, a.y - b.y);
};
goog.math.Vec2.dot = function(a, b) {
  return a.x * b.x + a.y * b.y;
};
goog.math.Vec2.lerp = function(a, b, x) {
  return new goog.math.Vec2(goog.math.lerp(a.x, b.x, x), goog.math.lerp(a.y, b.y, x));
};
// INPUT (javascript/gviz/devel/graphics/canvas-renderer.js)
gviz.graphics.CanvasRenderer = function(container, textMeasurementDiv) {
  gviz.graphics.BrowserRenderer.call(this, container, textMeasurementDiv);
  this.ctx_ = null;
  var canvas = goog.dom.getDomHelper(textMeasurementDiv).createElement("canvas");
  this.textMeasurementDiv.appendChild(canvas);
  this.textCtx_ = canvas.getContext("2d");
  this.clipRect_ = null;
};
goog.inherits(gviz.graphics.CanvasRenderer, gviz.graphics.BrowserRenderer);
gviz.graphics.CanvasRenderer.prototype.createPath_ = function() {
  this.pathCreated_ || (this.ctx_.beginPath(), this.pathCreated_ = !0);
};
gviz.graphics.CanvasRenderer.prototype.createCanvasInternal = function(width, height) {
  goog.asserts.assert(!isNaN(width));
  goog.asserts.assert(!isNaN(height));
  goog.asserts.assert(isFinite(width));
  goog.asserts.assert(isFinite(height));
  goog.asserts.assert(0 <= width);
  goog.asserts.assert(0 <= height);
  var canvas = goog.dom.getDomHelper(this.container).createElement("canvas");
  canvas.setAttribute("width", width);
  canvas.setAttribute("height", height);
  this.container.appendChild(canvas);
  this.ctx_ = canvas.getContext("2d");
  return new gviz.graphics.DrawingGroup(canvas);
};
gviz.graphics.CanvasRenderer.prototype.deleteContentsInternal = function() {
  var element = this.getCanvas().getElement();
  this.ctx_.clearRect(0, 0, element.width, element.height);
};
gviz.graphics.CanvasRenderer.prototype.emptyElement_ = function() {
  return goog.dom.getDomHelper(this.container).createElement("empty");
};
gviz.graphics.CanvasRenderer.prototype.rgbFromColorAndOpacity_ = function(color, opacity) {
  if ("none" == color) {
    return "rgba(0,0,0,0)";
  }
  "none" == opacity && (opacity = 1);
  var rgb = goog.color.hexToRgb(color);
  return "rgba(" + rgb + "," + opacity + ")";
};
gviz.graphics.CanvasRenderer.prototype.drawDiagonalStripesPattern_ = function(pattern) {
  var canvas = this.doc.createElement("canvas");
  canvas.setAttribute("width", 4);
  canvas.setAttribute("height", 4);
  var context = canvas.getContext("2d");
  context.fillStyle = pattern.getBackgroundColor();
  context.fillRect(0, 0, 4, 4);
  context.strokeStyle = pattern.getColor();
  context.beginPath();
  context.lineWidth = 2;
  context.lineCap = "square";
  context.moveTo(2, 0);
  context.lineTo(4, 2);
  context.moveTo(0, 2);
  context.lineTo(2, 4);
  context.stroke();
  return canvas;
};
gviz.graphics.CanvasRenderer.prototype.setLineDash_ = function(context, dashArray) {
  "undefined" !== typeof context.setLineDash ? context.setLineDash(dashArray) : context.mozDash = dashArray;
};
gviz.graphics.CanvasRenderer.prototype.setBrush_ = function(brush) {
  this.ctx_.strokeStyle = this.rgbFromColorAndOpacity_(brush.getStroke(), brush.getStrokeOpacity());
  this.ctx_.fillStyle = this.rgbFromColorAndOpacity_(brush.getFill(), brush.getFillOpacity());
  var dash = brush.getStrokeDashStyle();
  goog.isDefAndNotNull(dash) && "dash" == dash ? this.setLineDash_(this.ctx_, [8, 2]) : goog.isArray(dash) ? this.setLineDash_(this.ctx_, dash) : this.setLineDash_(this.ctx_, []);
  var pattern = brush.getPattern(), brushGradient = brush.getGradient();
  if (goog.isDefAndNotNull(pattern)) {
    var canvas;
    switch(pattern.getStyle()) {
      case gviz.graphics.Pattern.Style.PRIMARY_DIAGONAL_STRIPES:
        canvas = this.drawDiagonalStripesPattern_(pattern);
        break;
      default:
        goog.asserts.assert("Unsupported pattern style " + pattern.getStyle());
    }
    this.ctx_.fillStyle = this.ctx_.createPattern(canvas, "repeat");
  } else {
    if (goog.isDefAndNotNull(brushGradient)) {
      var gradient = this.ctx_.createLinearGradient(+brushGradient.x1, +brushGradient.y1, +brushGradient.x2, +brushGradient.y2);
      gradient.addColorStop(0, brushGradient.color1);
      gradient.addColorStop(1, brushGradient.color2);
      this.ctx_.fillStyle = gradient;
    }
  }
  this.ctx_.lineWidth = brush.getStrokeWidth();
};
gviz.graphics.CanvasRenderer.prototype.setTextFromStyle_ = function(context, style) {
  style.auraColor && "none" != style.auraColor ? (context.strokeStyle = style.auraColor, context.lineWidth = 3) : context.strokeStyle = "rgba(0,0,0,0)";
  var opacity = style.opacity ? style.opacity : 1;
  context.fillStyle = this.rgbFromColorAndOpacity_(style.color, opacity);
  this.setLineDash_(context, []);
  var font = "";
  style.italic && (font = "italic ");
  style.bold && (font += "bold ");
  font += style.fontSize + "px " + style.fontName;
  context.font = font;
};
gviz.graphics.CanvasRenderer.prototype.createCircle = function(cx, cy, r, brush) {
  goog.asserts.assert(!isNaN(cx));
  goog.asserts.assert(!isNaN(cy));
  goog.asserts.assert(!isNaN(r));
  goog.asserts.assert(isFinite(cx));
  goog.asserts.assert(isFinite(cy));
  goog.asserts.assert(isFinite(r));
  goog.asserts.assert(0 <= r);
  this.ctx_.beginPath();
  this.setBrush_(brush);
  this.ctx_.arc(cx, cy, r, 0, 2 * Math.PI);
  this.ctx_.closePath();
  this.ctx_.fill();
  this.ctx_.stroke();
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.createEllipse = function(cx, cy, rx, ry, brush) {
  goog.asserts.assert(!isNaN(cx));
  goog.asserts.assert(!isNaN(cy));
  goog.asserts.assert(!isNaN(rx));
  goog.asserts.assert(!isNaN(ry));
  goog.asserts.assert(isFinite(cx));
  goog.asserts.assert(isFinite(cy));
  goog.asserts.assert(isFinite(rx));
  goog.asserts.assert(isFinite(ry));
  goog.asserts.assert(0 <= rx);
  goog.asserts.assert(0 <= ry);
  this.ctx_.save();
  this.setBrush_(brush);
  this.ctx_.translate(cx, cy);
  var radius;
  rx > ry ? (this.ctx_.scale(1, ry / rx), radius = rx) : (this.ctx_.scale(rx / ry, 1), radius = ry);
  this.ctx_.arc(0, 0, radius, 0, 2 * Math.PI, !1);
  this.ctx_.fill();
  this.ctx_.stroke();
  this.ctx_.restore();
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.createRect = function(x, y, width, height, brush) {
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(!isNaN(width));
  goog.asserts.assert(!isNaN(height));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  goog.asserts.assert(isFinite(width));
  goog.asserts.assert(isFinite(height));
  goog.asserts.assert(0 <= width);
  goog.asserts.assert(0 <= height);
  this.setBrush_(brush);
  this.ctx_.fillRect(x, y, width, height);
  this.ctx_.strokeRect(x, y, width, height);
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.makeElementScrollable = function() {
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.createPathInternal = function(pathSegments, brush) {
  this.setBrush_(brush);
  this.ctx_.fill();
  this.ctx_.stroke();
  this.pathCreated_ = !1;
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.createText = function(text, x, y, width, horizAlign, vertAlign, textStyle) {
  return this.createTextOnLineByAngle(text, x, y, width, 0, horizAlign, vertAlign, textStyle);
};
gviz.graphics.CanvasRenderer.prototype.createTextOnLine = function(text, x1, y1, x2, y2, horizAlign, perpenAlign, textStyle) {
  var x = gviz.graphics.TextAlign.getRelativeCoordinate(x1, x2, horizAlign), y = gviz.graphics.TextAlign.getRelativeCoordinate(y1, y2, horizAlign), line = new goog.math.Line(x1, y1, x2, y2), length = line.getSegmentLength(), angle = goog.math.angle(x1, y1, x2, y2);
  return this.createTextOnLineByAngle(text, x, y, length, angle, horizAlign, perpenAlign, textStyle);
};
gviz.graphics.CanvasRenderer.prototype.createTextOnLineByAngle = function(text, x, y, length, angle, horizAlign, vertAlign, textStyle) {
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(!isNaN(length));
  goog.asserts.assert(!isNaN(angle));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  goog.asserts.assert(isFinite(length));
  goog.asserts.assert(isFinite(angle));
  this.setTextFromStyle_(this.ctx_, textStyle);
  this.ctx_.save();
  angle = goog.math.toRadians(angle);
  var y2 = x * Math.sin(-angle) + y * Math.cos(-angle), x2 = x * Math.cos(-angle) - y * Math.sin(-angle);
  this.ctx_.rotate(angle);
  "start" == vertAlign ? y2 += 4 * textStyle.fontSize / 5 : "center" == vertAlign ? y2 += textStyle.fontSize / 3 : "end" == vertAlign ? y2 -= textStyle.fontSize / 5 : goog.asserts.fail("Unknown vertAlign: " + vertAlign);
  "start" != horizAlign && ("center" == horizAlign ? x2 -= this.getTextSizeInternal(text, textStyle).width / 2 : "end" == horizAlign ? x2 -= this.getTextSizeInternal(text, textStyle).width : goog.asserts.fail("Unknown horizAlign: " + horizAlign));
  this.ctx_.strokeText(text, x2, y2);
  this.ctx_.fillText(text, x2, y2);
  if (textStyle.underline) {
    this.ctx_.beginPath();
    var textSize = textStyle.fontSize, lineWidth = textSize / 15, y2 = y2 + (lineWidth + 1);
    1 > lineWidth && (lineWidth = 1);
    this.ctx_.lineWidth = lineWidth;
    this.ctx_.moveTo(x2, y2);
    this.ctx_.lineTo(this.ctx_.measureText(text).width + x2, y2);
    this.ctx_.strokeStyle = this.ctx_.fillStyle;
    this.ctx_.stroke();
  }
  this.ctx_.restore();
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.createGroupInternal = function() {
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.describeClipRegion = function(rect) {
  if (goog.isNull(rect)) {
    return this.emptyElement_();
  }
  this.clipRect_ = rect;
  this.ctx_.save();
  this.ctx_.beginPath();
  this.ctx_.fillStyle = "rgba(0,0,0,0)";
  this.ctx_.rect(rect.left, rect.top, rect.width, rect.height);
  this.ctx_.clip();
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.disableClipping = function() {
  var oldClipRect = this.clipRect_;
  this.clipRect_ && (this.clipRect_ = null, this.ctx_.restore());
  return oldClipRect;
};
gviz.graphics.CanvasRenderer.prototype.clipGroup = function() {
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.addPathMove = function(path, x, y) {
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  this.createPath_();
  this.ctx_.moveTo(x, y);
};
gviz.graphics.CanvasRenderer.prototype.addPathLine = function(path, x, y) {
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  this.createPath_();
  this.ctx_.lineTo(x, y);
};
gviz.graphics.CanvasRenderer.prototype.addPathCurve = function(path, x1, y1, x2, y2, x, y) {
  goog.asserts.assert(!isNaN(x1));
  goog.asserts.assert(!isNaN(y1));
  goog.asserts.assert(!isNaN(x2));
  goog.asserts.assert(!isNaN(y2));
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(isFinite(x1));
  goog.asserts.assert(isFinite(y1));
  goog.asserts.assert(isFinite(x2));
  goog.asserts.assert(isFinite(y2));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  this.createPath_();
  this.ctx_.bezierCurveTo(x1, y1, x2, y2, x, y);
};
gviz.graphics.CanvasRenderer.prototype.addPathClose = function() {
  this.createPath_();
  this.ctx_.closePath();
};
gviz.graphics.CanvasRenderer.prototype.addPathArc = function(path, cx, cy, rx, ry, fromAngle, toAngle, isClockwise) {
  goog.asserts.assert(!isNaN(cx));
  goog.asserts.assert(!isNaN(cy));
  goog.asserts.assert(!isNaN(rx));
  goog.asserts.assert(!isNaN(ry));
  goog.asserts.assert(!isNaN(fromAngle));
  goog.asserts.assert(!isNaN(toAngle));
  goog.asserts.assert(isFinite(cx));
  goog.asserts.assert(isFinite(cy));
  goog.asserts.assert(isFinite(rx));
  goog.asserts.assert(isFinite(ry));
  goog.asserts.assert(isFinite(fromAngle));
  goog.asserts.assert(isFinite(toAngle));
  this.createPath_();
  fromAngle = goog.math.toRadians(fromAngle - 90);
  toAngle = goog.math.toRadians(toAngle - 90);
  var radius = Math.max(rx, ry);
  this.ctx_.save();
  this.ctx_.translate(cx, cy);
  this.ctx_.scale(rx / radius, ry / radius);
  this.ctx_.arc(0, 0, radius, fromAngle, toAngle, !isClockwise);
  this.ctx_.restore();
};
gviz.graphics.CanvasRenderer.prototype.setOffset = function() {
};
gviz.graphics.CanvasRenderer.prototype.setWidth = function() {
};
gviz.graphics.CanvasRenderer.prototype.setHeight = function() {
};
gviz.graphics.CanvasRenderer.prototype.setLeftPosition = function() {
};
gviz.graphics.CanvasRenderer.prototype.setTopPosition = function() {
};
gviz.graphics.CanvasRenderer.prototype.setStroke = function() {
};
gviz.graphics.CanvasRenderer.prototype.getTextSizeInternal = function(text, textStyle) {
  this.setTextFromStyle_(this.textCtx_, textStyle);
  var width = this.textCtx_.measureText(text).width;
  return new goog.math.Size(width, textStyle.fontSize);
};
gviz.graphics.CanvasRenderer.prototype.getScrollbarSize = function() {
  return this.emptyElement_();
};
gviz.graphics.CanvasRenderer.prototype.setBrush = function() {
};
// INPUT (javascript/closure/a11y/aria/attributes.js)
goog.a11y = {};
goog.a11y.aria = {};
goog.a11y.aria.State = {ACTIVEDESCENDANT:"activedescendant", ATOMIC:"atomic", AUTOCOMPLETE:"autocomplete", BUSY:"busy", CHECKED:"checked", CONTROLS:"controls", DESCRIBEDBY:"describedby", DISABLED:"disabled", DROPEFFECT:"dropeffect", EXPANDED:"expanded", FLOWTO:"flowto", GRABBED:"grabbed", HASPOPUP:"haspopup", HIDDEN:"hidden", INVALID:"invalid", LABEL:"label", LABELLEDBY:"labelledby", LEVEL:"level", LIVE:"live", MULTILINE:"multiline", MULTISELECTABLE:"multiselectable", ORIENTATION:"orientation", OWNS:"owns", 
POSINSET:"posinset", PRESSED:"pressed", READONLY:"readonly", RELEVANT:"relevant", REQUIRED:"required", SELECTED:"selected", SETSIZE:"setsize", SORT:"sort", VALUEMAX:"valuemax", VALUEMIN:"valuemin", VALUENOW:"valuenow", VALUETEXT:"valuetext"};
goog.a11y.aria.AutoCompleteValues = {INLINE:"inline", LIST:"list", BOTH:"both", NONE:"none"};
goog.a11y.aria.DropEffectValues = {COPY:"copy", MOVE:"move", LINK:"link", EXECUTE:"execute", POPUP:"popup", NONE:"none"};
goog.a11y.aria.LivePriority = {OFF:"off", POLITE:"polite", ASSERTIVE:"assertive"};
goog.a11y.aria.OrientationValues = {VERTICAL:"vertical", HORIZONTAL:"horizontal"};
goog.a11y.aria.RelevantValues = {ADDITIONS:"additions", REMOVALS:"removals", TEXT:"text", ALL:"all"};
goog.a11y.aria.SortValues = {ASCENDING:"ascending", DESCENDING:"descending", NONE:"none", OTHER:"other"};
goog.a11y.aria.CheckedValues = {TRUE:"true", FALSE:"false", MIXED:"mixed", UNDEFINED:"undefined"};
goog.a11y.aria.ExpandedValues = {TRUE:"true", FALSE:"false", UNDEFINED:"undefined"};
goog.a11y.aria.GrabbedValues = {TRUE:"true", FALSE:"false", UNDEFINED:"undefined"};
goog.a11y.aria.InvalidValues = {FALSE:"false", TRUE:"true", GRAMMAR:"grammar", SPELLING:"spelling"};
goog.a11y.aria.PressedValues = {TRUE:"true", FALSE:"false", MIXED:"mixed", UNDEFINED:"undefined"};
goog.a11y.aria.SelectedValues = {TRUE:"true", FALSE:"false", UNDEFINED:"undefined"};
// INPUT (javascript/closure/a11y/aria/datatables.js)
goog.a11y.aria.datatables = {};
goog.a11y.aria.datatables.getDefaultValuesMap = function() {
  goog.a11y.aria.DefaultStateValueMap_ || (goog.a11y.aria.DefaultStateValueMap_ = goog.object.create(goog.a11y.aria.State.ATOMIC, !1, goog.a11y.aria.State.AUTOCOMPLETE, "none", goog.a11y.aria.State.DROPEFFECT, "none", goog.a11y.aria.State.HASPOPUP, !1, goog.a11y.aria.State.LIVE, "off", goog.a11y.aria.State.MULTILINE, !1, goog.a11y.aria.State.MULTISELECTABLE, !1, goog.a11y.aria.State.ORIENTATION, "vertical", goog.a11y.aria.State.READONLY, !1, goog.a11y.aria.State.RELEVANT, "additions text", goog.a11y.aria.State.REQUIRED, 
  !1, goog.a11y.aria.State.SORT, "none", goog.a11y.aria.State.BUSY, !1, goog.a11y.aria.State.DISABLED, !1, goog.a11y.aria.State.HIDDEN, !1, goog.a11y.aria.State.INVALID, "false"));
  return goog.a11y.aria.DefaultStateValueMap_;
};
// INPUT (javascript/closure/a11y/aria/roles.js)
goog.a11y.aria.Role = {ALERT:"alert", ALERTDIALOG:"alertdialog", APPLICATION:"application", ARTICLE:"article", BANNER:"banner", BUTTON:"button", CHECKBOX:"checkbox", COLUMNHEADER:"columnheader", COMBOBOX:"combobox", COMPLEMENTARY:"complementary", CONTENTINFO:"contentinfo", DEFINITION:"definition", DIALOG:"dialog", DIRECTORY:"directory", DOCUMENT:"document", FORM:"form", GRID:"grid", GRIDCELL:"gridcell", GROUP:"group", HEADING:"heading", IMG:"img", LINK:"link", LIST:"list", LISTBOX:"listbox", LISTITEM:"listitem", 
LOG:"log", MAIN:"main", MARQUEE:"marquee", MATH:"math", MENU:"menu", MENUBAR:"menubar", MENU_ITEM:"menuitem", MENU_ITEM_CHECKBOX:"menuitemcheckbox", MENU_ITEM_RADIO:"menuitemradio", NAVIGATION:"navigation", NOTE:"note", OPTION:"option", PRESENTATION:"presentation", PROGRESSBAR:"progressbar", RADIO:"radio", RADIOGROUP:"radiogroup", REGION:"region", ROW:"row", ROWGROUP:"rowgroup", ROWHEADER:"rowheader", SCROLLBAR:"scrollbar", SEARCH:"search", SEPARATOR:"separator", SLIDER:"slider", SPINBUTTON:"spinbutton", 
STATUS:"status", TAB:"tab", TAB_LIST:"tablist", TAB_PANEL:"tabpanel", TEXTBOX:"textbox", TIMER:"timer", TOOLBAR:"toolbar", TOOLTIP:"tooltip", TREE:"tree", TREEGRID:"treegrid", TREEITEM:"treeitem"};
// INPUT (javascript/closure/a11y/aria/aria.js)
goog.a11y.aria.ARIA_PREFIX_ = "aria-";
goog.a11y.aria.ROLE_ATTRIBUTE_ = "role";
goog.a11y.aria.TAGS_WITH_ASSUMED_ROLES_ = [goog.dom.TagName.A, goog.dom.TagName.AREA, goog.dom.TagName.BUTTON, goog.dom.TagName.HEAD, goog.dom.TagName.INPUT, goog.dom.TagName.LINK, goog.dom.TagName.MENU, goog.dom.TagName.META, goog.dom.TagName.OPTGROUP, goog.dom.TagName.OPTION, goog.dom.TagName.PROGRESS, goog.dom.TagName.STYLE, goog.dom.TagName.SELECT, goog.dom.TagName.SOURCE, goog.dom.TagName.TEXTAREA, goog.dom.TagName.TITLE, goog.dom.TagName.TRACK];
goog.a11y.aria.setRole = function(element, roleName) {
  roleName ? (goog.asserts.ENABLE_ASSERTS && goog.asserts.assert(goog.object.containsValue(goog.a11y.aria.Role, roleName), "No such ARIA role " + roleName), element.setAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_, roleName)) : goog.a11y.aria.removeRole(element);
};
goog.a11y.aria.getRole = function(element) {
  var role = element.getAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_);
  return role || null;
};
goog.a11y.aria.removeRole = function(element) {
  element.removeAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_);
};
goog.a11y.aria.setState = function(element, stateName, value) {
  goog.isArray(value) && (value = value.join(" "));
  var attrStateName = goog.a11y.aria.getAriaAttributeName_(stateName);
  if ("" === value || void 0 == value) {
    var defaultValueMap = goog.a11y.aria.datatables.getDefaultValuesMap();
    stateName in defaultValueMap ? element.setAttribute(attrStateName, defaultValueMap[stateName]) : element.removeAttribute(attrStateName);
  } else {
    element.setAttribute(attrStateName, value);
  }
};
goog.a11y.aria.toggleState = function(el, attr) {
  var val = goog.a11y.aria.getState(el, attr);
  goog.string.isEmptySafe(val) || "true" == val || "false" == val ? goog.a11y.aria.setState(el, attr, "true" == val ? "false" : "true") : goog.a11y.aria.removeState(el, attr);
};
goog.a11y.aria.removeState = function(element, stateName) {
  element.removeAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
};
goog.a11y.aria.getState = function(element, stateName) {
  var attr = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName)), isNullOrUndefined = null == attr || void 0 == attr;
  return isNullOrUndefined ? "" : String(attr);
};
goog.a11y.aria.getActiveDescendant = function(element) {
  var id = goog.a11y.aria.getState(element, goog.a11y.aria.State.ACTIVEDESCENDANT);
  return goog.dom.getOwnerDocument(element).getElementById(id);
};
goog.a11y.aria.setActiveDescendant = function(element, activeElement) {
  var id = "";
  activeElement && (id = activeElement.id, goog.asserts.assert(id, "The active element should have an id."));
  goog.a11y.aria.setState(element, goog.a11y.aria.State.ACTIVEDESCENDANT, id);
};
goog.a11y.aria.getLabel = function(element) {
  return goog.a11y.aria.getState(element, goog.a11y.aria.State.LABEL);
};
goog.a11y.aria.setLabel = function(element, label) {
  goog.a11y.aria.setState(element, goog.a11y.aria.State.LABEL, label);
};
goog.a11y.aria.assertRoleIsSetInternalUtil = function(element, allowedRoles) {
  if (!goog.array.contains(goog.a11y.aria.TAGS_WITH_ASSUMED_ROLES_, element.tagName)) {
    var elementRole = goog.a11y.aria.getRole(element);
    goog.asserts.assert(null != elementRole, "The element ARIA role cannot be null.");
    goog.asserts.assert(goog.array.contains(allowedRoles, elementRole), 'Non existing or incorrect role set for element.The role set is "' + elementRole + '". The role should be any of "' + allowedRoles + '". Check the ARIA specification for more details http://www.w3.org/TR/wai-aria/roles.');
  }
};
goog.a11y.aria.getStateBoolean = function(element, stateName) {
  var attr = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
  goog.asserts.assert(goog.isBoolean(attr) || null == attr || "true" == attr || "false" == attr);
  return null == attr ? attr : goog.isBoolean(attr) ? attr : "true" == attr;
};
goog.a11y.aria.getStateNumber = function(element, stateName) {
  var attr = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
  goog.asserts.assert((null == attr || !isNaN(Number(attr))) && !goog.isBoolean(attr));
  return null == attr ? null : Number(attr);
};
goog.a11y.aria.getStateString = function(element, stateName) {
  var attr = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
  goog.asserts.assert((null == attr || goog.isString(attr)) && isNaN(Number(attr)) && "true" != attr && "false" != attr);
  return null == attr ? null : attr;
};
goog.a11y.aria.getStringArrayStateInternalUtil = function(element, stateName) {
  var attrValue = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
  return goog.a11y.aria.splitStringOnWhitespace_(attrValue);
};
goog.a11y.aria.splitStringOnWhitespace_ = function(stringValue) {
  return stringValue ? stringValue.split(/\s+/) : [];
};
goog.a11y.aria.getAriaAttributeName_ = function(ariaName) {
  goog.asserts.ENABLE_ASSERTS && (goog.asserts.assert(ariaName, "ARIA attribute cannot be empty."), goog.asserts.assert(goog.object.containsValue(goog.a11y.aria.State, ariaName), "No such ARIA attribute " + ariaName));
  return goog.a11y.aria.ARIA_PREFIX_ + ariaName;
};
// INPUT (javascript/gviz/devel/graphics/mobile-renderer.js)
gviz.graphics.MobileRenderer = function(container, textMeasurementDiv) {
  gviz.graphics.AbstractRenderer.call(this, container, textMeasurementDiv);
  this.uniqueId = constructor_Native();
  this.setEventHandler = function() {
  };
  this.toFlush_ = [];
  this.ops_ = [];
};
goog.inherits(gviz.graphics.MobileRenderer, gviz.graphics.AbstractRenderer);
gviz.graphics.MobileRenderer.CommandType = {ADD_PATH_ARC:"addPathArc", ADD_PATH_CLOSE:"addPathClose", ADD_PATH_CURVE:"addPathCurve", ADD_PATH_LINE:"addPathLine", ADD_PATH_MOVE:"addPathMove", CLIP_GROUP:"clipGroup", CREATE_CANVAS_INTERNAL:"createCanvasInternal", CREATE_CIRCLE:"createCircle", CREATE_ELLIPSE:"createElipse", CREATE_GROUP_INTERNAL:"createGroupInternal", CREATE_PATH_INTERNAL:"createPathInternal", CREATE_RECT:"createRect", CREATE_TEXT:"createText", CREATE_TEXT_ON_LINE_BY_ANGLE:"createTextOnLineByAngle", 
CREATE_TEXT_ON_LINE:"createTextOnLine", DID_APPEND_CHILD:"didAppendChild", DID_REMOVE:"didRemove", DID_REMOVE_CHILDREN:"didRemoveChildren", DID_REPLACE_CHILD:"didReplaceChild", MAKE_ELEMENT_SCROLLABLE:"makeElementScrollable", SET_HEIGHT:"setHeight", SET_LEFT_POSITION:"setLeftPosition", SET_LOGICAL_NAME:"setLogicalName", SET_OFFSET:"setOffset", SET_TOP_POSITION:"setTopPosition", SET_WIDTH:"setWidth"};
gviz.graphics.MobileRenderer.prototype.queueCommand_ = function(va_args) {
  var id = "" + this.uniqueId + "_" + this.ops_.length, argsArray = Array.prototype.slice.call(arguments, 0), args = [id].concat(argsArray);
  this.ops_.push(args);
  return id;
};
gviz.graphics.MobileRenderer.prototype.createCanvasInternal = function() {
  var uid = this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CREATE_CANVAS_INTERNAL, this.width, this.height), element = MobileCreateElementWithUID(uid);
  return new gviz.graphics.DrawingGroup(element);
};
gviz.graphics.MobileRenderer.prototype.createGroupInternal = function() {
  var uid = this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CREATE_GROUP_INTERNAL);
  return MobileCreateElementWithUID(uid);
};
gviz.graphics.MobileRenderer.prototype.clipGroup = function(group, clipRect, opt_ellipseClipping) {
  var elem = group.getElement();
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CLIP_GROUP, elem.uid, clipRect, opt_ellipseClipping);
  return elem;
};
gviz.graphics.MobileRenderer.prototype.deleteContentsInternal = function(markForFlush) {
  for (var chartCanvas = this.getCanvas(), parent = chartCanvas.getElement(), children = parent.childNodes, i = 0, leni = children.length;i < leni;i++) {
    markForFlush ? this.toFlush_.push(children[i]) : this.removeFromParent(children[0]);
  }
};
gviz.graphics.MobileRenderer.prototype.flush = function() {
  for (;this.toFlush_.length;) {
    this.removeFromParent(this.toFlush_.shift());
  }
};
gviz.graphics.MobileRenderer.prototype.setOffset = function(element, dx, dy) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.SET_OFFSET, element.uid, dx, dy);
};
gviz.graphics.MobileRenderer.prototype.setWidth = function(element, width) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.SET_WIDTH, element.uid, width);
};
gviz.graphics.MobileRenderer.prototype.setHeight = function(element, height) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.SET_HEIGHT, element.uid, height);
};
gviz.graphics.MobileRenderer.prototype.setLeftPosition = function(element, left) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.SET_LEFT_POSITION, element.uid, left);
};
gviz.graphics.MobileRenderer.prototype.setTopPosition = function(element, top) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.SET_TOP_POSITION, element.uid, top);
};
gviz.graphics.MobileRenderer.prototype.addPathMove = function(path, x, y) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.ADD_PATH_MOVE, path, x, y);
};
gviz.graphics.MobileRenderer.prototype.addPathLine = function(path, x, y) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.ADD_PATH_LINE, path, x, y);
};
gviz.graphics.MobileRenderer.prototype.addPathCurve = function(path, x1, y1, x2, y2, x, y) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.ADD_PATH_CURVE, path, x1, y1, x2, y2, x, y);
};
gviz.graphics.MobileRenderer.prototype.addPathClose = function(path) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.ADD_PATH_CLOSE, path);
};
gviz.graphics.MobileRenderer.prototype.addPathArc = function(path, cx, cy, rx, ry, fromAngle, toAngle, isClockwise) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.ADD_PATH_ARC, path, cx, cy, rx, ry, fromAngle, toAngle, isClockwise);
};
gviz.graphics.MobileRenderer.prototype.createCircle = function(cx, cy, r, brush) {
  var uid = this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CREATE_CIRCLE, cx, cy, r, brush.toJSON());
  return MobileCreateElementWithUID(uid);
};
gviz.graphics.MobileRenderer.prototype.createEllipse = function(cx, cy, rx, ry, brush) {
  var uid = this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CREATE_ELLIPSE, cx, cy, rx, ry, brush.toJSON());
  return MobileCreateElementWithUID(uid);
};
gviz.graphics.MobileRenderer.prototype.createRect = function(x, y, width, height, brush) {
  var uid = this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CREATE_RECT, x, y, width, height, brush.toJSON());
  return MobileCreateElementWithUID(uid);
};
gviz.graphics.MobileRenderer.prototype.makeElementScrollable = function(elems, viewWidth, viewHeight, scrollWidth, scrollHeight, scrollX, scrollY) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.MAKE_ELEMENT_SCROLLABLE, elems, viewWidth, viewHeight, scrollWidth, scrollHeight, scrollX, scrollY);
  return MobileCreateElement();
};
gviz.graphics.MobileRenderer.prototype.createPathInternal = function(pathSegments, brush) {
  var uid = this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CREATE_PATH_INTERNAL, pathSegments, brush.toJSON());
  return MobileCreateElementWithUID(uid);
};
gviz.graphics.MobileRenderer.prototype.createText = function(text, x, y, width, horizAlign, vertAlign, textStyle) {
  var uid = this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CREATE_TEXT, text, x, y, width, horizAlign, vertAlign, gviz.graphics.TextStyleToJSON(textStyle));
  return MobileCreateElementWithUID(uid);
};
gviz.graphics.MobileRenderer.prototype.createTextOnLine = function(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle) {
  var uid = this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CREATE_TEXT_ON_LINE, text, x1, y1, x2, y2, paralAlign, perpenAlign, gviz.graphics.TextStyleToJSON(textStyle));
  return MobileCreateElementWithUID(uid);
};
gviz.graphics.MobileRenderer.prototype.createTextOnLineByAngle = function(text, x, y, length, angle, paralAlign, perpenAlign, textStyle) {
  var uid = this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.CREATE_TEXT_ON_LINE_BY_ANGLE, text, x, y, length, angle, paralAlign, perpenAlign, gviz.graphics.TextStyleToJSON(textStyle));
  return MobileCreateElementWithUID(uid);
};
gviz.graphics.MobileRenderer.prototype.getTextSizeInternal = function(text, textStyle) {
  var ret = JSON.parse(getTextSizeInternal_Native(this.uniqueId, text, gviz.graphics.TextStyleToJSON(textStyle)));
  return ret;
};
gviz.graphics.MobileRenderer.prototype.getScrollbarSize = function() {
  var ret = JSON.parse(getScrollbarSize_Native(this.uniqueId));
  return ret;
};
gviz.graphics.MobileRenderer.prototype.getBoundingBox = function() {
  var ret = JSON.parse(getBoundingBox_Native(this.uniqueId));
  return ret;
};
gviz.graphics.MobileRenderer.prototype.addTooltip = function(element, text, cssStyle) {
  var ret = JSON.parse(addTooltip_Native(this.uniqueId, element.uid, text, JSON.stringify(cssStyle)));
  return ret;
};
gviz.graphics.MobileRenderer.prototype.setBrush = function() {
};
gviz.graphics.MobileRenderer.prototype.didAppendChild = function(parentID, childID) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.DID_APPEND_CHILD, parentID, childID);
};
gviz.graphics.MobileRenderer.prototype.didRemove = function(parentUID, childUID) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.DID_REMOVE, parentUID, childUID);
};
gviz.graphics.MobileRenderer.prototype.didReplaceChild = function(parentID, newChildID, replacedChildID) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.DID_REPLACE_CHILD, parentID, newChildID, replacedChildID);
};
gviz.graphics.MobileRenderer.prototype.didRemoveChildren = function(parentID) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.DID_REMOVE_CHILDREN, parentID);
};
gviz.graphics.MobileRenderer.prototype.setLogicalName = function(elementOrGroup, name) {
  this.queueCommand_(gviz.graphics.MobileRenderer.CommandType.SET_LOGICAL_NAME, name, elementOrGroup.uid);
};
gviz.graphics.MobileRenderer.prototype.getLogicalName = function(element) {
  return getLogicalName_Native(this.uniqueId, element.uid);
};
gviz.graphics.MobileRenderer.prototype.removeElement = function(element) {
  this.removeFromParent(element);
  goog.events.removeAll(element);
};
gviz.graphics.MobileRenderer.prototype.getCursorPosition = function(event) {
  for (var element = event.currentTarget;null != element;) {
    var point = element[gviz.graphics.cursorposition.REFERENCE_POINT_ATTRIBUTE];
    if (null != point) {
      return goog.style.getRelativePosition(event, point);
    }
    element = element.parentElement;
  }
  goog.asserts.assert(!1);
  return null;
};
gviz.graphics.MobileRenderer.prototype.flushRenderingCommands = function() {
  flushRenderer_Native(this.uniqueId, JSON.stringify(this.ops_));
  this.ops_ = [];
};
// INPUT (javascript/gviz/devel/graphics/overlay-area.js)
gviz.graphics.OverlayArea = function(container) {
  goog.Disposable.call(this);
  this.container_ = container;
  this.eventHandler_ = new goog.events.EventHandler;
};
goog.inherits(gviz.graphics.OverlayArea, goog.Disposable);
gviz.graphics.OverlayArea.prototype.getContainer = function() {
  return this.container_;
};
gviz.graphics.OverlayArea.prototype.clear = function() {
  this.clear_();
  this.eventHandler_ = new goog.events.EventHandler;
};
gviz.graphics.OverlayArea.prototype.clear_ = function() {
  goog.dom.removeChildren(this.container_);
  this.eventHandler_.removeAll();
  goog.dispose(this.eventHandler_);
};
gviz.graphics.OverlayArea.prototype.disposeInternal = function() {
  this.clear_();
  gviz.graphics.OverlayArea.superClass_.disposeInternal.call(this);
};
gviz.graphics.OverlayArea.prototype.setEventHandler = function(element, eventType, listener) {
  this.eventHandler_.listen(element, eventType, listener);
};
// INPUT (javascript/closure/string/stringformat.js)
goog.string.format = function(formatString, var_args) {
  function replacerDemuxer(match, flags, width, dotp, precision, type, offset, wholeString) {
    if ("%" == type) {
      return "%";
    }
    var value = args.shift();
    if ("undefined" == typeof value) {
      throw Error("[goog.string.format] Not enough arguments");
    }
    arguments[0] = value;
    return goog.string.format.demuxes_[type].apply(null, arguments);
  }
  var args = Array.prototype.slice.call(arguments), template = args.shift();
  if ("undefined" == typeof template) {
    throw Error("[goog.string.format] Template required");
  }
  var formatRe = /%([0\-\ \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g;
  return template.replace(formatRe, replacerDemuxer);
};
goog.string.format.demuxes_ = {};
goog.string.format.demuxes_.s = function(value, flags, width) {
  var replacement = value;
  return isNaN(width) || "" == width || replacement.length >= width ? replacement : replacement = -1 < flags.indexOf("-", 0) ? replacement + goog.string.repeat(" ", width - replacement.length) : goog.string.repeat(" ", width - replacement.length) + replacement;
};
goog.string.format.demuxes_.f = function(value, flags, width, dotp, precision) {
  var replacement = value.toString();
  isNaN(precision) || "" == precision || (replacement = value.toFixed(precision));
  var sign;
  sign = 0 > value ? "-" : 0 <= flags.indexOf("+") ? "+" : 0 <= flags.indexOf(" ") ? " " : "";
  0 <= value && (replacement = sign + replacement);
  if (isNaN(width) || replacement.length >= width) {
    return replacement;
  }
  var replacement = isNaN(precision) ? Math.abs(value).toString() : Math.abs(value).toFixed(precision), padCount = width - replacement.length - sign.length;
  if (0 <= flags.indexOf("-", 0)) {
    replacement = sign + replacement + goog.string.repeat(" ", padCount);
  } else {
    var paddingChar = 0 <= flags.indexOf("0", 0) ? "0" : " ", replacement = sign + goog.string.repeat(paddingChar, padCount) + replacement
  }
  return replacement;
};
goog.string.format.demuxes_.d = function(value, flags, width, dotp, precision, type, offset, wholeString) {
  return goog.string.format.demuxes_.f(parseInt(value, 10), flags, width, dotp, 0, type, offset, wholeString);
};
goog.string.format.demuxes_.i = goog.string.format.demuxes_.d;
goog.string.format.demuxes_.u = goog.string.format.demuxes_.d;
// INPUT (javascript/gviz/devel/graphics/svg-renderer.js)
gviz.graphics.SvgRenderer = function(container, textMeasurementDiv) {
  gviz.graphics.BrowserRenderer.call(this, container, textMeasurementDiv);
  this.defs_ = null;
  this.patternDefsUrls_ = {};
  this.gradientDefsUrls_ = {};
  this.getTextSizeInternal("GViz is Great.", {fontSize:8, fontName:"Arial", bold:!1, italic:!1});
};
goog.inherits(gviz.graphics.SvgRenderer, gviz.graphics.BrowserRenderer);
gviz.graphics.SvgRenderer.XHTML_NAMESPACE_ = "http://www.w3.org/1999/xhtml";
gviz.graphics.SvgRenderer.SVG_NAMESPACE_ = "http://www.w3.org/2000/svg";
gviz.graphics.SvgRenderer.prototype.resetCaches_ = function(chartElement) {
  this.defs_ = this.createSvgElement_("defs");
  this.defs_.setAttribute("id", "defs");
  this.patternDefsUrls_ = {};
  this.gradientDefsUrls_ = {};
  this.shadowDefsUrls_ = {};
  chartElement.appendChild(this.defs_);
};
gviz.graphics.SvgRenderer.prototype.createCanvasInternal = function(width, height) {
  goog.asserts.assert(!isNaN(width));
  goog.asserts.assert(!isNaN(height));
  goog.asserts.assert(isFinite(width));
  goog.asserts.assert(isFinite(height));
  goog.asserts.assert(0 <= width);
  goog.asserts.assert(0 <= height);
  this.width = width;
  this.height = height;
  var chartElement = this.createSvgElement_("svg");
  chartElement.setAttribute("width", width);
  chartElement.setAttribute("height", height);
  chartElement.style.overflow = "hidden";
  chartElement.setAttribute("aria-label", "A chart.");
  this.container.appendChild(chartElement);
  this.resetCaches_(chartElement);
  return new gviz.graphics.DrawingGroup(chartElement);
};
gviz.graphics.SvgRenderer.prototype.getBoundingBox = function(element) {
  if (element instanceof goog.global.SVGElement && "path" !== element.tagName.toLowerCase() && "svg" !== element.tagName.toLowerCase()) {
    var bbox = element.getBBox();
    return bbox.y | bbox.x | bbox.height | bbox.width ? new goog.math.Box(bbox.y, bbox.x + bbox.width, bbox.y + bbox.height, bbox.x) : gviz.graphics.SvgRenderer.superClass_.getBoundingBox.call(this, element);
  }
  return gviz.graphics.SvgRenderer.superClass_.getBoundingBox.call(this, element);
};
gviz.graphics.SvgRenderer.prototype.deleteContentsInternal = function() {
  for (var chartCanvas = this.getCanvas(), parent = chartCanvas.getElement(), children = parent.childNodes, numberOfNodes = children.length;1 < numberOfNodes;) {
    parent.removeChild(children[0]), numberOfNodes--;
  }
  this.resetCaches_(parent);
};
gviz.graphics.SvgRenderer.prototype.getInternalSvg = function() {
  return this.container.innerHTML;
};
gviz.graphics.SvgRenderer.prototype.round = function(n) {
  goog.asserts.assert(!isNaN(n));
  goog.asserts.assert(isFinite(n));
  return Math.round(100 * n) / 100;
};
gviz.graphics.SvgRenderer.prototype.createCircle = function(cx, cy, r, brush) {
  goog.asserts.assert(!isNaN(cx));
  goog.asserts.assert(!isNaN(cy));
  goog.asserts.assert(!isNaN(r));
  goog.asserts.assert(isFinite(cx));
  goog.asserts.assert(isFinite(cy));
  goog.asserts.assert(isFinite(r));
  goog.asserts.assert(0 <= r);
  var element = this.createSvgElement_("circle");
  element.setAttribute("cx", cx);
  element.setAttribute("cy", cy);
  element.setAttribute("r", r);
  this.setBrush(element, brush);
  return element;
};
gviz.graphics.SvgRenderer.prototype.createEllipse = function(cx, cy, rx, ry, brush) {
  goog.asserts.assert(!isNaN(cx));
  goog.asserts.assert(!isNaN(cy));
  goog.asserts.assert(!isNaN(rx));
  goog.asserts.assert(!isNaN(ry));
  goog.asserts.assert(isFinite(cx));
  goog.asserts.assert(isFinite(cy));
  goog.asserts.assert(isFinite(rx));
  goog.asserts.assert(isFinite(ry));
  goog.asserts.assert(0 <= rx);
  goog.asserts.assert(0 <= ry);
  var element = this.createSvgElement_("ellipse");
  element.setAttribute("cx", cx);
  element.setAttribute("cy", cy);
  element.setAttribute("rx", rx);
  element.setAttribute("ry", ry);
  this.setBrush(element, brush);
  return element;
};
gviz.graphics.SvgRenderer.prototype.createRect = function(x, y, width, height, brush) {
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(!isNaN(width));
  goog.asserts.assert(!isNaN(height));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  goog.asserts.assert(isFinite(width));
  goog.asserts.assert(isFinite(height));
  goog.asserts.assert(0 <= width);
  goog.asserts.assert(0 <= height);
  var element = this.createSvgElement_("rect");
  element.setAttribute("x", x);
  element.setAttribute("y", y);
  element.setAttribute("width", width);
  element.setAttribute("height", height);
  this.setBrush(element, brush);
  return element;
};
gviz.graphics.SvgRenderer.prototype.makeElementScrollable = function(elems, viewWidth, viewHeight, scrollWidth, scrollHeight, scrollX, scrollY) {
  var overflowX = scrollX ? "scroll" : "hidden", overflowY = scrollY ? "scroll" : "hidden", divStyle = "height:" + viewHeight + "px;overflow-x:" + overflowX + ";overflow-y:" + overflowY + ";width:" + viewWidth + "px;position: absolute;top:0;left:0;", newCanvas = this.createCanvasInternal(scrollWidth, scrollHeight);
  if (goog.isArrayLike(elems)) {
    for (var i = 0, leni = elems.length;i < leni;i++) {
      this.appendChild(newCanvas, elems[i]);
    }
  } else {
    this.appendChild(newCanvas, elems);
  }
  var scrollDiv = goog.dom.createDom("div", {style:divStyle}, newCanvas.getElement());
  this.container.appendChild(scrollDiv);
  return{append:[], events:[newCanvas.getElement()]};
};
gviz.graphics.SvgRenderer.prototype.createPathInternal = function(pathSegments, brush) {
  var element = this.createSvgElement_("path");
  0 < pathSegments.length && element.setAttribute("d", pathSegments.join(""));
  this.setBrush(element, brush);
  return element;
};
gviz.graphics.SvgRenderer.prototype.createText = function(text, x, y, width, horizAlign, vertAlign, textStyle, opt_rtl) {
  return this.createTextOnLineByAngle(text, x, y, width, 0, horizAlign, vertAlign, textStyle, opt_rtl);
};
gviz.graphics.SvgRenderer.prototype.createTextOnLine = function(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle, opt_rtl) {
  var x = gviz.graphics.TextAlign.getRelativeCoordinate(x1, x2, paralAlign, opt_rtl), y = gviz.graphics.TextAlign.getRelativeCoordinate(y1, y2, paralAlign, opt_rtl), line = new goog.math.Line(x1, y1, x2, y2), length = line.getSegmentLength(), angle = goog.math.angle(x1, y1, x2, y2);
  return this.createTextOnLineByAngle(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, opt_rtl);
};
gviz.graphics.SvgRenderer.prototype.createTextOnLineByAngle = function(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, opt_rtl) {
  var opacity = goog.isDef(textStyle.opacity) ? textStyle.opacity : 1, brush = new gviz.graphics.Brush({fill:textStyle.color, fillOpacity:opacity});
  if (textStyle.color && textStyle.color != gviz.graphics.util.NO_COLOR && textStyle.auraColor && textStyle.auraColor != gviz.graphics.util.NO_COLOR) {
    var brushWithAura = new gviz.graphics.Brush({fill:textStyle.color, fillOpacity:opacity, stroke:textStyle.auraColor, strokeOpacity:opacity, strokeWidth:3}), textGroup = this.createGroup(), auraText = this.drawTextInternal_(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, brushWithAura, textGroup, opt_rtl);
    auraText.setAttribute("aria-hidden", "true");
    this.drawTextInternal_(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, brush, textGroup, opt_rtl);
    return textGroup.getElement();
  }
  return this.createTextInternal_(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, brush, opt_rtl);
};
gviz.graphics.SvgRenderer.prototype.createTextInternal_ = function(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, brush, opt_rtl) {
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(!isNaN(length));
  goog.asserts.assert(!isNaN(angle));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  goog.asserts.assert(isFinite(length));
  goog.asserts.assert(isFinite(angle));
  var element = this.createSvgElement_("text"), perpenStartEnd = gviz.graphics.TextAlign.getAbsoluteCoordinates(0, textStyle.fontSize, perpenAlign);
  perpenAlign = gviz.graphics.TextAlign.END;
  var perpenCenter = gviz.graphics.TextAlign.getRelativeCoordinate(perpenStartEnd.start, perpenStartEnd.end, perpenAlign), perpenCenter = perpenCenter - .15 * textStyle.fontSize, shiftVec = new goog.math.Vec2(0, perpenCenter);
  shiftVec.rotate(goog.math.toRadians(angle));
  var p = new goog.math.Vec2(x, y);
  p.add(shiftVec);
  x = p.x;
  y = p.y;
  element.appendChild(this.doc.createTextNode(text));
  switch(paralAlign) {
    case gviz.graphics.TextAlign.START:
      element.setAttribute("text-anchor", "start");
      break;
    case gviz.graphics.TextAlign.CENTER:
      element.setAttribute("text-anchor", "middle");
      break;
    case gviz.graphics.TextAlign.END:
      element.setAttribute("text-anchor", "end");
      break;
    default:
      goog.asserts.fail('Invalid parallel alignment "' + paralAlign + '"');
  }
  element.setAttribute("x", x);
  element.setAttribute("y", y);
  element.setAttribute("font-family", textStyle.fontName);
  element.setAttribute("font-size", textStyle.fontSize || 0);
  textStyle.bold && element.setAttribute("font-weight", "bold");
  textStyle.italic && element.setAttribute("font-style", "italic");
  textStyle.underline && element.setAttribute("text-decoration", "underline");
  opt_rtl && element.setAttribute("direction", "rtl");
  0 != angle && element.setAttribute("transform", "rotate(" + angle + " " + x + " " + y + ")");
  this.setBrush(element, brush);
  return element;
};
gviz.graphics.SvgRenderer.prototype.drawTextInternal_ = function(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, brush, group, opt_rtl) {
  var textElement = this.createTextInternal_(text, x, y, length, angle, paralAlign, perpenAlign, textStyle, brush, opt_rtl);
  this.appendChild(group, textElement);
  return textElement;
};
gviz.graphics.SvgRenderer.prototype.createGroupInternal = function() {
  return this.createSvgElement_("g");
};
gviz.graphics.SvgRenderer.prototype.clipGroup = function(group, clipRect, opt_ellipseClipping) {
  var id = gviz.graphics.AbstractRenderer.newUniqueId(), clipPath = this.createSvgElement_("clipPath");
  if (opt_ellipseClipping) {
    var ellipse = this.createSvgElement_("ellipse");
    ellipse.setAttribute("cx", clipRect.left + clipRect.width / 2);
    ellipse.setAttribute("cy", clipRect.top + clipRect.height / 2);
    ellipse.setAttribute("rx", clipRect.width / 2);
    ellipse.setAttribute("ry", clipRect.height / 2);
    clipPath.appendChild(ellipse);
  } else {
    var rect = this.createSvgElement_("rect");
    rect.setAttribute("x", clipRect.left);
    rect.setAttribute("y", clipRect.top);
    rect.setAttribute("width", clipRect.width);
    rect.setAttribute("height", clipRect.height);
    clipPath.appendChild(rect);
  }
  clipPath.setAttribute("id", id);
  goog.asserts.assert(this.defs_);
  this.defs_.appendChild(clipPath);
  var element = group.getElement(), url = "";
  goog.userAgent.GECKO && (url = window.location.href.split("#")[0]);
  element.setAttribute("clip-path", "url(" + url + "#" + id + ")");
  return element;
};
gviz.graphics.SvgRenderer.prototype.addPathMove = function(path, x, y) {
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  path.push("M" + x + "," + y);
};
gviz.graphics.SvgRenderer.prototype.addPathLine = function(path, x, y) {
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  path.push("L" + x + "," + y);
};
gviz.graphics.SvgRenderer.prototype.addPathCurve = function(path, x1, y1, x2, y2, x, y) {
  goog.asserts.assert(!isNaN(x1));
  goog.asserts.assert(!isNaN(y1));
  goog.asserts.assert(!isNaN(x2));
  goog.asserts.assert(!isNaN(y2));
  goog.asserts.assert(!isNaN(x));
  goog.asserts.assert(!isNaN(y));
  goog.asserts.assert(isFinite(x1));
  goog.asserts.assert(isFinite(y1));
  goog.asserts.assert(isFinite(x2));
  goog.asserts.assert(isFinite(y2));
  goog.asserts.assert(isFinite(x));
  goog.asserts.assert(isFinite(y));
  path.push("C" + x1 + "," + y1 + "," + x2 + "," + y2 + "," + x + "," + y);
};
gviz.graphics.SvgRenderer.prototype.addPathClose = function(path) {
  path.push("Z");
};
gviz.graphics.SvgRenderer.ARC_MIN_DISTANCE = .1;
gviz.graphics.SvgRenderer.prototype.addPathArc = function(path, cx, cy, rx, ry, fromAngle, toAngle, isClockwise) {
  goog.asserts.assert(!isNaN(cx));
  goog.asserts.assert(!isNaN(cy));
  goog.asserts.assert(!isNaN(rx));
  goog.asserts.assert(!isNaN(ry));
  goog.asserts.assert(!isNaN(fromAngle));
  goog.asserts.assert(!isNaN(toAngle));
  goog.asserts.assert(isFinite(cx));
  goog.asserts.assert(isFinite(cy));
  goog.asserts.assert(isFinite(rx));
  goog.asserts.assert(isFinite(ry));
  goog.asserts.assert(isFinite(fromAngle));
  goog.asserts.assert(isFinite(toAngle));
  if (0 < rx && 0 < ry) {
    var angleDiff = goog.math.angleDifference(fromAngle, toAngle), circumference = 2 * Math.PI * Math.min(rx, ry), angleDistance = angleDiff / 360 * circumference;
    if (Math.abs(angleDistance) < gviz.graphics.SvgRenderer.ARC_MIN_DISTANCE) {
      var desiredMinAngle = gviz.graphics.SvgRenderer.ARC_MIN_DISTANCE / circumference * 360, angleDiff = (desiredMinAngle - Math.abs(angleDiff)) * goog.math.sign(angleDiff) / 2;
      fromAngle -= angleDiff;
      toAngle += angleDiff;
    }
  }
  fromAngle = goog.math.standardAngle(fromAngle);
  toAngle = goog.math.standardAngle(toAngle);
  var toAngleDx = goog.math.angleDx(toAngle - 90, rx), toAngleDy = goog.math.angleDy(toAngle - 90, ry), angleDiff = isClockwise ? toAngle - fromAngle : fromAngle - toAngle;
  0 > angleDiff && (angleDiff += 360);
  var isLong = 180 < angleDiff ? 1 : 0, endx = cx + toAngleDx, endy = cy + toAngleDy;
  path.push("A" + rx + "," + ry + ",0," + isLong + "," + (isClockwise ? 1 : 0) + "," + endx + "," + endy);
};
gviz.graphics.SvgRenderer.prototype.setOffset = function(element, dx, dy) {
  goog.asserts.assert(!isNaN(dx));
  goog.asserts.assert(!isNaN(dy));
  goog.asserts.assert(isFinite(dx));
  goog.asserts.assert(isFinite(dy));
  element.setAttribute("transform", "translate(" + dx + ", " + dy + ")");
};
gviz.graphics.SvgRenderer.prototype.setWidth = function(element, width) {
  element.setAttribute("width", width);
};
gviz.graphics.SvgRenderer.prototype.setHeight = function(element, height) {
  element.setAttribute("height", height);
};
gviz.graphics.SvgRenderer.prototype.setLeftPosition = function(element, left) {
  element.setAttribute("x", left);
};
gviz.graphics.SvgRenderer.prototype.setTopPosition = function(element, top) {
  element.setAttribute("y", top);
};
gviz.graphics.SvgRenderer.prototype.setStroke = function(element, color, width) {
  goog.asserts.assert(!isNaN(width));
  goog.asserts.assert(isFinite(width));
  element.setAttribute("stroke-width", width);
  color && element.setAttribute("stroke", color);
};
gviz.graphics.SvgRenderer.prototype.getTextSizeInternal = function(text, textStyle, opt_rotation) {
  var textDiv = this.textMeasurementDiv;
  textDiv.firstChild.data = text;
  var style = textDiv.style;
  style.fontFamily = textStyle.fontName;
  style.fontSize = textStyle.fontSize + "px";
  style.fontWeight = textStyle.bold ? "bold" : "";
  style.fontStyle = textStyle.italic ? "italic" : "";
  style.display = "block";
  if (null != opt_rotation) {
    var rotateTransform = goog.string.format("rotate(%ddeg)", opt_rotation);
    style.transform = rotateTransform;
    style.transformOrigin = "0 0";
    style.WebkitTransform = rotateTransform;
    style.WebkitTransformOrigin = "0 0";
    style.MozTransform = rotateTransform;
    style.MozTransformOrigin = "0 0";
    style.OTransform = rotateTransform;
    style.OTransformOrigin = "0 0";
    style.msTransform = rotateTransform;
    style.msTransformOrigin = "0 0";
  }
  var width = textDiv.clientWidth, height = textDiv.clientHeight;
  style.display = "none";
  return new goog.math.Size(width, height);
};
gviz.graphics.SvgRenderer.prototype.getScrollbarSize = function() {
  return null != this.scrollBarSize ? this.scrollBarSize : this.scrollBarSize = goog.style.getScrollbarWidth();
};
gviz.graphics.SvgRenderer.prototype.createSvgElement_ = function(name) {
  return this.doc.createElementNS(gviz.graphics.SvgRenderer.SVG_NAMESPACE_, name);
};
gviz.graphics.SvgRenderer.prototype.setBrush = function(element, brush) {
  brush.hasStroke() ? (element.setAttribute("stroke", brush.getStroke()), element.setAttribute("stroke-width", brush.getStrokeWidth()), brush.isStrokeOpaque() ? element.removeAttribute("stroke-opacity") : element.setAttribute("stroke-opacity", brush.getStrokeOpacity()), brush.strokeHasDashStyle() ? element.setAttribute("stroke-dasharray", gviz.graphics.SvgRenderer.convertStrokeDashStyle_(brush.getStrokeDashStyle(), brush.getStrokeWidth())) : element.removeAttribute("stroke-dasharray")) : (element.setAttribute("stroke", 
  gviz.graphics.util.NO_COLOR), element.setAttribute("stroke-width", 0));
  brush.isFillOpaque() ? element.removeAttribute("fill-opacity") : element.setAttribute("fill-opacity", brush.getFillOpacity());
  var rx = brush.getRadiusX();
  goog.isNumber(rx) && element.setAttribute("rx", rx);
  var ry = brush.getRadiusY();
  goog.isNumber(ry) && element.setAttribute("ry", ry);
  var brushGradient = brush.getGradient();
  if (brushGradient) {
    var url = this.getGradientDefinitionUrl_(brushGradient);
    element.setAttribute("fill", "url(#" + url + ")");
  } else {
    goog.isDefAndNotNull(brush.getPattern()) ? (url = this.getPatternDefinitionUrl_(brush.getPattern()), element.setAttribute("fill", "url(#" + url + ")")) : element.setAttribute("fill", brush.getFill());
  }
  if (brush.hasShadow()) {
    var brushShadow = brush.getShadow(), url = this.getShadowDefinitionUrl_(brushShadow);
    element.setAttribute("filter", "url(#" + url + ")");
  }
};
gviz.graphics.SvgRenderer.prototype.getShadowDefinitionUrl_ = function(shadow) {
  var hash = gviz.util.VisCommon.getHash(shadow).toString(), id = this.shadowDefsUrls_[hash];
  if (id) {
    return id;
  }
  id = gviz.graphics.AbstractRenderer.newUniqueId();
  this.shadowDefsUrls_[hash] = id;
  var filterElement = this.createSvgElement_("filter");
  filterElement.setAttribute("id", id);
  var gaussianBlurElement = this.createSvgElement_("feGaussianBlur");
  gaussianBlurElement.setAttribute("in", "SourceAlpha");
  gaussianBlurElement.setAttribute("stdDeviation", shadow.radius);
  filterElement.appendChild(gaussianBlurElement);
  var offsetElement = this.createSvgElement_("feOffset");
  offsetElement.setAttribute("dx", shadow.xOffset || 0);
  offsetElement.setAttribute("dy", shadow.yOffset || 0);
  filterElement.appendChild(offsetElement);
  if (goog.isDefAndNotNull(shadow.opacity)) {
    var componentTransferElement = this.createSvgElement_("feComponentTransfer"), alphaFuncElement = this.createSvgElement_("feFuncA");
    alphaFuncElement.setAttribute("type", "linear");
    alphaFuncElement.setAttribute("slope", shadow.opacity);
    componentTransferElement.appendChild(alphaFuncElement);
    filterElement.appendChild(componentTransferElement);
  }
  var mergeElement = this.createSvgElement_("feMerge"), mergeNode1 = this.createSvgElement_("feMergeNode");
  mergeElement.appendChild(mergeNode1);
  var mergeNode2 = this.createSvgElement_("feMergeNode");
  mergeNode2.setAttribute("in", "SourceGraphic");
  mergeElement.appendChild(mergeNode2);
  filterElement.appendChild(mergeElement);
  goog.asserts.assert(this.defs_);
  this.defs_.appendChild(filterElement);
  return id;
};
gviz.graphics.SvgRenderer.prototype.getGradientDefinitionUrl_ = function(gradient) {
  var hash = gviz.util.VisCommon.getHash(gradient).toString(), id = this.gradientDefsUrls_[hash];
  if (id) {
    return id;
  }
  id = gviz.graphics.AbstractRenderer.newUniqueId();
  this.gradientDefsUrls_[hash] = id;
  var gradientElement = this.createSvgElement_("linearGradient"), x1 = gradient.x1, x2 = gradient.x2, y1 = gradient.y1, y2 = gradient.y2, color1 = gradient.color1, color2 = gradient.color2, opacity1 = 1;
  if (0 === gradient.opacity1 || gradient.opacity1) {
    opacity1 = gradient.opacity1;
  }
  var opacity2 = 1;
  if (0 === gradient.opacity2 || gradient.opacity2) {
    opacity2 = gradient.opacity2;
  }
  var gradientUnits = gradient.useObjectBoundingBoxUnits ? "objectBoundingBox" : "userSpaceOnUse";
  gradientElement.setAttribute("id", id);
  gradientElement.setAttribute("x1", x1);
  gradientElement.setAttribute("y1", y1);
  gradientElement.setAttribute("x2", x2);
  gradientElement.setAttribute("y2", y2);
  gradientElement.setAttribute("gradientUnits", gradientUnits);
  var stop1Style = "stop-color:" + color1 + ";stop-opacity:" + opacity1, stop2Style = "stop-color:" + color2 + ";stop-opacity:" + opacity2, stop1 = this.createSvgElement_("stop");
  stop1.setAttribute("offset", "0%");
  stop1.setAttribute("style", stop1Style);
  gradientElement.appendChild(stop1);
  if (gradient.sharpTransition) {
    var stop1MidPoint = this.createSvgElement_("stop");
    stop1MidPoint.setAttribute("offset", "49.99%");
    stop1MidPoint.setAttribute("style", stop1Style);
    gradientElement.appendChild(stop1MidPoint);
    var stop2MidPoint = this.createSvgElement_("stop");
    stop2MidPoint.setAttribute("offset", "50%");
    stop2MidPoint.setAttribute("style", stop2Style);
    gradientElement.appendChild(stop2MidPoint);
  }
  var stop2 = this.createSvgElement_("stop");
  stop2.setAttribute("offset", "100%");
  stop2.setAttribute("style", stop2Style);
  gradientElement.appendChild(stop2);
  goog.asserts.assert(this.defs_);
  this.defs_.appendChild(gradientElement);
  return id;
};
gviz.graphics.SvgRenderer.calcPatternId_ = function(pattern) {
  var id = pattern.getStyle() + "_" + pattern.getColor() + "_" + pattern.getBackgroundColor();
  return id;
};
gviz.graphics.SvgRenderer.prototype.getPatternDefinitionUrl_ = function(pattern) {
  var patternId = gviz.graphics.SvgRenderer.calcPatternId_(pattern);
  if (!(patternId in this.patternDefsUrls_)) {
    var patternElement = null, patternStyle = pattern.getStyle();
    switch(patternStyle) {
      case gviz.graphics.Pattern.Style.PRIMARY_DIAGONAL_STRIPES:
        patternElement = this.createDiagonalStripesPatternDefinition_(pattern);
        break;
      case gviz.graphics.Pattern.Style.SECONDARY_DIAGONAL_STRIPES:
        patternElement = this.createSecondaryStripesPatternDefinition_(pattern);
        break;
      default:
        goog.asserts.assert("Unsupported pattern style " + patternStyle);
    }
    var id = gviz.graphics.AbstractRenderer.newUniqueId();
    patternElement.setAttribute("id", id);
    goog.asserts.assert(this.defs_);
    this.defs_.appendChild(patternElement);
    this.patternDefsUrls_[patternId] = id;
  }
  return this.patternDefsUrls_[patternId];
};
gviz.graphics.SvgRenderer.prototype.createDiagonalStripesPatternDefinition_ = function(pattern) {
  var patternElement = this.createSvgElement_("pattern");
  patternElement.setAttribute("patternUnits", "userSpaceOnUse");
  patternElement.setAttribute("x", "0");
  patternElement.setAttribute("y", "0");
  patternElement.setAttribute("width", "4");
  patternElement.setAttribute("height", "4");
  patternElement.setAttribute("viewBox", "0 0 4 4");
  var rectElement = this.createSvgElement_("rect");
  rectElement.setAttribute("x", "0");
  rectElement.setAttribute("y", "0");
  rectElement.setAttribute("width", "4");
  rectElement.setAttribute("height", "4");
  rectElement.setAttribute("fill", pattern.getBackgroundColor());
  patternElement.appendChild(rectElement);
  var groupElement = this.createSvgElement_("g");
  groupElement.setAttribute("stroke", pattern.getColor());
  groupElement.setAttribute("stroke-linecap", "square");
  var lineElement = this.createSvgElement_("line");
  lineElement.setAttribute("x1", "2");
  lineElement.setAttribute("y1", "0");
  lineElement.setAttribute("x2", "4");
  lineElement.setAttribute("y2", "2");
  lineElement.setAttribute("stroke-width", "2");
  groupElement.appendChild(lineElement);
  lineElement = this.createSvgElement_("line");
  lineElement.setAttribute("x1", "0");
  lineElement.setAttribute("y1", "2");
  lineElement.setAttribute("x2", "2");
  lineElement.setAttribute("y2", "4");
  lineElement.setAttribute("stroke-width", "2");
  groupElement.appendChild(lineElement);
  patternElement.appendChild(groupElement);
  return patternElement;
};
gviz.graphics.SvgRenderer.prototype.createSecondaryStripesPatternDefinition_ = function(pattern) {
  var patternElement = this.createSvgElement_("pattern");
  patternElement.setAttribute("patternUnits", "userSpaceOnUse");
  patternElement.setAttribute("x", "0");
  patternElement.setAttribute("y", "0");
  patternElement.setAttribute("width", "6");
  patternElement.setAttribute("height", "6");
  patternElement.setAttribute("viewBox", "0 0 4 4");
  var rectElement = this.createSvgElement_("rect");
  rectElement.setAttribute("x", "0");
  rectElement.setAttribute("y", "0");
  rectElement.setAttribute("width", "4");
  rectElement.setAttribute("height", "4");
  rectElement.setAttribute("fill", pattern.getBackgroundColor());
  patternElement.appendChild(rectElement);
  var groupElement = this.createSvgElement_("g");
  groupElement.setAttribute("stroke", pattern.getColor());
  groupElement.setAttribute("stroke-linecap", "square");
  var lineElement = this.createSvgElement_("line");
  lineElement.setAttribute("x1", "2");
  lineElement.setAttribute("y1", "0");
  lineElement.setAttribute("x2", "0");
  lineElement.setAttribute("y2", "2");
  lineElement.setAttribute("stroke-width", "2");
  groupElement.appendChild(lineElement);
  lineElement = this.createSvgElement_("line");
  lineElement.setAttribute("x1", "4");
  lineElement.setAttribute("y1", "2");
  lineElement.setAttribute("x2", "2");
  lineElement.setAttribute("y2", "4");
  lineElement.setAttribute("stroke-width", "2");
  groupElement.appendChild(lineElement);
  patternElement.appendChild(groupElement);
  return patternElement;
};
gviz.graphics.SvgRenderer.convertStrokeDashStyle_ = function(strokeDashStyle, strokeWidth) {
  if (goog.isArray(strokeDashStyle)) {
    return strokeDashStyle.join(",");
  }
  switch(strokeDashStyle) {
    case gviz.graphics.Brush.StrokeDashStyleType.SOLID:
      return "0";
    case gviz.graphics.Brush.StrokeDashStyleType.DASH:
      return String(4 * strokeWidth) + "," + String(strokeWidth);
    default:
      return gviz.graphics.SvgRenderer.convertStrokeDashStyle_(gviz.graphics.Brush.DEFAULT_STROKE_DASH_STYLE, strokeWidth);
  }
};
gviz.graphics.SvgRenderer.prototype.createAccessibilityContainer = function() {
  var div = goog.dom.createDom("div", {"aria-label":"A tabular representation of the data in the chart.", style:"position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden"});
  this.container.appendChild(div);
  this.container.setAttribute("aria-label", "A chart.");
  return div;
};
// INPUT (javascript/gviz/devel/graphics/vml-renderer.js)
gviz.graphics.VmlRenderer = function(container, textMeasurementDiv) {
  gviz.graphics.BrowserRenderer.call(this, container, textMeasurementDiv);
  this.textWidthDiv_ = null;
};
goog.inherits(gviz.graphics.VmlRenderer, gviz.graphics.BrowserRenderer);
gviz.graphics.VmlRenderer.DIV_OFFSET = 5E4;
gviz.graphics.VmlRenderer.prototype.createCanvasInternal = function(width, height) {
  this.width = width;
  this.height = height;
  var offset = gviz.graphics.VmlRenderer.DIV_OFFSET, div = this.createElement_("div");
  this.setPositionAndSize_(div, -offset, -offset, this.width + 2 * offset, this.height + 2 * offset);
  this.container.appendChild(div);
  var chart = this.createGroup(), chartElement = chart.getElement();
  chartElement.coordorigin = "0 0";
  chartElement.coordsize = width + " " + height;
  chartElement.style.top = offset;
  chartElement.style.left = offset;
  div.appendChild(chartElement);
  return chart;
};
gviz.graphics.VmlRenderer.prototype.deleteContentsInternal = function() {
  for (var chartCanvas = this.getCanvas(), parent = chartCanvas.getElement(), children = parent.childNodes, numberOfNodes = children.length;1 < numberOfNodes;) {
    parent.removeChild(children[0]), numberOfNodes--;
  }
};
gviz.graphics.VmlRenderer.prototype.round = function(n) {
  return Math.round(n);
};
gviz.graphics.VmlRenderer.prototype.createCircle = function(cx, cy, r, brush) {
  var element = this.createElement_("v:oval"), d = 2 * r;
  this.setPositionAndSize_(element, cx - r, cy - r, d, d);
  this.setBrush(element, brush, !1);
  return element;
};
gviz.graphics.VmlRenderer.prototype.createEllipse = function(cx, cy, rx, ry, brush) {
  var element = this.createElement_("v:oval");
  this.setPositionAndSize_(element, cx - rx, cy - ry, 2 * rx, 2 * ry);
  this.setBrush(element, brush, !1);
  return element;
};
gviz.graphics.VmlRenderer.prototype.createRect = function(x, y, width, height, brush) {
  var element = this.createElement_("v:rect"), allowImplicitOutline = brush.isFillOpaque() && 1 <= height && 1 <= width && !goog.isDefAndNotNull(brush.getGradient());
  this.setBrush(element, brush, allowImplicitOutline);
  if (brush.hasStroke() || allowImplicitOutline) {
    width = Math.max(width - 1, 0), height = Math.max(height - 1, 0);
  }
  this.setPositionAndSize_(element, x, y, width, height);
  return element;
};
gviz.graphics.VmlRenderer.prototype.makeElementScrollable = function(elems, viewWidth, viewHeight, scrollWidth, scrollHeight, scrollX, scrollY) {
  var overflowX = scrollX ? "scroll" : "hidden", overflowY = scrollY ? "scroll" : "hidden", divStyle = "height:" + viewHeight + "px;overflow-x:" + overflowX + ";overflow-y:" + overflowY + ";width:" + viewWidth + "px;", scrollDiv = goog.dom.createDom("div", {style:divStyle}), group = new gviz.graphics.DrawingGroup(scrollDiv);
  if (goog.isArrayLike(elems)) {
    for (var i = 0, leni = elems.length;i < leni;i++) {
      this.appendChild(group, elems[i]);
    }
  } else {
    this.appendChild(group, elems);
  }
  return{append:[group.getElement()], events:[]};
};
gviz.graphics.VmlRenderer.prototype.createPathInternal = function(pathSegments, brush) {
  for (var element = this.createElement_("v:shape"), pathData = this.createElement_("v:path");0 < pathSegments.length && goog.string.startsWith(goog.array.peek(pathSegments), "M");) {
    pathSegments = goog.array.slice(pathSegments, 0, pathSegments.length - 1);
  }
  pathData.setAttribute("v", pathSegments.join(""));
  this.setPositionAndSize_(element, 0, 0, this.width, this.height);
  element.appendChild(pathData);
  this.setBrush(element, brush, !1);
  return element;
};
gviz.graphics.VmlRenderer.prototype.createText = function(text, x, y, width, horizAlign, vertAlign, textStyle) {
  var xStartEnd = gviz.graphics.TextAlign.getAbsoluteCoordinates(x, width, horizAlign), yStartEnd = gviz.graphics.TextAlign.getAbsoluteCoordinates(y, textStyle.fontSize, vertAlign);
  vertAlign = gviz.graphics.TextAlign.CENTER;
  var yCenter = gviz.graphics.TextAlign.getRelativeCoordinate(yStartEnd.start, yStartEnd.end, vertAlign);
  return this.createTextOnLine(text, xStartEnd.start, yCenter, xStartEnd.end, yCenter, horizAlign, vertAlign, textStyle);
};
gviz.graphics.VmlRenderer.prototype.createTextOnLine = function(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle) {
  var brush = new gviz.graphics.Brush({fill:textStyle.color});
  if (textStyle.color && textStyle.color != gviz.graphics.util.NO_COLOR && textStyle.auraColor && textStyle.auraColor != gviz.graphics.util.NO_COLOR) {
    var brushWithAura = new gviz.graphics.Brush({fill:textStyle.color, stroke:textStyle.auraColor, strokeWidth:2}), textGroup = this.createGroup();
    this.drawTextInternal_(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle, brushWithAura, textGroup);
    this.drawTextInternal_(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle, brush, textGroup);
    return textGroup.getElement();
  }
  return this.createTextInternal_(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle, brush);
};
gviz.graphics.VmlRenderer.prototype.createTextOnLineByAngle = function(text, x, y, length, angle, paralAlign, perpenAlign, textStyle) {
  var radians = goog.math.toRadians(angle), xStartEnd = gviz.graphics.TextAlign.getAbsoluteCoordinates(x, length, paralAlign), axisPoint = new goog.math.Vec2(x, y), startPoint = new goog.math.Vec2(xStartEnd.start, y), startPoint = goog.math.Vec2.rotateAroundPoint(startPoint, axisPoint, radians), endPoint = new goog.math.Vec2(xStartEnd.end, y), endPoint = goog.math.Vec2.rotateAroundPoint(endPoint, axisPoint, radians);
  return this.createTextOnLine(text, startPoint.x, startPoint.y, endPoint.x, endPoint.y, paralAlign, perpenAlign, textStyle);
};
gviz.graphics.VmlRenderer.prototype.createTextInternal_ = function(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle, brush) {
  var shape = this.createElement_("v:shape");
  this.setPositionAndSize_(shape, 0, 0, this.width, this.height);
  if (perpenAlign != gviz.graphics.TextAlign.CENTER) {
    var perpenStartEnd = gviz.graphics.TextAlign.getAbsoluteCoordinates(0, textStyle.fontSize, perpenAlign);
    perpenAlign = gviz.graphics.TextAlign.CENTER;
    var perpenCenter = gviz.graphics.TextAlign.getRelativeCoordinate(perpenStartEnd.start, perpenStartEnd.end, perpenAlign), shiftVec = new goog.math.Vec2(0, perpenCenter), angle = goog.math.angle(x1, y1, x2, y2);
    shiftVec.rotate(goog.math.toRadians(angle));
    var p1 = new goog.math.Vec2(x1, y1), p2 = new goog.math.Vec2(x2, y2);
    p1.add(shiftVec);
    p2.add(shiftVec);
    x1 = p1.x;
    y1 = p1.y;
    x2 = p2.x;
    y2 = p2.y;
  }
  x1 = Math.round(x1);
  y1 = Math.round(y1);
  x2 = Math.round(x2);
  y2 = Math.round(y2);
  var pathElement = this.createElement_("v:path"), path = "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + "E";
  pathElement.setAttribute("v", path);
  pathElement.setAttribute("textpathok", "true");
  var textPathElement = this.createElement_("v:textpath");
  textPathElement.setAttribute("on", "true");
  var style = textPathElement.style;
  style.fontSize = textStyle.fontSize || "";
  style.fontFamily = textStyle.fontName || "";
  switch(paralAlign) {
    case gviz.graphics.TextAlign.START:
      style.setAttribute("v-text-align", "left");
      break;
    case gviz.graphics.TextAlign.CENTER:
      style.setAttribute("v-text-align", "center");
      break;
    case gviz.graphics.TextAlign.END:
      style.setAttribute("v-text-align", "right");
      break;
    default:
      goog.asserts.fail('Invalid parallel alignment "' + paralAlign + '"');
  }
  textStyle.bold && (style.fontWeight = "bold");
  textStyle.italic && (style.fontStyle = "italic");
  textPathElement.setAttribute("string", text);
  shape.appendChild(pathElement);
  shape.appendChild(textPathElement);
  this.setBrush(shape, brush, !1);
  return shape;
};
gviz.graphics.VmlRenderer.prototype.drawTextInternal_ = function(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle, brush, group) {
  var textElement = this.createTextInternal_(text, x1, y1, x2, y2, paralAlign, perpenAlign, textStyle, brush);
  this.appendChild(group, textElement);
  return textElement;
};
gviz.graphics.VmlRenderer.prototype.createGroupInternal = function() {
  var element = this.createElement_("v:group");
  this.setPositionAndSize_(element, 0, 0, this.width, this.height);
  return element;
};
gviz.graphics.VmlRenderer.prototype.clipGroup = function(group, clipRect, opt_ellipseClipping) {
  goog.asserts.assert(!(goog.isDefAndNotNull(opt_ellipseClipping) && opt_ellipseClipping));
  var offset = gviz.graphics.VmlRenderer.DIV_OFFSET, div = this.createElement_("div"), r = [this.px_(offset + clipRect.top), this.px_(offset + clipRect.left + clipRect.width), this.px_(offset + clipRect.top + clipRect.height), this.px_(offset + clipRect.left)];
  div.style.clip = "rect(" + r.join(", ") + ")";
  this.setPositionAndSize_(div, 0, 0, this.width + 2 * offset, this.height + 2 * offset);
  group.getElement();
  var divDrawingGroup = new gviz.graphics.DrawingGroup(div);
  this.appendChild(divDrawingGroup, group);
  this.drawRect(1, 1, 1, 1, new gviz.graphics.Brush({fill:"white"}), divDrawingGroup);
  return div;
};
gviz.graphics.VmlRenderer.prototype.addPathMove = function(path, x, y) {
  path.push("M" + Math.round(x) + "," + Math.round(y));
};
gviz.graphics.VmlRenderer.prototype.addPathLine = function(path, x, y) {
  path.push("L" + Math.round(x) + "," + Math.round(y));
};
gviz.graphics.VmlRenderer.prototype.addPathCurve = function(path, x1, y1, x2, y2, x, y) {
  path.push("C" + Math.round(x1) + "," + Math.round(y1) + "," + Math.round(x2) + "," + Math.round(y2) + "," + Math.round(x) + "," + Math.round(y));
};
gviz.graphics.VmlRenderer.prototype.addPathClose = function(path) {
  path.push("X");
};
gviz.graphics.VmlRenderer.prototype.addPathArc = function(path, cx, cy, rx, ry, fromAngle, toAngle, isClockwise) {
  fromAngle = goog.math.standardAngle(fromAngle);
  toAngle = goog.math.standardAngle(toAngle);
  var fromAngleDx = Math.round(goog.math.angleDx(fromAngle - 90, rx)), fromAngleDy = Math.round(goog.math.angleDy(fromAngle - 90, ry)), toAngleDx = Math.round(goog.math.angleDx(toAngle - 90, rx)), toAngleDy = Math.round(goog.math.angleDy(toAngle - 90, ry));
  rx = Math.round(rx);
  ry = Math.round(ry);
  cx = Math.round(cx);
  cy = Math.round(cy);
  if (fromAngleDx !== toAngleDx || fromAngleDy !== toAngleDy || !(isClockwise && 180 > goog.math.standardAngle(toAngle - fromAngle) || !isClockwise && 180 > goog.math.standardAngle(fromAngle - toAngle))) {
    var op = isClockwise ? "WA" : "AT";
    path.push(op + (cx - rx) + "," + (cy - ry) + "," + (cx + rx) + "," + (cy + ry) + "," + (cx + fromAngleDx) + "," + (cy + fromAngleDy) + "," + (cx + toAngleDx) + "," + (cy + toAngleDy));
  }
};
gviz.graphics.VmlRenderer.prototype.setOffset = function(element, dx, dy) {
  element.style.top = this.px_(dy);
  element.style.left = this.px_(dx);
};
gviz.graphics.VmlRenderer.prototype.setWidth = function(element, width) {
  element.style.width = this.px_(width);
};
gviz.graphics.VmlRenderer.prototype.setHeight = function(element, height) {
  element.style.height = this.px_(height);
};
gviz.graphics.VmlRenderer.prototype.setLeftPosition = function(element, left) {
  element.style.left = this.px_(left);
};
gviz.graphics.VmlRenderer.prototype.setTopPosition = function(element, top) {
  element.style.top = this.px_(top);
};
gviz.graphics.VmlRenderer.prototype.setStroke = function(element, color, width) {
  0 == width ? element.stroked = !1 : (element.stroked = !0, color && (element.strokecolor = color), element.strokeweight = width);
};
gviz.graphics.VmlRenderer.prototype.getTextSizeInternal = function(text, textStyle) {
  var textDiv = this.textMeasurementDiv;
  textDiv.firstChild.data = text;
  var style = textDiv.style;
  style.fontFamily = textStyle.fontName;
  style.fontSize = this.px_(textStyle.fontSize || 0);
  style.fontWeight = textStyle.bold ? "bold" : "";
  style.fontStyle = textStyle.italic ? "italic" : "";
  style.display = "block";
  var width = textDiv.clientWidth, height = textDiv.clientHeight;
  style.display = "none";
  textStyle.bold && (width *= 1.1);
  textStyle.italic && (width *= .9);
  return new goog.math.Size(width, height);
};
gviz.graphics.VmlRenderer.prototype.getScrollbarSize = function() {
  if (null != this.scrollBarSize) {
    return this.scrollBarSize;
  }
  var scrollDiv = goog.dom.createDom("div", {style:"width:100px;height:100px;overflow:scroll;position:absolute;visibility:hidden;"});
  goog.dom.appendChild(this.textMeasurementDiv, scrollDiv);
  this.textMeasurementDiv.style.display = "block";
  this.scrollBarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  this.textMeasurementDiv.style.display = "none";
  goog.dom.removeNode(scrollDiv);
  return this.scrollBarSize;
};
gviz.graphics.VmlRenderer.prototype.px_ = function(number) {
  return Math.round(number) + "px";
};
gviz.graphics.VmlRenderer.prototype.createElement_ = function(name) {
  return this.doc.createElement(name);
};
gviz.graphics.VmlRenderer.prototype.setBrush = function(element, brush, opt_allowImplicitOutline) {
  for (var children = element.children, i = 0;i < children.length;i++) {
    "fill" != element.children[i].tagName && "stroke" != element.children[i].tagName || element.removeChild(children[i]);
  }
  var allowImplicitOutline = goog.isDefAndNotNull(opt_allowImplicitOutline) ? opt_allowImplicitOutline : !0;
  if (brush.hasStroke()) {
    element.stroked = !0;
    element.strokeweight = brush.getStrokeWidth();
    element.strokecolor = brush.getStroke();
    var isStrokeNotOpaque = !brush.isStrokeOpaque(), strokeHasDashStyle = brush.strokeHasDashStyle();
    if (isStrokeNotOpaque || strokeHasDashStyle) {
      var strokeNode = this.createElement_("v:stroke");
      isStrokeNotOpaque && (strokeNode.opacity = String(Math.round(100 * brush.getStrokeOpacity())) + "%");
      strokeHasDashStyle && (strokeNode.dashstyle = gviz.graphics.VmlRenderer.convertStrokeDashStyle_(brush.getStrokeDashStyle()));
      element.appendChild(strokeNode);
    }
  } else {
    allowImplicitOutline && brush.isFillOpaque() ? (element.stroked = !0, element.strokeweight = 1, element.strokecolor = brush.getFill()) : element.stroked = !1;
  }
  goog.isDef(element.filled) && (element.filled = !0);
  var brushGradient = brush.getGradient();
  if (goog.isDefAndNotNull(brushGradient)) {
    var gradient = this.createElement_("v:fill");
    gradient.setAttribute("color", brushGradient.color1);
    gradient.setAttribute("color2", brushGradient.color2);
    gradient.setAttribute("opacity", brushGradient.opacity1 || 1);
    gradient.setAttribute("opacity2", brushGradient.opacity2 || 1);
    var x1 = brushGradient.x1, y1 = brushGradient.y1, x2 = brushGradient.x2, y2 = brushGradient.y2;
    "string" == typeof x1 && (x1 = parseInt(x1, 10));
    "string" == typeof y1 && (y1 = parseInt(y1, 10));
    "string" == typeof x2 && (x2 = parseInt(x2, 10));
    "string" == typeof y2 && (y2 = parseInt(y2, 10));
    var angle = goog.math.angle(x1, y1, x2, y2), angle = goog.math.modulo(270 - angle, 360);
    gradient.setAttribute("angle", angle);
    gradient.setAttribute("type", "gradient");
    element.appendChild(gradient);
  } else {
    if (brush.getPattern()) {
      var patternFillElement = this.createPatternFillElement_(brush.getPattern());
      element.appendChild(patternFillElement);
    } else {
      if (brush.getFill() == gviz.graphics.util.NO_COLOR) {
        element.filled = !1;
      } else {
        if (brush.isFillOpaque()) {
          element.fillcolor = brush.getFill();
        } else {
          var fillNode = this.createElement_("v:fill");
          fillNode.opacity = String(Math.round(100 * brush.getFillOpacity())) + "%";
          fillNode.color = brush.getFill();
          element.appendChild(fillNode);
        }
      }
    }
  }
};
gviz.graphics.VmlRenderer.prototype.createPatternFillElement_ = function(pattern) {
  var fillElement = this.createElement_("v:fill");
  fillElement.setAttribute("type", "pattern");
  fillElement.setAttribute("color", pattern.getColor());
  fillElement.setAttribute("color2", pattern.getBackgroundColor());
  var patternUrl = gviz.util.VisCommon.getModulePath() + "/core/patterns/" + pattern.getStyle() + ".gif";
  fillElement.setAttribute("src", patternUrl);
  return fillElement;
};
gviz.graphics.VmlRenderer.prototype.setPositionAndSize_ = function(element, left, top, width, height) {
  var style = element.style;
  style.position = "absolute";
  style.left = this.px_(left);
  style.top = this.px_(top);
  style.width = this.px_(width);
  style.height = this.px_(height);
};
gviz.graphics.VmlRenderer.prototype.isSlowRenderer = function() {
  return!0;
};
gviz.graphics.VmlRenderer.convertStrokeDashStyle_ = function(strokeDashStyle) {
  if (goog.isArray(strokeDashStyle)) {
    return strokeDashStyle.join(" ");
  }
  switch(strokeDashStyle) {
    case gviz.graphics.Brush.StrokeDashStyleType.SOLID:
      return "solid";
    case gviz.graphics.Brush.StrokeDashStyleType.DASH:
      return "shortdash";
    default:
      return gviz.graphics.VmlRenderer.convertStrokeDashStyle_(gviz.graphics.Brush.DEFAULT_STROKE_DASH_STYLE);
  }
};
// INPUT (javascript/gviz/devel/graphics/drawing-frame.js)
gviz.graphics.DrawingFrame = function(container, dimensions, asyncWrapper, forceIFrame) {
  goog.Disposable.call(this);
  var isSupported = gviz.graphics.DrawingFrame.isBrowserSupported_();
  if (!isSupported) {
    throw Error("Graphics is not supported");
  }
  this.frameId_ = gviz.graphics.DrawingFrame.generateFrameId_();
  this.container = container;
  gviz.graphics.cursorposition.setReferencePoint(this.container);
  this.container.innerHTML = "";
  this.dimensions = dimensions;
  this.domHelper_ = goog.dom.getDomHelper(this.container);
  this.textMeasurementDiv_ = this.renderersDiv_ = null;
  this.isReady_ = !1;
  this.renderers_ = [];
  this.overlayArea_ = null;
  var isVml;
  this.rendererCtor_ = (isVml = gviz.graphics.DrawingFrame.isVml_()) ? gviz.graphics.VmlRenderer : gviz.graphics.SvgRenderer;
  (this.useIFrame_ = isVml || forceIFrame) && this.createDrawingFrame_(isVml);
  this.waitUntilFrameReady_(asyncWrapper);
};
goog.inherits(gviz.graphics.DrawingFrame, goog.Disposable);
gviz.graphics.DrawingFrame.prototype.waitUntilFrameReady_ = function(asyncWrapper) {
  var isFrameReady = goog.bind(this.isFrameReady_, this), onFrameReady = goog.bind(this.onFrameReady_, this);
  gviz.graphics.DrawingFrame.waitForCondition(isFrameReady, onFrameReady, asyncWrapper);
};
gviz.graphics.DrawingFrame.prototype.onFrameReady_ = function() {
  if (this.useIFrame_) {
    var iFrameDoc = this.getIFrameDocument_();
    this.renderersDiv_ = iFrameDoc.getElementById("renderers");
    gviz.graphics.cursorposition.setReferencePoint(this.renderersDiv_);
    goog.asserts.assert(iFrameDoc.body);
    this.textMeasurementDiv_ = gviz.graphics.DrawingFrame.createTextMeasurementDiv(iFrameDoc.body, this.dimensions);
  } else {
    this.renderersDiv_ = this.domHelper_.createElement("div"), goog.style.setStyle(this.renderersDiv_, "position", "relative"), goog.style.setSize(this.renderersDiv_, this.dimensions), this.renderersDiv_.dir = "ltr", this.container.appendChild(this.renderersDiv_), this.textMeasurementDiv_ = gviz.graphics.DrawingFrame.createTextMeasurementDiv(this.container, this.dimensions);
  }
  this.isReady_ = !0;
};
gviz.graphics.DrawingFrame.createTextMeasurementDiv = function(parent, dimensions) {
  goog.asserts.assert(parent);
  goog.asserts.assert(dimensions);
  var domHelper = goog.dom.getDomHelper(parent), textMeasurementDiv = domHelper.createElement("div"), style = textMeasurementDiv.style;
  style.display = "none";
  style.position = "absolute";
  style.top = dimensions.height + 10 + "px";
  style.left = dimensions.width + 10 + "px";
  style.whiteSpace = "nowrap";
  goog.a11y.aria.setState(textMeasurementDiv, goog.a11y.aria.State.HIDDEN, !0);
  textMeasurementDiv.setAttribute("aria-hidden", !0);
  var doc = domHelper.getDocument();
  domHelper.appendChild(textMeasurementDiv, doc.createTextNode(" "));
  domHelper.appendChild(parent, textMeasurementDiv);
  return textMeasurementDiv;
};
gviz.graphics.DrawingFrame.prototype.createRenderer_ = function() {
  var domHelper = goog.dom.getDomHelper(this.renderersDiv_), div = domHelper.createElement("div");
  goog.style.setStyle(div, "position", "absolute");
  goog.style.setPosition(div, 0, 0);
  goog.style.setSize(div, "100%", "100%");
  this.renderersDiv_.appendChild(div);
  var renderer = new this.rendererCtor_(div, this.textMeasurementDiv_);
  this.registerDisposable(renderer);
  this.renderers_.push(renderer);
};
gviz.graphics.DrawingFrame.prototype.createOverlayArea_ = function() {
  var element;
  element = this.domHelper_.createElement("div");
  this.overlayArea_ = new gviz.graphics.OverlayArea(element);
  this.domHelper_.appendChild(this.container, this.overlayArea_.getContainer());
};
gviz.graphics.DrawingFrame.isVml_ = function() {
  return goog.userAgent.IE ? goog.isDefAndNotNull(document.documentMode) ? 9 > document.documentMode : !goog.userAgent.isVersionOrHigher("9") : !1;
};
gviz.graphics.DrawingFrame.prototype.isFrameReady_ = function() {
  if (!this.useIFrame_) {
    return!0;
  }
  var iframeWindow = this.getIFrameWindow_();
  return iframeWindow && iframeWindow._loaded;
};
gviz.graphics.DrawingFrame.prototype.getRenderer = function(opt_index) {
  if (!this.isReady_) {
    return null;
  }
  for (var index = goog.isDefAndNotNull(opt_index) ? opt_index : 0;this.renderers_.length <= index;) {
    this.createRenderer_();
  }
  return this.renderers_[index];
};
gviz.graphics.DrawingFrame.prototype.getOverlayArea = function() {
  if (!this.isReady_) {
    return null;
  }
  this.overlayArea_ || this.createOverlayArea_();
  return this.overlayArea_;
};
gviz.graphics.DrawingFrame.prototype.waitUntilReady = function(callback, asyncWrapper) {
  gviz.graphics.DrawingFrame.waitForCondition(goog.bind(function() {
    return goog.isDefAndNotNull(this.renderersDiv_);
  }, this), callback, asyncWrapper);
};
gviz.graphics.DrawingFrame.prototype.update = function(dimensions, asyncWrapper) {
  if (!goog.math.Size.equals(this.dimensions, dimensions)) {
    if (this.dimensions = dimensions, this.useIFrame_) {
      var frame = this.getIFrame_();
      frame && (frame.width = this.dimensions.width.toString(), frame.height = this.dimensions.height.toString());
    } else {
      this.isReady_ && goog.style.setSize(this.renderersDiv_, this.dimensions);
    }
  }
  this.isReady_ || this.waitUntilFrameReady_(asyncWrapper);
};
gviz.graphics.DrawingFrame.generateFrameId_ = function() {
  for (var chartId = goog.math.randomInt(1E5);window.frames["Drawing_Frame_" + chartId];) {
    chartId++;
  }
  return "Drawing_Frame_" + chartId;
};
gviz.graphics.DrawingFrame.prototype.getIFrameDocument_ = function() {
  var iframe = this.getIFrame_();
  return iframe ? goog.dom.getFrameContentDocument(iframe) : null;
};
gviz.graphics.DrawingFrame.prototype.getIFrameWindow_ = function() {
  var iframe = this.getIFrame_();
  return iframe ? goog.dom.getFrameContentWindow(iframe) : null;
};
gviz.graphics.DrawingFrame.prototype.getIFrame_ = function() {
  var elem = this.domHelper_.getElement(this.frameId_);
  return elem;
};
gviz.graphics.DrawingFrame.prototype.createDrawingFrame_ = function(isVml) {
  var frame = this.domHelper_.createElement("iframe");
  frame.name = this.frameId_;
  frame.id = this.frameId_;
  frame.width = this.dimensions.width.toString();
  frame.height = this.dimensions.height.toString();
  frame.frameBorder = 0;
  frame.scrolling = "no";
  frame.marginHeight = 0;
  frame.marginWidth = 0;
  frame.allowTransparency = "true";
  isVml || (frame.type = "image/svg+xml");
  this.domHelper_.appendChild(this.container, frame);
  var frameDoc = goog.dom.getFrameContentDocument(frame);
  frameDoc.open();
  var frameSource = [];
  isVml ? (frameSource.push('<html xmlns:v="urn:schemas-microsoft-com:vml">'), frameSource.push("<head>"), frameSource.push("<style> v\\:* { behavior:url(#default#VML);}</style>")) : (frameSource.push('<?xml version="1.0"?>'), frameSource.push('<html xmlns="http://www.w3.org/1999/xhtml"'), frameSource.push(' xmlns:svg="http://www.w3.org/2000/svg"'), frameSource.push(' xmlns:xlink="http://www.w3.org/1999/xlink">'), frameSource.push("<head>"));
  frameSource.push('<script type="text/javascript">');
  frameSource.push("var _loaded = false;");
  frameSource.push("function CHART_loaded() {");
  frameSource.push(" _loaded = true;");
  frameSource.push("}");
  frameSource.push("\x3c/script>");
  frameSource.push("</head>");
  frameSource.push('<body marginwidth="0" marginheight="0"');
  frameSource.push(' onload="CHART_loaded()"');
  frameSource.push(">");
  frameSource.push('<div id="renderers"></div>');
  frameSource.push("</body>");
  frameSource.push("</html>");
  frameDoc.write(frameSource.join("\n"));
  frameDoc.close();
};
gviz.graphics.DrawingFrame.isBrowserSupported_ = function() {
  var version = goog.userAgent.VERSION;
  return goog.userAgent.IE ? 0 <= goog.string.compareVersions(version, "5.5") : goog.userAgent.GECKO ? 0 <= goog.string.compareVersions(version, "1.8") : goog.userAgent.OPERA ? 0 <= goog.string.compareVersions(version, "9.0") : goog.userAgent.WEBKIT ? 0 <= goog.string.compareVersions(version, "420+") : !1;
};
gviz.graphics.DrawingFrame.waitForCondition = function(condition, callback, asyncWrapper, opt_interval) {
  condition.call() ? callback.call() : gviz.graphics.DrawingFrame.waitForConditionAsync(condition, callback, asyncWrapper, opt_interval);
};
gviz.graphics.DrawingFrame.waitForConditionAsync = function(condition, callback, asyncWrapper, opt_interval) {
  var interval = goog.isDefAndNotNull(opt_interval) ? opt_interval : 10;
  window.setTimeout(asyncWrapper(function() {
    gviz.graphics.DrawingFrame.waitForCondition(condition, callback, asyncWrapper, interval);
  }), interval);
};
gviz.graphics.DrawingFrame.prototype.disposeInternal = function() {
  try {
    this.domHelper_.removeChildren(this.container), goog.dispose(this.overlayArea_), goog.array.forEach(this.renderers_, function(renderer) {
      goog.dispose(renderer);
    });
  } catch (e) {
  }
  gviz.graphics.DrawingFrame.superClass_.disposeInternal.call(this);
};
// INPUT (javascript/gviz/devel/graphics/multi-brush-path-segments.js)
gviz.graphics.MultiBrushPathSegments = function() {
  this.segments = [];
};
gviz.graphics.MultiBrushPathSegments.prototype.addSegment = function(brush, segment) {
  goog.array.isEmpty(this.segments) && goog.asserts.assert(segment.type == gviz.graphics.PathSegments.SegmentType.MOVE);
  this.segments.push({brush:brush, segment:segment});
};
gviz.graphics.MultiBrushPathSegments.prototype.move = function(x, y) {
  var segment = gviz.graphics.PathSegments.createMoveSegment(x, y);
  this.addSegment(null, segment);
};
gviz.graphics.MultiBrushPathSegments.prototype.addLine = function(brush, x, y) {
  var segment = gviz.graphics.PathSegments.createLineSegment(x, y);
  this.addSegment(brush, segment);
};
gviz.graphics.MultiBrushPathSegments.prototype.addCurve = function(brush, x1, y1, x2, y2, x, y) {
  var segment = gviz.graphics.PathSegments.createCurveSegment(x1, y1, x2, y2, x, y);
  this.addSegment(brush, segment);
};
gviz.graphics.MultiBrushPathSegments.prototype.addArc = function(brush, cx, cy, rx, ry, fromAngle, toAngle, isClockwise) {
  var segment = gviz.graphics.PathSegments.createArcSegment(cx, cy, rx, ry, fromAngle, toAngle, isClockwise);
  this.addSegment(brush, segment);
};
gviz.graphics.MultiBrushPathSegments.prototype.close = function(brush) {
  goog.asserts.assert(!goog.array.isEmpty(this.segments));
  var startPos = this.segments[0].segment.data;
  this.addLine(brush, startPos.x, startPos.y);
};
gviz.graphics.MultiBrushPathSegments.getPathByBrush_ = function(paths, brush) {
  for (var p = 0;p < paths.length;p++) {
    var path = paths[p];
    if (gviz.graphics.Brush.equals(brush, path.brush)) {
      return path;
    }
  }
  path = {brush:brush, segments:new gviz.graphics.PathSegments, endPos:null};
  paths.push(path);
  return path;
};
gviz.graphics.MultiBrushPathSegments.calcSegmentEndPos_ = function(segment) {
  switch(segment.type) {
    case gviz.graphics.PathSegments.SegmentType.MOVE:
    ;
    case gviz.graphics.PathSegments.SegmentType.LINE:
    ;
    case gviz.graphics.PathSegments.SegmentType.CURVE:
      var pos = segment.data;
      return new goog.math.Coordinate(pos.x, pos.y);
    case gviz.graphics.PathSegments.SegmentType.ARC:
      var arc = segment.data, toAngle = goog.math.standardAngle(arc.toAngle), toAngleDx = goog.math.angleDx(toAngle - 90, arc.rx), toAngleDy = goog.math.angleDy(toAngle - 90, arc.ry);
      return new goog.math.Coordinate(arc.cx + toAngleDx, arc.cy + toAngleDy);
    default:
      return goog.asserts.assert(!1), new goog.math.Coordinate(0, 0);
  }
};
gviz.graphics.MultiBrushPathSegments.prototype.buildPaths_ = function() {
  for (var paths = [], curPos = null, i = 0;i < this.segments.length;i++) {
    var brushSegment = this.segments[i], segment = brushSegment.segment;
    if (segment.type == gviz.graphics.PathSegments.SegmentType.MOVE) {
      curPos = gviz.graphics.MultiBrushPathSegments.calcSegmentEndPos_(segment);
    } else {
      var brush = brushSegment.brush;
      goog.asserts.assert(brush);
      var path = gviz.graphics.MultiBrushPathSegments.getPathByBrush_(paths, brush);
      goog.asserts.assert(curPos);
      goog.math.Coordinate.equals(path.endPos, curPos) || path.segments.move(curPos.x, curPos.y);
      path.segments.addSegment(segment);
      curPos = path.endPos = gviz.graphics.MultiBrushPathSegments.calcSegmentEndPos_(segment);
    }
  }
  return paths;
};
gviz.graphics.MultiBrushPathSegments.createPathElement_ = function(renderer, paths) {
  if (goog.array.isEmpty(paths)) {
    return null;
  }
  if (1 == paths.length) {
    return renderer.createPath(paths[0].segments, paths[0].brush);
  }
  for (var pathGroup = renderer.createGroup(), p = 0;p < paths.length;p++) {
    var path = paths[p], pathElement = renderer.createPath(path.segments, path.brush);
    renderer.appendChild(pathGroup, pathElement);
  }
  return pathGroup.getElement();
};
gviz.graphics.MultiBrushPathSegments.prototype.createPath = function(renderer) {
  var paths = this.buildPaths_();
  return gviz.graphics.MultiBrushPathSegments.createPathElement_(renderer, paths);
};
gviz.graphics.MultiBrushPathSegments.prototype.toSingleBrush = function() {
  for (var path = new gviz.graphics.PathSegments, i = 0;i < this.segments.length;i++) {
    var brushSegment = this.segments[i];
    path.addSegment(brushSegment.segment);
  }
  return path;
};
// INPUT (javascript/gviz/devel/graphics/path-segments-util.js)
gviz.graphics.pathsegmentsutil = {};
gviz.graphics.pathsegmentsutil.calcParallelPath = function(path, dist) {
  var parallelPath = new gviz.graphics.PathSegments, segments = path.segments;
  if (0 == segments.length || 1 == segments.length) {
    return parallelPath;
  }
  for (var points = [null], i = 0;i < segments.length;i++) {
    var segment = segments[i];
    segment.data && points.push(new goog.math.Coordinate(segment.data.x, segment.data.y));
  }
  points.push(null);
  var lastSegmentType = segments[segments.length - 1].type, closed = lastSegmentType == gviz.graphics.PathSegments.SegmentType.CLOSE;
  gviz.graphics.pathsegmentsutil.addPaddingPoints_(points, closed);
  for (var calcParallelToTheRight = gviz.graphics.pathsegmentsutil.calcParallelToTheRight, calcPerpendicularLine = gviz.graphics.pathsegmentsutil.calcPerpendicularLine, intersectLines = gviz.graphics.pathsegmentsutil.intersectLines, segmentContainsPoint = gviz.graphics.pathsegmentsutil.segmentContainsPoint, calcParallelSegment = gviz.graphics.pathsegmentsutil.calcParallelSegment_, clockwise = 0 > dist, previousParallelLine = null, previousPoint = null, previousSegment = null, lastPathPointIndex = 
  points.length - 2, i = 0;i <= lastPathPointIndex;i++) {
    if (!goog.math.Coordinate.equals(points[i], points[i + 1])) {
      var parallelLine = calcParallelToTheRight(points[i], points[i + 1], dist);
      if (previousParallelLine) {
        var intersectionPoint = intersectLines(previousParallelLine, parallelLine), parallelSegmentsIntersect;
        if (goog.isObject(intersectionPoint)) {
          var v1 = intersectLines(calcPerpendicularLine(previousPoint, points[i]), previousParallelLine), v2 = intersectLines(calcPerpendicularLine(points[i], previousPoint), previousParallelLine);
          parallelSegmentsIntersect = segmentContainsPoint(v1, v2, intersectionPoint);
        } else {
          parallelSegmentsIntersect = Infinity == intersectionPoint;
        }
        var parallelSegmentEndPoint;
        if (parallelSegmentsIntersect && Infinity != intersectionPoint) {
          parallelSegmentEndPoint = intersectionPoint;
        } else {
          var previousPerpendicularLine = calcPerpendicularLine(points[i], previousPoint);
          parallelSegmentEndPoint = intersectLines(previousPerpendicularLine, previousParallelLine);
        }
        goog.asserts.assert(previousSegment);
        parallelPath.addSegment(calcParallelSegment(previousSegment, parallelSegmentEndPoint));
        if (!parallelSegmentsIntersect) {
          var fromRadians = Math.atan2(parallelSegmentEndPoint.x - points[i].x, parallelSegmentEndPoint.y - points[i].y), fromAngle = 180 - goog.math.toDegrees(fromRadians), perpendicularLine = calcPerpendicularLine(points[i], points[i + 1]), arcEndPoint = intersectLines(perpendicularLine, parallelLine), toRadians = Math.atan2(arcEndPoint.x - points[i].x, arcEndPoint.y - points[i].y), toAngle = 180 - goog.math.toDegrees(toRadians);
          goog.asserts.assert(fromAngle != toAngle, "Two adjacent input segments cannot be parallel, so their parallel segments cannot be either");
          parallelPath.addArc(points[i].x, points[i].y, Math.abs(dist), Math.abs(dist), fromAngle, toAngle, clockwise);
        }
        previousParallelLine = parallelLine;
        previousPoint = points[i];
        previousSegment = segments[i];
      } else {
        previousParallelLine = parallelLine, previousPoint = points[i], previousSegment = gviz.graphics.PathSegments.createMoveSegment(segments[i].x, segments[i].y);
      }
    }
  }
  closed && parallelPath.close();
  return parallelPath;
};
gviz.graphics.pathsegmentsutil.addPaddingPoints_ = function(points, closed) {
  goog.asserts.assert(4 <= points.length);
  goog.asserts.assert(goog.isNull(points[0]));
  goog.asserts.assert(goog.isNull(points[points.length - 1]));
  var firstPoint = points[1].clone(), secondPoint = points[2].clone(), penultimatePoint = points[points.length - 3].clone(), lastPoint = points[points.length - 2].clone();
  if (closed) {
    points[0] = lastPoint, points[points.length - 1] = firstPoint;
  } else {
    if (goog.math.Coordinate.equals(firstPoint, lastPoint)) {
      points[0] = penultimatePoint, points[points.length - 1] = secondPoint;
    } else {
      var firstLine = new goog.math.Line(firstPoint.x, firstPoint.y, secondPoint.x, secondPoint.y);
      points[0] = firstLine.getInterpolatedPoint(-1);
      var lastLine = new goog.math.Line(lastPoint.x, lastPoint.y, penultimatePoint.x, penultimatePoint.y);
      points[points.length - 1] = lastLine.getInterpolatedPoint(-1);
    }
  }
};
gviz.graphics.pathsegmentsutil.calcParallelSegment_ = function(segment, point) {
  var parallelSegment = goog.object.unsafeClone(segment);
  switch(segment.type) {
    case gviz.graphics.PathSegments.SegmentType.MOVE:
    ;
    case gviz.graphics.PathSegments.SegmentType.LINE:
      parallelSegment.data.x = point.x;
      parallelSegment.data.y = point.y;
      break;
    case gviz.graphics.PathSegments.SegmentType.CURVE:
      parallelSegment.data.x = point.x;
      parallelSegment.data.y = point.y;
      var offsetX = point.x - segment.data.x, offsetY = point.y - segment.data.y;
      parallelSegment.data.x1 += offsetX;
      parallelSegment.data.y1 += offsetY;
      parallelSegment.data.x2 += offsetX;
      parallelSegment.data.y2 += offsetY;
      break;
    case gviz.graphics.PathSegments.SegmentType.ARC:
      goog.asserts.fail("Calculating parallel arcs is not yet supported.");
      break;
    case gviz.graphics.PathSegments.SegmentType.CLOSE:
      break;
    default:
      goog.asserts.fail('Unsupported segment type "' + segment.type + '"');
  }
  return parallelSegment;
};
gviz.graphics.pathsegmentsutil.segmentContainsPoint = function(v1, v2, p) {
  return goog.math.Range.containsPoint(new goog.math.Range(v1.x, v2.x), p.x) && goog.math.Range.containsPoint(new goog.math.Range(v1.y, v2.y), p.y);
};
gviz.graphics.pathsegmentsutil.calcLineFromTwoPoints = function(p1, p2) {
  goog.asserts.assert(!goog.math.Coordinate.equals(p1, p2));
  var dx = p2.x - p1.x, dy = p2.y - p1.y, m = dy / dx;
  if (!isFinite(m)) {
    return{m:Infinity, n:p1.x};
  }
  var n = p1.y - m * p1.x;
  return{m:m, n:n};
};
gviz.graphics.pathsegmentsutil.calcParallelToTheRight = function(p1, p2, dist) {
  var line = gviz.graphics.pathsegmentsutil.calcLineFromTwoPoints(p1, p2), m = line.m, n = line.n;
  if (Infinity == m) {
    var dy = p2.y - p1.y;
    return{m:Infinity, n:0 > dy ? n + dist : n - dist};
  }
  var h = dist * Math.sqrt(1 + m * m), dx = p2.x - p1.x;
  return{m:m, n:0 < dx ? n + h : n - h};
};
gviz.graphics.pathsegmentsutil.calcPerpendicularLine = function(p1, p2) {
  var m = (p1.x - p2.x) / (p2.y - p1.y), n;
  isFinite(m) ? n = p1.y - m * p1.x : (m = Infinity, n = p1.x);
  return{m:m, n:n};
};
gviz.graphics.pathsegmentsutil.intersectLines = function(l1, l2) {
  var m1 = l1.m, n1 = l1.n, m2 = l2.m, n2 = l2.n;
  isFinite(m1) || (m1 = Infinity);
  isFinite(m2) || (m2 = Infinity);
  if (gviz.util.roughlyEquals(m1, m2)) {
    return gviz.util.roughlyEquals(n1, n2) ? Infinity : null;
  }
  if (Infinity == m1) {
    return new goog.math.Coordinate(n1, m2 * n1 + n2);
  }
  if (Infinity == m2) {
    return new goog.math.Coordinate(n2, m1 * n2 + n1);
  }
  var dm = m2 - m1, dn = n2 - n1, n1m2 = n1 * m2, m1n2 = m1 * n2;
  return new goog.math.Coordinate(-dn / dm, (n1m2 - m1n2) / dm);
};
// INPUT (blaze-out/gcc-4.X.Y-crosstool-v17-hybrid-grtev3-k8-fastbuild/genfiles/javascript/gviz/devel/rabljs/rabl-closure-private-closurized.js)
var RaBl = {};
RaBl.RaBl = function() {
  var window = {}, mitchRequire = {}, define = function(name, reqs, func) {
    for (var args = [], i = 0, leni = reqs.length;i < leni;i++) {
      args.push(mitchRequire[resolvePath(name, reqs[i])]);
    }
    mitchRequire[name] = func.apply(this, args);
  }, resolvePath = function(name, relPath) {
    if (-1 === relPath.indexOf(".")) {
      return relPath;
    }
    var splitName = name.split("/");
    splitName.pop();
    var splitRel = relPath.split("/"), endName = splitRel.pop();
    if ("." === splitRel[0]) {
      splitRel.splice.apply(splitRel, [0, 1].concat(splitName));
    } else {
      for (var i = 0, leni = splitRel.length;i < leni;i++) {
        if (".." === splitRel[i]) {
          splitName.pop(), splitRel.splice(i, 1), i--;
        } else {
          break;
        }
      }
      splitRel = splitName.concat(splitRel);
    }
    splitRel.push(endName);
    return splitRel.join("/");
  };
  define("classdef", [], function() {
    function tempCtor() {
    }
    function createObj(proto) {
      tempCtor.prototype = proto;
      return new tempCtor;
    }
    function notImplemented(method) {
      return function() {
        throw'abstract method "' + method + '" not implemented.';
      };
    }
    function addNotImplementedMethods(constructor, properties) {
      for (var property, i = 0, leni = properties.length;i < leni;i++) {
        property = properties[i], constructor.prototype[property] = notImplemented(property);
      }
    }
    function listen(event, handler) {
      this.checkValidEvent_(event);
      this.events_[event].push(handler);
      return this;
    }
    function unlisten(event, handler) {
      this.checkValidEvent_(event);
      for (var events = this.events_[event], eventIndex = null, i = 0, leni = events.length;i < leni;i++) {
        if (events[i] === handler) {
          eventIndex = i;
          break;
        }
      }
      return null != eventIndex ? (events.splice(eventIndex, 1), !0) : !1;
    }
    function fireEvent(type, eventArgs) {
      this.checkValidEvent_(type);
      for (var events = this.events_[type], copy = [], i = 0, leni = events.length;i < leni;i++) {
        copy.push(events[i]);
      }
      for (i = 0;i < leni;i++) {
        copy[i].apply(this, eventArgs);
      }
      return 0 < leni;
    }
    function checkValidEvent(event) {
      if (!this.events_.hasOwnProperty(event)) {
        throw'event type "' + event + '" unknown.';
      }
    }
    function makeListenable(constructor) {
      constructor.prototype.listen = listen;
      constructor.prototype.unlisten = unlisten;
      constructor.prototype.fireEvent = fireEvent;
      constructor.prototype.checkValidEvent_ = checkValidEvent;
    }
    var classdefMethods = {};
    classdefMethods.createObj = Object.create || createObj;
    classdefMethods.notImplemented = notImplemented;
    classdefMethods.addNotImplementedMethods = addNotImplementedMethods;
    classdefMethods.makeListenable = makeListenable;
    return classdefMethods;
  });
  define("shapes/abstract_shape", ["classdef"], function(ClassDef) {
    function AbstractShape(opt_style) {
      this.events_ = {add:[], click:[], getcontext:[], mousemove:[], mouseenter:[], mouseleave:[], box:[], redraw:[], remove:[], playAnimation:[], finishAnimation:[]};
      this.context_ = this.data_ = null;
      this.style_ = {};
      this.animations_ = [];
      this.removeAnimationQueue_ = [];
      this.onFinishAnimationBound_ = onFinishAnimation_.bind(this);
      if (null != opt_style) {
        for (var key in opt_style) {
          setStyle.call(this, key, opt_style[key]);
        }
      }
    }
    function data(opt_newData) {
      return void 0 !== opt_newData ? (this.data_ = opt_newData, this) : this.data_;
    }
    function setStyle(path, value) {
      value instanceof Object && (value = value.toString());
      if (this.style_[path] === value) {
        return!1;
      }
      this.style_[path] = value;
      this.box_ = null;
      return!0;
    }
    function getStyle(opt_path) {
      return opt_path ? this.style_[opt_path] : this.style_;
    }
    function style(path, opt_value) {
      return void 0 !== opt_value ? (setStyle.call(this, path, opt_value) && this.fireEvent("redraw", [this, path]), this) : getStyle.call(this, path);
    }
    function getContext() {
      this.context_ || this.fireEvent("getcontext", [this]);
      return this.context_;
    }
    function getBoundingBox() {
      if (!(null != this.box_ || this.calculateBoundingBox_() && null != this.box_ || this.fireEvent("box", [this]) && null != this.box_)) {
        throw "cannot determine bounding box until inserted into a scene.";
      }
      return this.box_;
    }
    function calculateBoundingBox_() {
      return!1;
    }
    function removeAnimation(animation) {
      if (this.animating_) {
        this.removeAnimationQueue_.push(animation);
      } else {
        var idx = this.animations_.indexOf(animation);
        -1 < idx && this.animations_.splice(idx, 1);
        0 === this.animations_.length && this.unlisten("finishAnimation", this.onFinishAnimationBound_);
      }
      return this;
    }
    function onFinishAnimation_() {
      if (!this.animating_) {
        for (var i = 0, leni = this.removeAnimationQueue_.length;i < leni;i++) {
          this.removeAnimation(this.removeAnimationQueue_[i]);
        }
        this.removeAnimationQueue_ = [];
      }
    }
    AbstractShape.prototype.data = data;
    AbstractShape.prototype.style = style;
    AbstractShape.prototype.getContext = getContext;
    AbstractShape.prototype.getBoundingBox = getBoundingBox;
    AbstractShape.prototype.calculateBoundingBox_ = calculateBoundingBox_;
    AbstractShape.prototype.removeAnimation = removeAnimation;
    AbstractShape.prototype.clone = ClassDef.notImplemented("clone");
    ClassDef.makeListenable(AbstractShape);
    return AbstractShape;
  });
  define("renderers/abstract/abstractrenderer", ["classdef", "shapes/abstract_shape"], function(ClassDef) {
    function AbstractRenderer(el, width, height) {
      this.width_ = width;
      this.height_ = height;
      this.events_ = {add:[], click:[], mousemove:[], mouseenter:[], mouseleave:[], redraw:[], remove:[]};
    }
    ClassDef.makeListenable(AbstractRenderer);
    ClassDef.addNotImplementedMethods(AbstractRenderer, "drawCircle drawEllipse drawLine drawRect drawShape drawText removeShape stageShape clear".split(" "));
    return AbstractRenderer;
  });
  define("shapes/group", ["./abstract_shape", "classdef"], function(AbstractShape, ClassDef) {
    function Group(opt_shapes, opt_style) {
      AbstractShape.call(this, opt_style);
      this.shapes_ = [];
      if (opt_shapes) {
        throw "prepopulating a group is unimplemented.";
      }
      this.onRedrawBound_ = onRedraw_.bind(this);
      this.onMouseEventBound_ = onMouseEvent_.bind(this);
      this.onGetContextBound_ = onGetContext_.bind(this);
      this.onRemoveShapeBound_ = onRemoveShape_.bind(this);
    }
    function drawShape(shape) {
      if (shape.getContext()) {
        throw "cannot add a shape to a group that already has a context.";
      }
      this.shapes_.push(shape);
      shape.listen("redraw", this.onRedrawBound_);
      shape.listen("click", this.onMouseEventBound_);
      shape.listen("mousemove", this.onMouseEventBound_);
      shape.listen("mouseenter", this.onMouseEventBound_);
      shape.listen("mouseleave", this.onMouseEventBound_);
      shape.listen("getcontext", this.onGetContextBound_);
      shape.listen("remove", this.onRemoveShapeBound_);
      this.fireEvent("add", [shape, !1]);
      return this;
    }
    function clear() {
      for (var i = 0, leni = this.shapes_.length;i < leni;i++) {
        this.shapes_[i].unlisten("redraw", this.onRedrawBound_), this.fireEvent("remove", [this.shapes_[i]]);
      }
      this.shapes_ = [];
      this.fireEvent("redraw", [this]);
      return this;
    }
    function contains(shape) {
      return 0 <= this.shapes_.indexOf(shape);
    }
    function onRedraw_() {
    }
    function onMouseEvent_(e) {
      this.fireEvent(e.type, [e]);
    }
    function onGetContext_(shape) {
      shape.context_ = this;
      return!0;
    }
    function onRemoveShape_(shape) {
      var shapeIndex = this.shapes_.indexOf(shape);
      if (0 > shapeIndex) {
        throw "Shape does not exist in this group.";
      }
      shape.unlisten("redraw", this.onRedrawBound_);
      shape.unlisten("click", this.onMouseEventBound_);
      shape.unlisten("mousemove", this.onMouseEventBound_);
      shape.unlisten("mouseenter", this.onMouseEventBound_);
      shape.unlisten("mouseleave", this.onMouseEventBound_);
      shape.unlisten("getcontext", this.onGetContextBound_);
      shape.unlisten("remove", this.onRemoveShapeBound_);
      shape.context_ = null;
      this.shapes_.splice(shapeIndex, 1);
      return!0;
    }
    function removeShape(shape) {
      var shapeIndex = this.shapes_.indexOf(shape);
      if (0 > shapeIndex) {
        throw "Shape does not exist in this group.";
      }
      shape.fireEvent("remove", [shape]);
      return this;
    }
    function getShapes() {
      return this.shapes_;
    }
    Group.prototype = ClassDef.createObj(AbstractShape.prototype);
    Group.prototype.constructor = Group;
    Group.safeName = "Group";
    Group.prototype.drawShape = drawShape;
    Group.prototype.add = drawShape;
    Group.prototype.clear = clear;
    Group.prototype.contains = contains;
    Group.prototype.removeShape = removeShape;
    Group.prototype.remove = removeShape;
    Group.prototype.getShapes = getShapes;
    return Group;
  });
  define("shapes/circle", ["./abstract_shape", "classdef"], function(AbstractShape, ClassDef) {
    function Circle(r, x, y, opt_style) {
      opt_style = opt_style || {};
      opt_style.r = null == r ? opt_style.r : r;
      opt_style.x = null == x ? opt_style.x : x;
      opt_style.y = null == y ? opt_style.y : y;
      AbstractShape.call(this, opt_style);
    }
    function calculateBoundingBox_() {
      var r = this.style("r"), x = this.style("x"), y = this.style("y");
      this.box_ = {x:x - r, y:y - r, width:2 * r, height:2 * r};
      return!0;
    }
    Circle.prototype = ClassDef.createObj(AbstractShape.prototype);
    Circle.prototype.constructor = Circle;
    Circle.safeName = "Circle";
    Circle.prototype.calculateBoundingBox_ = calculateBoundingBox_;
    return Circle;
  });
  define("shapes/ellipse", ["./abstract_shape", "classdef"], function(AbstractShape, ClassDef) {
    function Ellipse(rx, ry, x, y, opt_style) {
      opt_style = opt_style || {};
      opt_style.rx = null == rx ? opt_style.rx : rx;
      opt_style.ry = null == ry ? opt_style.ry : ry;
      opt_style.x = null == x ? opt_style.x : x;
      opt_style.y = null == y ? opt_style.y : y;
      AbstractShape.call(this, opt_style);
    }
    function calculateBoundingBox_() {
      var rx = this.style("rx"), ry = this.style("ry"), x = this.style("x"), y = this.style("y");
      this.box_ = {x:x - rx, y:y - ry, width:2 * rx, height:2 * ry};
      return!0;
    }
    Ellipse.prototype = ClassDef.createObj(AbstractShape.prototype);
    Ellipse.prototype.constructor = Ellipse;
    Ellipse.safeName = "Ellipse";
    Ellipse.prototype.calculateBoundingBox_ = calculateBoundingBox_;
    return Ellipse;
  });
  define("shapes/line", ["./abstract_shape", "classdef"], function(AbstractShape, ClassDef) {
    function Line(x1, y1, x2, y2, opt_style) {
      opt_style = opt_style || {};
      opt_style.x1 = null == x1 ? opt_style.x1 : x1;
      opt_style.y1 = null == y1 ? opt_style.y1 : y1;
      opt_style.x2 = null == x2 ? opt_style.x2 : x2;
      opt_style.y2 = null == y2 ? opt_style.y2 : y2;
      AbstractShape.call(this, opt_style);
    }
    function calculateBoundingBox_() {
      var x1 = this.style("x1"), y1 = this.style("y1"), x2 = this.style("x2"), y2 = this.style("y2");
      this.box_ = {x:Math.min(x1, x2), y:Math.min(y1, y2), width:Math.abs(x2 - x1), height:Math.abs(y2 - y1)};
      return!0;
    }
    Line.prototype = ClassDef.createObj(AbstractShape.prototype);
    Line.prototype.constructor = Line;
    Line.safeName = "Line";
    Line.prototype.calculateBoundingBox_ = calculateBoundingBox_;
    return Line;
  });
  define("math", [], function() {
    function getBezierCurveBB(p1, c1, c2, p2) {
      function curveValue(t) {
        var t1 = 1 - t, t1squared = t1 * t1, tsquared = t * t, a = t1squared * t1, b = 3 * t * t1squared, c = 3 * t1 * tsquared, d = tsquared * t;
        x.push(p1.x * a + c1.x * b + c2.x * c + p2.x * d);
        y.push(p1.y * a + c1.y * b + c2.y * c + p2.y * d);
      }
      var x = [p1.x, p2.x], y = [p1.y, p2.y], u = 2 * p1.x - 4 * c1.x + 2 * c2.x, v = c1.x - p1.x, w = -p1.x + 3 * c1.x + p2.x - 3 * c2.x, t1 = (-u + Math.sqrt(u * u - 4 * v * w)) / (2 * w), t2 = (-u - Math.sqrt(u * u - 4 * v * w)) / (2 * w);
      "1e12" < Math.abs(t1) && (t1 = .5);
      "1e12" < Math.abs(t2) && (t2 = .5);
      0 < t1 && 1 > t1 && curveValue(t1);
      0 < t2 && 1 > t2 && curveValue(t2);
      u = 2 * p1.y - 4 * c1.y + 2 * c2.y;
      v = c1.y - p1.y;
      w = -p1.y + 3 * c1.y + p2.y - 3 * c2.y;
      t1 = (-u + Math.sqrt(u * u - 4 * v * w)) / (2 * w);
      t2 = (-u - Math.sqrt(u * u - 4 * v * w)) / (2 * w);
      "1e12" < Math.abs(t1) && (t1 = .5);
      "1e12" < Math.abs(t2) && (t2 = .5);
      0 < t1 && 1 > t1 && curveValue(t1);
      0 < t2 && 1 > t2 && curveValue(t2);
      var ret = {x1:Math.min.apply(Math, x), y1:Math.min.apply(Math, y), x2:Math.max.apply(Math, x), y2:Math.max.apply(Math, y)};
      ret.width = ret.x2 - ret.x1;
      ret.height = ret.y2 - ret.y1;
      return ret;
    }
    function modulo(a, b) {
      var r = a % b;
      return 0 > r * b ? r + b : r;
    }
    function containsAngle(rangeStart, rangeEnd, angle) {
      rangeStart = modulo(rangeStart, 360);
      rangeEnd = modulo(rangeEnd, 360);
      rangeEnd < rangeStart && (rangeEnd += 360);
      angle = modulo(angle, 360);
      angle < rangeStart && (angle += 360);
      return angle <= rangeEnd;
    }
    function getArcBB(cx, cy, rx, ry, fromAngle, toAngle, isClockwise) {
      fromAngle = modulo(fromAngle, 360);
      toAngle = modulo(toAngle, 360);
      var fromAngleRad = fromAngle / 180 * Math.PI, toAngleRad = fromAngle / 180 * Math.PI, fromX = cx + rx * Math.cos(fromAngleRad), fromY = cy + ry * Math.sin(fromAngleRad), toX = cx + rx * Math.cos(toAngleRad), toY = cy + ry * Math.sin(toAngleRad);
      if (!isClockwise) {
        var tmp = fromAngle;
        fromAngle = toAngle;
        toAngle = tmp;
      }
      var right = containsAngle(fromAngle, toAngle, 0) ? cx + rx : Math.max(fromX, toX), bottom = containsAngle(fromAngle, toAngle, 90) ? cy + ry : Math.max(fromY, toY), left = containsAngle(fromAngle, toAngle, 180) ? cx - rx : Math.min(fromX, toX), top = containsAngle(fromAngle, toAngle, 270) ? cy - ry : Math.min(fromY, toY);
      return{x1:left, y1:top, x2:right, y2:bottom};
    }
    return{modulo:modulo, getArcBB:getArcBB, getBezierCurveBB:getBezierCurveBB};
  });
  define("shapes/path", ["./abstract_shape", "classdef", "math"], function(AbstractShape, ClassDef, math) {
    function Path(opt_style) {
      AbstractShape.call(this, opt_style);
      this.box_ = {x1:null, y1:null, x2:null, y2:null, width:0, height:0};
      this.commands_ = [];
    }
    function calculateBoundingBox_() {
      return!1;
    }
    function move(x, y) {
      this.commands_.push("M " + x + " " + y);
      return this;
    }
    function line(x, y) {
      this.commands_.push("L " + x + " " + y);
      return this;
    }
    function arc(cx, cy, rx, ry, fromAngle, toAngle, isClockwise) {
      fromAngle = math.modulo(fromAngle, 360);
      toAngle = math.modulo(toAngle, 360);
      this.commands_.push("GVIZARC " + cx + " " + cy + " " + rx + " " + ry + " " + fromAngle + " " + toAngle + " " + Number(isClockwise));
      return this;
    }
    function close() {
      this.commands_.push("Z");
      return this;
    }
    function getCommands() {
      return this.commands_;
    }
    Path.prototype = ClassDef.createObj(AbstractShape.prototype);
    Path.prototype.constructor = Path;
    Path.safeName = "Path";
    Path.prototype.calculateBoundingBox_ = calculateBoundingBox_;
    Path.prototype.move = move;
    Path.prototype.line = line;
    Path.prototype.arc = arc;
    Path.prototype.close = close;
    Path.prototype.getCommands = getCommands;
    return Path;
  });
  define("shapes/rect", ["./abstract_shape", "classdef"], function(AbstractShape, ClassDef) {
    function Rect(x, y, width, height, opt_style) {
      opt_style = opt_style || {};
      opt_style.x = null == x ? opt_style.x : x;
      opt_style.y = null == y ? opt_style.y : y;
      opt_style.width = null == width ? opt_style.width : width;
      opt_style.height = null == height ? opt_style.height : height;
      AbstractShape.call(this, opt_style);
    }
    function calculateBoundingBox_() {
      this.box_ = {x:this.style("x"), y:this.style("y"), width:this.style("width"), height:this.style("height")};
      return!0;
    }
    function clone() {
      return new Rect(this.style("x"), this.style("y"), this.style("width"), this.style("height"), this.style());
    }
    Rect.prototype = ClassDef.createObj(AbstractShape.prototype);
    Rect.prototype.constructor = Rect;
    Rect.safeName = "Rect";
    Rect.prototype.calculateBoundingBox_ = calculateBoundingBox_;
    Rect.prototype.clone = clone;
    return Rect;
  });
  define("shapes/text", ["./abstract_shape", "classdef"], function(Shape, ClassDef) {
    function Text(x, y, text, opt_style) {
      opt_style = opt_style || {};
      opt_style.x = null == x ? opt_style.x : x;
      opt_style.y = null == y ? opt_style.y : y;
      opt_style.text = null == text ? opt_style.text : text;
      Shape.call(this, opt_style);
    }
    Text.prototype = ClassDef.createObj(Shape.prototype);
    Text.prototype.constructor = Text;
    Text.safeName = "Text";
    return Text;
  });
  define("shapes/shapes", "./group ./circle ./ellipse ./line ./path ./rect ./text".split(" "), function(Group, Circle, Ellipse, Line, Path, Rect, Text) {
    return{Group:Group, Circle:Circle, Ellipse:Ellipse, Line:Line, Path:Path, Rect:Rect, Text:Text};
  });
  define("renderers/svg/svg-util", [], function() {
    function firstDefined(var_args) {
      for (var i = 0, leni = arguments.length;i < leni;i++) {
        if (null != arguments[i]) {
          return arguments[i];
        }
      }
    }
    function applyCommonSVGStyles(element, shape, context) {
      applyOpacity(element, shape, context);
      applyFillColor(element, shape, context);
      applyFillOpacity(element, shape, context);
      applyStrokeColor(element, shape, context);
      applyStrokeOpacity(element, shape, context);
      applyStrokeWidth(element, shape, context);
      applyBlur(element, shape, context);
      applyClip(element, shape, context);
    }
    function applySingleStyle(element, property, shape, context, opt_props) {
      opt_props = opt_props || {};
      var updateFunc = opt_props[property] || props[property];
      return updateFunc ? (updateFunc(element, shape, context), !0) : !1;
    }
    function applyHeight(element, shape) {
      var height = shape.style("height");
      element.setAttribute("height", height);
    }
    function applyWidth(element, shape) {
      var width = shape.style("width");
      element.setAttribute("width", width);
    }
    function applyX(element, shape) {
      var x = shape.style("x");
      element.setAttribute("x", x);
    }
    function applyY(element, shape) {
      var y = shape.style("y");
      element.setAttribute("y", y);
    }
    function applyFillColor(element, shape, context) {
      applyGradient(element, shape, context, !1);
      var fillColor = firstDefined(shape.style("fill.color"), shape.style("fillColor"), shape.style("fill"));
      "string" !== typeof fillColor && "number" !== typeof fillColor || element.setAttribute("fill", fillColor);
    }
    function applyFillOpacity(element, shape) {
      var fillOpacity = firstDefined(shape.style("fill.opacity"), shape.style("fillOpacity"), shape.style("fill-opacity"));
      "string" !== typeof fillOpacity && "number" !== typeof fillOpacity || element.setAttribute("fill-opacity", fillOpacity);
    }
    function applyStrokeColor(element, shape, context) {
      applyGradient(element, shape, context, !0);
      var strokeColor = firstDefined(shape.style("stroke.color"), shape.style("strokeColor"), shape.style("stroke"));
      "string" !== typeof strokeColor && "number" !== typeof strokeColor || element.setAttribute("stroke", strokeColor);
    }
    function applyStrokeOpacity(element, shape) {
      var strokeOpacity = firstDefined(shape.style("stroke.opacity"), shape.style("strokeOpacity"), shape.style("stroke-opacity"));
      "string" !== typeof strokeOpacity && "number" !== typeof strokeOpacity || element.setAttribute("stroke-opacity", strokeOpacity);
    }
    function applyStrokeWidth(element, shape) {
      var strokeWidth = firstDefined(shape.style("stroke.width"), shape.style("strokeWidth"), shape.style("stroke-width"));
      "string" !== typeof strokeWidth && "number" !== typeof strokeWidth || element.setAttribute("stroke-width", strokeWidth);
    }
    function applyOpacity(element, shape) {
      var opacity = shape.style("opacity");
      "string" !== typeof opacity && "number" !== typeof opacity || element.setAttribute("opacity", opacity);
    }
    function applyClip(element, shape, context) {
      var width = shape.style("clip.width"), height = shape.style("clip.height");
      if (width && height) {
        var x = shape.style("clip.x") || 0, y = shape.style("clip.y") || 0, key = [x, y, width, height].join(), staged = shape.staged_, clipElement = staged ? stagedClips[key] : clips[key];
        if (clipElement) {
          clipId = clipElement.getAttribute("id");
        } else {
          var clipElement = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), clipId = "rablclip" + (staged ? stagedClipCount++ : clipCount++);
          clipElement.setAttribute("id", clipId);
          var clipRectElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          clipRectElement.setAttribute("x", x);
          clipRectElement.setAttribute("y", y);
          clipRectElement.setAttribute("width", width);
          clipRectElement.setAttribute("height", height);
          clipElement.appendChild(clipRectElement);
          staged ? stagedClips[key] = clipElement : clips[key] = clipElement;
          for (var svg = context;"svg" !== svg.nodeName;) {
            svg = svg.parentNode;
          }
          svg = svg.querySelector("defs") || svg;
          svg.insertBefore(clipElement, svg.firstChild);
        }
        element.setAttribute("clip-path", "url(#" + clipId + ")");
      } else {
        element.hasAttribute("clip-path") && element.removeAttribute("clip-path");
      }
    }
    function applyGradient(element, shape, context, opt_stroke) {
      var prefix = opt_stroke ? "stroke" : "fill", from = shape.style(prefix + ".gradient.from"), to = shape.style(prefix + ".gradient.to"), currentValue = element.getAttribute(prefix);
      if (from && to) {
        var x1 = shape.style(prefix + ".gradient.x1") || "0%", y1 = shape.style(prefix + ".gradient.y1") || "0%", x2 = shape.style(prefix + ".gradient.x2") || "100%", y2 = shape.style(prefix + ".gradient.y2") || "0%", key = [from, to, x1, y1, x2, y2].join(), staged = shape.staged_, gradientElement = staged ? stagedGradients[key] : gradients[key];
        if (gradientElement) {
          gradientId = gradientElement.getAttribute("id");
        } else {
          var gradientElement = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"), gradientId = "rablgradient" + (staged ? stagedGradientCount++ : gradientCount++);
          gradientElement.setAttribute("id", gradientId);
          gradientElement.setAttribute("x1", x1);
          gradientElement.setAttribute("y1", y1);
          gradientElement.setAttribute("x2", x2);
          gradientElement.setAttribute("y2", y2);
          var fromElement = document.createElementNS("http://www.w3.org/2000/svg", "stop");
          fromElement.setAttribute("stop-color", from);
          fromElement.setAttribute("offset", "0%");
          var toElement = document.createElementNS("http://www.w3.org/2000/svg", "stop");
          toElement.setAttribute("stop-color", to);
          toElement.setAttribute("offset", "100%");
          gradientElement.appendChild(fromElement);
          gradientElement.appendChild(toElement);
          staged ? stagedGradients[key] = gradientElement : gradients[key] = gradientElement;
          for (var svg = context;"svg" !== svg.nodeName;) {
            svg = svg.parentNode;
          }
          svg = svg.querySelector("defs") || svg;
          svg.insertBefore(gradientElement, svg.firstChild);
        }
        var newGradientId = "url(#" + gradientId + ")";
        currentValue !== newGradientId && element.setAttribute("fill", newGradientId);
      } else {
        currentValue && "url(#" === currentValue.substr(0, 5) && element.removeAttribute(prefix);
      }
    }
    function applyBlur(element, shape, context) {
      var radius = shape.style("shadow.radius") || 0, opacity = shape.style("shadow.opacity") || 0;
      if (radius || opacity) {
        var xOffset = shape.style("shadow.xOffset") || shape.style("shadow.x-offset") || shape.style("shadow.xoffset") || 0, yOffset = shape.style("shadow.yOffset") || shape.style("shadow.y-offset") || shape.style("shadow.yoffset") || 0, key = [radius, opacity, xOffset, yOffset].join(), staged = shape.staged_, filterElement = staged ? stagedFilters[key] : filters[key];
        if (filterElement) {
          filterId = filterElement.getAttribute("id");
        } else {
          var filterElement = document.createElementNS("http://www.w3.org/2000/svg", "filter"), filterId = "rablshadow" + (staged ? stagedShadowCount++ : shadowCount++);
          filterElement.setAttribute("id", filterId);
          var gaussianBlurElement = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
          gaussianBlurElement.setAttribute("in", "SourceAlpha");
          gaussianBlurElement.setAttribute("stdDeviation", radius);
          var offsetElement = document.createElementNS("http://www.w3.org/2000/svg", "feOffset");
          offsetElement.setAttribute("dx", xOffset);
          offsetElement.setAttribute("dy", yOffset);
          if (null != opacity) {
            var componentTransferElement = document.createElementNS("http://www.w3.org/2000/svg", "feComponentTransfer"), alphaFuncElement = document.createElementNS("http://www.w3.org/2000/svg", "feFuncA");
            alphaFuncElement.setAttribute("type", "linear");
            alphaFuncElement.setAttribute("slope", opacity);
          }
          var mergeElement = document.createElementNS("http://www.w3.org/2000/svg", "feMerge"), mergeNode1 = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode"), mergeNode2 = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode");
          mergeNode2.setAttribute("in", "SourceGraphic");
          filterElement.appendChild(gaussianBlurElement);
          filterElement.appendChild(offsetElement);
          null != opacity && (componentTransferElement.appendChild(alphaFuncElement), filterElement.appendChild(componentTransferElement));
          mergeElement.appendChild(mergeNode1);
          mergeElement.appendChild(mergeNode2);
          filterElement.appendChild(mergeElement);
          staged ? stagedFilters[key] = filterElement : filters[key] = filterElement;
          for (var svg = context;"svg" !== svg.nodeName;) {
            svg = svg.parentNode;
          }
          svg = svg.querySelector("defs") || svg;
          svg.insertBefore(filterElement, svg.firstChild);
        }
        var currentFilterId = element.getAttribute("filter"), newFilterId = "url(#" + filterId + ")";
        currentFilterId !== newFilterId && element.setAttribute("filter", newFilterId);
      } else {
        element.hasAttribute("filter") && element.removeAttribute("filter");
      }
    }
    function clearDefs() {
      clearFilters();
      clearGradients();
      clearClips();
    }
    function clearFilters() {
      for (var k in filters) {
        if (filters.hasOwnProperty(k)) {
          var elem = filters[k], parent = elem.parentNode;
          parent.removeChild(elem);
          delete filters[k];
        }
      }
      shadowCount = 0;
      filters = {};
    }
    function clearGradients() {
      for (var k in gradients) {
        if (filters.hasOwnProperty(k)) {
          var elem = gradients[k], parent = elem.parentNode;
          parent.removeChild(elem);
          delete gradients[k];
        }
      }
      gradientCount = 0;
      gradients = {};
    }
    function clearClips() {
      for (var k in clips) {
        if (clips.hasOwnProperty(k)) {
          var elem = clips[k], parent = elem.parentNode;
          parent.removeChild(elem);
          delete clips[k];
        }
      }
      clipCount = 0;
      clips = {};
    }
    var props = {"fill.color":applyFillColor, fillColor:applyFillColor, fill:applyFillColor, "fill.gradient.from":applyFillColor, "fill.gradient.to":applyFillColor, "fill.gradient.x1":applyFillColor, "fill.gradient.y1":applyFillColor, "fill.gradient.x2":applyFillColor, "fill.gradient.y2":applyFillColor, "fill.opacity":applyFillOpacity, fillOpacity:applyFillOpacity, "fill-opacity":applyFillOpacity, height:applyHeight, opacity:applyOpacity, "stroke.color":applyStrokeColor, strokeColor:applyStrokeColor, 
    stroke:applyStrokeColor, "stroke.gradient.from":applyStrokeColor, "stroke.gradient.to":applyStrokeColor, "stroke.gradient.x1":applyStrokeColor, "stroke.gradient.y1":applyStrokeColor, "stroke.gradient.x2":applyStrokeColor, "stroke.gradient.y2":applyStrokeColor, "stroke.opacity":applyStrokeOpacity, strokeOpacity:applyStrokeOpacity, "stroke-opacity":applyStrokeOpacity, "stroke.width":applyStrokeWidth, strokeWidth:applyStrokeWidth, "stroke-width":applyStrokeWidth, width:applyWidth, x:applyX, y:applyY}, 
    clips = {}, stagedClips = {}, clipCount = 0, stagedClipCount = 0, gradients = {}, stagedGradients = {}, gradientCount = 0, stagedGradientCount = 0, filters = {}, stagedFilters = {}, shadowCount = 0, stagedShadowCount = 0;
    return{applyBlur:applyBlur, applyCommonSVGStyles:applyCommonSVGStyles, applySingleStyle:applySingleStyle, clearDefs:clearDefs};
  });
  define("renderers/svg/circle", ["./svg-util"], function(SvgUtil) {
    function applyX(element, shape) {
      var x = shape.style("x");
      element.setAttribute("cx", x);
    }
    function applyY(element, shape) {
      var y = shape.style("y");
      element.setAttribute("cy", y);
    }
    function applyR(element, shape) {
      var r = shape.style("r");
      element.setAttribute("r", r);
    }
    function draw(circle, context, opt_element) {
      var elem = opt_element || document.createElementNS("http://www.w3.org/2000/svg", "circle");
      applyX(elem, circle);
      applyY(elem, circle);
      applyR(elem, circle);
      SvgUtil.applyCommonSVGStyles(elem, circle, context);
      context && elem.parentNode !== context && context.appendChild(elem);
      return elem;
    }
    function redraw(circle, changedProperty, context, element) {
      SvgUtil.applySingleStyle(element, changedProperty, circle, context, props);
    }
    var circleMethods = {}, props = {r:applyR, x:applyX, y:applyY};
    circleMethods.draw = draw;
    circleMethods.redraw = redraw;
    return circleMethods;
  });
  define("renderers/svg/ellipse", ["./svg-util"], function(SvgUtil) {
    function applyX(element, shape) {
      var x = shape.style("x");
      element.setAttribute("cx", x);
    }
    function applyY(element, shape) {
      var y = shape.style("y");
      element.setAttribute("cy", y);
    }
    function applyRx(element, shape) {
      var x = shape.style("rx");
      element.setAttribute("rx", x);
    }
    function applyRy(element, shape) {
      var y = shape.style("ry");
      element.setAttribute("ry", y);
    }
    function draw(ellipse, context, opt_element) {
      var elem = opt_element || document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
      applyX(elem, ellipse);
      applyY(elem, ellipse);
      applyRx(elem, ellipse);
      applyRy(elem, ellipse);
      SvgUtil.applyCommonSVGStyles(elem, ellipse, context);
      context && elem.parentNode !== context && context.appendChild(elem);
      return elem;
    }
    function redraw(ellipse, changedProperty, context, element) {
      SvgUtil.applySingleStyle(element, changedProperty, ellipse, context);
    }
    var ellipseMethods = {};
    ellipseMethods.draw = draw;
    ellipseMethods.redraw = redraw;
    return ellipseMethods;
  });
  define("renderers/svg/line", ["./svg-util"], function(SvgUtil) {
    function applyX1(element, shape) {
      var x1 = shape.style("x1");
      element.setAttribute("x1", x1);
    }
    function applyY1(element, shape) {
      var y1 = shape.style("y1");
      element.setAttribute("y1", y1);
    }
    function applyX2(element, shape) {
      var x2 = shape.style("x2");
      element.setAttribute("x2", x2);
    }
    function applyY2(element, shape) {
      var y2 = shape.style("y2");
      element.setAttribute("y2", y2);
    }
    function draw(line, context, opt_element) {
      var elem = opt_element || document.createElementNS("http://www.w3.org/2000/svg", "line");
      applyX1(elem, line);
      applyX2(elem, line);
      applyY1(elem, line);
      applyY2(elem, line);
      SvgUtil.applyCommonSVGStyles(elem, line, context);
      context && elem.parentNode !== context && context.appendChild(elem);
      return elem;
    }
    function redraw(line, changedProperty, context, element) {
      SvgUtil.applySingleStyle(element, changedProperty, line, context, props);
    }
    var lineMethods = {}, props = {x1:applyX1, x2:applyX2, y1:applyY1, y2:applyY2};
    lineMethods.draw = draw;
    lineMethods.redraw = redraw;
    return lineMethods;
  });
  define("renderers/svg/path-util", ["math", "./svg-util"], function(math, SvgUtil) {
    function createSVGPath(context, path, opt_element) {
      var elem = opt_element || document.createElementNS("http://www.w3.org/2000/svg", "path");
      opt_element || elem.setAttribute("d", constructSvgPathCommands(path));
      SvgUtil.applyCommonSVGStyles(elem, path, context);
      return elem;
    }
    function constructSvgPathCommands(path) {
      for (var commands = path.getCommands(), newCommands = [], i = 0, leni = commands.length;i < leni;i++) {
        var command = commands[i];
        if ("GVIZARC " === command.substring(0, 8)) {
          var cmd = command.split(" "), cx = +cmd[1], cy = +cmd[2], rx = +cmd[3], ry = +cmd[4], fromAngle = math.modulo(+cmd[5], 360), toAngle = math.modulo(+cmd[6], 360), isClockwise = !!+cmd[7];
          if (270 === fromAngle && 0 === toAngle) {
            command = "A " + rx + " " + ry + " 0 0 1 " + (rx + cx) + " " + cy;
          } else {
            if (180 === fromAngle && 270 === toAngle) {
              command = "A " + rx + " " + ry + " 0 0 1 " + cx + " " + (cy - ry);
            } else {
              if (0 === fromAngle && 90 === toAngle) {
                command = "A " + rx + " " + ry + " 0 0 1 " + cx + " " + (cy + ry);
              } else {
                if (90 === fromAngle && 180 === toAngle) {
                  command = "A " + rx + " " + ry + " 0 0 1 " + (cx - rx) + " " + cy;
                } else {
                  var sx = cx + Math.cos(toAngle / 180 * Math.PI) * rx, sy = cy + Math.sin(toAngle / 180 * Math.PI) * ry, angleDiff = isClockwise ? toAngle - fromAngle : fromAngle - toAngle;
                  0 > angleDiff && (angleDiff += 360);
                  var isLong = Number(180 < angleDiff), command = "A " + rx + " " + ry + " 0 " + isLong + " " + Number(isClockwise) + " " + sx + " " + sy;
                }
              }
            }
          }
        }
        newCommands.push(command);
      }
      return newCommands.join(" ");
    }
    return{createSVGPath:createSVGPath, constructSvgPathCommands:constructSvgPathCommands};
  });
  define("renderers/svg/path", ["./path-util", "./svg-util"], function(PathUtil, SvgUtil) {
    function draw(path, context, opt_element) {
      var elem = PathUtil.createSVGPath(context, path, opt_element);
      context && elem.parentNode !== context && context.appendChild(elem);
      return elem;
    }
    function redraw(path, changedProperty, context, element) {
      SvgUtil.applySingleStyle(element, changedProperty, path, context);
    }
    var pathMethods = {};
    pathMethods.draw = draw;
    pathMethods.redraw = redraw;
    return pathMethods;
  });
  define("shapes/rect-util", ["./path"], function(Path) {
    function hasIndividualRoundedCorners(rect) {
      var topleftX = rect.style("corners.topleft.rx") || 0, topleftY = rect.style("corners.topleft.ry") || 0, toprightX = rect.style("corners.topright.rx") || 0, toprightY = rect.style("corners.topright.ry") || 0, bottomleftX = rect.style("corners.bottomleft.rx") || 0, bottomleftY = rect.style("corners.bottomleft.ry") || 0, bottomrightX = rect.style("corners.bottomright.rx") || 0, bottomrightY = rect.style("corners.bottomright.ry") || 0;
      return topleftX || topleftY || toprightX || toprightY || bottomleftX || bottomleftY || bottomrightX || bottomrightY;
    }
    function constructRoundedRectPath(rect) {
      var rx = rect.style("corners.rx") || 0, ry = rect.style("corners.ry") || 0, topleftX = rect.style("corners.topleft.rx") || rx, topleftY = rect.style("corners.topleft.ry") || ry, toprightX = rect.style("corners.topright.rx") || rx, toprightY = rect.style("corners.topright.ry") || ry, bottomleftX = rect.style("corners.bottomleft.rx") || rx, bottomleftY = rect.style("corners.bottomleft.ry") || ry, bottomrightX = rect.style("corners.bottomright.rx") || rx, bottomrightY = rect.style("corners.bottomright.ry") || 
      ry, width = rect.style("width"), height = rect.style("height"), x = rect.style("x"), y = rect.style("y"), x = 0 <= width ? x : x + width, y = 0 <= height ? y : y + height, width = Math.abs(width), height = Math.abs(height);
      if (topleftX + toprightX > width) {
        var ratio = width / (topleftX + toprightX), topleftX = topleftX * ratio, topleftY = topleftY * ratio, toprightX = toprightX * ratio, toprightY = toprightY * ratio
      }
      bottomleftX + bottomrightX > width && (ratio = width / (bottomleftX + bottomrightX), bottomleftX *= ratio, bottomleftY *= ratio, bottomrightX *= ratio, bottomrightY *= ratio);
      topleftY + bottomleftY > height && (ratio = height / (topleftY + bottomleftY), topleftX *= ratio, topleftY *= ratio, bottomleftX *= ratio, bottomleftY *= ratio);
      toprightY + bottomrightY > height && (ratio = height / (toprightY + bottomrightY), toprightX *= ratio, toprightY *= ratio, bottomrightX *= ratio, bottomrightY *= ratio);
      return(new Path(rect.style())).move(x + width - toprightX, y).arc(x + width - toprightX, y + toprightY, toprightX, toprightY, 270, 0, !0).line(x + width, y + height - bottomrightY).arc(x + width - bottomrightX, y + height - bottomrightY, bottomrightX, bottomrightY, 0, 90, !0).line(x + bottomleftX, y + height).arc(x + bottomleftX, y + height - bottomleftY, bottomleftX, bottomleftY, 90, 180, !0).line(x, y + topleftY).arc(x + topleftX, y + topleftY, topleftX, topleftY, 180, 270, !0).close();
    }
    return{hasIndividualRoundedCorners:hasIndividualRoundedCorners, constructRoundedRectPath:constructRoundedRectPath};
  });
  define("renderers/svg/rect", ["../../shapes/rect-util", "./path-util", "./svg-util"], function(RectUtil, PathUtil, SvgUtil) {
    function draw(rect, context, opt_element) {
      var rx = rect.style("corners.rx"), ry = rect.style("corners.ry"), elem, width = rect.style("width"), height = rect.style("height"), x = rect.style("x"), y = rect.style("y"), x = 0 <= width ? x : x + width, y = 0 <= height ? y : y + height, width = Math.abs(width), height = Math.abs(height);
      if ("number" === typeof rx && "number" === typeof ry || !RectUtil.hasIndividualRoundedCorners(rect)) {
        elem = opt_element || document.createElementNS("http://www.w3.org/2000/svg", "rect"), elem.setAttribute("x", x), elem.setAttribute("y", y), elem.setAttribute("width", width), elem.setAttribute("height", height), null != rx && "number" === typeof rx && elem.setAttribute("rx", rx), null != ry && "number" === typeof ry && elem.setAttribute("ry", ry), SvgUtil.applyCommonSVGStyles(elem, rect, context);
      } else {
        var path = RectUtil.constructRoundedRectPath(rect);
        elem = PathUtil.createSVGPath(context, path, opt_element);
      }
      context && elem.parentNode !== context && context.appendChild(elem);
      return elem;
    }
    function redraw(rect, changedProperty, context, element) {
      if (!SvgUtil.applySingleStyle(element, changedProperty, rect, context)) {
        switch(changedProperty) {
          case "corners.rx":
          ;
          case "corners.ry":
          ;
          case "corners.topleft.rx":
          ;
          case "corners.topleft.ry":
          ;
          case "corners.topright.rx":
          ;
          case "corners.topright.ry":
          ;
          case "corners.bottomleft.rx":
          ;
          case "corners.bottomleft.ry":
          ;
          case "corners.bottomright.rx":
          ;
          case "corners.bottomright.ry":
            if ("path" === element.tagName.toLowerCase()) {
              var path = RectUtil.constructRoundedRectPath(rect), commands = PathUtil.constructSvgPathCommands(path);
              element.setAttribute("d", commands);
            } else {
              "corners.rx" === changedProperty ? element.setAttribute("rx", rect.style("corners.rx")) : "corners.ry" === changedProperty && element.setAttribute("ry", rect.style("corners.ry"));
            }
            break;
          case "shadow.radius":
          ;
          case "shadow.opacity":
          ;
          case "shadow.xOffset":
          ;
          case "shadow.x-offset":
          ;
          case "shadow.xoffset":
          ;
          case "shadow.yOffset":
          ;
          case "shadow.y-offset":
          ;
          case "shadow.yoffset":
            SvgUtil.applyBlur(element, rect, context);
            break;
          default:
            throw'unknown property on rect "' + changedProperty + '".';;
        }
      }
    }
    var rectMethods = {};
    rectMethods.draw = draw;
    rectMethods.redraw = redraw;
    return rectMethods;
  });
  define("renderers/svg/text", ["./svg-util", "../../shapes/shapes"], function(SvgUtil) {
    function applyFontFamily(element, shape) {
      var fontFamily = shape.style("font.family") || shape.style("fontFamily") || shape.style("fontName");
      element.style.fontFamily = "string" === typeof fontFamily ? fontFamily : "";
    }
    function applyFontSize(element, shape) {
      var fontSize = shape.style("font.size") || shape.style("fontSize");
      element.style.fontSize = "number" === typeof fontSize ? fontSize + "px" : "string" === typeof fontSize ? fontSize : "";
    }
    function applyFontWeight(element, shape) {
      var fontWeight = shape.style("font.weight") || shape.style("fontWeight");
      element.style.fontWeight = "string" === typeof fontWeight || "number" === typeof fontWeight ? fontWeight : "";
    }
    function applyItalic(element, shape) {
      !0 === shape.style("italic") ? element.style.fontStyle = "italic" : element.style.fontStyle = "";
    }
    function applyUnderline(element, shape) {
      !0 === shape.style("underline") ? element.style.textDecoration = "underline" : element.style.textDecoration = "";
    }
    function createTextElement(context, textContent, textShape, elem, opt_tag, opt_x, opt_y) {
      var tag = opt_tag || "text";
      elem = !elem || tag && elem.tagName !== tag ? document.createElementNS("http://www.w3.org/2000/svg", tag) : elem;
      elem.textContent = textContent;
      elem.setAttribute("rabl-use-parent", "true");
      elem.setAttribute("x", null == opt_x ? textShape.style("x") : opt_x);
      elem.setAttribute("y", null == opt_y ? textShape.style("y") : opt_y);
      elem.setAttribute("style", "cursor:default;-webkit-user-select:none;-moz-osx-font-smoothing:grayscale;");
      elem.style.webkitFontSmoothing = "antialiased";
      SvgUtil.applyCommonSVGStyles(elem, textShape, context);
      applyItalic(elem, textShape);
      applyUnderline(elem, textShape);
      applyFontFamily(elem, textShape);
      applyFontSize(elem, textShape);
      applyFontWeight(elem, textShape);
      return elem;
    }
    function drawTextElement(text, context, opt_element) {
      var lineSpacing = text.style("lineSpacing") || text.style("line-spacing") || 0, textContent = text.style("text");
      "string" === typeof textContent && (textContent = textContent.split("\n"));
      var initialY = text.style("y"), y = initialY, isTextContentArray = !0;
      1 === textContent.length && (textContent = textContent[0], isTextContentArray = !1);
      var textElement = createTextElement(context, isTextContentArray ? "" : textContent, text, opt_element, null, text.style("x"), y);
      context && textElement.parentNode !== context && context.appendChild(textElement);
      var lines = [];
      if (isTextContentArray) {
        for (var i = 0, leni = textContent.length;i < leni;i++) {
          var span = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          span.textContent = textContent[i];
          span.setAttribute("x", text.style("x"));
          span.setAttribute("y", text.style("y"));
          var dy = textElement.getBBox().height;
          0 < i && (dy += lineSpacing);
          span.setAttribute("dy", dy + "px");
          textElement.appendChild(span);
          lines.push(span);
        }
      }
      return{group:textElement, lines:isTextContentArray ? lines : [textElement]};
    }
    function draw(text, context, opt_element) {
      var renderedText = drawTextElement(text, context, opt_element), lines = renderedText.lines, group = renderedText.group, halign = Math.max(0, Math.min(1, text.style("halign") || 0));
      if (isNaN(halign) || !isFinite(halign)) {
        halign = 0;
      }
      var valign = text.style("valign");
      if ("number" === typeof valign) {
        if (valign = Math.max(0, Math.min(1, valign)), isNaN(valign) || !isFinite(valign)) {
          valign = 0;
        }
      } else {
        valign = "baseline";
      }
      var box = group.getBBox(), baselineOffset = text.style("y") - box.y, lastLine = lines[lines.length - 1], lastLineOffset;
      lastLineOffset = "tspan" === lastLine.tagName.toLowerCase() ? lines[lines.length - 1].getBoundingClientRect().top - group.getBoundingClientRect().top : lines[lines.length - 1].getBBox().y - box.y;
      var texty = text.style("y");
      if ("number" === typeof valign) {
        texty += baselineOffset, texty -= box.height * valign;
      } else {
        if ("baseline" === valign) {
          texty = texty + baselineOffset - lastLineOffset;
        } else {
          throw "Unrecognized valign value: " + valign;
        }
      }
      group.setAttribute("y", texty);
      for (var i = 0, leni = lines.length;i < leni;i++) {
        var elem = lines[i];
        elem.setAttribute("dx", -elem.getComputedTextLength() * halign + "px");
        elem.setAttribute("y", texty);
      }
      var angle = text.style("rotate");
      null != angle && 0 != angle && group.setAttribute("transform", "rotate(" + angle + " " + text.style("x") + " " + text.style("y") + ")");
      return group;
    }
    function redraw(text, changedProperty, context, element) {
      if (!SvgUtil.applySingleStyle(element, changedProperty, text, context, props)) {
        if ("text" === changedProperty || "halign" === changedProperty || "valign" === changedProperty) {
          for (;element && element.firstChild;) {
            element.removeChild(element.firstChild);
          }
          var newElement = draw(text, context, element);
          if (element !== newElement) {
            throw "error redrawing text";
          }
        } else {
          throw'error redrawing text element with changed property "' + changedProperty + '".';
        }
      }
    }
    var textMethods = {}, props = {"font.family":applyFontFamily, fontFamily:applyFontFamily, fontName:applyFontFamily, "font.size":applyFontSize, fontSize:applyFontSize, "font.weight":applyFontWeight, fontWeight:applyFontWeight, italic:applyItalic, underline:applyUnderline};
    textMethods.draw = draw;
    textMethods.redraw = redraw;
    return textMethods;
  });
  define("renderers/svg/group", "./circle ./ellipse ./line ./path ./rect ./text ./svg-util".split(" "), function(Circle, Ellipse, Line, Path, Rect, Text, SvgUtil) {
    function draw(group, context, opt_element) {
      var elem = opt_element || document.createElementNS("http://www.w3.org/2000/svg", "g");
      SvgUtil.applyCommonSVGStyles(elem, group, context);
      context && elem.parentNode !== context && context.appendChild(elem);
      return elem;
    }
    function redraw(group, context, element) {
      var newElement = draw(group, context, element);
      element !== newElement && group.getContext().fireEvent("add", [group, newElement, !1]);
      var shapes = group.getShapes().slice();
      shapes.reverse();
      return shapes;
    }
    var groupMethods = {};
    groupMethods.draw = draw;
    groupMethods.redraw = redraw;
    return groupMethods;
  });
  define("renderers/svg/shapes", "shapes/shapes ./group ./circle ./ellipse ./line ./path ./rect ./text".split(" "), function(AbstractShapes, Group, Circle, Ellipse, Line, Path, Rect, Text) {
    var ret = {};
    ret[AbstractShapes.Group.safeName] = Group;
    ret[AbstractShapes.Circle.safeName] = Circle;
    ret[AbstractShapes.Ellipse.safeName] = Ellipse;
    ret[AbstractShapes.Line.safeName] = Line;
    ret[AbstractShapes.Path.safeName] = Path;
    ret[AbstractShapes.Rect.safeName] = Rect;
    ret[AbstractShapes.Text.safeName] = Text;
    return ret;
  });
  define("renderers/svg/svg", ["renderers/abstract/abstractrenderer", "classdef", "shapes/shapes", "./shapes", "./svg-util"], function(AbstractRenderer, ClassDef, AbstractShapes, Shapes, SvgUtil) {
    function SvgRenderer(el, width, height) {
      AbstractRenderer.call(this, el, width, height);
      var svg = this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", width);
      svg.setAttribute("height", height);
      clear.call({svg:el});
      svg.appendChild(document.createElementNS("http://www.w3.org/2000/svg", "defs"));
      el.appendChild(svg);
      this.onGetContextBound_ = onGetContext_.bind(this);
      this.onBoxBound_ = onBox_.bind(this);
      this.onRedrawBound_ = onRedraw_.bind(this);
      this.onRemoveShapeBound_ = onRemoveShape_.bind(this);
      this.onAddShapeBound_ = onAddShape_.bind(this);
      this.onMouseEventBound_ = onMouseEvent_.bind(this);
      this.onPlayAnimationBound_ = onPlayAnimation_.bind(this);
      svg.addEventListener("click", this.onMouseEventBound_);
      svg.addEventListener("mousemove", this.onMouseEventBound_);
      svg.addEventListener("mouseover", this.onMouseEventBound_);
      svg.addEventListener("mouseout", this.onMouseEventBound_);
      this.shapes = [];
      this.elements = [];
    }
    function addShape_(shape, elem, opt_setContext) {
      var existingShapeIndex = this.shapes.indexOf(shape);
      if (0 <= existingShapeIndex) {
        if (null != this.elements[existingShapeIndex] || !shape.staged_) {
          throw "Shape exists and is not a staged shape.";
        }
        shape.staged_ = !1;
        this.elements[existingShapeIndex] = elem;
      } else {
        this.shapes.push(shape), this.elements.push(elem);
      }
      "Text" === shape.constructor.safeName && shape.listen("box", this.onBoxBound_);
      shape.listen("redraw", this.onRedrawBound_);
      shape.listen("add", this.onAddShapeBound_);
      shape.listen("playAnimation", this.onPlayAnimationBound_);
      shape.listen("remove", this.onRemoveShapeBound_);
      opt_setContext && shape.listen("getcontext", this.onGetContextBound_);
      return shape;
    }
    function onAddShape_(shape, opt_setContext) {
      var context = opt_setContext ? this.svg : getElementFromShape_.call(this, shape.getContext()), elem = Shapes[shape.constructor.safeName].draw(shape, context);
      addShape_.call(this, shape, elem, !!opt_setContext);
      drawShapeChildren_.call(this, shape, elem);
      return shape;
    }
    function drawShape(shape) {
      var elem = getElementFromShape_.call(this, shape);
      return elem || shape.getContext() ? (shape.fireEvent("redraw", [shape]), shape) : onAddShape_.call(this, shape, !0);
    }
    function drawShapeChildren_(contextShape, contextElem) {
      if (contextShape.getShapes) {
        for (var children = contextShape.getShapes(), i = 0, leni = children.length;i < leni;i++) {
          var child = children[i], childElem = Shapes[child.constructor.safeName].draw(child, contextElem);
          addShape_.call(this, child, childElem, !1);
          drawShapeChildren_.call(this, child, childElem);
        }
      }
    }
    function drawCircle(r, x, y, opt_style) {
      var circle = new AbstractShapes.Circle(r, x, y, opt_style);
      return this.drawShape(circle);
    }
    function drawEllipse(rx, ry, x, y, opt_style) {
      var ellipse = new AbstractShapes.Ellipse(rx, ry, x, y, opt_style);
      return this.drawShape(ellipse);
    }
    function drawRect(x, y, width, height, opt_style) {
      var rect = new AbstractShapes.Rect(x, y, width, height, opt_style);
      return this.drawShape(rect);
    }
    function drawText(x, y, text, opt_style) {
      text = new AbstractShapes.Text(x, y, text, opt_style);
      return this.drawShape(text);
    }
    function drawLine(x1, y1, x2, y2, opt_style) {
      var line = new AbstractShapes.Line(x1, y1, x2, y2, opt_style);
      return this.drawShape(line);
    }
    function removeShape(shape) {
      var context = shape.getContext();
      if (null == context) {
        throw "Attempted to remove shape that doesn't have a context.";
      }
      return shape.fireEvent("remove", [shape]);
    }
    function onRemoveShape_(shape) {
      var idx = this.shapes.indexOf(shape);
      if (0 > idx) {
        return!1;
      }
      if (shape.getShapes) {
        for (var children = shape.getShapes(), i = 0, leni = children.length;i < leni;i++) {
          shape.fireEvent("remove", [children[i]]);
        }
        idx = this.shapes.indexOf(shape);
      }
      shape.staged_ || this.elements[idx].parentNode.removeChild(this.elements[idx]);
      this.shapes.splice(idx, 1);
      this.elements.splice(idx, 1);
      shape.unlisten("box", this.onBoxBound_);
      shape.unlisten("redraw", this.onRedrawBound_);
      shape.unlisten("remove", this.onRemoveShapeBound_);
      shape.unlisten("getcontext", this.onGetContextBound_);
      shape.unlisten("add", this.onAddShapeBound_);
      shape.unlisten("playAnimation", this.onPlayAnimationBound_);
      shape.context_ = null;
      return!0;
    }
    function onMouseEvent_(e) {
      for (var target = e.target;null != target.getAttribute("rabl-use-parent");) {
        target = target.parentNode;
      }
      var idx = this.elements.indexOf(e.target);
      if (0 <= idx) {
        var box = {x1:e.offsetX, y1:e.offsetY, x2:e.offsetX, y2:e.offsetY}, type = e.type;
        "mouseover" === type ? type = "mouseenter" : "mouseout" === type && (type = "mouseleave");
        var shape = this.shapes[idx];
        shape.fireEvent(type, [{point:{x:box.x1, y:box.y1}, type:type, target:shape}]);
      }
    }
    function onRedraw_(changedShape, changedProperty) {
      var context = changedShape.getContext() || this, elem = getElementFromShape_.call(this, changedShape), contextElem = getElementFromShape_.call(this, context), type = changedShape.constructor.safeName;
      Shapes[type].redraw(changedShape, changedProperty, contextElem, elem);
    }
    function onGetContext_(shape) {
      shape.context_ = this;
    }
    function onBox_(shape) {
      var type = shape.constructor.safeName;
      if ("Path" !== type) {
        if (shape.staged_) {
          var div = getMeasureElement_.call(this);
          div.style.display = "block";
          var elem = Shapes[shape.constructor.safeName].draw(shape, div.firstChild);
        } else {
          elem = getElementFromShape_.call(this, shape);
        }
        var box = elem.getBBox();
        shape.box_ = {width:box.width, height:box.height, x:box.x, y:box.y};
        shape.staged_ && (div.style.display = "none", elem.parentNode.removeChild(elem));
      }
    }
    function onPlayAnimation_(shape) {
      var startTime, endTimes = [], interpolateFuncs = [], finished = [];
      shape.animating_ = !0;
      var remainingAnimations = shape.animations_.length, animationLoop = function(ts) {
        startTime || (startTime = ts);
        shape.animations_.forEach(function(animation, idx) {
          finished[idx] || (interpolateFuncs[idx] || (interpolateFuncs[idx] = animation.interpolateFunc_(animation.from_, animation.to_, animation.duration_, startTime), endTimes[idx] = startTime + animation.duration_), ts >= endTimes[idx] ? (shape.style(animation.property_, animation.to_), remainingAnimations--, finished[idx] = !0, animation.fireEvent("finishAnimation", [shape, animation])) : shape.style(animation.property_, interpolateFuncs[idx](ts)));
        });
        remainingAnimations ? this.reqId = SvgRenderer.raf.call(win, animationLoop) : (this.reqId = void 0, shape.animating_ = !1, shape.fireEvent("finishAnimation", [shape]));
      };
      this.reqId = SvgRenderer.raf.call(win, animationLoop);
    }
    function getMeasureElement_() {
      if (!this.measureElement_) {
        var div = this.measureElement_ = document.createElement("div");
        div.style.position = "absolute";
        div.style.top = "-1000px";
        div.style.left = "-1000px";
        div.style.whiteSpace = "nowrap";
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        div.appendChild(svg);
        document.body.appendChild(div);
      }
      return this.measureElement_;
    }
    function getElementFromShape_(shape) {
      if (shape === this) {
        return this.svg;
      }
      var idx = this.shapes.indexOf(shape);
      return 0 > idx ? null : this.elements[idx];
    }
    function stageShape(shape) {
      if (shape.staged_) {
        throw Error("can't stage a shape that's already staged.");
      }
      if (-1 !== this.shapes.indexOf(shape)) {
        throw Error("can't stage a shape that's already drawn.");
      }
      shape.staged_ = !0;
      this.shapes.push(shape);
      this.elements.push(null);
      shape.listen("box", this.onBoxBound_);
      shape.listen("redraw", this.onRedrawBound_);
      shape.listen("remove", this.onRemoveShapeBound_);
      shape.listen("getcontext", this.onGetContextBound_);
      shape.listen("add", this.onAddShapeBound_);
      shape.listen("playAnimation", this.onPlayAnimationBound_);
      return shape;
    }
    function clear() {
      for (var svg = this.svg, defs;svg.firstChild;) {
        "defs" === svg.firstChild.tagName && (defs = !0), svg.removeChild(svg.firstChild);
      }
      defs && svg.appendChild(document.createElementNS("http://www.w3.org/2000/svg", "defs"));
      this.shapes = [];
      this.elements = [];
      SvgUtil.clearDefs();
      SvgRenderer.cancelRaf.call(win, this.reqId);
    }
    var win = function() {
      return this;
    }();
    SvgRenderer.raf = win.requestAnimationFrame || win.mozRequestAnimationFrame || win.webkitRequestAnimationFrame || win.msRequestAnimationFrame || function(cb) {
      win.setTimeout((function() {
        return cb.call(this, Date.now());
      }, 1E3 / 60));
    };
    SvgRenderer.cancelRaf = win.cancelRequestAnimationFrame || win.cancelAnimationFrame || win.mozCancelRequestAnimationFrame || win.mozCancelAnimationFrame || win.webkitCancelRequestAnimationFrame || win.webkitCancelAnimationFrame || win.msCancelRequestAnimationFrame || win.msCancelAnimationFrame || win.clearTimeout;
    SvgRenderer.prototype = ClassDef.createObj(AbstractRenderer.prototype);
    SvgRenderer.prototype.constructor = SvgRenderer;
    SvgRenderer.prototype.drawShape = drawShape;
    SvgRenderer.prototype.drawCircle = drawCircle;
    SvgRenderer.prototype.drawEllipse = drawEllipse;
    SvgRenderer.prototype.drawRect = drawRect;
    SvgRenderer.prototype.drawLine = drawLine;
    SvgRenderer.prototype.drawText = drawText;
    SvgRenderer.prototype.removeShape = removeShape;
    SvgRenderer.prototype.stageShape = stageShape;
    SvgRenderer.prototype.clear = clear;
    SvgRenderer.prototype.flushRenderingCommands = function() {
    };
    return SvgRenderer;
  });
  define("quadtree", [], function() {
    function QuadTree(bounds, opt_level) {
      if (!bounds || bounds.x1 >= bounds.x2 || bounds.y1 >= bounds.y2) {
        throw "Error constructing QuadTree: invalid bounds given.";
      }
      this.level = opt_level || 0;
      this.bounds = bounds;
      this.nodes = Array(4);
      this.hasSplit = !1;
      this.items = [];
    }
    function insert(item) {
      var box = item.getBoundingBox();
      if (this.hasSplit) {
        var idx = this.getIndex(box), node = this.nodes[idx];
        isBoxInBounds(box, node.bounds) ? node.insert(item) : this.items.push(item);
      } else {
        if (this.items.push(item), 4 > this.level && 4 < this.items.length) {
          this.split();
          for (var i = 0, leni = this.items.length;i < leni;i++) {
            this.insert(this.items[i]);
          }
          this.items = this.items.length > leni ? this.items.splice(leni, this.items.length - leni) : [];
        }
      }
    }
    function clear() {
      this.items = [];
      if (this.hasSplit) {
        for (var i = 0, leni = this.nodes.length;i < leni;i++) {
          this.nodes[i].clear();
        }
        delete this.nodes;
        this.nodes = Array(4);
        this.hasSplit = !1;
      }
    }
    function query(box) {
      return queryInternal_.call(this, [], box);
    }
    function queryInternal_(ret, box) {
      if (this.hasSplit) {
        var idx = this.getIndex(box);
        queryInternal_.call(this.nodes[idx], ret, box);
      }
      ret.push.apply(ret, this.items);
      return ret;
    }
    function getIndex(box) {
      var left = !(box.x1 > (this.bounds.x1 + this.bounds.x2) / 2), top = !(box.y1 > (this.bounds.y1 + this.bounds.y2) / 2), idx = 0;
      left ? top || (idx = 3) : idx = top ? 1 : 2;
      return idx;
    }
    function split() {
      var w = (this.bounds.x2 - this.bounds.x1) / 2, h = (this.bounds.y2 - this.bounds.y1) / 2, x = this.bounds.x1, y = this.bounds.y1, l = this.level + 1;
      this.nodes[0] = new QuadTree({x1:x, y1:y, x2:x + w, y2:y + h}, l);
      this.nodes[1] = new QuadTree({x1:x + w, y1:y, x2:x + w + w, y2:y + h}, l);
      this.nodes[2] = new QuadTree({x1:x + w, y1:y + h, x2:x + w + w, y2:y + h + h}, l);
      this.nodes[3] = new QuadTree({x1:x, y1:y + h, x2:x + w, y2:y + h + h}, l);
      this.hasSplit = !0;
    }
    function remove(item) {
      var idx = this.items.indexOf(item);
      return 0 <= idx ? (this.items.splice(idx, 1), !0) : this.hasSplit ? !this.nodes.every(function(value) {
        return!value.remove(item);
      }) : !1;
    }
    function isBoxInBounds(box, bounds) {
      return box.x1 >= bounds.x1 && box.x2 <= bounds.x2 && box.y1 >= bounds.y1 && box.y2 <= bounds.y2;
    }
    QuadTree.prototype = {insert:insert, clear:clear, query:query, getIndex:getIndex, split:split, remove:remove};
    return QuadTree;
  });
  define("renderers/canvas/circle", [], function() {
    function draw(circle, context) {
      context.beginPath();
      context.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI, !1);
      context.closePath();
      context.fill();
    }
    function doesPointCollide(circle, point) {
      var dx = circle.x - point.x, dy = circle.y - point.y;
      return Math.sqrt(dx * dx + dy * dy) <= circle.r;
    }
    var circleMethods = {};
    circleMethods.draw = draw;
    circleMethods.doesPointCollide = doesPointCollide;
    return circleMethods;
  });
  define("renderers/canvas/ellipse", [], function() {
    function draw(ellipse, context) {
      context.save();
      context.beginPath();
      context.translate(ellipse.x - ellipse.rx, ellipse.y - ellipse.ry);
      context.scale(ellipse.rx, ellipse.ry);
      context.arc(1, 1, 1, 0, 2 * Math.PI, !1);
      context.fillStyle = "#f00";
      context.fill();
      context.restore();
    }
    function doesPointCollide(ellipse, point) {
      var a = (point.x - ellipse.x) / ellipse.rx, b = (point.y - ellipse.y) / ellipse.ry;
      return 1 >= a * a + b * b;
    }
    var ellipseMethods = {};
    ellipseMethods.draw = draw;
    ellipseMethods.doesPointCollide = doesPointCollide;
    return ellipseMethods;
  });
  define("renderers/canvas/line", [], function() {
    function draw(line, context) {
      context.save();
      context.beginPath();
      context.moveTo(line.x1, line.y1);
      context.lineTo(line.x2, line.y2);
      context.closePath();
      context.strokeStyle = "purple";
      context.stroke();
      context.restore();
    }
    function doesPointCollide(line, point) {
      var m = (line.y1 - line.y2) / (line.x1 - line.x2), b = line.y1 - m * line.x1;
      return.5 > Math.abs(m * point.x + b - point.y);
    }
    var lineMethods = {};
    lineMethods.draw = draw;
    lineMethods.doesPointCollide = doesPointCollide;
    return lineMethods;
  });
  define("renderers/canvas/path", [], function() {
    function draw(path, context) {
      context.save();
      tracePath_(path, context);
      context.fillStyle = "#00f";
      context.fill();
      context.restore();
    }
    function tracePath_(path, context) {
      context.beginPath();
      for (var cmds = path.getCommands(), i = 0, leni = cmds.length;i < leni;i++) {
        var cmd = cmds[i].split(" ");
        switch(cmd[0]) {
          case "M":
            context.moveTo(cmd[1], cmd[2]);
            break;
          case "L":
            context.lineTo(cmd[1], cmd[2]);
            break;
          case "C":
            context.bezierCurveTo(cmd[1], cmd[2], cmd[3], cmd[4], cmd[5], cmd[6]);
            break;
          case "Z":
            context.closePath();
            return;
          default:
            throw'unknown path command "' + cmds[i] + '".';;
        }
      }
    }
    function doesPointCollide(path, point) {
      var canvas = document.createElement("canvas"), context = canvas.getContext("2d");
      tracePath_(path, context);
      return context.isPointInPath(point.x, point.y) || context.isPointInStroke(point.x, point.y);
    }
    var pathMethods = {};
    pathMethods.draw = draw;
    pathMethods.doesPointCollide = doesPointCollide;
    return pathMethods;
  });
  define("renderers/canvas/rect", [], function() {
    function draw(rect, context) {
      context.save();
      context.beginPath();
      context.rect(rect.x, rect.y, rect.width, rect.height);
      context.fillStyle = "#0f0";
      context.fill();
      context.restore();
    }
    function doesPointCollide(rect, point) {
      var ret = point.x > rect.x && point.x < rect.x + rect.width && point.y > rect.y && point.y < rect.y + rect.height;
      return ret;
    }
    var rectMethods = {};
    rectMethods.draw = draw;
    rectMethods.doesPointCollide = doesPointCollide;
    return rectMethods;
  });
  define("renderers/canvas/text", [], function() {
    function draw(text, context) {
      context.font = "12pt Times New Roman";
      context.fillText(text.text_, text.x, text.y);
    }
    function doesPointCollide(text, point) {
      var rect = text.getBoundingBox(), ret = point.x > rect.x && point.x < rect.x + rect.width && point.y > rect.y && point.y < rect.y + rect.height;
      return ret;
    }
    var textMethods = {};
    textMethods.draw = draw;
    textMethods.doesPointCollide = doesPointCollide;
    return textMethods;
  });
  define("renderers/canvas/shapes", "./circle ./ellipse ./line ./path ./rect ./text".split(" "), function(Circle, Ellipse, Line, Path, Rect, Text) {
    return{Circle:Circle, Ellipse:Ellipse, Line:Line, Path:Path, Rect:Rect, Text:Text};
  });
  define("renderers/canvas/canvas", ["quadtree", "renderers/abstract/abstractrenderer", "classdef", "shapes/shapes", "./shapes"], function(QuadTree, AbstractRenderer, ClassDef, AbstractShapes, Shapes) {
    function CanvasRenderer(el, width, height) {
      AbstractRenderer.call(this, el, width, height);
      var canvas = this.canvas = document.createElement("canvas");
      canvas.setAttribute("width", width);
      canvas.setAttribute("height", height);
      canvas.setAttribute("style", "-webkit-user-select:none;");
      el.appendChild(canvas);
      this.context = canvas.getContext("2d");
      this.qt = new QuadTree({x1:0, y1:0, x2:width, y2:height});
      this.all = [];
      el.addEventListener("click", onClick_.bind(this));
    }
    function addShape_(shape) {
      this.all.push(shape);
      shape.listen("box", onBox_.bind(this));
      this.qt.insert(shape);
      return shape;
    }
    function drawShape(shape) {
      Shapes[shape.constructor.name].draw(shape, this.context);
      return addShape_.call(this, shape);
    }
    function drawCircle(r, x, y) {
      var circle = new AbstractShapes.Circle(r, x, y);
      Shapes.Circle.draw(circle, this.context);
      return addShape_.call(this, circle);
    }
    function drawEllipse(rx, ry, x, y) {
      var ellipse = new AbstractShapes.Ellipse(rx, ry, x, y);
      Shapes.Ellipse.draw(ellipse, this.context);
      return addShape_.call(this, ellipse);
    }
    function drawRect(x, y, width, height) {
      var rect = new AbstractShapes.Rect(x, y, width, height);
      Shapes.Rect.draw(rect, this.context);
      return addShape_.call(this, rect);
    }
    function drawLine(x1, y1, x2, y2) {
      var line = new AbstractShapes.Line(x1, y1, x2, y2);
      Shapes.Line.draw(line, this.context);
      return addShape_.call(this, line);
    }
    function onClick_(e) {
      for (var point = {x:e.offsetX, y:e.offsetY}, box = {x1:point.x, y1:point.y, x2:point.x, y2:point.y}, clicks = [], retrievedItems = this.qt.query(box), i = 0, leni = retrievedItems.length;i < leni;i++) {
        var shape = retrievedItems[i];
        lookupShape(shape).doesPointCollide(shape, point) && clicks.push(shape);
      }
      if (clicks.length) {
        for (var idx = -1, winner = clicks[0], i = 0, leni = clicks.length;i < leni;i++) {
          var testIdx = this.all.indexOf(clicks[i]);
          testIdx > idx && (idx = testIdx, winner = clicks[i]);
        }
        winner.fireEvent("click");
      }
    }
    function onBox_(shape) {
      "Text" === shape.constructor.name && (shape.box_ = {width:this.context.measureText(shape.text_).width, height:12, x:shape.x, y:shape.y});
    }
    function redraw_() {
      this.canvas.width = this.canvas.width;
      for (var i = 0, leni = this.all.length;i < leni;i++) {
        var shape = this.all[i];
        shape && lookupShape(shape).draw(shape, this.context);
      }
    }
    function removeShape(shape) {
      var idx = this.all.indexOf(shape);
      if (0 > idx) {
        return!1;
      }
      this.qt.remove(shape);
      this.all.splice(idx, 1);
      redraw_.call(this);
      return!0;
    }
    function lookupShape(shape, opt_methodName) {
      var ret = Shapes[shape.constructor.name];
      opt_methodName && (ret = ret[opt_methodName]);
      return ret;
    }
    CanvasRenderer.prototype = ClassDef.createObj(AbstractRenderer.prototype);
    CanvasRenderer.prototype.constructor = CanvasRenderer;
    CanvasRenderer.prototype.drawShape = drawShape;
    CanvasRenderer.prototype.drawCircle = drawCircle;
    CanvasRenderer.prototype.drawEllipse = drawEllipse;
    CanvasRenderer.prototype.drawRect = drawRect;
    CanvasRenderer.prototype.drawLine = drawLine;
    CanvasRenderer.prototype.removeShape = removeShape;
    return CanvasRenderer;
  });
  define("renderers/mobile/group", [], function() {
    function draw(group, queueFunc) {
      var uid = queueFunc("createGroupInternal");
      return uid;
    }
    var groupMethods = {};
    groupMethods.draw = draw;
    return groupMethods;
  });
  define("renderers/mobile/mobile-util", [], function() {
    function makeTextStyle(text) {
      var ret = {fontName:text.style("font.family") || text.style("fontFamily") || text.style("fontName"), fontSize:text.style("font.size") || text.style("fontSize") || 10, color:text.style("fill") || text.style("fillColor") || text.style("fill.color") || "#000000", auraColor:text.style("stroke") || text.style("strokeColor") || text.style("stroke.color"), bold:!(!text.style("font.weight") && !text.style("fontWeight")), italic:!!text.style("italic"), underline:!!text.style("underline")};
      return JSON.stringify(ret);
    }
    function makeBrush(shape) {
      var brush = {fill:"" + (shape.style("fill.color") || shape.style("fillColor") || shape.style("fill") || "#000000"), fillOpacity:parseFloat(shape.style("fill.opacity") || shape.style("fillOpacity") || shape.style("fill-opacity") || 1), stroke:"" + (shape.style("stroke.color") || shape.style("strokeColor") || shape.style("stroke") || "#FFFFFF"), strokeWidth:parseFloat(shape.style("stroke.width") || shape.style("strokeWidth") || shape.style("stroke-width") || 0), strokeOpacity:parseFloat(shape.style("stroke.opacity") || 
      shape.style("strokeOpacity") || shape.style("stroke-opacity") || 1), strokeDashStyle:"solid", rx:0, ry:0, gradient:null, pattern:null};
      "black" === brush.fill ? brush.fill = "#000000" : "white" === brush.fill && (brush.fill = "#FFFFFF");
      "black" === brush.stroke ? brush.stroke = "#000000" : "white" === brush.stroke && (brush.stroke = "#FFFFFF");
      return JSON.stringify(brush);
    }
    return{makeBrush:makeBrush, makeTextStyle:makeTextStyle};
  });
  define("renderers/mobile/circle", ["./mobile-util"], function(MobileUtil) {
    function draw(circle, queueFunc) {
      var uid = queueFunc("createCircle", circle.style("x"), circle.style("y"), circle.style("r"), MobileUtil.makeBrush(circle));
      return uid;
    }
    var circleMethods = {};
    circleMethods.draw = draw;
    return circleMethods;
  });
  define("renderers/mobile/ellipse", ["./mobile-util"], function(MobileUtil) {
    function draw(ellipse, queueFunc) {
      var uid = queueFunc("createElipse", ellipse.style("x"), ellipse.style("y"), ellipse.style("rx"), ellipse.style("ry"), MobileUtil.makeBrush(ellipse));
      return uid;
    }
    var ellipseMethods = {};
    ellipseMethods.draw = draw;
    return ellipseMethods;
  });
  define("renderers/mobile/line", ["./mobile-util"], function(MobileUtil) {
    function draw(line, queueFunc) {
      var lineArray = [];
      queueFunc("addPathMove", lineArray, line.style("x1"), line.style("y1"));
      queueFunc("addPathLine", lineArray, line.style("x2"), line.style("y2"));
      queueFunc("addPathClose", lineArray);
      var uid = queueFunc("createPathInternal", lineArray, MobileUtil.makeBrush(line));
      return uid;
    }
    var lineMethods = {};
    lineMethods.draw = draw;
    return lineMethods;
  });
  define("renderers/mobile/path", ["./mobile-util"], function(MobileUtil) {
    function draw(path, queueFunc) {
      for (var pathArray = [], commands = path.getCommands(), i = 0, leni = commands.length;i < leni;i++) {
        var cmd = commands[i].split(" ");
        switch(cmd[0]) {
          case "L":
            queueFunc("addPathLine", pathArray, parseFloat(cmd[1]), parseFloat(cmd[2]));
            break;
          case "C":
            queueFunc("addPathCurve", pathArray, parseFloat(cmd[1]), parseFloat(cmd[2]), parseFloat(cmd[3]), parseFloat(cmd[4]), parseFloat(cmd[5]), parseFloat(cmd[6]));
            break;
          case "GVIZARC":
            var a1 = parseFloat(cmd[5]), a2 = parseFloat(cmd[6]), a1 = a1 + 90, a2 = a2 + 90;
            a1 > a2 && 360 === a1 && (a1 = 0);
            360 === a2 && a2--;
            queueFunc("addPathArc", pathArray, parseFloat(cmd[1]), parseFloat(cmd[2]), parseFloat(cmd[3]), parseFloat(cmd[4]), a1, a2, !!parseFloat(cmd[7]));
            break;
          case "M":
            queueFunc("addPathMove", pathArray, parseFloat(cmd[1]), parseFloat(cmd[2]));
            break;
          case "Z":
            queueFunc("addPathClose", pathArray);
            break;
          default:
            throw'unknown path command: "' + cmd[0] + '".';;
        }
      }
      var uid = queueFunc("createPathInternal", pathArray, MobileUtil.makeBrush(path));
      return uid;
    }
    var pathMethods = {};
    pathMethods.draw = draw;
    return pathMethods;
  });
  define("renderers/mobile/rect", ["./mobile-util", "../../shapes/rect-util", "./path"], function(MobileUtil, RectUtil, Path) {
    function draw(rect, queueFunc) {
      var x = parseFloat(rect.style("x")), y = parseFloat(rect.style("y")), width = parseFloat(rect.style("width")), height = parseFloat(rect.style("height"));
      0 > width && (width *= -1, x -= width);
      0 > height && (height *= -1, y -= height);
      if (RectUtil.hasIndividualRoundedCorners(rect) || rect.style("corners.rx") || rect.style("corners.ry")) {
        var path = RectUtil.constructRoundedRectPath(rect), uid = Path.draw(path, queueFunc)
      } else {
        var uid = queueFunc("createRect", x, y, width, height, MobileUtil.makeBrush(rect))
      }
      return uid;
    }
    var rectMethods = {};
    rectMethods.draw = draw;
    return rectMethods;
  });
  define("renderers/mobile/text", ["./mobile-util"], function(MobileUtil) {
    function draw(text, queueFunc) {
      var halign = Math.max(0, Math.min(1, text.style("halign") || 0));
      if (isNaN(halign) || !isFinite(halign)) {
        halign = 0;
      }
      var halign = 1 === halign ? "end" : 0 === halign ? "start" : "center", valign = text.style("valign");
      if ("number" === typeof valign) {
        if (valign = Math.max(0, Math.min(1, valign)), isNaN(valign) || !isFinite(valign)) {
          valign = 0;
        }
      } else {
        valign = "baseline";
      }
      var valign = "baseline" === valign || 0 === valign ? "start" : 1 === valign ? "end" : "center", uid = queueFunc("createText", text.style("text"), text.style("x"), text.style("y"), 0, halign, valign, MobileUtil.makeTextStyle(text));
      return uid;
    }
    var textMethods = {};
    textMethods.draw = draw;
    return textMethods;
  });
  define("renderers/mobile/shapes", "shapes/shapes ./group ./circle ./ellipse ./line ./path ./rect ./text".split(" "), function(AbstractShapes, Group, Circle, Ellipse, Line, Path, Rect, Text) {
    var ret = {};
    ret[AbstractShapes.Group.safeName] = Group;
    ret[AbstractShapes.Circle.safeName] = Circle;
    ret[AbstractShapes.Ellipse.safeName] = Ellipse;
    ret[AbstractShapes.Line.safeName] = Line;
    ret[AbstractShapes.Path.safeName] = Path;
    ret[AbstractShapes.Rect.safeName] = Rect;
    ret[AbstractShapes.Text.safeName] = Text;
    return ret;
  });
  define("renderers/mobile/mobile", ["renderers/abstract/abstractrenderer", "classdef", "shapes/shapes", "./shapes", "./mobile-util"], function(AbstractRenderer, ClassDef, AbstractShapes, Shapes, MobileUtil) {
    function MobileRenderer(el, width, height) {
      this.uid_ = win.constructor_Native();
      this.ops_ = [];
      this.shapes = [];
      this.uids = [];
      this.queueCommandBound_ = queueCommand_.bind(this);
      this.queueCommandBound_("createCanvasInternal", width, height);
      this.onGetContextBound_ = onGetContext_.bind(this);
      this.onBoxBound_ = onBox_.bind(this);
      this.onRemoveShapeBound_ = onRemoveShape_.bind(this);
      this.onAddShapeBound_ = onAddShape_.bind(this);
    }
    function queueCommand_() {
      var id = this.uid_ + "_" + this.ops_.length, argsArray = Array.prototype.slice.call(arguments, 0), args = [id].concat(argsArray);
      this.ops_.push(args);
      return id;
    }
    function addShape_(shape, uid, opt_setContext) {
      var existingShapeIndex = this.shapes.indexOf(shape);
      if (0 <= existingShapeIndex) {
        if (null != this.uids[existingShapeIndex] || !shape.staged_) {
          throw "Shape exists and is not a staged shape.";
        }
        shape.staged_ = !1;
        this.uids[existingShapeIndex] = uid;
      } else {
        this.shapes.push(shape), this.uids.push(uid);
      }
      "Text" === shape.constructor.safeName && shape.listen("box", this.onBoxBound_);
      shape.listen("redraw", this.onRedrawBound_);
      shape.listen("add", this.onAddShapeBound_);
      shape.listen("playAnimation", this.onPlayAnimationBound_);
      shape.listen("remove", this.onRemoveShapeBound_);
      opt_setContext && shape.listen("getcontext", this.onGetContextBound_);
      return shape;
    }
    function onAddShape_(shape, opt_setContext) {
      var uid = Shapes[shape.constructor.safeName].draw(shape, this.queueCommandBound_);
      addShape_.call(this, shape, uid, !!opt_setContext);
      drawShapeChildren_.call(this, shape);
      return shape;
    }
    function drawShape(shape) {
      var uid = getUidFromShape_.call(this, shape);
      if (uid) {
        throw "Shape already drawn.";
      }
      return onAddShape_.call(this, shape, !0);
    }
    function drawShapeChildren_(contextShape) {
      if (contextShape.getShapes) {
        for (var children = contextShape.getShapes(), i = 0, leni = children.length;i < leni;i++) {
          var child = children[i], childUid = Shapes[child.constructor.safeName].draw(child, this.queueCommandBound_);
          addShape_.call(this, child, childUid, !1);
          drawShapeChildren_.call(this, child);
        }
      }
    }
    function onGetContext_(shape) {
      shape.context_ = this;
    }
    function removeShape(shape) {
      var context = shape.getContext();
      if (null == context) {
        throw "Attempted to remove shape that doesn't have a context.";
      }
      return shape.fireEvent("remove", [shape]);
    }
    function onRemoveShape_(shape) {
      var idx = this.shapes.indexOf(shape);
      if (0 > idx) {
        return!1;
      }
      if (shape.getShapes) {
        for (var children = shape.getShapes(), i = 0, leni = children.length;i < leni;i++) {
          shape.fireEvent("remove", [children[i]]);
        }
        idx = this.shapes.indexOf(shape);
      }
      this.shapes.splice(idx, 1);
      this.uids.splice(idx, 1);
      shape.unlisten("box", this.onBoxBound_);
      shape.unlisten("redraw", this.onRedrawBound_);
      shape.unlisten("remove", this.onRemoveShapeBound_);
      shape.unlisten("getcontext", this.onGetContextBound_);
      shape.unlisten("add", this.onAddShapeBound_);
      shape.unlisten("playAnimation", this.onPlayAnimationBound_);
      shape.context_ = null;
      return!0;
    }
    function getUidFromShape_(shape) {
      var idx = this.shapes.indexOf(shape);
      return 0 > idx ? null : this.uids[idx];
    }
    function onBox_(shape) {
      var type = shape.constructor.safeName;
      if ("Text" === type) {
        var ret = JSON.parse(win.getTextSizeInternal_Native(this.uid_, shape.style("text"), MobileUtil.makeTextStyle(shape)));
        shape.box_ = {width:ret.width, height:ret.height, x:shape.style("x"), y:shape.style("y")};
      }
    }
    function stageShape(shape) {
      if (shape.staged_) {
        throw Error("can't stage a shape that's already staged.");
      }
      if (-1 !== this.shapes.indexOf(shape)) {
        throw Error("can't stage a shape that's already drawn.");
      }
      shape.staged_ = !0;
      this.shapes.push(shape);
      this.uids.push(null);
      shape.listen("box", this.onBoxBound_);
      shape.listen("getcontext", this.onGetContextBound_);
      return shape;
    }
    function drawCircle(r, x, y, opt_style) {
      var circle = new AbstractShapes.Circle(r, x, y, opt_style);
      return this.drawShape(circle);
    }
    function drawEllipse(rx, ry, x, y, opt_style) {
      var ellipse = new AbstractShapes.Ellipse(rx, ry, x, y, opt_style);
      return this.drawShape(ellipse);
    }
    function drawRect(x, y, width, height, opt_style) {
      var rect = new AbstractShapes.Rect(x, y, width, height, opt_style);
      return this.drawShape(rect);
    }
    function drawText(x, y, text, opt_style) {
      text = new AbstractShapes.Text(x, y, text, opt_style);
      return this.drawShape(text);
    }
    function drawLine(x1, y1, x2, y2, opt_style) {
      var line = new AbstractShapes.Line(x1, y1, x2, y2, opt_style);
      return this.drawShape(line);
    }
    function flushRenderingCommands() {
      win.flushRenderer_Native(this.uid_, JSON.stringify(this.ops_));
      this.ops_ = [];
    }
    var win = function() {
      return this;
    }();
    MobileRenderer.prototype = ClassDef.createObj(AbstractRenderer.prototype);
    MobileRenderer.prototype.constructor = MobileRenderer;
    MobileRenderer.prototype.drawShape = drawShape;
    MobileRenderer.prototype.stageShape = stageShape;
    MobileRenderer.prototype.removeShape = removeShape;
    MobileRenderer.prototype.drawCircle = drawCircle;
    MobileRenderer.prototype.drawEllipse = drawEllipse;
    MobileRenderer.prototype.drawRect = drawRect;
    MobileRenderer.prototype.drawLine = drawLine;
    MobileRenderer.prototype.drawText = drawText;
    MobileRenderer.prototype.flushRenderingCommands = flushRenderingCommands;
    MobileRenderer.prototype.clear = function() {
    };
    return MobileRenderer;
  });
  define("animation", ["classdef"], function(ClassDef) {
    function Animation(property, from, to, duration, opt_interpolateFunc) {
      this.property_ = property;
      this.from_ = from;
      this.to_ = to;
      this.duration_ = duration;
      this.interpolateFunc_ = opt_interpolateFunc || linear;
      this.events_ = {finishAnimation:[]};
    }
    function linear(startVal, endVal, duration, startTime) {
      var unitsPerTick = (endVal - startVal) / duration, preCalc = unitsPerTick * -startTime + startVal;
      return function(ts) {
        var ret = unitsPerTick * ts + preCalc;
        return ret;
      };
    }
    ClassDef.makeListenable(Animation);
    return Animation;
  });
  define("rabl", ["renderers/svg/svg", "renderers/canvas/canvas", "renderers/mobile/mobile", "shapes/shapes", "animation"], function(svg, canvas, mobile, Shapes, Animation) {
    function generateNewRenderer(width, height, type, el) {
      var renderer;
      "svg" === type ? renderer = svg : "canvas" === type ? renderer = canvas : "mobile" === type && (renderer = mobile);
      RaBl.renderer = renderer;
      RaBl.Shapes = Shapes;
      RaBl.generateTextMeasureFunction = generateTextMeasureFunction;
      return new renderer(el, width, height);
    }
    function generateTextMeasureFunction(renderer) {
      return function(text, style) {
        var textShape = new Shapes.Text(0, 0, text, style);
        renderer.stageShape(textShape);
        var box = textShape.getBoundingBox();
        renderer.removeShape(textShape);
        delete box.x;
        delete box.y;
        return box;
      };
    }
    var RaBl = window.RaBl = function(width, height, type, el, options) {
      var win = function() {
        return this;
      }(), cb, immediate = !1, calledActive = !1;
      options && options.fonts && win.WebFont ? WebFont.load({google:{families:options.fonts}, active:function() {
        calledActive = !0;
        cb && cb(generateNewRenderer(width, height, type, el));
      }, fontinactive:function() {
        throw Error("one or more fonts could not be loaded.");
      }}) : immediate = !0;
      return{then:function(callback) {
        calledActive || immediate ? (immediate || calledActive) && win.setTimeout(callback.bind(win, generateNewRenderer(width, height, type, el)), 0) : cb = callback;
      }};
    };
    RaBl.Shapes = Shapes;
    RaBl.Animation = Animation;
  });
  return window.RaBl;
}();
// INPUT (javascript/gviz/devel/graphics/rabl-drawing-frame.js)
gviz.graphics.RaBlDrawingFrame = function(container, dimensions, asyncWrapper, opt_fonts) {
  this.container = container;
  this.dimensions = new goog.math.Size(0, 0);
  this.fonts_ = opt_fonts || null;
  this.update(dimensions, asyncWrapper);
};
goog.inherits(gviz.graphics.RaBlDrawingFrame, gviz.graphics.DrawingFrame);
gviz.graphics.RaBlDrawingFrame.createTextMeasurementDiv = function() {
};
gviz.graphics.RaBlDrawingFrame.prototype.getRenderer = function() {
  var ret = this.rabl;
  return ret;
};
gviz.graphics.RaBlDrawingFrame.prototype.getOverlayArea = function() {
  return{};
};
gviz.graphics.RaBlDrawingFrame.prototype.waitUntilReady = function(callback, asyncWrapper) {
  gviz.graphics.RaBlDrawingFrame.superClass_.waitUntilReady.call(this, callback, asyncWrapper);
};
gviz.graphics.RaBlDrawingFrame.prototype.update = function(dimensions) {
  if (!goog.math.Size.equals(this.dimensions, dimensions)) {
    this.dimensions = dimensions.clone();
    var me = this;
    this.renderersDiv_ = null;
    this.rabl_ && this.rabl_.clear();
    var type = "svg";
    (new RaBl.RaBl(dimensions.width || 0, dimensions.height || 0, type, this.container, this.fonts_ ? {fonts:this.fonts_} : void 0)).then(function(rabl) {
      me.rabl = rabl;
      me.rabl.getTextSize = RaBl.RaBl.textMeasureFunction = goog.memoize(RaBl.RaBl.generateTextMeasureFunction(me.rabl), function(functionUid, args) {
        var signatureTokens = [functionUid, args[0]];
        signatureTokens.push(JSON.stringify(args[1]));
        var s = signatureTokens.join("_");
        return s;
      });
      me.renderersDiv_ = {};
    });
  }
};
gviz.graphics.RaBlDrawingFrame.prototype.disposeInternal = function() {
};
// INPUT (javascript/closure/dom/savedrange.js)
goog.dom.SavedRange = function() {
  goog.Disposable.call(this);
};
goog.inherits(goog.dom.SavedRange, goog.Disposable);
goog.dom.SavedRange.logger_ = goog.log.getLogger("goog.dom.SavedRange");
goog.dom.SavedRange.prototype.restore = function(opt_stayAlive) {
  this.isDisposed() && goog.log.error(goog.dom.SavedRange.logger_, "Disposed SavedRange objects cannot be restored.");
  var range = this.restoreInternal();
  opt_stayAlive || this.dispose();
  return range;
};
// INPUT (javascript/closure/dom/savedcaretrange.js)
goog.dom.SavedCaretRange = function(range) {
  goog.dom.SavedRange.call(this);
  this.startCaretId_ = goog.string.createUniqueString();
  this.endCaretId_ = goog.string.createUniqueString();
  this.reversed_ = range.isReversed();
  this.dom_ = goog.dom.getDomHelper(range.getDocument());
  range.surroundWithNodes(this.createCaret_(!0), this.createCaret_(!1));
};
goog.inherits(goog.dom.SavedCaretRange, goog.dom.SavedRange);
goog.dom.SavedCaretRange.prototype.getCaret = function(start) {
  return this.dom_.getElement(start ? this.startCaretId_ : this.endCaretId_);
};
goog.dom.SavedCaretRange.prototype.removeCarets = function(opt_range) {
  goog.dom.removeNode(this.getCaret(!0));
  goog.dom.removeNode(this.getCaret(!1));
  return opt_range;
};
goog.dom.SavedCaretRange.prototype.restoreInternal = function() {
  var range = null, anchorCaret = this.getCaret(!this.reversed_), focusCaret = this.getCaret(this.reversed_);
  if (anchorCaret && focusCaret) {
    var anchorNode = anchorCaret.parentNode, anchorOffset = goog.array.indexOf(anchorNode.childNodes, anchorCaret), focusNode = focusCaret.parentNode, focusOffset = goog.array.indexOf(focusNode.childNodes, focusCaret);
    focusNode == anchorNode && (this.reversed_ ? anchorOffset-- : focusOffset--);
    range = goog.dom.Range.createFromNodes(anchorNode, anchorOffset, focusNode, focusOffset);
    range = this.removeCarets(range);
    range.select();
  } else {
    this.removeCarets();
  }
  return range;
};
goog.dom.SavedCaretRange.prototype.disposeInternal = function() {
  this.removeCarets();
  this.dom_ = null;
};
goog.dom.SavedCaretRange.prototype.createCaret_ = function(start) {
  return this.dom_.createDom(goog.dom.TagName.SPAN, {id:start ? this.startCaretId_ : this.endCaretId_});
};
goog.dom.SavedCaretRange.CARET_REGEX = /<span\s+id="?goog_\d+"?><\/span>/ig;
goog.dom.SavedCaretRange.htmlEqual = function(str1, str2) {
  return str1 == str2 || str1.replace(goog.dom.SavedCaretRange.CARET_REGEX, "") == str2.replace(goog.dom.SavedCaretRange.CARET_REGEX, "");
};
// INPUT (javascript/closure/dom/tagiterator.js)
goog.dom.TagWalkType = {START_TAG:1, OTHER:0, END_TAG:-1};
goog.dom.TagIterator = function(opt_node, opt_reversed, opt_unconstrained, opt_tagType, opt_depth) {
  this.reversed = !!opt_reversed;
  opt_node && this.setPosition(opt_node, opt_tagType);
  this.depth = void 0 != opt_depth ? opt_depth : this.tagType || 0;
  this.reversed && (this.depth *= -1);
  this.constrained = !opt_unconstrained;
};
goog.inherits(goog.dom.TagIterator, goog.iter.Iterator);
goog.dom.TagIterator.prototype.node = null;
goog.dom.TagIterator.prototype.tagType = goog.dom.TagWalkType.OTHER;
goog.dom.TagIterator.prototype.started_ = !1;
goog.dom.TagIterator.prototype.setPosition = function(node, opt_tagType, opt_depth) {
  if (this.node = node) {
    this.tagType = goog.isNumber(opt_tagType) ? opt_tagType : this.node.nodeType != goog.dom.NodeType.ELEMENT ? goog.dom.TagWalkType.OTHER : this.reversed ? goog.dom.TagWalkType.END_TAG : goog.dom.TagWalkType.START_TAG;
  }
  goog.isNumber(opt_depth) && (this.depth = opt_depth);
};
goog.dom.TagIterator.prototype.copyFrom = function(other) {
  this.node = other.node;
  this.tagType = other.tagType;
  this.depth = other.depth;
  this.reversed = other.reversed;
  this.constrained = other.constrained;
};
goog.dom.TagIterator.prototype.clone = function() {
  return new goog.dom.TagIterator(this.node, this.reversed, !this.constrained, this.tagType, this.depth);
};
goog.dom.TagIterator.prototype.restartTag = function() {
  var check = this.reversed ? goog.dom.TagWalkType.START_TAG : goog.dom.TagWalkType.END_TAG;
  this.tagType == check && (this.tagType = -1 * check, this.depth += this.tagType * (this.reversed ? -1 : 1));
};
goog.dom.TagIterator.prototype.next = function() {
  var node;
  if (this.started_) {
    if (!this.node || this.constrained && 0 == this.depth) {
      throw goog.iter.StopIteration;
    }
    node = this.node;
    var startType = this.reversed ? goog.dom.TagWalkType.END_TAG : goog.dom.TagWalkType.START_TAG;
    if (this.tagType == startType) {
      var child = this.reversed ? node.lastChild : node.firstChild;
      child ? this.setPosition(child) : this.setPosition(node, -1 * startType);
    } else {
      var sibling = this.reversed ? node.previousSibling : node.nextSibling;
      sibling ? this.setPosition(sibling) : this.setPosition(node.parentNode, -1 * startType);
    }
    this.depth += this.tagType * (this.reversed ? -1 : 1);
  } else {
    this.started_ = !0;
  }
  node = this.node;
  if (!this.node) {
    throw goog.iter.StopIteration;
  }
  return node;
};
goog.dom.TagIterator.prototype.isStarted = function() {
  return this.started_;
};
goog.dom.TagIterator.prototype.isStartTag = function() {
  return this.tagType == goog.dom.TagWalkType.START_TAG;
};
goog.dom.TagIterator.prototype.isEndTag = function() {
  return this.tagType == goog.dom.TagWalkType.END_TAG;
};
goog.dom.TagIterator.prototype.equals = function(other) {
  return other.node == this.node && (!this.node || other.tagType == this.tagType);
};
goog.dom.TagIterator.prototype.splice = function(var_args) {
  var node = this.node;
  this.restartTag();
  this.reversed = !this.reversed;
  goog.dom.TagIterator.prototype.next.call(this);
  this.reversed = !this.reversed;
  for (var arr = goog.isArrayLike(arguments[0]) ? arguments[0] : arguments, i = arr.length - 1;0 <= i;i--) {
    goog.dom.insertSiblingAfter(arr[i], node);
  }
  goog.dom.removeNode(node);
};
// INPUT (javascript/closure/dom/abstractrange.js)
goog.dom.RangeType = {TEXT:"text", CONTROL:"control", MULTI:"mutli"};
goog.dom.AbstractRange = function() {
};
goog.dom.AbstractRange.getBrowserSelectionForWindow = function(win) {
  if (win.getSelection) {
    return win.getSelection();
  }
  var doc = win.document, sel = doc.selection;
  if (sel) {
    try {
      var range = sel.createRange();
      if (range.parentElement) {
        if (range.parentElement().document != doc) {
          return null;
        }
      } else {
        if (!range.length || range.item(0).document != doc) {
          return null;
        }
      }
    } catch (e) {
      return null;
    }
    return sel;
  }
  return null;
};
goog.dom.AbstractRange.isNativeControlRange = function(range) {
  return!!range && !!range.addElement;
};
goog.dom.AbstractRange.prototype.getTextRanges = function() {
  for (var output = [], i = 0, len = this.getTextRangeCount();i < len;i++) {
    output.push(this.getTextRange(i));
  }
  return output;
};
goog.dom.AbstractRange.prototype.getAnchorNode = function() {
  return this.isReversed() ? this.getEndNode() : this.getStartNode();
};
goog.dom.AbstractRange.prototype.getAnchorOffset = function() {
  return this.isReversed() ? this.getEndOffset() : this.getStartOffset();
};
goog.dom.AbstractRange.prototype.getFocusNode = function() {
  return this.isReversed() ? this.getStartNode() : this.getEndNode();
};
goog.dom.AbstractRange.prototype.getFocusOffset = function() {
  return this.isReversed() ? this.getStartOffset() : this.getEndOffset();
};
goog.dom.AbstractRange.prototype.isReversed = function() {
  return!1;
};
goog.dom.AbstractRange.prototype.getDocument = function() {
  return goog.dom.getOwnerDocument(goog.userAgent.IE ? this.getContainer() : this.getStartNode());
};
goog.dom.AbstractRange.prototype.getWindow = function() {
  return goog.dom.getWindow(this.getDocument());
};
goog.dom.AbstractRange.prototype.containsNode = function(node, opt_allowPartial) {
  return this.containsRange(goog.dom.Range.createFromNodeContents(node), opt_allowPartial);
};
goog.dom.RangeIterator = function(node, opt_reverse) {
  goog.dom.TagIterator.call(this, node, opt_reverse, !0);
};
goog.inherits(goog.dom.RangeIterator, goog.dom.TagIterator);
// INPUT (javascript/closure/dom/abstractmultirange.js)
goog.dom.AbstractMultiRange = function() {
};
goog.inherits(goog.dom.AbstractMultiRange, goog.dom.AbstractRange);
goog.dom.AbstractMultiRange.prototype.containsRange = function(otherRange, opt_allowPartial) {
  var ranges = this.getTextRanges(), otherRanges = otherRange.getTextRanges(), fn = opt_allowPartial ? goog.array.some : goog.array.every;
  return fn(otherRanges, function(otherRange) {
    return goog.array.some(ranges, function(range) {
      return range.containsRange(otherRange, opt_allowPartial);
    });
  });
};
goog.dom.AbstractMultiRange.prototype.insertNode = function(node, before) {
  before ? goog.dom.insertSiblingBefore(node, this.getStartNode()) : goog.dom.insertSiblingAfter(node, this.getEndNode());
  return node;
};
goog.dom.AbstractMultiRange.prototype.surroundWithNodes = function(startNode, endNode) {
  this.insertNode(startNode, !0);
  this.insertNode(endNode, !1);
};
// INPUT (javascript/closure/dom/rangeendpoint.js)
goog.dom.RangeEndpoint = {START:1, END:0};
// INPUT (javascript/closure/dom/textrangeiterator.js)
goog.dom.TextRangeIterator = function(startNode, startOffset, endNode, endOffset, opt_reverse) {
  var goNext;
  if (startNode) {
    this.startNode_ = startNode;
    this.startOffset_ = startOffset;
    this.endNode_ = endNode;
    this.endOffset_ = endOffset;
    if (startNode.nodeType == goog.dom.NodeType.ELEMENT && startNode.tagName != goog.dom.TagName.BR) {
      var startChildren = startNode.childNodes, candidate = startChildren[startOffset];
      candidate ? (this.startNode_ = candidate, this.startOffset_ = 0) : (startChildren.length && (this.startNode_ = goog.array.peek(startChildren)), goNext = !0);
    }
    endNode.nodeType == goog.dom.NodeType.ELEMENT && ((this.endNode_ = endNode.childNodes[endOffset]) ? this.endOffset_ = 0 : this.endNode_ = endNode);
  }
  goog.dom.RangeIterator.call(this, opt_reverse ? this.endNode_ : this.startNode_, opt_reverse);
  if (goNext) {
    try {
      this.next();
    } catch (e) {
      if (e != goog.iter.StopIteration) {
        throw e;
      }
    }
  }
};
goog.inherits(goog.dom.TextRangeIterator, goog.dom.RangeIterator);
goog.dom.TextRangeIterator.prototype.startNode_ = null;
goog.dom.TextRangeIterator.prototype.endNode_ = null;
goog.dom.TextRangeIterator.prototype.startOffset_ = 0;
goog.dom.TextRangeIterator.prototype.endOffset_ = 0;
goog.dom.TextRangeIterator.prototype.getStartNode = function() {
  return this.startNode_;
};
goog.dom.TextRangeIterator.prototype.getEndNode = function() {
  return this.endNode_;
};
goog.dom.TextRangeIterator.prototype.isLast = function() {
  return this.isStarted() && this.node == this.endNode_ && (!this.endOffset_ || !this.isStartTag());
};
goog.dom.TextRangeIterator.prototype.next = function() {
  if (this.isLast()) {
    throw goog.iter.StopIteration;
  }
  return goog.dom.TextRangeIterator.superClass_.next.call(this);
};
goog.dom.TextRangeIterator.prototype.copyFrom = function(other) {
  this.startNode_ = other.startNode_;
  this.endNode_ = other.endNode_;
  this.startOffset_ = other.startOffset_;
  this.endOffset_ = other.endOffset_;
  this.isReversed_ = other.isReversed_;
  goog.dom.TextRangeIterator.superClass_.copyFrom.call(this, other);
};
goog.dom.TextRangeIterator.prototype.clone = function() {
  var copy = new goog.dom.TextRangeIterator(this.startNode_, this.startOffset_, this.endNode_, this.endOffset_, this.isReversed_);
  copy.copyFrom(this);
  return copy;
};
// INPUT (javascript/closure/string/stringbuffer.js)
goog.string.StringBuffer = function(opt_a1, var_args) {
  null != opt_a1 && this.append.apply(this, arguments);
};
goog.string.StringBuffer.prototype.buffer_ = "";
goog.string.StringBuffer.prototype.set = function(s) {
  this.buffer_ = "" + s;
};
goog.string.StringBuffer.prototype.append = function(a1, opt_a2, var_args) {
  this.buffer_ += a1;
  if (null != opt_a2) {
    for (var i = 1;i < arguments.length;i++) {
      this.buffer_ += arguments[i];
    }
  }
  return this;
};
goog.string.StringBuffer.prototype.clear = function() {
  this.buffer_ = "";
};
goog.string.StringBuffer.prototype.getLength = function() {
  return this.buffer_.length;
};
goog.string.StringBuffer.prototype.toString = function() {
  return this.buffer_;
};
// INPUT (javascript/closure/dom/browserrange/abstractrange.js)
goog.dom.browserrange = {};
goog.dom.browserrange.AbstractRange = function() {
};
goog.dom.browserrange.AbstractRange.prototype.containsRange = function(abstractRange, opt_allowPartial) {
  var checkPartial = opt_allowPartial && !abstractRange.isCollapsed(), range = abstractRange.getBrowserRange(), start = goog.dom.RangeEndpoint.START, end = goog.dom.RangeEndpoint.END;
  try {
    return checkPartial ? 0 <= this.compareBrowserRangeEndpoints(range, end, start) && 0 >= this.compareBrowserRangeEndpoints(range, start, end) : 0 <= this.compareBrowserRangeEndpoints(range, end, end) && 0 >= this.compareBrowserRangeEndpoints(range, start, start);
  } catch (e) {
    if (!goog.userAgent.IE) {
      throw e;
    }
    return!1;
  }
};
goog.dom.browserrange.AbstractRange.prototype.containsNode = function(node, opt_allowPartial) {
  return this.containsRange(goog.dom.browserrange.createRangeFromNodeContents(node), opt_allowPartial);
};
goog.dom.browserrange.AbstractRange.prototype.__iterator__ = function() {
  return new goog.dom.TextRangeIterator(this.getStartNode(), this.getStartOffset(), this.getEndNode(), this.getEndOffset());
};
// INPUT (javascript/closure/dom/browserrange/w3crange.js)
goog.dom.browserrange.W3cRange = function(range) {
  this.range_ = range;
};
goog.inherits(goog.dom.browserrange.W3cRange, goog.dom.browserrange.AbstractRange);
goog.dom.browserrange.W3cRange.getBrowserRangeForNode = function(node) {
  var nodeRange = goog.dom.getOwnerDocument(node).createRange();
  if (node.nodeType == goog.dom.NodeType.TEXT) {
    nodeRange.setStart(node, 0), nodeRange.setEnd(node, node.length);
  } else {
    if (goog.dom.browserrange.canContainRangeEndpoint(node)) {
      for (var tempNode, leaf = node;(tempNode = leaf.firstChild) && goog.dom.browserrange.canContainRangeEndpoint(tempNode);) {
        leaf = tempNode;
      }
      nodeRange.setStart(leaf, 0);
      for (leaf = node;(tempNode = leaf.lastChild) && goog.dom.browserrange.canContainRangeEndpoint(tempNode);) {
        leaf = tempNode;
      }
      nodeRange.setEnd(leaf, leaf.nodeType == goog.dom.NodeType.ELEMENT ? leaf.childNodes.length : leaf.length);
    } else {
      var rangeParent = node.parentNode, rangeStartOffset = goog.array.indexOf(rangeParent.childNodes, node);
      nodeRange.setStart(rangeParent, rangeStartOffset);
      nodeRange.setEnd(rangeParent, rangeStartOffset + 1);
    }
  }
  return nodeRange;
};
goog.dom.browserrange.W3cRange.getBrowserRangeForNodes = function(startNode, startOffset, endNode, endOffset) {
  var nodeRange = goog.dom.getOwnerDocument(startNode).createRange();
  nodeRange.setStart(startNode, startOffset);
  nodeRange.setEnd(endNode, endOffset);
  return nodeRange;
};
goog.dom.browserrange.W3cRange.createFromNodeContents = function(node) {
  return new goog.dom.browserrange.W3cRange(goog.dom.browserrange.W3cRange.getBrowserRangeForNode(node));
};
goog.dom.browserrange.W3cRange.createFromNodes = function(startNode, startOffset, endNode, endOffset) {
  return new goog.dom.browserrange.W3cRange(goog.dom.browserrange.W3cRange.getBrowserRangeForNodes(startNode, startOffset, endNode, endOffset));
};
goog.dom.browserrange.W3cRange.prototype.clone = function() {
  return new this.constructor(this.range_.cloneRange());
};
goog.dom.browserrange.W3cRange.prototype.getBrowserRange = function() {
  return this.range_;
};
goog.dom.browserrange.W3cRange.prototype.getContainer = function() {
  return this.range_.commonAncestorContainer;
};
goog.dom.browserrange.W3cRange.prototype.getStartNode = function() {
  return this.range_.startContainer;
};
goog.dom.browserrange.W3cRange.prototype.getStartOffset = function() {
  return this.range_.startOffset;
};
goog.dom.browserrange.W3cRange.prototype.getEndNode = function() {
  return this.range_.endContainer;
};
goog.dom.browserrange.W3cRange.prototype.getEndOffset = function() {
  return this.range_.endOffset;
};
goog.dom.browserrange.W3cRange.prototype.compareBrowserRangeEndpoints = function(range, thisEndpoint, otherEndpoint) {
  return this.range_.compareBoundaryPoints(otherEndpoint == goog.dom.RangeEndpoint.START ? thisEndpoint == goog.dom.RangeEndpoint.START ? goog.global.Range.START_TO_START : goog.global.Range.START_TO_END : thisEndpoint == goog.dom.RangeEndpoint.START ? goog.global.Range.END_TO_START : goog.global.Range.END_TO_END, range);
};
goog.dom.browserrange.W3cRange.prototype.isCollapsed = function() {
  return this.range_.collapsed;
};
goog.dom.browserrange.W3cRange.prototype.getText = function() {
  return this.range_.toString();
};
goog.dom.browserrange.W3cRange.prototype.select = function(reverse) {
  var win = goog.dom.getWindow(goog.dom.getOwnerDocument(this.getStartNode()));
  this.selectInternal(win.getSelection(), reverse);
};
goog.dom.browserrange.W3cRange.prototype.selectInternal = function(selection) {
  selection.removeAllRanges();
  selection.addRange(this.range_);
};
goog.dom.browserrange.W3cRange.prototype.surroundContents = function(element) {
  this.range_.surroundContents(element);
  return element;
};
goog.dom.browserrange.W3cRange.prototype.insertNode = function(node, before) {
  var range = this.range_.cloneRange();
  range.collapse(before);
  range.insertNode(node);
  range.detach();
  return node;
};
goog.dom.browserrange.W3cRange.prototype.surroundWithNodes = function(startNode, endNode) {
  var win = goog.dom.getWindow(goog.dom.getOwnerDocument(this.getStartNode())), selectionRange = goog.dom.Range.createFromWindow(win);
  if (selectionRange) {
    var sNode = selectionRange.getStartNode(), eNode = selectionRange.getEndNode(), sOffset = selectionRange.getStartOffset(), eOffset = selectionRange.getEndOffset()
  }
  var clone1 = this.range_.cloneRange(), clone2 = this.range_.cloneRange();
  clone1.collapse(!1);
  clone2.collapse(!0);
  clone1.insertNode(endNode);
  clone2.insertNode(startNode);
  clone1.detach();
  clone2.detach();
  if (selectionRange) {
    var isInsertedNode = function(n) {
      return n == startNode || n == endNode;
    };
    if (sNode.nodeType == goog.dom.NodeType.TEXT) {
      for (;sOffset > sNode.length;) {
        sOffset -= sNode.length;
        do {
          sNode = sNode.nextSibling;
        } while (isInsertedNode(sNode));
      }
    }
    if (eNode.nodeType == goog.dom.NodeType.TEXT) {
      for (;eOffset > eNode.length;) {
        eOffset -= eNode.length;
        do {
          eNode = eNode.nextSibling;
        } while (isInsertedNode(eNode));
      }
    }
    goog.dom.Range.createFromNodes(sNode, sOffset, eNode, eOffset).select();
  }
};
goog.dom.browserrange.W3cRange.prototype.collapse = function(toStart) {
  this.range_.collapse(toStart);
};
// INPUT (javascript/closure/dom/browserrange/geckorange.js)
goog.dom.browserrange.GeckoRange = function(range) {
  goog.dom.browserrange.W3cRange.call(this, range);
};
goog.inherits(goog.dom.browserrange.GeckoRange, goog.dom.browserrange.W3cRange);
goog.dom.browserrange.GeckoRange.createFromNodeContents = function(node) {
  return new goog.dom.browserrange.GeckoRange(goog.dom.browserrange.W3cRange.getBrowserRangeForNode(node));
};
goog.dom.browserrange.GeckoRange.createFromNodes = function(startNode, startOffset, endNode, endOffset) {
  return new goog.dom.browserrange.GeckoRange(goog.dom.browserrange.W3cRange.getBrowserRangeForNodes(startNode, startOffset, endNode, endOffset));
};
goog.dom.browserrange.GeckoRange.prototype.selectInternal = function(selection, reversed) {
  !reversed || this.isCollapsed() ? goog.dom.browserrange.GeckoRange.superClass_.selectInternal.call(this, selection, reversed) : (selection.collapse(this.getEndNode(), this.getEndOffset()), selection.extend(this.getStartNode(), this.getStartOffset()));
};
// INPUT (javascript/closure/dom/browserrange/ierange.js)
goog.dom.browserrange.IeRange = function(range, doc) {
  this.range_ = range;
  this.doc_ = doc;
};
goog.inherits(goog.dom.browserrange.IeRange, goog.dom.browserrange.AbstractRange);
goog.dom.browserrange.IeRange.logger_ = goog.log.getLogger("goog.dom.browserrange.IeRange");
goog.dom.browserrange.IeRange.getBrowserRangeForNode_ = function(node) {
  var nodeRange = goog.dom.getOwnerDocument(node).body.createTextRange();
  if (node.nodeType == goog.dom.NodeType.ELEMENT) {
    nodeRange.moveToElementText(node), goog.dom.browserrange.canContainRangeEndpoint(node) && !node.childNodes.length && nodeRange.collapse(!1);
  } else {
    for (var offset = 0, sibling = node;sibling = sibling.previousSibling;) {
      var nodeType = sibling.nodeType;
      if (nodeType == goog.dom.NodeType.TEXT) {
        offset += sibling.length;
      } else {
        if (nodeType == goog.dom.NodeType.ELEMENT) {
          nodeRange.moveToElementText(sibling);
          break;
        }
      }
    }
    sibling || nodeRange.moveToElementText(node.parentNode);
    nodeRange.collapse(!sibling);
    offset && nodeRange.move("character", offset);
    nodeRange.moveEnd("character", node.length);
  }
  return nodeRange;
};
goog.dom.browserrange.IeRange.getBrowserRangeForNodes_ = function(startNode, startOffset, endNode, endOffset) {
  var child, collapse = !1;
  startNode.nodeType == goog.dom.NodeType.ELEMENT && (startOffset > startNode.childNodes.length && goog.log.error(goog.dom.browserrange.IeRange.logger_, "Cannot have startOffset > startNode child count"), child = startNode.childNodes[startOffset], collapse = !child, startNode = child || startNode.lastChild || startNode, startOffset = 0);
  var leftRange = goog.dom.browserrange.IeRange.getBrowserRangeForNode_(startNode);
  startOffset && leftRange.move("character", startOffset);
  if (startNode == endNode && startOffset == endOffset) {
    return leftRange.collapse(!0), leftRange;
  }
  collapse && leftRange.collapse(!1);
  collapse = !1;
  endNode.nodeType == goog.dom.NodeType.ELEMENT && (endOffset > endNode.childNodes.length && goog.log.error(goog.dom.browserrange.IeRange.logger_, "Cannot have endOffset > endNode child count"), endNode = (child = endNode.childNodes[endOffset]) || endNode.lastChild || endNode, endOffset = 0, collapse = !child);
  var rightRange = goog.dom.browserrange.IeRange.getBrowserRangeForNode_(endNode);
  rightRange.collapse(!collapse);
  endOffset && rightRange.moveEnd("character", endOffset);
  leftRange.setEndPoint("EndToEnd", rightRange);
  return leftRange;
};
goog.dom.browserrange.IeRange.createFromNodeContents = function(node) {
  var range = new goog.dom.browserrange.IeRange(goog.dom.browserrange.IeRange.getBrowserRangeForNode_(node), goog.dom.getOwnerDocument(node));
  if (goog.dom.browserrange.canContainRangeEndpoint(node)) {
    for (var tempNode, leaf = node;(tempNode = leaf.firstChild) && goog.dom.browserrange.canContainRangeEndpoint(tempNode);) {
      leaf = tempNode;
    }
    range.startNode_ = leaf;
    range.startOffset_ = 0;
    for (leaf = node;(tempNode = leaf.lastChild) && goog.dom.browserrange.canContainRangeEndpoint(tempNode);) {
      leaf = tempNode;
    }
    range.endNode_ = leaf;
    range.endOffset_ = leaf.nodeType == goog.dom.NodeType.ELEMENT ? leaf.childNodes.length : leaf.length;
    range.parentNode_ = node;
  } else {
    range.startNode_ = range.endNode_ = range.parentNode_ = node.parentNode, range.startOffset_ = goog.array.indexOf(range.parentNode_.childNodes, node), range.endOffset_ = range.startOffset_ + 1;
  }
  return range;
};
goog.dom.browserrange.IeRange.createFromNodes = function(startNode, startOffset, endNode, endOffset) {
  var range = new goog.dom.browserrange.IeRange(goog.dom.browserrange.IeRange.getBrowserRangeForNodes_(startNode, startOffset, endNode, endOffset), goog.dom.getOwnerDocument(startNode));
  range.startNode_ = startNode;
  range.startOffset_ = startOffset;
  range.endNode_ = endNode;
  range.endOffset_ = endOffset;
  return range;
};
goog.dom.browserrange.IeRange.prototype.parentNode_ = null;
goog.dom.browserrange.IeRange.prototype.startNode_ = null;
goog.dom.browserrange.IeRange.prototype.endNode_ = null;
goog.dom.browserrange.IeRange.prototype.startOffset_ = -1;
goog.dom.browserrange.IeRange.prototype.endOffset_ = -1;
goog.dom.browserrange.IeRange.prototype.clone = function() {
  var range = new goog.dom.browserrange.IeRange(this.range_.duplicate(), this.doc_);
  range.parentNode_ = this.parentNode_;
  range.startNode_ = this.startNode_;
  range.endNode_ = this.endNode_;
  return range;
};
goog.dom.browserrange.IeRange.prototype.getBrowserRange = function() {
  return this.range_;
};
goog.dom.browserrange.IeRange.prototype.clearCachedValues_ = function() {
  this.parentNode_ = this.startNode_ = this.endNode_ = null;
  this.startOffset_ = this.endOffset_ = -1;
};
goog.dom.browserrange.IeRange.prototype.getContainer = function() {
  if (!this.parentNode_) {
    var selectText = this.range_.text, range = this.range_.duplicate(), rightTrimmedSelectText = selectText.replace(/ +$/, ""), numSpacesAtEnd = selectText.length - rightTrimmedSelectText.length;
    numSpacesAtEnd && range.moveEnd("character", -numSpacesAtEnd);
    var parent = range.parentElement(), htmlText = range.htmlText, htmlTextLen = goog.string.stripNewlines(htmlText).length;
    if (this.isCollapsed() && 0 < htmlTextLen) {
      return this.parentNode_ = parent;
    }
    for (;htmlTextLen > goog.string.stripNewlines(parent.outerHTML).length;) {
      parent = parent.parentNode;
    }
    for (;1 == parent.childNodes.length && parent.innerText == goog.dom.browserrange.IeRange.getNodeText_(parent.firstChild) && goog.dom.browserrange.canContainRangeEndpoint(parent.firstChild);) {
      parent = parent.firstChild;
    }
    0 == selectText.length && (parent = this.findDeepestContainer_(parent));
    this.parentNode_ = parent;
  }
  return this.parentNode_;
};
goog.dom.browserrange.IeRange.prototype.findDeepestContainer_ = function(node) {
  for (var childNodes = node.childNodes, i = 0, len = childNodes.length;i < len;i++) {
    var child = childNodes[i];
    if (goog.dom.browserrange.canContainRangeEndpoint(child)) {
      var childRange = goog.dom.browserrange.IeRange.getBrowserRangeForNode_(child), start = goog.dom.RangeEndpoint.START, end = goog.dom.RangeEndpoint.END, isChildRangeErratic = childRange.htmlText != child.outerHTML, isNativeInRangeErratic = this.isCollapsed() && isChildRangeErratic, inChildRange = isNativeInRangeErratic ? 0 <= this.compareBrowserRangeEndpoints(childRange, start, start) && 0 >= this.compareBrowserRangeEndpoints(childRange, start, end) : this.range_.inRange(childRange);
      if (inChildRange) {
        return this.findDeepestContainer_(child);
      }
    }
  }
  return node;
};
goog.dom.browserrange.IeRange.prototype.getStartNode = function() {
  this.startNode_ || (this.startNode_ = this.getEndpointNode_(goog.dom.RangeEndpoint.START), this.isCollapsed() && (this.endNode_ = this.startNode_));
  return this.startNode_;
};
goog.dom.browserrange.IeRange.prototype.getStartOffset = function() {
  0 > this.startOffset_ && (this.startOffset_ = this.getOffset_(goog.dom.RangeEndpoint.START), this.isCollapsed() && (this.endOffset_ = this.startOffset_));
  return this.startOffset_;
};
goog.dom.browserrange.IeRange.prototype.getEndNode = function() {
  if (this.isCollapsed()) {
    return this.getStartNode();
  }
  this.endNode_ || (this.endNode_ = this.getEndpointNode_(goog.dom.RangeEndpoint.END));
  return this.endNode_;
};
goog.dom.browserrange.IeRange.prototype.getEndOffset = function() {
  if (this.isCollapsed()) {
    return this.getStartOffset();
  }
  0 > this.endOffset_ && (this.endOffset_ = this.getOffset_(goog.dom.RangeEndpoint.END), this.isCollapsed() && (this.startOffset_ = this.endOffset_));
  return this.endOffset_;
};
goog.dom.browserrange.IeRange.prototype.compareBrowserRangeEndpoints = function(range, thisEndpoint, otherEndpoint) {
  return this.range_.compareEndPoints((thisEndpoint == goog.dom.RangeEndpoint.START ? "Start" : "End") + "To" + (otherEndpoint == goog.dom.RangeEndpoint.START ? "Start" : "End"), range);
};
goog.dom.browserrange.IeRange.prototype.getEndpointNode_ = function(endpoint, opt_node) {
  var node = opt_node || this.getContainer();
  if (!node || !node.firstChild) {
    return node;
  }
  for (var start = goog.dom.RangeEndpoint.START, end = goog.dom.RangeEndpoint.END, isStartEndpoint = endpoint == start, j = 0, length = node.childNodes.length;j < length;j++) {
    var i = isStartEndpoint ? j : length - j - 1, child = node.childNodes[i], childRange;
    try {
      childRange = goog.dom.browserrange.createRangeFromNodeContents(child);
    } catch (e) {
      continue;
    }
    var ieRange = childRange.getBrowserRange();
    if (this.isCollapsed()) {
      if (!goog.dom.browserrange.canContainRangeEndpoint(child)) {
        if (0 == this.compareBrowserRangeEndpoints(ieRange, start, start)) {
          this.startOffset_ = this.endOffset_ = i;
          break;
        }
      } else {
        if (childRange.containsRange(this)) {
          return this.getEndpointNode_(endpoint, child);
        }
      }
    } else {
      if (this.containsRange(childRange)) {
        if (!goog.dom.browserrange.canContainRangeEndpoint(child)) {
          isStartEndpoint ? this.startOffset_ = i : this.endOffset_ = i + 1;
          break;
        }
        return this.getEndpointNode_(endpoint, child);
      }
      if (0 > this.compareBrowserRangeEndpoints(ieRange, start, end) && 0 < this.compareBrowserRangeEndpoints(ieRange, end, start)) {
        return this.getEndpointNode_(endpoint, child);
      }
    }
  }
  return node;
};
goog.dom.browserrange.IeRange.prototype.compareNodeEndpoints_ = function(node, thisEndpoint, otherEndpoint) {
  return this.range_.compareEndPoints((thisEndpoint == goog.dom.RangeEndpoint.START ? "Start" : "End") + "To" + (otherEndpoint == goog.dom.RangeEndpoint.START ? "Start" : "End"), goog.dom.browserrange.createRangeFromNodeContents(node).getBrowserRange());
};
goog.dom.browserrange.IeRange.prototype.getOffset_ = function(endpoint, opt_container) {
  var isStartEndpoint = endpoint == goog.dom.RangeEndpoint.START, container = opt_container || (isStartEndpoint ? this.getStartNode() : this.getEndNode());
  if (container.nodeType == goog.dom.NodeType.ELEMENT) {
    for (var children = container.childNodes, len = children.length, edge = isStartEndpoint ? 0 : len - 1, sign = isStartEndpoint ? 1 : -1, i = edge;0 <= i && i < len;i += sign) {
      var child = children[i];
      if (!goog.dom.browserrange.canContainRangeEndpoint(child)) {
        var endPointCompare = this.compareNodeEndpoints_(child, endpoint, endpoint);
        if (0 == endPointCompare) {
          return isStartEndpoint ? i : i + 1;
        }
      }
    }
    return-1 == i ? 0 : i;
  }
  var range = this.range_.duplicate(), nodeRange = goog.dom.browserrange.IeRange.getBrowserRangeForNode_(container);
  range.setEndPoint(isStartEndpoint ? "EndToEnd" : "StartToStart", nodeRange);
  var rangeLength = range.text.length;
  return isStartEndpoint ? container.length - rangeLength : rangeLength;
};
goog.dom.browserrange.IeRange.getNodeText_ = function(node) {
  return node.nodeType == goog.dom.NodeType.TEXT ? node.nodeValue : node.innerText;
};
goog.dom.browserrange.IeRange.prototype.isCollapsed = function() {
  return 0 == this.range_.compareEndPoints("StartToEnd", this.range_);
};
goog.dom.browserrange.IeRange.prototype.getText = function() {
  return this.range_.text;
};
goog.dom.browserrange.IeRange.prototype.select = function() {
  this.range_.select();
};
goog.dom.browserrange.IeRange.getDomHelper_ = function(range) {
  return goog.dom.getDomHelper(range.parentElement());
};
goog.dom.browserrange.IeRange.pasteElement_ = function(range, element, opt_domHelper) {
  opt_domHelper = opt_domHelper || goog.dom.browserrange.IeRange.getDomHelper_(range);
  var id, originalId = id = element.id;
  id || (id = element.id = goog.string.createUniqueString());
  range.pasteHTML(element.outerHTML);
  (element = opt_domHelper.getElement(id)) && (originalId || element.removeAttribute("id"));
  return element;
};
goog.dom.browserrange.IeRange.prototype.surroundContents = function(element) {
  goog.dom.removeNode(element);
  element.innerHTML = this.range_.htmlText;
  (element = goog.dom.browserrange.IeRange.pasteElement_(this.range_, element)) && this.range_.moveToElementText(element);
  this.clearCachedValues_();
  return element;
};
goog.dom.browserrange.IeRange.insertNode_ = function(clone, node, before, opt_domHelper) {
  opt_domHelper = opt_domHelper || goog.dom.browserrange.IeRange.getDomHelper_(clone);
  var isNonElement;
  node.nodeType != goog.dom.NodeType.ELEMENT && (isNonElement = !0, node = opt_domHelper.createDom(goog.dom.TagName.DIV, null, node));
  clone.collapse(before);
  node = goog.dom.browserrange.IeRange.pasteElement_(clone, node, opt_domHelper);
  if (isNonElement) {
    var newNonElement = node.firstChild;
    opt_domHelper.flattenElement(node);
    node = newNonElement;
  }
  return node;
};
goog.dom.browserrange.IeRange.prototype.insertNode = function(node, before) {
  var output = goog.dom.browserrange.IeRange.insertNode_(this.range_.duplicate(), node, before);
  this.clearCachedValues_();
  return output;
};
goog.dom.browserrange.IeRange.prototype.surroundWithNodes = function(startNode, endNode) {
  var clone1 = this.range_.duplicate(), clone2 = this.range_.duplicate();
  goog.dom.browserrange.IeRange.insertNode_(clone1, startNode, !0);
  goog.dom.browserrange.IeRange.insertNode_(clone2, endNode, !1);
  this.clearCachedValues_();
};
goog.dom.browserrange.IeRange.prototype.collapse = function(toStart) {
  this.range_.collapse(toStart);
  toStart ? (this.endNode_ = this.startNode_, this.endOffset_ = this.startOffset_) : (this.startNode_ = this.endNode_, this.startOffset_ = this.endOffset_);
};
// INPUT (javascript/closure/dom/browserrange/operarange.js)
goog.dom.browserrange.OperaRange = function(range) {
  goog.dom.browserrange.W3cRange.call(this, range);
};
goog.inherits(goog.dom.browserrange.OperaRange, goog.dom.browserrange.W3cRange);
goog.dom.browserrange.OperaRange.createFromNodeContents = function(node) {
  return new goog.dom.browserrange.OperaRange(goog.dom.browserrange.W3cRange.getBrowserRangeForNode(node));
};
goog.dom.browserrange.OperaRange.createFromNodes = function(startNode, startOffset, endNode, endOffset) {
  return new goog.dom.browserrange.OperaRange(goog.dom.browserrange.W3cRange.getBrowserRangeForNodes(startNode, startOffset, endNode, endOffset));
};
goog.dom.browserrange.OperaRange.prototype.selectInternal = function(selection) {
  selection.collapse(this.getStartNode(), this.getStartOffset());
  this.getEndNode() == this.getStartNode() && this.getEndOffset() == this.getStartOffset() || selection.extend(this.getEndNode(), this.getEndOffset());
  0 == selection.rangeCount && selection.addRange(this.range_);
};
// INPUT (javascript/closure/dom/browserrange/webkitrange.js)
goog.dom.browserrange.WebKitRange = function(range) {
  goog.dom.browserrange.W3cRange.call(this, range);
};
goog.inherits(goog.dom.browserrange.WebKitRange, goog.dom.browserrange.W3cRange);
goog.dom.browserrange.WebKitRange.createFromNodeContents = function(node) {
  return new goog.dom.browserrange.WebKitRange(goog.dom.browserrange.W3cRange.getBrowserRangeForNode(node));
};
goog.dom.browserrange.WebKitRange.createFromNodes = function(startNode, startOffset, endNode, endOffset) {
  return new goog.dom.browserrange.WebKitRange(goog.dom.browserrange.W3cRange.getBrowserRangeForNodes(startNode, startOffset, endNode, endOffset));
};
goog.dom.browserrange.WebKitRange.prototype.compareBrowserRangeEndpoints = function(range, thisEndpoint, otherEndpoint) {
  return goog.userAgent.isVersionOrHigher("528") ? goog.dom.browserrange.WebKitRange.superClass_.compareBrowserRangeEndpoints.call(this, range, thisEndpoint, otherEndpoint) : this.range_.compareBoundaryPoints(otherEndpoint == goog.dom.RangeEndpoint.START ? thisEndpoint == goog.dom.RangeEndpoint.START ? goog.global.Range.START_TO_START : goog.global.Range.END_TO_START : thisEndpoint == goog.dom.RangeEndpoint.START ? goog.global.Range.START_TO_END : goog.global.Range.END_TO_END, range);
};
goog.dom.browserrange.WebKitRange.prototype.selectInternal = function(selection, reversed) {
  selection.removeAllRanges();
  reversed ? selection.setBaseAndExtent(this.getEndNode(), this.getEndOffset(), this.getStartNode(), this.getStartOffset()) : selection.setBaseAndExtent(this.getStartNode(), this.getStartOffset(), this.getEndNode(), this.getEndOffset());
};
// INPUT (javascript/closure/dom/browserrange/browserrange.js)
goog.dom.browserrange.Error = {NOT_IMPLEMENTED:"Not Implemented"};
goog.dom.browserrange.createRange = function(range) {
  return goog.dom.BrowserFeature.LEGACY_IE_RANGES ? new goog.dom.browserrange.IeRange(range, goog.dom.getOwnerDocument(range.parentElement())) : goog.userAgent.WEBKIT ? new goog.dom.browserrange.WebKitRange(range) : goog.userAgent.GECKO ? new goog.dom.browserrange.GeckoRange(range) : goog.userAgent.OPERA ? new goog.dom.browserrange.OperaRange(range) : new goog.dom.browserrange.W3cRange(range);
};
goog.dom.browserrange.createRangeFromNodeContents = function(node) {
  return goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) ? goog.dom.browserrange.IeRange.createFromNodeContents(node) : goog.userAgent.WEBKIT ? goog.dom.browserrange.WebKitRange.createFromNodeContents(node) : goog.userAgent.GECKO ? goog.dom.browserrange.GeckoRange.createFromNodeContents(node) : goog.userAgent.OPERA ? goog.dom.browserrange.OperaRange.createFromNodeContents(node) : goog.dom.browserrange.W3cRange.createFromNodeContents(node);
};
goog.dom.browserrange.createRangeFromNodes = function(startNode, startOffset, endNode, endOffset) {
  return goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) ? goog.dom.browserrange.IeRange.createFromNodes(startNode, startOffset, endNode, endOffset) : goog.userAgent.WEBKIT ? goog.dom.browserrange.WebKitRange.createFromNodes(startNode, startOffset, endNode, endOffset) : goog.userAgent.GECKO ? goog.dom.browserrange.GeckoRange.createFromNodes(startNode, startOffset, endNode, endOffset) : goog.userAgent.OPERA ? goog.dom.browserrange.OperaRange.createFromNodes(startNode, startOffset, endNode, 
  endOffset) : goog.dom.browserrange.W3cRange.createFromNodes(startNode, startOffset, endNode, endOffset);
};
goog.dom.browserrange.canContainRangeEndpoint = function(node) {
  return goog.dom.canHaveChildren(node) || node.nodeType == goog.dom.NodeType.TEXT;
};
// INPUT (javascript/closure/dom/textrange.js)
goog.dom.TextRange = function() {
};
goog.inherits(goog.dom.TextRange, goog.dom.AbstractRange);
goog.dom.TextRange.createFromBrowserRange = function(range, opt_isReversed) {
  return goog.dom.TextRange.createFromBrowserRangeWrapper_(goog.dom.browserrange.createRange(range), opt_isReversed);
};
goog.dom.TextRange.createFromBrowserRangeWrapper_ = function(browserRange, opt_isReversed) {
  var range = new goog.dom.TextRange;
  range.browserRangeWrapper_ = browserRange;
  range.isReversed_ = !!opt_isReversed;
  return range;
};
goog.dom.TextRange.createFromNodeContents = function(node, opt_isReversed) {
  return goog.dom.TextRange.createFromBrowserRangeWrapper_(goog.dom.browserrange.createRangeFromNodeContents(node), opt_isReversed);
};
goog.dom.TextRange.createFromNodes = function(anchorNode, anchorOffset, focusNode, focusOffset) {
  var range = new goog.dom.TextRange;
  range.isReversed_ = goog.dom.Range.isReversed(anchorNode, anchorOffset, focusNode, focusOffset);
  if (goog.dom.isElement(anchorNode) && !goog.dom.canHaveChildren(anchorNode)) {
    var parent = anchorNode.parentNode;
    anchorOffset = goog.array.indexOf(parent.childNodes, anchorNode);
    anchorNode = parent;
  }
  goog.dom.isElement(focusNode) && !goog.dom.canHaveChildren(focusNode) && (parent = focusNode.parentNode, focusOffset = goog.array.indexOf(parent.childNodes, focusNode), focusNode = parent);
  range.isReversed_ ? (range.startNode_ = focusNode, range.startOffset_ = focusOffset, range.endNode_ = anchorNode, range.endOffset_ = anchorOffset) : (range.startNode_ = anchorNode, range.startOffset_ = anchorOffset, range.endNode_ = focusNode, range.endOffset_ = focusOffset);
  return range;
};
goog.dom.TextRange.prototype.browserRangeWrapper_ = null;
goog.dom.TextRange.prototype.startNode_ = null;
goog.dom.TextRange.prototype.startOffset_ = null;
goog.dom.TextRange.prototype.endNode_ = null;
goog.dom.TextRange.prototype.endOffset_ = null;
goog.dom.TextRange.prototype.isReversed_ = !1;
goog.dom.TextRange.prototype.clone = function() {
  var range = new goog.dom.TextRange;
  range.browserRangeWrapper_ = this.browserRangeWrapper_ && this.browserRangeWrapper_.clone();
  range.startNode_ = this.startNode_;
  range.startOffset_ = this.startOffset_;
  range.endNode_ = this.endNode_;
  range.endOffset_ = this.endOffset_;
  range.isReversed_ = this.isReversed_;
  return range;
};
goog.dom.TextRange.prototype.getType = function() {
  return goog.dom.RangeType.TEXT;
};
goog.dom.TextRange.prototype.getBrowserRangeObject = function() {
  return this.getBrowserRangeWrapper_().getBrowserRange();
};
goog.dom.TextRange.prototype.clearCachedValues_ = function() {
  this.startNode_ = this.startOffset_ = this.endNode_ = this.endOffset_ = null;
};
goog.dom.TextRange.prototype.getTextRangeCount = function() {
  return 1;
};
goog.dom.TextRange.prototype.getTextRange = function() {
  return this;
};
goog.dom.TextRange.prototype.getBrowserRangeWrapper_ = function() {
  return this.browserRangeWrapper_ || (this.browserRangeWrapper_ = goog.dom.browserrange.createRangeFromNodes(this.getStartNode(), this.getStartOffset(), this.getEndNode(), this.getEndOffset()));
};
goog.dom.TextRange.prototype.getContainer = function() {
  return this.getBrowserRangeWrapper_().getContainer();
};
goog.dom.TextRange.prototype.getStartNode = function() {
  return this.startNode_ || (this.startNode_ = this.getBrowserRangeWrapper_().getStartNode());
};
goog.dom.TextRange.prototype.getStartOffset = function() {
  return null != this.startOffset_ ? this.startOffset_ : this.startOffset_ = this.getBrowserRangeWrapper_().getStartOffset();
};
goog.dom.TextRange.prototype.getEndNode = function() {
  return this.endNode_ || (this.endNode_ = this.getBrowserRangeWrapper_().getEndNode());
};
goog.dom.TextRange.prototype.getEndOffset = function() {
  return null != this.endOffset_ ? this.endOffset_ : this.endOffset_ = this.getBrowserRangeWrapper_().getEndOffset();
};
goog.dom.TextRange.prototype.isReversed = function() {
  return this.isReversed_;
};
goog.dom.TextRange.prototype.containsRange = function(otherRange, opt_allowPartial) {
  var otherRangeType = otherRange.getType();
  if (otherRangeType == goog.dom.RangeType.TEXT) {
    return this.getBrowserRangeWrapper_().containsRange(otherRange.getBrowserRangeWrapper_(), opt_allowPartial);
  }
  if (otherRangeType == goog.dom.RangeType.CONTROL) {
    var elements = otherRange.getElements(), fn = opt_allowPartial ? goog.array.some : goog.array.every;
    return fn(elements, function(el) {
      return this.containsNode(el, opt_allowPartial);
    }, this);
  }
  return!1;
};
goog.dom.TextRange.isAttachedNode = function(node) {
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
    var returnValue = !1;
    try {
      returnValue = node.parentNode;
    } catch (e) {
    }
    return!!returnValue;
  }
  return goog.dom.contains(node.ownerDocument.body, node);
};
goog.dom.TextRange.prototype.isCollapsed = function() {
  return this.getBrowserRangeWrapper_().isCollapsed();
};
goog.dom.TextRange.prototype.getText = function() {
  return this.getBrowserRangeWrapper_().getText();
};
goog.dom.TextRange.prototype.__iterator__ = function() {
  return new goog.dom.TextRangeIterator(this.getStartNode(), this.getStartOffset(), this.getEndNode(), this.getEndOffset());
};
goog.dom.TextRange.prototype.select = function() {
  this.getBrowserRangeWrapper_().select(this.isReversed_);
};
goog.dom.TextRange.prototype.surroundContents = function(element) {
  var output = this.getBrowserRangeWrapper_().surroundContents(element);
  this.clearCachedValues_();
  return output;
};
goog.dom.TextRange.prototype.insertNode = function(node, before) {
  var output = this.getBrowserRangeWrapper_().insertNode(node, before);
  this.clearCachedValues_();
  return output;
};
goog.dom.TextRange.prototype.surroundWithNodes = function(startNode, endNode) {
  this.getBrowserRangeWrapper_().surroundWithNodes(startNode, endNode);
  this.clearCachedValues_();
};
goog.dom.TextRange.prototype.saveUsingDom = function() {
  return new goog.dom.DomSavedTextRange_(this);
};
goog.dom.TextRange.prototype.collapse = function(toAnchor) {
  var toStart = this.isReversed() ? !toAnchor : toAnchor;
  this.browserRangeWrapper_ && this.browserRangeWrapper_.collapse(toStart);
  toStart ? (this.endNode_ = this.startNode_, this.endOffset_ = this.startOffset_) : (this.startNode_ = this.endNode_, this.startOffset_ = this.endOffset_);
  this.isReversed_ = !1;
};
goog.dom.DomSavedTextRange_ = function(range) {
  goog.dom.SavedRange.call(this);
  this.anchorNode_ = range.getAnchorNode();
  this.anchorOffset_ = range.getAnchorOffset();
  this.focusNode_ = range.getFocusNode();
  this.focusOffset_ = range.getFocusOffset();
};
goog.inherits(goog.dom.DomSavedTextRange_, goog.dom.SavedRange);
goog.dom.DomSavedTextRange_.prototype.restoreInternal = function() {
  return goog.dom.Range.createFromNodes(this.anchorNode_, this.anchorOffset_, this.focusNode_, this.focusOffset_);
};
goog.dom.DomSavedTextRange_.prototype.disposeInternal = function() {
  goog.dom.DomSavedTextRange_.superClass_.disposeInternal.call(this);
  this.focusNode_ = this.anchorNode_ = null;
};
// INPUT (javascript/closure/dom/controlrange.js)
goog.dom.ControlRange = function() {
};
goog.inherits(goog.dom.ControlRange, goog.dom.AbstractMultiRange);
goog.dom.ControlRange.createFromBrowserRange = function(controlRange) {
  var range = new goog.dom.ControlRange;
  range.range_ = controlRange;
  return range;
};
goog.dom.ControlRange.createFromElements = function(var_args) {
  for (var range = goog.dom.getOwnerDocument(arguments[0]).body.createControlRange(), i = 0, len = arguments.length;i < len;i++) {
    range.addElement(arguments[i]);
  }
  return goog.dom.ControlRange.createFromBrowserRange(range);
};
goog.dom.ControlRange.prototype.range_ = null;
goog.dom.ControlRange.prototype.elements_ = null;
goog.dom.ControlRange.prototype.sortedElements_ = null;
goog.dom.ControlRange.prototype.clearCachedValues_ = function() {
  this.sortedElements_ = this.elements_ = null;
};
goog.dom.ControlRange.prototype.clone = function() {
  return goog.dom.ControlRange.createFromElements.apply(this, this.getElements());
};
goog.dom.ControlRange.prototype.getType = function() {
  return goog.dom.RangeType.CONTROL;
};
goog.dom.ControlRange.prototype.getBrowserRangeObject = function() {
  return this.range_ || document.body.createControlRange();
};
goog.dom.ControlRange.prototype.getTextRangeCount = function() {
  return this.range_ ? this.range_.length : 0;
};
goog.dom.ControlRange.prototype.getTextRange = function(i) {
  return goog.dom.TextRange.createFromNodeContents(this.range_.item(i));
};
goog.dom.ControlRange.prototype.getContainer = function() {
  return goog.dom.findCommonAncestor.apply(null, this.getElements());
};
goog.dom.ControlRange.prototype.getStartNode = function() {
  return this.getSortedElements()[0];
};
goog.dom.ControlRange.prototype.getStartOffset = function() {
  return 0;
};
goog.dom.ControlRange.prototype.getEndNode = function() {
  var sorted = this.getSortedElements(), startsLast = goog.array.peek(sorted);
  return goog.array.find(sorted, function(el) {
    return goog.dom.contains(el, startsLast);
  });
};
goog.dom.ControlRange.prototype.getEndOffset = function() {
  return this.getEndNode().childNodes.length;
};
goog.dom.ControlRange.prototype.getElements = function() {
  if (!this.elements_ && (this.elements_ = [], this.range_)) {
    for (var i = 0;i < this.range_.length;i++) {
      this.elements_.push(this.range_.item(i));
    }
  }
  return this.elements_;
};
goog.dom.ControlRange.prototype.getSortedElements = function() {
  this.sortedElements_ || (this.sortedElements_ = this.getElements().concat(), this.sortedElements_.sort(function(a, b) {
    return a.sourceIndex - b.sourceIndex;
  }));
  return this.sortedElements_;
};
goog.dom.ControlRange.prototype.isCollapsed = function() {
  return!this.range_ || !this.range_.length;
};
goog.dom.ControlRange.prototype.getText = function() {
  return "";
};
goog.dom.ControlRange.prototype.__iterator__ = function() {
  return new goog.dom.ControlRangeIterator(this);
};
goog.dom.ControlRange.prototype.select = function() {
  this.range_ && this.range_.select();
};
goog.dom.ControlRange.prototype.saveUsingDom = function() {
  return new goog.dom.DomSavedControlRange_(this);
};
goog.dom.ControlRange.prototype.collapse = function() {
  this.range_ = null;
  this.clearCachedValues_();
};
goog.dom.DomSavedControlRange_ = function(range) {
  this.elements_ = range.getElements();
};
goog.inherits(goog.dom.DomSavedControlRange_, goog.dom.SavedRange);
goog.dom.DomSavedControlRange_.prototype.restoreInternal = function() {
  for (var doc = this.elements_.length ? goog.dom.getOwnerDocument(this.elements_[0]) : document, controlRange = doc.body.createControlRange(), i = 0, len = this.elements_.length;i < len;i++) {
    controlRange.addElement(this.elements_[i]);
  }
  return goog.dom.ControlRange.createFromBrowserRange(controlRange);
};
goog.dom.DomSavedControlRange_.prototype.disposeInternal = function() {
  goog.dom.DomSavedControlRange_.superClass_.disposeInternal.call(this);
  delete this.elements_;
};
goog.dom.ControlRangeIterator = function(range) {
  range && (this.elements_ = range.getSortedElements(), this.startNode_ = this.elements_.shift(), this.endNode_ = goog.array.peek(this.elements_) || this.startNode_);
  goog.dom.RangeIterator.call(this, this.startNode_, !1);
};
goog.inherits(goog.dom.ControlRangeIterator, goog.dom.RangeIterator);
goog.dom.ControlRangeIterator.prototype.startNode_ = null;
goog.dom.ControlRangeIterator.prototype.endNode_ = null;
goog.dom.ControlRangeIterator.prototype.elements_ = null;
goog.dom.ControlRangeIterator.prototype.getStartNode = function() {
  return this.startNode_;
};
goog.dom.ControlRangeIterator.prototype.getEndNode = function() {
  return this.endNode_;
};
goog.dom.ControlRangeIterator.prototype.isLast = function() {
  return!this.depth && !this.elements_.length;
};
goog.dom.ControlRangeIterator.prototype.next = function() {
  if (this.isLast()) {
    throw goog.iter.StopIteration;
  }
  if (!this.depth) {
    var el = this.elements_.shift();
    this.setPosition(el, goog.dom.TagWalkType.START_TAG, goog.dom.TagWalkType.START_TAG);
    return el;
  }
  return goog.dom.ControlRangeIterator.superClass_.next.call(this);
};
goog.dom.ControlRangeIterator.prototype.copyFrom = function(other) {
  this.elements_ = other.elements_;
  this.startNode_ = other.startNode_;
  this.endNode_ = other.endNode_;
  goog.dom.ControlRangeIterator.superClass_.copyFrom.call(this, other);
};
goog.dom.ControlRangeIterator.prototype.clone = function() {
  var copy = new goog.dom.ControlRangeIterator(null);
  copy.copyFrom(this);
  return copy;
};
// INPUT (javascript/closure/dom/multirange.js)
goog.dom.MultiRange = function() {
  this.browserRanges_ = [];
  this.ranges_ = [];
  this.container_ = this.sortedRanges_ = null;
};
goog.inherits(goog.dom.MultiRange, goog.dom.AbstractMultiRange);
goog.dom.MultiRange.createFromBrowserSelection = function(selection) {
  for (var range = new goog.dom.MultiRange, i = 0, len = selection.rangeCount;i < len;i++) {
    range.browserRanges_.push(selection.getRangeAt(i));
  }
  return range;
};
goog.dom.MultiRange.createFromBrowserRanges = function(browserRanges) {
  var range = new goog.dom.MultiRange;
  range.browserRanges_ = goog.array.clone(browserRanges);
  return range;
};
goog.dom.MultiRange.createFromTextRanges = function(textRanges) {
  var range$$0 = new goog.dom.MultiRange;
  range$$0.ranges_ = textRanges;
  range$$0.browserRanges_ = goog.array.map(textRanges, function(range) {
    return range.getBrowserRangeObject();
  });
  return range$$0;
};
goog.dom.MultiRange.prototype.logger_ = goog.log.getLogger("goog.dom.MultiRange");
goog.dom.MultiRange.prototype.clearCachedValues_ = function() {
  this.ranges_ = [];
  this.container_ = this.sortedRanges_ = null;
};
goog.dom.MultiRange.prototype.clone = function() {
  return goog.dom.MultiRange.createFromBrowserRanges(this.browserRanges_);
};
goog.dom.MultiRange.prototype.getType = function() {
  return goog.dom.RangeType.MULTI;
};
goog.dom.MultiRange.prototype.getBrowserRangeObject = function() {
  1 < this.browserRanges_.length && goog.log.warning(this.logger_, "getBrowserRangeObject called on MultiRange with more than 1 range");
  return this.browserRanges_[0];
};
goog.dom.MultiRange.prototype.getTextRangeCount = function() {
  return this.browserRanges_.length;
};
goog.dom.MultiRange.prototype.getTextRange = function(i) {
  this.ranges_[i] || (this.ranges_[i] = goog.dom.TextRange.createFromBrowserRange(this.browserRanges_[i]));
  return this.ranges_[i];
};
goog.dom.MultiRange.prototype.getContainer = function() {
  if (!this.container_) {
    for (var nodes = [], i = 0, len = this.getTextRangeCount();i < len;i++) {
      nodes.push(this.getTextRange(i).getContainer());
    }
    this.container_ = goog.dom.findCommonAncestor.apply(null, nodes);
  }
  return this.container_;
};
goog.dom.MultiRange.prototype.getSortedRanges = function() {
  this.sortedRanges_ || (this.sortedRanges_ = this.getTextRanges(), this.sortedRanges_.sort(function(a, b) {
    var aStartNode = a.getStartNode(), aStartOffset = a.getStartOffset(), bStartNode = b.getStartNode(), bStartOffset = b.getStartOffset();
    return aStartNode == bStartNode && aStartOffset == bStartOffset ? 0 : goog.dom.Range.isReversed(aStartNode, aStartOffset, bStartNode, bStartOffset) ? 1 : -1;
  }));
  return this.sortedRanges_;
};
goog.dom.MultiRange.prototype.getStartNode = function() {
  return this.getSortedRanges()[0].getStartNode();
};
goog.dom.MultiRange.prototype.getStartOffset = function() {
  return this.getSortedRanges()[0].getStartOffset();
};
goog.dom.MultiRange.prototype.getEndNode = function() {
  return goog.array.peek(this.getSortedRanges()).getEndNode();
};
goog.dom.MultiRange.prototype.getEndOffset = function() {
  return goog.array.peek(this.getSortedRanges()).getEndOffset();
};
goog.dom.MultiRange.prototype.isCollapsed = function() {
  return 0 == this.browserRanges_.length || 1 == this.browserRanges_.length && this.getTextRange(0).isCollapsed();
};
goog.dom.MultiRange.prototype.getText = function() {
  return goog.array.map(this.getTextRanges(), function(range) {
    return range.getText();
  }).join("");
};
goog.dom.MultiRange.prototype.__iterator__ = function() {
  return new goog.dom.MultiRangeIterator(this);
};
goog.dom.MultiRange.prototype.select = function() {
  var selection = goog.dom.AbstractRange.getBrowserSelectionForWindow(this.getWindow());
  selection.removeAllRanges();
  for (var i = 0, len = this.getTextRangeCount();i < len;i++) {
    selection.addRange(this.getTextRange(i).getBrowserRangeObject());
  }
};
goog.dom.MultiRange.prototype.saveUsingDom = function() {
  return new goog.dom.DomSavedMultiRange_(this);
};
goog.dom.MultiRange.prototype.collapse = function(toAnchor) {
  if (!this.isCollapsed()) {
    var range = toAnchor ? this.getTextRange(0) : this.getTextRange(this.getTextRangeCount() - 1);
    this.clearCachedValues_();
    range.collapse(toAnchor);
    this.ranges_ = [range];
    this.sortedRanges_ = [range];
    this.browserRanges_ = [range.getBrowserRangeObject()];
  }
};
goog.dom.DomSavedMultiRange_ = function(range$$0) {
  this.savedRanges_ = goog.array.map(range$$0.getTextRanges(), function(range) {
    return range.saveUsingDom();
  });
};
goog.inherits(goog.dom.DomSavedMultiRange_, goog.dom.SavedRange);
goog.dom.DomSavedMultiRange_.prototype.restoreInternal = function() {
  var ranges = goog.array.map(this.savedRanges_, function(savedRange) {
    return savedRange.restore();
  });
  return goog.dom.MultiRange.createFromTextRanges(ranges);
};
goog.dom.DomSavedMultiRange_.prototype.disposeInternal = function() {
  goog.dom.DomSavedMultiRange_.superClass_.disposeInternal.call(this);
  goog.array.forEach(this.savedRanges_, function(savedRange) {
    savedRange.dispose();
  });
  delete this.savedRanges_;
};
goog.dom.MultiRangeIterator = function(range) {
  range && (this.iterators_ = goog.array.map(range.getSortedRanges(), function(r) {
    return goog.iter.toIterator(r);
  }));
  goog.dom.RangeIterator.call(this, range ? this.getStartNode() : null, !1);
};
goog.inherits(goog.dom.MultiRangeIterator, goog.dom.RangeIterator);
goog.dom.MultiRangeIterator.prototype.iterators_ = null;
goog.dom.MultiRangeIterator.prototype.currentIdx_ = 0;
goog.dom.MultiRangeIterator.prototype.getStartNode = function() {
  return this.iterators_[0].getStartNode();
};
goog.dom.MultiRangeIterator.prototype.getEndNode = function() {
  return goog.array.peek(this.iterators_).getEndNode();
};
goog.dom.MultiRangeIterator.prototype.isLast = function() {
  return this.iterators_[this.currentIdx_].isLast();
};
goog.dom.MultiRangeIterator.prototype.next = function() {
  try {
    var it = this.iterators_[this.currentIdx_], next = it.next();
    this.setPosition(it.node, it.tagType, it.depth);
    return next;
  } catch (ex) {
    if (ex !== goog.iter.StopIteration || this.iterators_.length - 1 == this.currentIdx_) {
      throw ex;
    }
    this.currentIdx_++;
    return this.next();
  }
};
goog.dom.MultiRangeIterator.prototype.copyFrom = function(other) {
  this.iterators_ = goog.array.clone(other.iterators_);
  goog.dom.MultiRangeIterator.superClass_.copyFrom.call(this, other);
};
goog.dom.MultiRangeIterator.prototype.clone = function() {
  var copy = new goog.dom.MultiRangeIterator(null);
  copy.copyFrom(this);
  return copy;
};
// INPUT (javascript/closure/dom/range.js)
goog.dom.Range = {};
goog.dom.Range.createFromWindow = function(opt_win) {
  var sel = goog.dom.AbstractRange.getBrowserSelectionForWindow(opt_win || window);
  return sel && goog.dom.Range.createFromBrowserSelection(sel);
};
goog.dom.Range.createFromBrowserSelection = function(selection) {
  var range, isReversed = !1;
  if (selection.createRange) {
    try {
      range = selection.createRange();
    } catch (e) {
      return null;
    }
  } else {
    if (selection.rangeCount) {
      if (1 < selection.rangeCount) {
        return goog.dom.MultiRange.createFromBrowserSelection(selection);
      }
      range = selection.getRangeAt(0);
      isReversed = goog.dom.Range.isReversed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    } else {
      return null;
    }
  }
  return goog.dom.Range.createFromBrowserRange(range, isReversed);
};
goog.dom.Range.createFromBrowserRange = function(range, opt_isReversed) {
  return goog.dom.AbstractRange.isNativeControlRange(range) ? goog.dom.ControlRange.createFromBrowserRange(range) : goog.dom.TextRange.createFromBrowserRange(range, opt_isReversed);
};
goog.dom.Range.createFromNodeContents = function(node, opt_isReversed) {
  return goog.dom.TextRange.createFromNodeContents(node, opt_isReversed);
};
goog.dom.Range.createCaret = function(node, offset) {
  return goog.dom.TextRange.createFromNodes(node, offset, node, offset);
};
goog.dom.Range.createFromNodes = function(anchorNode, anchorOffset, focusNode, focusOffset) {
  return goog.dom.TextRange.createFromNodes(anchorNode, anchorOffset, focusNode, focusOffset);
};
goog.dom.Range.clearSelection = function(opt_win) {
  var sel = goog.dom.AbstractRange.getBrowserSelectionForWindow(opt_win || window);
  if (sel) {
    if (sel.empty) {
      try {
        sel.empty();
      } catch (e) {
      }
    } else {
      try {
        sel.removeAllRanges();
      } catch (e$$0) {
      }
    }
  }
};
goog.dom.Range.hasSelection = function(opt_win) {
  var sel = goog.dom.AbstractRange.getBrowserSelectionForWindow(opt_win || window);
  return!!sel && (goog.dom.BrowserFeature.LEGACY_IE_RANGES ? "None" != sel.type : !!sel.rangeCount);
};
goog.dom.Range.isReversed = function(anchorNode, anchorOffset, focusNode, focusOffset) {
  if (anchorNode == focusNode) {
    return focusOffset < anchorOffset;
  }
  var child;
  if (anchorNode.nodeType == goog.dom.NodeType.ELEMENT && anchorOffset) {
    if (child = anchorNode.childNodes[anchorOffset]) {
      anchorNode = child, anchorOffset = 0;
    } else {
      if (goog.dom.contains(anchorNode, focusNode)) {
        return!0;
      }
    }
  }
  if (focusNode.nodeType == goog.dom.NodeType.ELEMENT && focusOffset) {
    if (child = focusNode.childNodes[focusOffset]) {
      focusNode = child, focusOffset = 0;
    } else {
      if (goog.dom.contains(focusNode, anchorNode)) {
        return!1;
      }
    }
  }
  return 0 < (goog.dom.compareNodeOrder(anchorNode, focusNode) || anchorOffset - focusOffset);
};
// INPUT (javascript/closure/ui/idgenerator.js)
goog.ui.IdGenerator = function() {
};
goog.addSingletonGetter(goog.ui.IdGenerator);
goog.ui.IdGenerator.prototype.nextId_ = 0;
goog.ui.IdGenerator.prototype.getNextUniqueId = function() {
  return ":" + (this.nextId_++).toString(36);
};
// INPUT (javascript/closure/ui/component.js)
goog.ui.Component = function(opt_domHelper) {
  goog.events.EventTarget.call(this);
  this.dom_ = opt_domHelper || goog.dom.getDomHelper();
  this.rightToLeft_ = goog.ui.Component.defaultRightToLeft_;
  this.id_ = null;
  this.inDocument_ = !1;
  this.element_ = null;
  this.googUiComponentHandler_ = void 0;
  this.childIndex_ = this.children_ = this.parent_ = this.model_ = null;
  this.wasDecorated_ = !1;
};
goog.inherits(goog.ui.Component, goog.events.EventTarget);
goog.ui.Component.ALLOW_DETACHED_DECORATION = !1;
goog.ui.Component.prototype.idGenerator_ = goog.ui.IdGenerator.getInstance();
goog.ui.Component.DEFAULT_BIDI_DIR = 0;
goog.ui.Component.defaultRightToLeft_ = 1 == goog.ui.Component.DEFAULT_BIDI_DIR ? !1 : -1 == goog.ui.Component.DEFAULT_BIDI_DIR ? !0 : null;
goog.ui.Component.EventType = {BEFORE_SHOW:"beforeshow", SHOW:"show", HIDE:"hide", DISABLE:"disable", ENABLE:"enable", HIGHLIGHT:"highlight", UNHIGHLIGHT:"unhighlight", ACTIVATE:"activate", DEACTIVATE:"deactivate", SELECT:"select", UNSELECT:"unselect", CHECK:"check", UNCHECK:"uncheck", FOCUS:"focus", BLUR:"blur", OPEN:"open", CLOSE:"close", ENTER:"enter", LEAVE:"leave", ACTION:"action", CHANGE:"change"};
goog.ui.Component.Error = {NOT_SUPPORTED:"Method not supported", DECORATE_INVALID:"Invalid element to decorate", ALREADY_RENDERED:"Component already rendered", PARENT_UNABLE_TO_BE_SET:"Unable to set parent component", CHILD_INDEX_OUT_OF_BOUNDS:"Child component index out of bounds", NOT_OUR_CHILD:"Child is not in parent component", NOT_IN_DOCUMENT:"Operation not supported while component is not in document", STATE_INVALID:"Invalid component state"};
goog.ui.Component.State = {ALL:255, DISABLED:1, HOVER:2, ACTIVE:4, SELECTED:8, CHECKED:16, FOCUSED:32, OPENED:64};
goog.ui.Component.getStateTransitionEvent = function(state, isEntering) {
  switch(state) {
    case goog.ui.Component.State.DISABLED:
      return isEntering ? goog.ui.Component.EventType.DISABLE : goog.ui.Component.EventType.ENABLE;
    case goog.ui.Component.State.HOVER:
      return isEntering ? goog.ui.Component.EventType.HIGHLIGHT : goog.ui.Component.EventType.UNHIGHLIGHT;
    case goog.ui.Component.State.ACTIVE:
      return isEntering ? goog.ui.Component.EventType.ACTIVATE : goog.ui.Component.EventType.DEACTIVATE;
    case goog.ui.Component.State.SELECTED:
      return isEntering ? goog.ui.Component.EventType.SELECT : goog.ui.Component.EventType.UNSELECT;
    case goog.ui.Component.State.CHECKED:
      return isEntering ? goog.ui.Component.EventType.CHECK : goog.ui.Component.EventType.UNCHECK;
    case goog.ui.Component.State.FOCUSED:
      return isEntering ? goog.ui.Component.EventType.FOCUS : goog.ui.Component.EventType.BLUR;
    case goog.ui.Component.State.OPENED:
      return isEntering ? goog.ui.Component.EventType.OPEN : goog.ui.Component.EventType.CLOSE;
  }
  throw Error(goog.ui.Component.Error.STATE_INVALID);
};
goog.ui.Component.setDefaultRightToLeft = function(rightToLeft) {
  goog.ui.Component.defaultRightToLeft_ = rightToLeft;
};
goog.ui.Component.prototype.getId = function() {
  return this.id_ || (this.id_ = this.idGenerator_.getNextUniqueId());
};
goog.ui.Component.prototype.setId = function(id) {
  this.parent_ && this.parent_.childIndex_ && (goog.object.remove(this.parent_.childIndex_, this.id_), goog.object.add(this.parent_.childIndex_, id, this));
  this.id_ = id;
};
goog.ui.Component.prototype.getElement = function() {
  return this.element_;
};
goog.ui.Component.prototype.getElementStrict = function() {
  var el = this.element_;
  goog.asserts.assert(el, "Can not call getElementStrict before rendering/decorating.");
  return el;
};
goog.ui.Component.prototype.setElementInternal = function(element) {
  this.element_ = element;
};
goog.ui.Component.prototype.getElementsByClass = function(className) {
  return this.element_ ? this.dom_.getElementsByClass(className, this.element_) : [];
};
goog.ui.Component.prototype.getElementByClass = function(className) {
  return this.element_ ? this.dom_.getElementByClass(className, this.element_) : null;
};
goog.ui.Component.prototype.getRequiredElementByClass = function(className) {
  var el = this.getElementByClass(className);
  goog.asserts.assert(el, "Expected element in component with class: %s", className);
  return el;
};
goog.ui.Component.prototype.getHandler = function() {
  this.googUiComponentHandler_ || (this.googUiComponentHandler_ = new goog.events.EventHandler(this));
  return this.googUiComponentHandler_;
};
goog.ui.Component.prototype.setParent = function(parent) {
  if (this == parent) {
    throw Error(goog.ui.Component.Error.PARENT_UNABLE_TO_BE_SET);
  }
  if (parent && this.parent_ && this.id_ && this.parent_.getChild(this.id_) && this.parent_ != parent) {
    throw Error(goog.ui.Component.Error.PARENT_UNABLE_TO_BE_SET);
  }
  this.parent_ = parent;
  goog.ui.Component.superClass_.setParentEventTarget.call(this, parent);
};
goog.ui.Component.prototype.getParent = function() {
  return this.parent_;
};
goog.ui.Component.prototype.setParentEventTarget = function(parent) {
  if (this.parent_ && this.parent_ != parent) {
    throw Error(goog.ui.Component.Error.NOT_SUPPORTED);
  }
  goog.ui.Component.superClass_.setParentEventTarget.call(this, parent);
};
goog.ui.Component.prototype.getDomHelper = function() {
  return this.dom_;
};
goog.ui.Component.prototype.isInDocument = function() {
  return this.inDocument_;
};
goog.ui.Component.prototype.createDom = function() {
  this.element_ = this.dom_.createElement("div");
};
goog.ui.Component.prototype.render = function(opt_parentElement) {
  this.render_(opt_parentElement);
};
goog.ui.Component.prototype.renderBefore = function(sibling) {
  this.render_(sibling.parentNode, sibling);
};
goog.ui.Component.prototype.render_ = function(opt_parentElement, opt_beforeNode) {
  if (this.inDocument_) {
    throw Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  this.element_ || this.createDom();
  opt_parentElement ? opt_parentElement.insertBefore(this.element_, opt_beforeNode || null) : this.dom_.getDocument().body.appendChild(this.element_);
  this.parent_ && !this.parent_.isInDocument() || this.enterDocument();
};
goog.ui.Component.prototype.decorate = function(element) {
  if (this.inDocument_) {
    throw Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  if (element && this.canDecorate(element)) {
    this.wasDecorated_ = !0;
    var doc = goog.dom.getOwnerDocument(element);
    this.dom_ && this.dom_.getDocument() == doc || (this.dom_ = goog.dom.getDomHelper(element));
    this.decorateInternal(element);
    goog.ui.Component.ALLOW_DETACHED_DECORATION && !goog.dom.contains(doc, element) || this.enterDocument();
  } else {
    throw Error(goog.ui.Component.Error.DECORATE_INVALID);
  }
};
goog.ui.Component.prototype.canDecorate = function() {
  return!0;
};
goog.ui.Component.prototype.decorateInternal = function(element) {
  this.element_ = element;
};
goog.ui.Component.prototype.enterDocument = function() {
  this.inDocument_ = !0;
  this.forEachChild(function(child) {
    !child.isInDocument() && child.getElement() && child.enterDocument();
  });
};
goog.ui.Component.prototype.exitDocument = function() {
  this.forEachChild(function(child) {
    child.isInDocument() && child.exitDocument();
  });
  this.googUiComponentHandler_ && this.googUiComponentHandler_.removeAll();
  this.inDocument_ = !1;
};
goog.ui.Component.prototype.disposeInternal = function() {
  this.inDocument_ && this.exitDocument();
  this.googUiComponentHandler_ && (this.googUiComponentHandler_.dispose(), delete this.googUiComponentHandler_);
  this.forEachChild(function(child) {
    child.dispose();
  });
  !this.wasDecorated_ && this.element_ && goog.dom.removeNode(this.element_);
  this.parent_ = this.model_ = this.element_ = this.childIndex_ = this.children_ = null;
  goog.ui.Component.superClass_.disposeInternal.call(this);
};
goog.ui.Component.prototype.makeId = function(idFragment) {
  return this.getId() + "." + idFragment;
};
goog.ui.Component.prototype.getModel = function() {
  return this.model_;
};
goog.ui.Component.prototype.setModel = function(obj) {
  this.model_ = obj;
};
goog.ui.Component.prototype.addChild = function(child, opt_render) {
  this.addChildAt(child, this.getChildCount(), opt_render);
};
goog.ui.Component.prototype.addChildAt = function(child, index, opt_render) {
  goog.asserts.assert(!!child, "Provided element must not be null.");
  if (child.inDocument_ && (opt_render || !this.inDocument_)) {
    throw Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  if (0 > index || index > this.getChildCount()) {
    throw Error(goog.ui.Component.Error.CHILD_INDEX_OUT_OF_BOUNDS);
  }
  this.childIndex_ && this.children_ || (this.childIndex_ = {}, this.children_ = []);
  child.getParent() == this ? (goog.object.set(this.childIndex_, child.getId(), child), goog.array.remove(this.children_, child)) : goog.object.add(this.childIndex_, child.getId(), child);
  child.setParent(this);
  goog.array.insertAt(this.children_, child, index);
  if (child.inDocument_ && this.inDocument_ && child.getParent() == this) {
    var contentElement = this.getContentElement();
    contentElement.insertBefore(child.getElement(), contentElement.childNodes[index] || null);
  } else {
    if (opt_render) {
      this.element_ || this.createDom();
      var sibling = this.getChildAt(index + 1);
      child.render_(this.getContentElement(), sibling ? sibling.element_ : null);
    } else {
      this.inDocument_ && !child.inDocument_ && child.element_ && child.element_.parentNode && child.element_.parentNode.nodeType == goog.dom.NodeType.ELEMENT && child.enterDocument();
    }
  }
};
goog.ui.Component.prototype.getContentElement = function() {
  return this.element_;
};
goog.ui.Component.prototype.isRightToLeft = function() {
  null == this.rightToLeft_ && (this.rightToLeft_ = goog.style.isRightToLeft(this.inDocument_ ? this.element_ : this.dom_.getDocument().body));
  return this.rightToLeft_;
};
goog.ui.Component.prototype.setRightToLeft = function(rightToLeft) {
  if (this.inDocument_) {
    throw Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  this.rightToLeft_ = rightToLeft;
};
goog.ui.Component.prototype.hasChildren = function() {
  return!!this.children_ && 0 != this.children_.length;
};
goog.ui.Component.prototype.getChildCount = function() {
  return this.children_ ? this.children_.length : 0;
};
goog.ui.Component.prototype.getChild = function(id) {
  return this.childIndex_ && id ? goog.object.get(this.childIndex_, id) || null : null;
};
goog.ui.Component.prototype.getChildAt = function(index) {
  return this.children_ ? this.children_[index] || null : null;
};
goog.ui.Component.prototype.forEachChild = function(f, opt_obj) {
  this.children_ && goog.array.forEach(this.children_, f, opt_obj);
};
goog.ui.Component.prototype.indexOfChild = function(child) {
  return this.children_ && child ? goog.array.indexOf(this.children_, child) : -1;
};
goog.ui.Component.prototype.removeChild = function(child, opt_unrender) {
  if (child) {
    var id = goog.isString(child) ? child : child.getId();
    child = this.getChild(id);
    id && child && (goog.object.remove(this.childIndex_, id), goog.array.remove(this.children_, child), opt_unrender && (child.exitDocument(), child.element_ && goog.dom.removeNode(child.element_)), child.setParent(null));
  }
  if (!child) {
    throw Error(goog.ui.Component.Error.NOT_OUR_CHILD);
  }
  return child;
};
goog.ui.Component.prototype.removeChildAt = function(index, opt_unrender) {
  return this.removeChild(this.getChildAt(index), opt_unrender);
};
goog.ui.Component.prototype.removeChildren = function(opt_unrender) {
  for (var removedChildren = [];this.hasChildren();) {
    removedChildren.push(this.removeChildAt(0, opt_unrender));
  }
  return removedChildren;
};
// INPUT (javascript/closure/dom/classlist.js)
goog.dom.classlist = {};
goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST = !1;
goog.dom.classlist.get = function(element) {
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    return element.classList;
  }
  var className = element.className;
  return goog.isString(className) && className.match(/\S+/g) || [];
};
goog.dom.classlist.set = function(element, className) {
  element.className = className;
};
goog.dom.classlist.contains = function(element, className) {
  return goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList ? element.classList.contains(className) : goog.array.contains(goog.dom.classlist.get(element), className);
};
goog.dom.classlist.add = function(element, className) {
  goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList ? element.classList.add(className) : goog.dom.classlist.contains(element, className) || (element.className += 0 < element.className.length ? " " + className : className);
};
goog.dom.classlist.addAll = function(element, classesToAdd) {
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    goog.array.forEach(classesToAdd, function(className) {
      goog.dom.classlist.add(element, className);
    });
  } else {
    var classMap = {};
    goog.array.forEach(goog.dom.classlist.get(element), function(className) {
      classMap[className] = !0;
    });
    goog.array.forEach(classesToAdd, function(className) {
      classMap[className] = !0;
    });
    element.className = "";
    for (var className$$0 in classMap) {
      element.className += 0 < element.className.length ? " " + className$$0 : className$$0;
    }
  }
};
goog.dom.classlist.remove = function(element, className) {
  goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList ? element.classList.remove(className) : goog.dom.classlist.contains(element, className) && (element.className = goog.array.filter(goog.dom.classlist.get(element), function(c) {
    return c != className;
  }).join(" "));
};
goog.dom.classlist.removeAll = function(element, classesToRemove) {
  goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList ? goog.array.forEach(classesToRemove, function(className) {
    goog.dom.classlist.remove(element, className);
  }) : element.className = goog.array.filter(goog.dom.classlist.get(element), function(className) {
    return!goog.array.contains(classesToRemove, className);
  }).join(" ");
};
goog.dom.classlist.enable = function(element, className, enabled) {
  enabled ? goog.dom.classlist.add(element, className) : goog.dom.classlist.remove(element, className);
};
goog.dom.classlist.enableAll = function(element, classesToEnable, enabled) {
  var f = enabled ? goog.dom.classlist.addAll : goog.dom.classlist.removeAll;
  f(element, classesToEnable);
};
goog.dom.classlist.swap = function(element, fromClass, toClass) {
  return goog.dom.classlist.contains(element, fromClass) ? (goog.dom.classlist.remove(element, fromClass), goog.dom.classlist.add(element, toClass), !0) : !1;
};
goog.dom.classlist.toggle = function(element, className) {
  var add = !goog.dom.classlist.contains(element, className);
  goog.dom.classlist.enable(element, className, add);
  return add;
};
goog.dom.classlist.addRemove = function(element, classToRemove, classToAdd) {
  goog.dom.classlist.remove(element, classToRemove);
  goog.dom.classlist.add(element, classToAdd);
};
// INPUT (javascript/closure/fx/dragger.js)
goog.fx.Dragger = function(target, opt_handle, opt_limits) {
  goog.events.EventTarget.call(this);
  this.target = target;
  this.handle = opt_handle || target;
  this.limits = opt_limits || new goog.math.Rect(NaN, NaN, NaN, NaN);
  this.document_ = goog.dom.getOwnerDocument(target);
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.eventHandler_);
  goog.events.listen(this.handle, [goog.events.EventType.TOUCHSTART, goog.events.EventType.MOUSEDOWN], this.startDrag, !1, this);
};
goog.inherits(goog.fx.Dragger, goog.events.EventTarget);
goog.fx.Dragger.HAS_SET_CAPTURE_ = goog.userAgent.IE || goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher("1.9.3");
goog.fx.Dragger.cloneNode = function(sourceEl) {
  for (var clonedEl = sourceEl.cloneNode(!0), origTexts = sourceEl.getElementsByTagName("textarea"), dragTexts = clonedEl.getElementsByTagName("textarea"), i = 0;i < origTexts.length;i++) {
    dragTexts[i].value = origTexts[i].value;
  }
  switch(sourceEl.tagName.toLowerCase()) {
    case "tr":
      return goog.dom.createDom("table", null, goog.dom.createDom("tbody", null, clonedEl));
    case "td":
    ;
    case "th":
      return goog.dom.createDom("table", null, goog.dom.createDom("tbody", null, goog.dom.createDom("tr", null, clonedEl)));
    case "textarea":
      clonedEl.value = sourceEl.value;
    default:
      return clonedEl;
  }
};
goog.fx.Dragger.EventType = {EARLY_CANCEL:"earlycancel", START:"start", BEFOREDRAG:"beforedrag", DRAG:"drag", END:"end"};
goog.fx.Dragger.prototype.clientX = 0;
goog.fx.Dragger.prototype.clientY = 0;
goog.fx.Dragger.prototype.screenX = 0;
goog.fx.Dragger.prototype.screenY = 0;
goog.fx.Dragger.prototype.startX = 0;
goog.fx.Dragger.prototype.startY = 0;
goog.fx.Dragger.prototype.deltaX = 0;
goog.fx.Dragger.prototype.deltaY = 0;
goog.fx.Dragger.prototype.enabled_ = !0;
goog.fx.Dragger.prototype.dragging_ = !1;
goog.fx.Dragger.prototype.hysteresisDistanceSquared_ = 0;
goog.fx.Dragger.prototype.mouseDownTime_ = 0;
goog.fx.Dragger.prototype.ieDragStartCancellingOn_ = !1;
goog.fx.Dragger.prototype.useRightPositioningForRtl_ = !1;
goog.fx.Dragger.prototype.enableRightPositioningForRtl = function(useRightPositioningForRtl) {
  this.useRightPositioningForRtl_ = useRightPositioningForRtl;
};
goog.fx.Dragger.prototype.getHandler = function() {
  return this.eventHandler_;
};
goog.fx.Dragger.prototype.setLimits = function(limits) {
  this.limits = limits || new goog.math.Rect(NaN, NaN, NaN, NaN);
};
goog.fx.Dragger.prototype.setEnabled = function(enabled) {
  this.enabled_ = enabled;
};
goog.fx.Dragger.prototype.disposeInternal = function() {
  goog.fx.Dragger.superClass_.disposeInternal.call(this);
  goog.events.unlisten(this.handle, [goog.events.EventType.TOUCHSTART, goog.events.EventType.MOUSEDOWN], this.startDrag, !1, this);
  this.cleanUpAfterDragging_();
  this.handle = this.target = null;
};
goog.fx.Dragger.prototype.isRightToLeft_ = function() {
  goog.isDef(this.rightToLeft_) || (this.rightToLeft_ = goog.style.isRightToLeft(this.target));
  return this.rightToLeft_;
};
goog.fx.Dragger.prototype.startDrag = function(e) {
  var isMouseDown = e.type == goog.events.EventType.MOUSEDOWN;
  if (!this.enabled_ || this.dragging_ || isMouseDown && !e.isMouseActionButton()) {
    this.dispatchEvent(goog.fx.Dragger.EventType.EARLY_CANCEL);
  } else {
    this.maybeReinitTouchEvent_(e);
    if (0 == this.hysteresisDistanceSquared_) {
      if (this.fireDragStart_(e)) {
        this.dragging_ = !0, e.preventDefault();
      } else {
        return;
      }
    } else {
      e.preventDefault();
    }
    this.setupDragHandlers();
    this.clientX = this.startX = e.clientX;
    this.clientY = this.startY = e.clientY;
    this.screenX = e.screenX;
    this.screenY = e.screenY;
    this.computeInitialPosition();
    this.pageScroll = goog.dom.getDomHelper(this.document_).getDocumentScroll();
    this.mouseDownTime_ = goog.now();
  }
};
goog.fx.Dragger.prototype.setupDragHandlers = function() {
  var doc = this.document_, docEl = doc.documentElement, useCapture = !goog.fx.Dragger.HAS_SET_CAPTURE_;
  this.eventHandler_.listen(doc, [goog.events.EventType.TOUCHMOVE, goog.events.EventType.MOUSEMOVE], this.handleMove_, useCapture);
  this.eventHandler_.listen(doc, [goog.events.EventType.TOUCHEND, goog.events.EventType.MOUSEUP], this.endDrag, useCapture);
  goog.fx.Dragger.HAS_SET_CAPTURE_ ? (docEl.setCapture(!1), this.eventHandler_.listen(docEl, goog.events.EventType.LOSECAPTURE, this.endDrag)) : this.eventHandler_.listen(goog.dom.getWindow(doc), goog.events.EventType.BLUR, this.endDrag);
  goog.userAgent.IE && this.ieDragStartCancellingOn_ && this.eventHandler_.listen(doc, goog.events.EventType.DRAGSTART, goog.events.Event.preventDefault);
  this.scrollTarget_ && this.eventHandler_.listen(this.scrollTarget_, goog.events.EventType.SCROLL, this.onScroll_, useCapture);
};
goog.fx.Dragger.prototype.fireDragStart_ = function(e) {
  return this.dispatchEvent(new goog.fx.DragEvent(goog.fx.Dragger.EventType.START, this, e.clientX, e.clientY, e));
};
goog.fx.Dragger.prototype.cleanUpAfterDragging_ = function() {
  this.eventHandler_.removeAll();
  goog.fx.Dragger.HAS_SET_CAPTURE_ && this.document_.releaseCapture();
};
goog.fx.Dragger.prototype.endDrag = function(e, opt_dragCanceled) {
  this.cleanUpAfterDragging_();
  if (this.dragging_) {
    this.maybeReinitTouchEvent_(e);
    this.dragging_ = !1;
    var x = this.limitX(this.deltaX), y = this.limitY(this.deltaY), dragCanceled = opt_dragCanceled || e.type == goog.events.EventType.TOUCHCANCEL;
    this.dispatchEvent(new goog.fx.DragEvent(goog.fx.Dragger.EventType.END, this, e.clientX, e.clientY, e, x, y, dragCanceled));
  } else {
    this.dispatchEvent(goog.fx.Dragger.EventType.EARLY_CANCEL);
  }
};
goog.fx.Dragger.prototype.maybeReinitTouchEvent_ = function(e) {
  var type = e.type;
  type == goog.events.EventType.TOUCHSTART || type == goog.events.EventType.TOUCHMOVE ? e.init(e.getBrowserEvent().targetTouches[0], e.currentTarget) : type != goog.events.EventType.TOUCHEND && type != goog.events.EventType.TOUCHCANCEL || e.init(e.getBrowserEvent().changedTouches[0], e.currentTarget);
};
goog.fx.Dragger.prototype.handleMove_ = function(e) {
  if (this.enabled_) {
    this.maybeReinitTouchEvent_(e);
    var sign = this.useRightPositioningForRtl_ && this.isRightToLeft_() ? -1 : 1, dx = sign * (e.clientX - this.clientX), dy = e.clientY - this.clientY;
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    this.screenX = e.screenX;
    this.screenY = e.screenY;
    if (!this.dragging_) {
      var diffX = this.startX - this.clientX, diffY = this.startY - this.clientY, distance = diffX * diffX + diffY * diffY;
      if (distance > this.hysteresisDistanceSquared_) {
        if (this.fireDragStart_(e)) {
          this.dragging_ = !0;
        } else {
          this.isDisposed() || this.endDrag(e);
          return;
        }
      }
    }
    var pos = this.calculatePosition_(dx, dy), x = pos.x, y = pos.y;
    if (this.dragging_) {
      var rv = this.dispatchEvent(new goog.fx.DragEvent(goog.fx.Dragger.EventType.BEFOREDRAG, this, e.clientX, e.clientY, e, x, y));
      rv && (this.doDrag(e, x, y, !1), e.preventDefault());
    }
  }
};
goog.fx.Dragger.prototype.calculatePosition_ = function(dx, dy) {
  var pageScroll = goog.dom.getDomHelper(this.document_).getDocumentScroll();
  dx += pageScroll.x - this.pageScroll.x;
  dy += pageScroll.y - this.pageScroll.y;
  this.pageScroll = pageScroll;
  this.deltaX += dx;
  this.deltaY += dy;
  var x = this.limitX(this.deltaX), y = this.limitY(this.deltaY);
  return new goog.math.Coordinate(x, y);
};
goog.fx.Dragger.prototype.onScroll_ = function(e) {
  var pos = this.calculatePosition_(0, 0);
  e.clientX = this.clientX;
  e.clientY = this.clientY;
  this.doDrag(e, pos.x, pos.y, !0);
};
goog.fx.Dragger.prototype.doDrag = function(e, x, y) {
  this.defaultAction(x, y);
  this.dispatchEvent(new goog.fx.DragEvent(goog.fx.Dragger.EventType.DRAG, this, e.clientX, e.clientY, e, x, y));
};
goog.fx.Dragger.prototype.limitX = function(x) {
  var rect = this.limits, left = isNaN(rect.left) ? null : rect.left, width = isNaN(rect.width) ? 0 : rect.width, maxX = null != left ? left + width : Infinity, minX = null != left ? left : -Infinity;
  return Math.min(maxX, Math.max(minX, x));
};
goog.fx.Dragger.prototype.limitY = function(y) {
  var rect = this.limits, top = isNaN(rect.top) ? null : rect.top, height = isNaN(rect.height) ? 0 : rect.height, maxY = null != top ? top + height : Infinity, minY = null != top ? top : -Infinity;
  return Math.min(maxY, Math.max(minY, y));
};
goog.fx.Dragger.prototype.computeInitialPosition = function() {
  this.deltaX = this.useRightPositioningForRtl_ ? goog.style.bidi.getOffsetStart(this.target) : this.target.offsetLeft;
  this.deltaY = this.target.offsetTop;
};
goog.fx.Dragger.prototype.defaultAction = function(x, y) {
  this.useRightPositioningForRtl_ && this.isRightToLeft_() ? this.target.style.right = x + "px" : this.target.style.left = x + "px";
  this.target.style.top = y + "px";
};
goog.fx.DragEvent = function(type, dragobj, clientX, clientY, browserEvent, opt_actX, opt_actY) {
  goog.events.Event.call(this, type);
  this.clientX = clientX;
  this.clientY = clientY;
  this.browserEvent = browserEvent;
  this.left = goog.isDef(opt_actX) ? opt_actX : dragobj.deltaX;
  this.top = goog.isDef(opt_actY) ? opt_actY : dragobj.deltaY;
  this.dragger = dragobj;
};
goog.inherits(goog.fx.DragEvent, goog.events.Event);
// INPUT (javascript/closure/dom/iframe.js)
goog.dom.iframe = {};
goog.dom.iframe.BLANK_SOURCE = 'javascript:""';
goog.dom.iframe.BLANK_SOURCE_NEW_FRAME = goog.userAgent.IE ? 'javascript:""' : "javascript:undefined";
goog.dom.iframe.STYLES_ = "border:0;vertical-align:bottom;";
goog.dom.iframe.createBlank = function(domHelper, opt_styles) {
  return domHelper.createDom("iframe", {frameborder:0, style:goog.dom.iframe.STYLES_ + (opt_styles || ""), src:goog.dom.iframe.BLANK_SOURCE});
};
goog.dom.iframe.writeContent = function(iframe, content) {
  var doc = goog.dom.getFrameContentDocument(iframe);
  doc.open();
  doc.write(content);
  doc.close();
};
goog.dom.iframe.createWithContent = function(parentElement, opt_headContents, opt_bodyContents, opt_styles, opt_quirks) {
  var domHelper = goog.dom.getDomHelper(parentElement), contentBuf = [];
  opt_quirks || contentBuf.push("<!DOCTYPE html>");
  contentBuf.push("<html><head>", opt_headContents, "</head><body>", opt_bodyContents, "</body></html>");
  var iframe = goog.dom.iframe.createBlank(domHelper, opt_styles);
  parentElement.appendChild(iframe);
  goog.dom.iframe.writeContent(iframe, contentBuf.join(""));
  return iframe;
};
// INPUT (javascript/closure/events/focushandler.js)
goog.events.FocusHandler = function(element) {
  goog.events.EventTarget.call(this);
  this.element_ = element;
  var typeIn = goog.userAgent.IE ? "focusin" : "focus", typeOut = goog.userAgent.IE ? "focusout" : "blur";
  this.listenKeyIn_ = goog.events.listen(this.element_, typeIn, this, !goog.userAgent.IE);
  this.listenKeyOut_ = goog.events.listen(this.element_, typeOut, this, !goog.userAgent.IE);
};
goog.inherits(goog.events.FocusHandler, goog.events.EventTarget);
goog.events.FocusHandler.EventType = {FOCUSIN:"focusin", FOCUSOUT:"focusout"};
goog.events.FocusHandler.prototype.handleEvent = function(e) {
  var be = e.getBrowserEvent(), event = new goog.events.BrowserEvent(be);
  event.type = "focusin" == e.type || "focus" == e.type ? goog.events.FocusHandler.EventType.FOCUSIN : goog.events.FocusHandler.EventType.FOCUSOUT;
  this.dispatchEvent(event);
};
goog.events.FocusHandler.prototype.disposeInternal = function() {
  goog.events.FocusHandler.superClass_.disposeInternal.call(this);
  goog.events.unlistenByKey(this.listenKeyIn_);
  goog.events.unlistenByKey(this.listenKeyOut_);
  delete this.element_;
};
// INPUT (javascript/closure/ui/modalpopup.js)
goog.ui.ModalPopup = function(opt_useIframeMask, opt_domHelper) {
  goog.ui.Component.call(this, opt_domHelper);
  this.useIframeMask_ = !!opt_useIframeMask;
  this.lastFocus_ = null;
};
goog.inherits(goog.ui.ModalPopup, goog.ui.Component);
goog.tagUnsealableClass(goog.ui.ModalPopup);
goog.ui.ModalPopup.prototype.focusHandler_ = null;
goog.ui.ModalPopup.prototype.visible_ = !1;
goog.ui.ModalPopup.prototype.bgEl_ = null;
goog.ui.ModalPopup.prototype.bgIframeEl_ = null;
goog.ui.ModalPopup.prototype.tabCatcherElement_ = null;
goog.ui.ModalPopup.prototype.backwardTabWrapInProgress_ = !1;
goog.ui.ModalPopup.prototype.getCssClass = function() {
  return "aAAaGVIZSENTINELaAAa-modalpopup";
};
goog.ui.ModalPopup.prototype.getBackgroundIframe = function() {
  return this.bgIframeEl_;
};
goog.ui.ModalPopup.prototype.getBackgroundElement = function() {
  return this.bgEl_;
};
goog.ui.ModalPopup.prototype.createDom = function() {
  goog.ui.ModalPopup.superClass_.createDom.call(this);
  var element = this.getElement();
  goog.asserts.assert(element);
  var allClasses = goog.string.trim(this.getCssClass()).split(" ");
  goog.dom.classlist.addAll(element, allClasses);
  goog.dom.setFocusableTabIndex(element, !0);
  goog.style.setElementShown(element, !1);
  this.manageBackgroundDom_();
  this.createTabCatcher_();
};
goog.ui.ModalPopup.prototype.manageBackgroundDom_ = function() {
  this.useIframeMask_ && !this.bgIframeEl_ && (this.bgIframeEl_ = goog.dom.iframe.createBlank(this.getDomHelper()), this.bgIframeEl_.className = this.getCssClass() + "-bg", goog.style.setElementShown(this.bgIframeEl_, !1), goog.style.setOpacity(this.bgIframeEl_, 0));
  this.bgEl_ || (this.bgEl_ = this.getDomHelper().createDom("div", this.getCssClass() + "-bg"), goog.style.setElementShown(this.bgEl_, !1));
};
goog.ui.ModalPopup.prototype.createTabCatcher_ = function() {
  this.tabCatcherElement_ || (this.tabCatcherElement_ = this.getDomHelper().createElement("span"), goog.style.setElementShown(this.tabCatcherElement_, !1), goog.dom.setFocusableTabIndex(this.tabCatcherElement_, !0), this.tabCatcherElement_.style.position = "absolute");
};
goog.ui.ModalPopup.prototype.setupBackwardTabWrap = function() {
  this.backwardTabWrapInProgress_ = !0;
  try {
    this.tabCatcherElement_.focus();
  } catch (e) {
  }
  goog.Timer.callOnce(this.resetBackwardTabWrap_, 0, this);
};
goog.ui.ModalPopup.prototype.resetBackwardTabWrap_ = function() {
  this.backwardTabWrapInProgress_ = !1;
};
goog.ui.ModalPopup.prototype.renderBackground_ = function() {
  goog.asserts.assert(!!this.bgEl_, "Background element must not be null.");
  this.bgIframeEl_ && goog.dom.insertSiblingBefore(this.bgIframeEl_, this.getElement());
  goog.dom.insertSiblingBefore(this.bgEl_, this.getElement());
};
goog.ui.ModalPopup.prototype.canDecorate = function(element) {
  return!!element && element.tagName == goog.dom.TagName.DIV;
};
goog.ui.ModalPopup.prototype.decorateInternal = function(element) {
  goog.ui.ModalPopup.superClass_.decorateInternal.call(this, element);
  var allClasses = goog.string.trim(this.getCssClass()).split(" ");
  goog.dom.classlist.addAll(goog.asserts.assert(this.getElement()), allClasses);
  this.manageBackgroundDom_();
  this.createTabCatcher_();
  goog.style.setElementShown(this.getElement(), !1);
};
goog.ui.ModalPopup.prototype.enterDocument = function() {
  this.renderBackground_();
  goog.ui.ModalPopup.superClass_.enterDocument.call(this);
  goog.dom.insertSiblingAfter(this.tabCatcherElement_, this.getElement());
  this.focusHandler_ = new goog.events.FocusHandler(this.getDomHelper().getDocument());
  this.getHandler().listen(this.focusHandler_, goog.events.FocusHandler.EventType.FOCUSIN, this.onFocus);
  this.setA11YDetectBackground(!1);
};
goog.ui.ModalPopup.prototype.exitDocument = function() {
  this.isVisible() && this.setVisible(!1);
  goog.dispose(this.focusHandler_);
  goog.ui.ModalPopup.superClass_.exitDocument.call(this);
  goog.dom.removeNode(this.bgIframeEl_);
  goog.dom.removeNode(this.bgEl_);
  goog.dom.removeNode(this.tabCatcherElement_);
};
goog.ui.ModalPopup.prototype.setVisible = function(visible) {
  goog.asserts.assert(this.isInDocument(), "ModalPopup must be rendered first.");
  visible != this.visible_ && (this.popupShowTransition_ && this.popupShowTransition_.stop(), this.bgShowTransition_ && this.bgShowTransition_.stop(), this.popupHideTransition_ && this.popupHideTransition_.stop(), this.bgHideTransition_ && this.bgHideTransition_.stop(), this.isInDocument() && this.setA11YDetectBackground(visible), visible ? this.show_() : this.hide_());
};
goog.ui.ModalPopup.prototype.setA11YDetectBackground = function(hide) {
  if (hide) {
    this.hiddenElements_ || (this.hiddenElements_ = []);
    for (var dom = this.getDomHelper(), topLevelChildren = dom.getChildren(dom.getDocument().body), i = 0;i < topLevelChildren.length;i++) {
      var child = topLevelChildren[i];
      child == this.getElementStrict() || goog.a11y.aria.getState(child, goog.a11y.aria.State.HIDDEN) || (goog.a11y.aria.setState(child, goog.a11y.aria.State.HIDDEN, !0), this.hiddenElements_.push(child));
    }
  } else {
    if (this.hiddenElements_) {
      for (i = 0;i < this.hiddenElements_.length;i++) {
        goog.a11y.aria.removeState(this.hiddenElements_[i], goog.a11y.aria.State.HIDDEN);
      }
      this.hiddenElements_ = null;
    }
  }
};
goog.ui.ModalPopup.prototype.setTransition = function(popupShowTransition, popupHideTransition, bgShowTransition, bgHideTransition) {
  this.popupShowTransition_ = popupShowTransition;
  this.popupHideTransition_ = popupHideTransition;
  this.bgShowTransition_ = bgShowTransition;
  this.bgHideTransition_ = bgHideTransition;
};
goog.ui.ModalPopup.prototype.show_ = function() {
  if (this.dispatchEvent(goog.ui.PopupBase.EventType.BEFORE_SHOW)) {
    try {
      this.lastFocus_ = this.getDomHelper().getDocument().activeElement;
    } catch (e) {
    }
    this.resizeBackground_();
    this.reposition();
    this.getHandler().listen(this.getDomHelper().getWindow(), goog.events.EventType.RESIZE, this.resizeBackground_);
    this.showPopupElement_(!0);
    this.focus();
    this.visible_ = !0;
    if (this.popupShowTransition_ && this.bgShowTransition_) {
      goog.events.listenOnce(this.popupShowTransition_, goog.fx.Transition.EventType.END, this.onShow, !1, this), this.bgShowTransition_.play(), this.popupShowTransition_.play();
    } else {
      this.onShow();
    }
  }
};
goog.ui.ModalPopup.prototype.hide_ = function() {
  if (this.dispatchEvent(goog.ui.PopupBase.EventType.BEFORE_HIDE)) {
    this.getHandler().unlisten(this.getDomHelper().getWindow(), goog.events.EventType.RESIZE, this.resizeBackground_);
    this.visible_ = !1;
    if (this.popupHideTransition_ && this.bgHideTransition_) {
      goog.events.listenOnce(this.popupHideTransition_, goog.fx.Transition.EventType.END, this.onHide, !1, this), this.bgHideTransition_.play(), this.popupHideTransition_.play();
    } else {
      this.onHide();
    }
    this.returnFocus_();
  }
};
goog.ui.ModalPopup.prototype.returnFocus_ = function() {
  try {
    var dom = this.getDomHelper(), body = dom.getDocument().body, active = dom.getDocument().activeElement || body;
    if (!this.lastFocus_ || this.lastFocus_ == body) {
      this.lastFocus_ = null;
      return;
    }
    (active == body || dom.contains(this.getElement(), active)) && this.lastFocus_.focus();
  } catch (e) {
  }
  this.lastFocus_ = null;
};
goog.ui.ModalPopup.prototype.showPopupElement_ = function(visible) {
  this.bgIframeEl_ && goog.style.setElementShown(this.bgIframeEl_, visible);
  this.bgEl_ && goog.style.setElementShown(this.bgEl_, visible);
  goog.style.setElementShown(this.getElement(), visible);
  goog.style.setElementShown(this.tabCatcherElement_, visible);
};
goog.ui.ModalPopup.prototype.onShow = function() {
  this.dispatchEvent(goog.ui.PopupBase.EventType.SHOW);
};
goog.ui.ModalPopup.prototype.onHide = function() {
  this.showPopupElement_(!1);
  this.dispatchEvent(goog.ui.PopupBase.EventType.HIDE);
};
goog.ui.ModalPopup.prototype.isVisible = function() {
  return this.visible_;
};
goog.ui.ModalPopup.prototype.focus = function() {
  this.focusElement_();
};
goog.ui.ModalPopup.prototype.resizeBackground_ = function() {
  this.bgIframeEl_ && goog.style.setElementShown(this.bgIframeEl_, !1);
  this.bgEl_ && goog.style.setElementShown(this.bgEl_, !1);
  var doc = this.getDomHelper().getDocument(), win = goog.dom.getWindow(doc) || window, viewSize = goog.dom.getViewportSize(win), w = Math.max(viewSize.width, Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth)), h = Math.max(viewSize.height, Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight));
  this.bgIframeEl_ && (goog.style.setElementShown(this.bgIframeEl_, !0), goog.style.setSize(this.bgIframeEl_, w, h));
  this.bgEl_ && (goog.style.setElementShown(this.bgEl_, !0), goog.style.setSize(this.bgEl_, w, h));
};
goog.ui.ModalPopup.prototype.reposition = function() {
  var doc = this.getDomHelper().getDocument(), win = goog.dom.getWindow(doc) || window;
  if ("fixed" == goog.style.getComputedPosition(this.getElement())) {
    var x = 0, y = 0
  } else {
    var scroll = this.getDomHelper().getDocumentScroll(), x = scroll.x, y = scroll.y
  }
  var popupSize = goog.style.getSize(this.getElement()), viewSize = goog.dom.getViewportSize(win), left = Math.max(x + viewSize.width / 2 - popupSize.width / 2, 0), top = Math.max(y + viewSize.height / 2 - popupSize.height / 2, 0);
  goog.style.setPosition(this.getElement(), left, top);
  goog.style.setPosition(this.tabCatcherElement_, left, top);
};
goog.ui.ModalPopup.prototype.onFocus = function(e) {
  this.backwardTabWrapInProgress_ ? this.resetBackwardTabWrap_() : e.target == this.tabCatcherElement_ && goog.Timer.callOnce(this.focusElement_, 0, this);
};
goog.ui.ModalPopup.prototype.focusElement_ = function() {
  try {
    goog.userAgent.IE && this.getDomHelper().getDocument().body.focus(), this.getElement().focus();
  } catch (e) {
  }
};
goog.ui.ModalPopup.prototype.disposeInternal = function() {
  goog.dispose(this.popupShowTransition_);
  this.popupShowTransition_ = null;
  goog.dispose(this.popupHideTransition_);
  this.popupHideTransition_ = null;
  goog.dispose(this.bgShowTransition_);
  this.bgShowTransition_ = null;
  goog.dispose(this.bgHideTransition_);
  this.bgHideTransition_ = null;
  goog.ui.ModalPopup.superClass_.disposeInternal.call(this);
};
// INPUT (javascript/closure/ui/dialog.js)
goog.ui.Dialog = function(opt_class, opt_useIframeMask, opt_domHelper) {
  goog.ui.ModalPopup.call(this, opt_useIframeMask, opt_domHelper);
  this.class_ = opt_class || "modal-dialog";
  this.buttons_ = goog.ui.Dialog.ButtonSet.createOkCancel();
};
goog.inherits(goog.ui.Dialog, goog.ui.ModalPopup);
goog.tagUnsealableClass(goog.ui.Dialog);
goog.ui.Dialog.prototype.escapeToCancel_ = !0;
goog.ui.Dialog.prototype.hasTitleCloseButton_ = !0;
goog.ui.Dialog.prototype.modal_ = !0;
goog.ui.Dialog.prototype.draggable_ = !0;
goog.ui.Dialog.prototype.backgroundElementOpacity_ = .5;
goog.ui.Dialog.prototype.title_ = "";
goog.ui.Dialog.prototype.content_ = null;
goog.ui.Dialog.prototype.dragger_ = null;
goog.ui.Dialog.prototype.disposeOnHide_ = !1;
goog.ui.Dialog.prototype.titleEl_ = null;
goog.ui.Dialog.prototype.titleTextEl_ = null;
goog.ui.Dialog.prototype.titleTextId_ = null;
goog.ui.Dialog.prototype.titleCloseEl_ = null;
goog.ui.Dialog.prototype.contentEl_ = null;
goog.ui.Dialog.prototype.buttonEl_ = null;
goog.ui.Dialog.prototype.preferredAriaRole_ = goog.a11y.aria.Role.DIALOG;
goog.ui.Dialog.prototype.getCssClass = function() {
  return this.class_;
};
goog.ui.Dialog.prototype.setTitle = function(title) {
  this.title_ = title;
  this.titleTextEl_ && goog.dom.setTextContent(this.titleTextEl_, title);
};
goog.ui.Dialog.prototype.getTitle = function() {
  return this.title_;
};
goog.ui.Dialog.prototype.setContent = function(html) {
  this.setSafeHtmlContent(goog.html.legacyconversions.safeHtmlFromString(html));
};
goog.ui.Dialog.prototype.setSafeHtmlContent = function(html) {
  this.content_ = html;
  this.contentEl_ && goog.dom.safe.setInnerHtml(this.contentEl_, html);
};
goog.ui.Dialog.prototype.getContent = function() {
  return null != this.content_ ? goog.html.SafeHtml.unwrap(this.content_) : "";
};
goog.ui.Dialog.prototype.getPreferredAriaRole = function() {
  return this.preferredAriaRole_;
};
goog.ui.Dialog.prototype.setPreferredAriaRole = function(role) {
  this.preferredAriaRole_ = role;
};
goog.ui.Dialog.prototype.renderIfNoDom_ = function() {
  this.getElement() || this.render();
};
goog.ui.Dialog.prototype.getContentElement = function() {
  this.renderIfNoDom_();
  return this.contentEl_;
};
goog.ui.Dialog.prototype.getTitleTextElement = function() {
  this.renderIfNoDom_();
  return this.titleTextEl_;
};
goog.ui.Dialog.prototype.getButtonElement = function() {
  this.renderIfNoDom_();
  return this.buttonEl_;
};
goog.ui.Dialog.prototype.getDialogElement = function() {
  this.renderIfNoDom_();
  return this.getElement();
};
goog.ui.Dialog.prototype.getBackgroundElement = function() {
  this.renderIfNoDom_();
  return goog.ui.Dialog.superClass_.getBackgroundElement.call(this);
};
goog.ui.Dialog.prototype.setBackgroundElementOpacity = function(opacity) {
  this.backgroundElementOpacity_ = opacity;
  if (this.getElement()) {
    var bgEl = this.getBackgroundElement();
    bgEl && goog.style.setOpacity(bgEl, this.backgroundElementOpacity_);
  }
};
goog.ui.Dialog.prototype.setModal = function(modal) {
  modal != this.modal_ && this.setModalInternal_(modal);
};
goog.ui.Dialog.prototype.setModalInternal_ = function(modal) {
  this.modal_ = modal;
  if (this.isInDocument()) {
    var dom = this.getDomHelper(), bg = this.getBackgroundElement(), bgIframe = this.getBackgroundIframe();
    modal ? (bgIframe && dom.insertSiblingBefore(bgIframe, this.getElement()), dom.insertSiblingBefore(bg, this.getElement())) : (dom.removeNode(bgIframe), dom.removeNode(bg));
  }
  this.isVisible() && this.setA11YDetectBackground(modal);
};
goog.ui.Dialog.prototype.getClass = function() {
  return this.getCssClass();
};
goog.ui.Dialog.prototype.setDraggable = function(draggable) {
  this.draggable_ = draggable;
  this.setDraggingEnabled_(draggable && this.isInDocument());
};
goog.ui.Dialog.prototype.createDragger = function() {
  return new goog.fx.Dragger(this.getElement(), this.titleEl_);
};
goog.ui.Dialog.prototype.getDraggable = function() {
  return this.draggable_;
};
goog.ui.Dialog.prototype.setDraggingEnabled_ = function(enabled) {
  var classNames = goog.string.trim(this.class_ + "-title-draggable").split(" ");
  this.getElement() && (enabled ? goog.dom.classlist.addAll(goog.asserts.assert(this.titleEl_), classNames) : goog.dom.classlist.removeAll(goog.asserts.assert(this.titleEl_), classNames));
  enabled && !this.dragger_ ? (this.dragger_ = this.createDragger(), goog.dom.classlist.addAll(goog.asserts.assert(this.titleEl_), classNames), goog.events.listen(this.dragger_, goog.fx.Dragger.EventType.START, this.setDraggerLimits_, !1, this)) : !enabled && this.dragger_ && (this.dragger_.dispose(), this.dragger_ = null);
};
goog.ui.Dialog.prototype.createDom = function() {
  goog.ui.Dialog.superClass_.createDom.call(this);
  var element = this.getElement();
  goog.asserts.assert(element, "getElement() returns null");
  var dom = this.getDomHelper();
  this.titleEl_ = dom.createDom("div", this.class_ + "-title", this.titleTextEl_ = dom.createDom("span", {className:this.class_ + "-title-text", id:this.getId()}, this.title_), this.titleCloseEl_ = dom.createDom("span", this.class_ + "-title-close"));
  goog.dom.append(element, this.titleEl_, this.contentEl_ = dom.createDom("div", this.class_ + "-content"), this.buttonEl_ = dom.createDom("div", this.class_ + "-buttons"));
  goog.a11y.aria.setRole(this.titleTextEl_, goog.a11y.aria.Role.HEADING);
  goog.a11y.aria.setRole(this.titleCloseEl_, goog.a11y.aria.Role.BUTTON);
  goog.dom.setFocusableTabIndex(this.titleCloseEl_, !0);
  goog.a11y.aria.setLabel(this.titleCloseEl_, goog.ui.Dialog.MSG_GOOG_UI_DIALOG_CLOSE_);
  this.titleTextId_ = this.titleTextEl_.id;
  goog.a11y.aria.setRole(element, this.getPreferredAriaRole());
  goog.a11y.aria.setState(element, goog.a11y.aria.State.LABELLEDBY, this.titleTextId_ || "");
  this.content_ && goog.dom.safe.setInnerHtml(this.contentEl_, this.content_);
  goog.style.setElementShown(this.titleCloseEl_, this.hasTitleCloseButton_);
  this.buttons_ && this.buttons_.attachToElement(this.buttonEl_);
  goog.style.setElementShown(this.buttonEl_, !!this.buttons_);
  this.setBackgroundElementOpacity(this.backgroundElementOpacity_);
};
goog.ui.Dialog.prototype.decorateInternal = function(element) {
  goog.ui.Dialog.superClass_.decorateInternal.call(this, element);
  var dialogElement = this.getElement();
  goog.asserts.assert(dialogElement, "The DOM element for dialog cannot be null.");
  var contentClass = this.class_ + "-content";
  this.contentEl_ = goog.dom.getElementsByTagNameAndClass(null, contentClass, dialogElement)[0];
  this.contentEl_ || (this.contentEl_ = this.getDomHelper().createDom("div", contentClass), this.content_ && goog.dom.safe.setInnerHtml(this.contentEl_, this.content_), dialogElement.appendChild(this.contentEl_));
  var titleClass = this.class_ + "-title", titleTextClass = this.class_ + "-title-text", titleCloseClass = this.class_ + "-title-close";
  (this.titleEl_ = goog.dom.getElementsByTagNameAndClass(null, titleClass, dialogElement)[0]) ? (this.titleTextEl_ = goog.dom.getElementsByTagNameAndClass(null, titleTextClass, this.titleEl_)[0], this.titleCloseEl_ = goog.dom.getElementsByTagNameAndClass(null, titleCloseClass, this.titleEl_)[0]) : (this.titleEl_ = this.getDomHelper().createDom("div", titleClass), dialogElement.insertBefore(this.titleEl_, this.contentEl_));
  this.titleTextEl_ ? (this.title_ = goog.dom.getTextContent(this.titleTextEl_), this.titleTextEl_.id || (this.titleTextEl_.id = this.getId())) : (this.titleTextEl_ = goog.dom.createDom("span", {className:titleTextClass, id:this.getId()}), this.titleEl_.appendChild(this.titleTextEl_));
  this.titleTextId_ = this.titleTextEl_.id;
  goog.a11y.aria.setState(dialogElement, goog.a11y.aria.State.LABELLEDBY, this.titleTextId_ || "");
  this.titleCloseEl_ || (this.titleCloseEl_ = this.getDomHelper().createDom("span", titleCloseClass), this.titleEl_.appendChild(this.titleCloseEl_));
  goog.style.setElementShown(this.titleCloseEl_, this.hasTitleCloseButton_);
  var buttonsClass = this.class_ + "-buttons";
  (this.buttonEl_ = goog.dom.getElementsByTagNameAndClass(null, buttonsClass, dialogElement)[0]) ? (this.buttons_ = new goog.ui.Dialog.ButtonSet(this.getDomHelper()), this.buttons_.decorate(this.buttonEl_)) : (this.buttonEl_ = this.getDomHelper().createDom("div", buttonsClass), dialogElement.appendChild(this.buttonEl_), this.buttons_ && this.buttons_.attachToElement(this.buttonEl_), goog.style.setElementShown(this.buttonEl_, !!this.buttons_));
  this.setBackgroundElementOpacity(this.backgroundElementOpacity_);
};
goog.ui.Dialog.prototype.enterDocument = function() {
  goog.ui.Dialog.superClass_.enterDocument.call(this);
  this.getHandler().listen(this.getElement(), goog.events.EventType.KEYDOWN, this.onKey_).listen(this.getElement(), goog.events.EventType.KEYPRESS, this.onKey_);
  this.getHandler().listen(this.buttonEl_, goog.events.EventType.CLICK, this.onButtonClick_);
  this.setDraggingEnabled_(this.draggable_);
  this.getHandler().listen(this.titleCloseEl_, goog.events.EventType.CLICK, this.onTitleCloseClick_);
  var element = this.getElement();
  goog.asserts.assert(element, "The DOM element for dialog cannot be null");
  goog.a11y.aria.setRole(element, this.getPreferredAriaRole());
  "" !== this.titleTextEl_.id && goog.a11y.aria.setState(element, goog.a11y.aria.State.LABELLEDBY, this.titleTextEl_.id);
  this.modal_ || this.setModalInternal_(!1);
};
goog.ui.Dialog.prototype.exitDocument = function() {
  this.isVisible() && this.setVisible(!1);
  this.setDraggingEnabled_(!1);
  goog.ui.Dialog.superClass_.exitDocument.call(this);
};
goog.ui.Dialog.prototype.setVisible = function(visible) {
  visible != this.isVisible() && (this.isInDocument() || this.render(), goog.ui.Dialog.superClass_.setVisible.call(this, visible));
};
goog.ui.Dialog.prototype.onShow = function() {
  goog.ui.Dialog.superClass_.onShow.call(this);
  this.dispatchEvent(goog.ui.Dialog.EventType.AFTER_SHOW);
};
goog.ui.Dialog.prototype.onHide = function() {
  goog.ui.Dialog.superClass_.onHide.call(this);
  this.dispatchEvent(goog.ui.Dialog.EventType.AFTER_HIDE);
  this.disposeOnHide_ && this.dispose();
};
goog.ui.Dialog.prototype.setDraggerLimits_ = function() {
  var doc = this.getDomHelper().getDocument(), win = goog.dom.getWindow(doc) || window, viewSize = goog.dom.getViewportSize(win), w = Math.max(doc.body.scrollWidth, viewSize.width), h = Math.max(doc.body.scrollHeight, viewSize.height), dialogSize = goog.style.getSize(this.getElement());
  "fixed" == goog.style.getComputedPosition(this.getElement()) ? this.dragger_.setLimits(new goog.math.Rect(0, 0, Math.max(0, viewSize.width - dialogSize.width), Math.max(0, viewSize.height - dialogSize.height))) : this.dragger_.setLimits(new goog.math.Rect(0, 0, w - dialogSize.width, h - dialogSize.height));
};
goog.ui.Dialog.prototype.onTitleCloseClick_ = function() {
  this.handleTitleClose_();
};
goog.ui.Dialog.prototype.handleTitleClose_ = function() {
  if (this.hasTitleCloseButton_) {
    var bs = this.getButtonSet(), key = bs && bs.getCancel();
    if (key) {
      var caption = bs.get(key);
      this.dispatchEvent(new goog.ui.Dialog.Event(key, caption)) && this.setVisible(!1);
    } else {
      this.setVisible(!1);
    }
  }
};
goog.ui.Dialog.prototype.setHasTitleCloseButton = function(b) {
  this.hasTitleCloseButton_ = b;
  this.titleCloseEl_ && goog.style.setElementShown(this.titleCloseEl_, this.hasTitleCloseButton_);
};
goog.ui.Dialog.prototype.setDisposeOnHide = function(b) {
  this.disposeOnHide_ = b;
};
goog.ui.Dialog.prototype.disposeInternal = function() {
  this.buttonEl_ = this.titleCloseEl_ = null;
  goog.ui.Dialog.superClass_.disposeInternal.call(this);
};
goog.ui.Dialog.prototype.setButtonSet = function(buttons) {
  this.buttons_ = buttons;
  this.buttonEl_ && (this.buttons_ ? this.buttons_.attachToElement(this.buttonEl_) : goog.dom.safe.setInnerHtml(this.buttonEl_, goog.html.SafeHtml.EMPTY), goog.style.setElementShown(this.buttonEl_, !!this.buttons_));
};
goog.ui.Dialog.prototype.getButtonSet = function() {
  return this.buttons_;
};
goog.ui.Dialog.prototype.onButtonClick_ = function(e) {
  var button = this.findParentButton_(e.target);
  if (button && !button.disabled) {
    var key = button.name, caption = this.getButtonSet().get(key);
    this.dispatchEvent(new goog.ui.Dialog.Event(key, caption)) && this.setVisible(!1);
  }
};
goog.ui.Dialog.prototype.findParentButton_ = function(element) {
  for (var el = element;null != el && el != this.buttonEl_;) {
    if ("BUTTON" == el.tagName) {
      return el;
    }
    el = el.parentNode;
  }
  return null;
};
goog.ui.Dialog.prototype.onKey_ = function(e) {
  var close = !1, hasHandler = !1, buttonSet = this.getButtonSet(), target = e.target;
  if (e.type == goog.events.EventType.KEYDOWN) {
    if (this.escapeToCancel_ && e.keyCode == goog.events.KeyCodes.ESC) {
      var cancel = buttonSet && buttonSet.getCancel(), isSpecialFormElement = "SELECT" == target.tagName && !target.disabled;
      if (cancel && !isSpecialFormElement) {
        var hasHandler = !0, caption = buttonSet.get(cancel), close = this.dispatchEvent(new goog.ui.Dialog.Event(cancel, caption))
      } else {
        isSpecialFormElement || (close = !0);
      }
    } else {
      e.keyCode == goog.events.KeyCodes.TAB && e.shiftKey && target == this.getElement() && this.setupBackwardTabWrap();
    }
  } else {
    if (e.keyCode == goog.events.KeyCodes.ENTER) {
      var key;
      if ("BUTTON" == target.tagName && !target.disabled) {
        key = target.name;
      } else {
        if (target == this.titleCloseEl_) {
          this.handleTitleClose_();
        } else {
          if (buttonSet) {
            var defaultKey = buttonSet.getDefault(), defaultButton = defaultKey && buttonSet.getButton(defaultKey), isSpecialFormElement = ("TEXTAREA" == target.tagName || "SELECT" == target.tagName || "A" == target.tagName) && !target.disabled;
            !defaultButton || defaultButton.disabled || isSpecialFormElement || (key = defaultKey);
          }
        }
      }
      key && buttonSet && (hasHandler = !0, close = this.dispatchEvent(new goog.ui.Dialog.Event(key, String(buttonSet.get(key)))));
    } else {
      target == this.titleCloseEl_ && e.keyCode == goog.events.KeyCodes.SPACE && this.handleTitleClose_();
    }
  }
  if (close || hasHandler) {
    e.stopPropagation(), e.preventDefault();
  }
  close && this.setVisible(!1);
};
goog.ui.Dialog.Event = function(key, caption) {
  this.type = goog.ui.Dialog.EventType.SELECT;
  this.key = key;
  this.caption = caption;
};
goog.inherits(goog.ui.Dialog.Event, goog.events.Event);
goog.ui.Dialog.SELECT_EVENT = "dialogselect";
goog.ui.Dialog.EventType = {SELECT:"dialogselect", AFTER_HIDE:"afterhide", AFTER_SHOW:"aftershow"};
goog.ui.Dialog.ButtonSet = function(opt_domHelper) {
  this.dom_ = opt_domHelper || goog.dom.getDomHelper();
  goog.structs.Map.call(this);
};
goog.inherits(goog.ui.Dialog.ButtonSet, goog.structs.Map);
goog.tagUnsealableClass(goog.ui.Dialog.ButtonSet);
goog.ui.Dialog.ButtonSet.prototype.class_ = "aAAaGVIZSENTINELaAAa-buttonset";
goog.ui.Dialog.ButtonSet.prototype.defaultButton_ = null;
goog.ui.Dialog.ButtonSet.prototype.element_ = null;
goog.ui.Dialog.ButtonSet.prototype.cancelButton_ = null;
goog.ui.Dialog.ButtonSet.prototype.set = function(key, caption, opt_isDefault, opt_isCancel) {
  goog.structs.Map.prototype.set.call(this, key, caption);
  opt_isDefault && (this.defaultButton_ = key);
  opt_isCancel && (this.cancelButton_ = key);
  return this;
};
goog.ui.Dialog.ButtonSet.prototype.addButton = function(button, opt_isDefault, opt_isCancel) {
  return this.set(button.key, button.caption, opt_isDefault, opt_isCancel);
};
goog.ui.Dialog.ButtonSet.prototype.attachToElement = function(el) {
  this.element_ = el;
  this.render();
};
goog.ui.Dialog.ButtonSet.prototype.render = function() {
  if (this.element_) {
    goog.dom.safe.setInnerHtml(this.element_, goog.html.SafeHtml.EMPTY);
    var domHelper = goog.dom.getDomHelper(this.element_);
    this.forEach(function(caption, key) {
      var button = domHelper.createDom("button", {name:key}, caption);
      key == this.defaultButton_ && (button.className = this.class_ + "-default");
      this.element_.appendChild(button);
    }, this);
  }
};
goog.ui.Dialog.ButtonSet.prototype.decorate = function(element) {
  if (element && element.nodeType == goog.dom.NodeType.ELEMENT) {
    this.element_ = element;
    for (var buttons = this.element_.getElementsByTagName("button"), i = 0, button, key, caption;button = buttons[i];i++) {
      if (key = button.name || button.id, caption = goog.dom.getTextContent(button) || button.value, key) {
        var isDefault = 0 == i, isCancel = button.name == goog.ui.Dialog.DefaultButtonKeys.CANCEL;
        this.set(key, caption, isDefault, isCancel);
        isDefault && goog.dom.classlist.add(button, this.class_ + "-default");
      }
    }
  }
};
goog.ui.Dialog.ButtonSet.prototype.getElement = function() {
  return this.element_;
};
goog.ui.Dialog.ButtonSet.prototype.getDomHelper = function() {
  return this.dom_;
};
goog.ui.Dialog.ButtonSet.prototype.getDefault = function() {
  return this.defaultButton_;
};
goog.ui.Dialog.ButtonSet.prototype.getCancel = function() {
  return this.cancelButton_;
};
goog.ui.Dialog.ButtonSet.prototype.getButton = function(key) {
  for (var buttons = this.getAllButtons(), i = 0, nextButton;nextButton = buttons[i];i++) {
    if (nextButton.name == key || nextButton.id == key) {
      return nextButton;
    }
  }
  return null;
};
goog.ui.Dialog.ButtonSet.prototype.getAllButtons = function() {
  return this.element_.getElementsByTagName(goog.dom.TagName.BUTTON);
};
goog.ui.Dialog.ButtonSet.prototype.setButtonEnabled = function(key, enabled) {
  var button = this.getButton(key);
  button && (button.disabled = !enabled);
};
goog.ui.Dialog.DefaultButtonKeys = {OK:"ok", CANCEL:"cancel", YES:"yes", NO:"no", SAVE:"save", CONTINUE:"continue"};
goog.ui.Dialog.MSG_DIALOG_OK_ = "OK";
goog.ui.Dialog.MSG_DIALOG_CANCEL_ = "Cancel";
goog.ui.Dialog.MSG_DIALOG_YES_ = "Yes";
goog.ui.Dialog.MSG_DIALOG_NO_ = "No";
goog.ui.Dialog.MSG_DIALOG_SAVE_ = "Save";
goog.ui.Dialog.MSG_DIALOG_CONTINUE_ = "Continue";
goog.ui.Dialog.MSG_GOOG_UI_DIALOG_CLOSE_ = "Close";
goog.ui.Dialog.DefaultButtonCaptions = {OK:goog.ui.Dialog.MSG_DIALOG_OK_, CANCEL:goog.ui.Dialog.MSG_DIALOG_CANCEL_, YES:goog.ui.Dialog.MSG_DIALOG_YES_, NO:goog.ui.Dialog.MSG_DIALOG_NO_, SAVE:goog.ui.Dialog.MSG_DIALOG_SAVE_, CONTINUE:goog.ui.Dialog.MSG_DIALOG_CONTINUE_};
goog.ui.Dialog.ButtonSet.DefaultButtons = {OK:{key:goog.ui.Dialog.DefaultButtonKeys.OK, caption:goog.ui.Dialog.DefaultButtonCaptions.OK}, CANCEL:{key:goog.ui.Dialog.DefaultButtonKeys.CANCEL, caption:goog.ui.Dialog.DefaultButtonCaptions.CANCEL}, YES:{key:goog.ui.Dialog.DefaultButtonKeys.YES, caption:goog.ui.Dialog.DefaultButtonCaptions.YES}, NO:{key:goog.ui.Dialog.DefaultButtonKeys.NO, caption:goog.ui.Dialog.DefaultButtonCaptions.NO}, SAVE:{key:goog.ui.Dialog.DefaultButtonKeys.SAVE, caption:goog.ui.Dialog.DefaultButtonCaptions.SAVE}, 
CONTINUE:{key:goog.ui.Dialog.DefaultButtonKeys.CONTINUE, caption:goog.ui.Dialog.DefaultButtonCaptions.CONTINUE}};
goog.ui.Dialog.ButtonSet.createOk = function() {
  return(new goog.ui.Dialog.ButtonSet).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.OK, !0, !0);
};
goog.ui.Dialog.ButtonSet.createOkCancel = function() {
  return(new goog.ui.Dialog.ButtonSet).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.OK, !0).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.CANCEL, !1, !0);
};
goog.ui.Dialog.ButtonSet.createYesNo = function() {
  return(new goog.ui.Dialog.ButtonSet).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.YES, !0).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.NO, !1, !0);
};
goog.ui.Dialog.ButtonSet.createYesNoCancel = function() {
  return(new goog.ui.Dialog.ButtonSet).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.YES).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.NO, !0).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.CANCEL, !1, !0);
};
goog.ui.Dialog.ButtonSet.createContinueSaveCancel = function() {
  return(new goog.ui.Dialog.ButtonSet).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.CONTINUE).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.SAVE).addButton(goog.ui.Dialog.ButtonSet.DefaultButtons.CANCEL, !0, !0);
};
(function() {
  "undefined" != typeof document && (goog.ui.Dialog.ButtonSet.OK = goog.ui.Dialog.ButtonSet.createOk(), goog.ui.Dialog.ButtonSet.OK_CANCEL = goog.ui.Dialog.ButtonSet.createOkCancel(), goog.ui.Dialog.ButtonSet.YES_NO = goog.ui.Dialog.ButtonSet.createYesNo(), goog.ui.Dialog.ButtonSet.YES_NO_CANCEL = goog.ui.Dialog.ButtonSet.createYesNoCancel(), goog.ui.Dialog.ButtonSet.CONTINUE_SAVE_CANCEL = goog.ui.Dialog.ButtonSet.createContinueSaveCancel());
})();
// INPUT (javascript/closure/events/keyhandler.js)
goog.events.KeyHandler = function(opt_element, opt_capture) {
  goog.events.EventTarget.call(this);
  opt_element && this.attach(opt_element, opt_capture);
};
goog.inherits(goog.events.KeyHandler, goog.events.EventTarget);
goog.events.KeyHandler.prototype.element_ = null;
goog.events.KeyHandler.prototype.keyPressKey_ = null;
goog.events.KeyHandler.prototype.keyDownKey_ = null;
goog.events.KeyHandler.prototype.keyUpKey_ = null;
goog.events.KeyHandler.prototype.lastKey_ = -1;
goog.events.KeyHandler.prototype.keyCode_ = -1;
goog.events.KeyHandler.prototype.altKey_ = !1;
goog.events.KeyHandler.EventType = {KEY:"key"};
goog.events.KeyHandler.safariKey_ = {3:goog.events.KeyCodes.ENTER, 12:goog.events.KeyCodes.NUMLOCK, 63232:goog.events.KeyCodes.UP, 63233:goog.events.KeyCodes.DOWN, 63234:goog.events.KeyCodes.LEFT, 63235:goog.events.KeyCodes.RIGHT, 63236:goog.events.KeyCodes.F1, 63237:goog.events.KeyCodes.F2, 63238:goog.events.KeyCodes.F3, 63239:goog.events.KeyCodes.F4, 63240:goog.events.KeyCodes.F5, 63241:goog.events.KeyCodes.F6, 63242:goog.events.KeyCodes.F7, 63243:goog.events.KeyCodes.F8, 63244:goog.events.KeyCodes.F9, 
63245:goog.events.KeyCodes.F10, 63246:goog.events.KeyCodes.F11, 63247:goog.events.KeyCodes.F12, 63248:goog.events.KeyCodes.PRINT_SCREEN, 63272:goog.events.KeyCodes.DELETE, 63273:goog.events.KeyCodes.HOME, 63275:goog.events.KeyCodes.END, 63276:goog.events.KeyCodes.PAGE_UP, 63277:goog.events.KeyCodes.PAGE_DOWN, 63289:goog.events.KeyCodes.NUMLOCK, 63302:goog.events.KeyCodes.INSERT};
goog.events.KeyHandler.keyIdentifier_ = {Up:goog.events.KeyCodes.UP, Down:goog.events.KeyCodes.DOWN, Left:goog.events.KeyCodes.LEFT, Right:goog.events.KeyCodes.RIGHT, Enter:goog.events.KeyCodes.ENTER, F1:goog.events.KeyCodes.F1, F2:goog.events.KeyCodes.F2, F3:goog.events.KeyCodes.F3, F4:goog.events.KeyCodes.F4, F5:goog.events.KeyCodes.F5, F6:goog.events.KeyCodes.F6, F7:goog.events.KeyCodes.F7, F8:goog.events.KeyCodes.F8, F9:goog.events.KeyCodes.F9, F10:goog.events.KeyCodes.F10, F11:goog.events.KeyCodes.F11, 
F12:goog.events.KeyCodes.F12, "U+007F":goog.events.KeyCodes.DELETE, Home:goog.events.KeyCodes.HOME, End:goog.events.KeyCodes.END, PageUp:goog.events.KeyCodes.PAGE_UP, PageDown:goog.events.KeyCodes.PAGE_DOWN, Insert:goog.events.KeyCodes.INSERT};
goog.events.KeyHandler.USES_KEYDOWN_ = goog.userAgent.IE || goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher("525");
goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_ = goog.userAgent.MAC && goog.userAgent.GECKO;
goog.events.KeyHandler.prototype.handleKeyDown_ = function(e) {
  goog.userAgent.WEBKIT && (this.lastKey_ == goog.events.KeyCodes.CTRL && !e.ctrlKey || this.lastKey_ == goog.events.KeyCodes.ALT && !e.altKey || goog.userAgent.MAC && this.lastKey_ == goog.events.KeyCodes.META && !e.metaKey) && (this.keyCode_ = this.lastKey_ = -1);
  -1 == this.lastKey_ && (e.ctrlKey && e.keyCode != goog.events.KeyCodes.CTRL ? this.lastKey_ = goog.events.KeyCodes.CTRL : e.altKey && e.keyCode != goog.events.KeyCodes.ALT ? this.lastKey_ = goog.events.KeyCodes.ALT : e.metaKey && e.keyCode != goog.events.KeyCodes.META && (this.lastKey_ = goog.events.KeyCodes.META));
  goog.events.KeyHandler.USES_KEYDOWN_ && !goog.events.KeyCodes.firesKeyPressEvent(e.keyCode, this.lastKey_, e.shiftKey, e.ctrlKey, e.altKey) ? this.handleEvent(e) : (this.keyCode_ = goog.events.KeyCodes.normalizeKeyCode(e.keyCode), goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_ && (this.altKey_ = e.altKey));
};
goog.events.KeyHandler.prototype.resetState = function() {
  this.keyCode_ = this.lastKey_ = -1;
};
goog.events.KeyHandler.prototype.handleKeyup_ = function(e) {
  this.resetState();
  this.altKey_ = e.altKey;
};
goog.events.KeyHandler.prototype.handleEvent = function(e) {
  var be = e.getBrowserEvent(), keyCode, charCode, altKey = be.altKey;
  goog.userAgent.IE && e.type == goog.events.EventType.KEYPRESS ? (keyCode = this.keyCode_, charCode = keyCode != goog.events.KeyCodes.ENTER && keyCode != goog.events.KeyCodes.ESC ? be.keyCode : 0) : goog.userAgent.WEBKIT && e.type == goog.events.EventType.KEYPRESS ? (keyCode = this.keyCode_, charCode = 0 <= be.charCode && 63232 > be.charCode && goog.events.KeyCodes.isCharacterKey(keyCode) ? be.charCode : 0) : goog.userAgent.OPERA ? (keyCode = this.keyCode_, charCode = goog.events.KeyCodes.isCharacterKey(keyCode) ? 
  be.keyCode : 0) : (keyCode = be.keyCode || this.keyCode_, charCode = be.charCode || 0, goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_ && (altKey = this.altKey_), goog.userAgent.MAC && charCode == goog.events.KeyCodes.QUESTION_MARK && keyCode == goog.events.KeyCodes.WIN_KEY && (keyCode = goog.events.KeyCodes.SLASH));
  var key = keyCode = goog.events.KeyCodes.normalizeKeyCode(keyCode), keyIdentifier = be.keyIdentifier;
  keyCode ? 63232 <= keyCode && keyCode in goog.events.KeyHandler.safariKey_ ? key = goog.events.KeyHandler.safariKey_[keyCode] : 25 == keyCode && e.shiftKey && (key = 9) : keyIdentifier && keyIdentifier in goog.events.KeyHandler.keyIdentifier_ && (key = goog.events.KeyHandler.keyIdentifier_[keyIdentifier]);
  var repeat = key == this.lastKey_;
  this.lastKey_ = key;
  var event = new goog.events.KeyEvent(key, charCode, repeat, be);
  event.altKey = altKey;
  this.dispatchEvent(event);
};
goog.events.KeyHandler.prototype.getElement = function() {
  return this.element_;
};
goog.events.KeyHandler.prototype.attach = function(element, opt_capture) {
  this.keyUpKey_ && this.detach();
  this.element_ = element;
  this.keyPressKey_ = goog.events.listen(this.element_, goog.events.EventType.KEYPRESS, this, opt_capture);
  this.keyDownKey_ = goog.events.listen(this.element_, goog.events.EventType.KEYDOWN, this.handleKeyDown_, opt_capture, this);
  this.keyUpKey_ = goog.events.listen(this.element_, goog.events.EventType.KEYUP, this.handleKeyup_, opt_capture, this);
};
goog.events.KeyHandler.prototype.detach = function() {
  this.keyPressKey_ && (goog.events.unlistenByKey(this.keyPressKey_), goog.events.unlistenByKey(this.keyDownKey_), goog.events.unlistenByKey(this.keyUpKey_), this.keyUpKey_ = this.keyDownKey_ = this.keyPressKey_ = null);
  this.element_ = null;
  this.keyCode_ = this.lastKey_ = -1;
};
goog.events.KeyHandler.prototype.disposeInternal = function() {
  goog.events.KeyHandler.superClass_.disposeInternal.call(this);
  this.detach();
};
goog.events.KeyEvent = function(keyCode, charCode, repeat, browserEvent) {
  goog.events.BrowserEvent.call(this, browserEvent);
  this.type = goog.events.KeyHandler.EventType.KEY;
  this.keyCode = keyCode;
  this.charCode = charCode;
  this.repeat = repeat;
};
goog.inherits(goog.events.KeyEvent, goog.events.BrowserEvent);
// INPUT (javascript/closure/ui/controlcontent.js)
// INPUT (javascript/closure/ui/controlrenderer.js)
goog.ui.ControlRenderer = function() {
};
goog.addSingletonGetter(goog.ui.ControlRenderer);
goog.tagUnsealableClass(goog.ui.ControlRenderer);
goog.ui.ControlRenderer.getCustomRenderer = function(ctor, cssClassName) {
  var renderer = new ctor;
  renderer.getCssClass = function() {
    return cssClassName;
  };
  return renderer;
};
goog.ui.ControlRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-control";
goog.ui.ControlRenderer.IE6_CLASS_COMBINATIONS = [];
goog.ui.ControlRenderer.TOGGLE_ARIA_STATE_MAP_ = goog.object.create(goog.a11y.aria.Role.BUTTON, goog.a11y.aria.State.PRESSED, goog.a11y.aria.Role.CHECKBOX, goog.a11y.aria.State.CHECKED, goog.a11y.aria.Role.MENU_ITEM, goog.a11y.aria.State.SELECTED, goog.a11y.aria.Role.MENU_ITEM_CHECKBOX, goog.a11y.aria.State.CHECKED, goog.a11y.aria.Role.MENU_ITEM_RADIO, goog.a11y.aria.State.CHECKED, goog.a11y.aria.Role.RADIO, goog.a11y.aria.State.CHECKED, goog.a11y.aria.Role.TAB, goog.a11y.aria.State.SELECTED, goog.a11y.aria.Role.TREEITEM, 
goog.a11y.aria.State.SELECTED);
goog.ui.ControlRenderer.prototype.getAriaRole = function() {
};
goog.ui.ControlRenderer.prototype.createDom = function(control) {
  var element = control.getDomHelper().createDom("div", this.getClassNames(control).join(" "), control.getContent());
  this.setAriaStates(control, element);
  return element;
};
goog.ui.ControlRenderer.prototype.getContentElement = function(element) {
  return element;
};
goog.ui.ControlRenderer.prototype.enableClassName = function(control, className, enable) {
  var element = control.getElement ? control.getElement() : control;
  if (element) {
    var classNames = [className];
    goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("7") && (classNames = this.getAppliedCombinedClassNames_(goog.dom.classlist.get(element), className), classNames.push(className));
    goog.dom.classlist.enableAll(element, classNames, enable);
  }
};
goog.ui.ControlRenderer.prototype.enableExtraClassName = function(control, className, enable) {
  this.enableClassName(control, className, enable);
};
goog.ui.ControlRenderer.prototype.canDecorate = function() {
  return!0;
};
goog.ui.ControlRenderer.prototype.decorate = function(control, element) {
  element.id && control.setId(element.id);
  var contentElem = this.getContentElement(element);
  contentElem && contentElem.firstChild ? control.setContentInternal(contentElem.firstChild.nextSibling ? goog.array.clone(contentElem.childNodes) : contentElem.firstChild) : control.setContentInternal(null);
  var state = 0, rendererClassName = this.getCssClass(), structuralClassName = this.getStructuralCssClass(), hasRendererClassName = !1, hasStructuralClassName = !1, hasCombinedClassName = !1, classNames = goog.array.toArray(goog.dom.classlist.get(element));
  goog.array.forEach(classNames, function(className) {
    hasRendererClassName || className != rendererClassName ? hasStructuralClassName || className != structuralClassName ? state |= this.getStateFromClass(className) : hasStructuralClassName = !0 : (hasRendererClassName = !0, structuralClassName == rendererClassName && (hasStructuralClassName = !0));
    this.getStateFromClass(className) == goog.ui.Component.State.DISABLED && goog.dom.isFocusableTabIndex(contentElem) && goog.dom.setFocusableTabIndex(contentElem, !1);
  }, this);
  control.setStateInternal(state);
  hasRendererClassName || (classNames.push(rendererClassName), structuralClassName == rendererClassName && (hasStructuralClassName = !0));
  hasStructuralClassName || classNames.push(structuralClassName);
  var extraClassNames = control.getExtraClassNames();
  extraClassNames && classNames.push.apply(classNames, extraClassNames);
  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("7")) {
    var combinedClasses = this.getAppliedCombinedClassNames_(classNames);
    0 < combinedClasses.length && (classNames.push.apply(classNames, combinedClasses), hasCombinedClassName = !0);
  }
  hasRendererClassName && hasStructuralClassName && !extraClassNames && !hasCombinedClassName || goog.dom.classlist.set(element, classNames.join(" "));
  this.setAriaStates(control, element);
  return element;
};
goog.ui.ControlRenderer.prototype.initializeDom = function(control) {
  control.isRightToLeft() && this.setRightToLeft(control.getElement(), !0);
  control.isEnabled() && this.setFocusable(control, control.isVisible());
};
goog.ui.ControlRenderer.prototype.setAriaRole = function(element, opt_preferredRole) {
  var ariaRole = opt_preferredRole || this.getAriaRole();
  if (ariaRole) {
    goog.asserts.assert(element, "The element passed as a first parameter cannot be null.");
    var currentRole = goog.a11y.aria.getRole(element);
    ariaRole != currentRole && goog.a11y.aria.setRole(element, ariaRole);
  }
};
goog.ui.ControlRenderer.prototype.setAriaStates = function(control, element) {
  goog.asserts.assert(control);
  goog.asserts.assert(element);
  control.isVisible() || goog.a11y.aria.setState(element, goog.a11y.aria.State.HIDDEN, !control.isVisible());
  control.isEnabled() || this.updateAriaState(element, goog.ui.Component.State.DISABLED, !control.isEnabled());
  control.isSupportedState(goog.ui.Component.State.SELECTED) && this.updateAriaState(element, goog.ui.Component.State.SELECTED, control.isSelected());
  control.isSupportedState(goog.ui.Component.State.CHECKED) && this.updateAriaState(element, goog.ui.Component.State.CHECKED, control.isChecked());
  control.isSupportedState(goog.ui.Component.State.OPENED) && this.updateAriaState(element, goog.ui.Component.State.OPENED, control.isOpen());
};
goog.ui.ControlRenderer.prototype.setAllowTextSelection = function(element, allow) {
  goog.style.setUnselectable(element, !allow, !goog.userAgent.IE && !goog.userAgent.OPERA);
};
goog.ui.ControlRenderer.prototype.setRightToLeft = function(element, rightToLeft) {
  this.enableClassName(element, this.getStructuralCssClass() + "-rtl", rightToLeft);
};
goog.ui.ControlRenderer.prototype.isFocusable = function(control) {
  var keyTarget;
  return control.isSupportedState(goog.ui.Component.State.FOCUSED) && (keyTarget = control.getKeyEventTarget()) ? goog.dom.isFocusableTabIndex(keyTarget) : !1;
};
goog.ui.ControlRenderer.prototype.setFocusable = function(control, focusable) {
  var keyTarget;
  if (control.isSupportedState(goog.ui.Component.State.FOCUSED) && (keyTarget = control.getKeyEventTarget())) {
    if (!focusable && control.isFocused()) {
      try {
        keyTarget.blur();
      } catch (e) {
      }
      control.isFocused() && control.handleBlur(null);
    }
    goog.dom.isFocusableTabIndex(keyTarget) != focusable && goog.dom.setFocusableTabIndex(keyTarget, focusable);
  }
};
goog.ui.ControlRenderer.prototype.setVisible = function(element, visible) {
  goog.style.setElementShown(element, visible);
  element && goog.a11y.aria.setState(element, goog.a11y.aria.State.HIDDEN, !visible);
};
goog.ui.ControlRenderer.prototype.setState = function(control, state, enable) {
  var element = control.getElement();
  if (element) {
    var className = this.getClassForState(state);
    className && this.enableClassName(control, className, enable);
    this.updateAriaState(element, state, enable);
  }
};
goog.ui.ControlRenderer.prototype.updateAriaState = function(element, state, enable) {
  goog.ui.ControlRenderer.ARIA_ATTRIBUTE_MAP_ || (goog.ui.ControlRenderer.ARIA_ATTRIBUTE_MAP_ = goog.object.create(goog.ui.Component.State.DISABLED, goog.a11y.aria.State.DISABLED, goog.ui.Component.State.SELECTED, goog.a11y.aria.State.SELECTED, goog.ui.Component.State.CHECKED, goog.a11y.aria.State.CHECKED, goog.ui.Component.State.OPENED, goog.a11y.aria.State.EXPANDED));
  goog.asserts.assert(element, "The element passed as a first parameter cannot be null.");
  var ariaAttr = goog.ui.ControlRenderer.getAriaStateForAriaRole_(element, goog.ui.ControlRenderer.ARIA_ATTRIBUTE_MAP_[state]);
  ariaAttr && goog.a11y.aria.setState(element, ariaAttr, enable);
};
goog.ui.ControlRenderer.getAriaStateForAriaRole_ = function(element, attr) {
  var role = goog.a11y.aria.getRole(element);
  if (!role) {
    return attr;
  }
  var matchAttr = goog.ui.ControlRenderer.TOGGLE_ARIA_STATE_MAP_[role] || attr;
  return goog.ui.ControlRenderer.isAriaState_(attr) ? matchAttr : attr;
};
goog.ui.ControlRenderer.isAriaState_ = function(attr) {
  return attr == goog.a11y.aria.State.CHECKED || attr == goog.a11y.aria.State.SELECTED;
};
goog.ui.ControlRenderer.prototype.setContent = function(element, content) {
  var contentElem = this.getContentElement(element);
  if (contentElem && (goog.dom.removeChildren(contentElem), content)) {
    if (goog.isString(content)) {
      goog.dom.setTextContent(contentElem, content);
    } else {
      var childHandler = function(child) {
        if (child) {
          var doc = goog.dom.getOwnerDocument(contentElem);
          contentElem.appendChild(goog.isString(child) ? doc.createTextNode(child) : child);
        }
      };
      goog.isArray(content) ? goog.array.forEach(content, childHandler) : !goog.isArrayLike(content) || "nodeType" in content ? childHandler(content) : goog.array.forEach(goog.array.clone(content), childHandler);
    }
  }
};
goog.ui.ControlRenderer.prototype.getKeyEventTarget = function(control) {
  return control.getElement();
};
goog.ui.ControlRenderer.prototype.getCssClass = function() {
  return goog.ui.ControlRenderer.CSS_CLASS;
};
goog.ui.ControlRenderer.prototype.getIe6ClassCombinations = function() {
  return[];
};
goog.ui.ControlRenderer.prototype.getStructuralCssClass = function() {
  return this.getCssClass();
};
goog.ui.ControlRenderer.prototype.getClassNames = function(control) {
  var cssClass = this.getCssClass(), classNames = [cssClass], structuralCssClass = this.getStructuralCssClass();
  structuralCssClass != cssClass && classNames.push(structuralCssClass);
  var classNamesForState = this.getClassNamesForState(control.getState());
  classNames.push.apply(classNames, classNamesForState);
  var extraClassNames = control.getExtraClassNames();
  extraClassNames && classNames.push.apply(classNames, extraClassNames);
  goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("7") && classNames.push.apply(classNames, this.getAppliedCombinedClassNames_(classNames));
  return classNames;
};
goog.ui.ControlRenderer.prototype.getAppliedCombinedClassNames_ = function(classes, opt_includedClass) {
  var toAdd = [];
  opt_includedClass && (classes = classes.concat([opt_includedClass]));
  goog.array.forEach(this.getIe6ClassCombinations(), function(combo) {
    !goog.array.every(combo, goog.partial(goog.array.contains, classes)) || opt_includedClass && !goog.array.contains(combo, opt_includedClass) || toAdd.push(combo.join("_"));
  });
  return toAdd;
};
goog.ui.ControlRenderer.prototype.getClassNamesForState = function(state) {
  for (var classNames = [];state;) {
    var mask = state & -state;
    classNames.push(this.getClassForState(mask));
    state &= ~mask;
  }
  return classNames;
};
goog.ui.ControlRenderer.prototype.getClassForState = function(state) {
  this.classByState_ || this.createClassByStateMap_();
  return this.classByState_[state];
};
goog.ui.ControlRenderer.prototype.getStateFromClass = function(className) {
  this.stateByClass_ || this.createStateByClassMap_();
  var state = parseInt(this.stateByClass_[className], 10);
  return isNaN(state) ? 0 : state;
};
goog.ui.ControlRenderer.prototype.createClassByStateMap_ = function() {
  var baseClass = this.getStructuralCssClass(), isValidClassName = !goog.string.contains(goog.string.normalizeWhitespace(baseClass), " ");
  goog.asserts.assert(isValidClassName, "ControlRenderer has an invalid css class: '" + baseClass + "'");
  this.classByState_ = goog.object.create(goog.ui.Component.State.DISABLED, baseClass + "-disabled", goog.ui.Component.State.HOVER, baseClass + "-hover", goog.ui.Component.State.ACTIVE, baseClass + "-active", goog.ui.Component.State.SELECTED, baseClass + "-selected", goog.ui.Component.State.CHECKED, baseClass + "-checked", goog.ui.Component.State.FOCUSED, baseClass + "-focused", goog.ui.Component.State.OPENED, baseClass + "-open");
};
goog.ui.ControlRenderer.prototype.createStateByClassMap_ = function() {
  this.classByState_ || this.createClassByStateMap_();
  this.stateByClass_ = goog.object.transpose(this.classByState_);
};
// INPUT (javascript/closure/ui/registry.js)
goog.ui.registry = {};
goog.ui.registry.getDefaultRenderer = function(componentCtor) {
  for (var key, rendererCtor;componentCtor;) {
    key = goog.getUid(componentCtor);
    if (rendererCtor = goog.ui.registry.defaultRenderers_[key]) {
      break;
    }
    componentCtor = componentCtor.superClass_ ? componentCtor.superClass_.constructor : null;
  }
  return rendererCtor ? goog.isFunction(rendererCtor.getInstance) ? rendererCtor.getInstance() : new rendererCtor : null;
};
goog.ui.registry.setDefaultRenderer = function(componentCtor, rendererCtor) {
  if (!goog.isFunction(componentCtor)) {
    throw Error("Invalid component class " + componentCtor);
  }
  if (!goog.isFunction(rendererCtor)) {
    throw Error("Invalid renderer class " + rendererCtor);
  }
  var key = goog.getUid(componentCtor);
  goog.ui.registry.defaultRenderers_[key] = rendererCtor;
};
goog.ui.registry.getDecoratorByClassName = function(className) {
  return className in goog.ui.registry.decoratorFunctions_ ? goog.ui.registry.decoratorFunctions_[className]() : null;
};
goog.ui.registry.setDecoratorByClassName = function(className, decoratorFn) {
  if (!className) {
    throw Error("Invalid class name " + className);
  }
  if (!goog.isFunction(decoratorFn)) {
    throw Error("Invalid decorator function " + decoratorFn);
  }
  goog.ui.registry.decoratorFunctions_[className] = decoratorFn;
};
goog.ui.registry.getDecorator = function(element) {
  var decorator;
  goog.asserts.assert(element);
  for (var classNames = goog.dom.classlist.get(element), i = 0, len = classNames.length;i < len;i++) {
    if (decorator = goog.ui.registry.getDecoratorByClassName(classNames[i])) {
      return decorator;
    }
  }
  return null;
};
goog.ui.registry.reset = function() {
  goog.ui.registry.defaultRenderers_ = {};
  goog.ui.registry.decoratorFunctions_ = {};
};
goog.ui.registry.defaultRenderers_ = {};
goog.ui.registry.decoratorFunctions_ = {};
// INPUT (javascript/closure/ui/decorate.js)
goog.ui.decorate = function(element) {
  var decorator = goog.ui.registry.getDecorator(element);
  decorator && decorator.decorate(element);
  return decorator;
};
// INPUT (javascript/closure/ui/control.js)
goog.ui.Control = function(opt_content, opt_renderer, opt_domHelper) {
  goog.ui.Component.call(this, opt_domHelper);
  this.renderer_ = opt_renderer || goog.ui.registry.getDefaultRenderer(this.constructor);
  this.setContentInternal(goog.isDef(opt_content) ? opt_content : null);
};
goog.inherits(goog.ui.Control, goog.ui.Component);
goog.tagUnsealableClass(goog.ui.Control);
goog.ui.Control.registerDecorator = goog.ui.registry.setDecoratorByClassName;
goog.ui.Control.getDecorator = goog.ui.registry.getDecorator;
goog.ui.Control.decorate = goog.ui.decorate;
goog.ui.Control.prototype.content_ = null;
goog.ui.Control.prototype.state_ = 0;
goog.ui.Control.prototype.supportedStates_ = goog.ui.Component.State.DISABLED | goog.ui.Component.State.HOVER | goog.ui.Component.State.ACTIVE | goog.ui.Component.State.FOCUSED;
goog.ui.Control.prototype.autoStates_ = goog.ui.Component.State.ALL;
goog.ui.Control.prototype.statesWithTransitionEvents_ = 0;
goog.ui.Control.prototype.visible_ = !0;
goog.ui.Control.prototype.extraClassNames_ = null;
goog.ui.Control.prototype.handleMouseEvents_ = !0;
goog.ui.Control.prototype.allowTextSelection_ = !1;
goog.ui.Control.prototype.preferredAriaRole_ = null;
goog.ui.Control.prototype.isHandleMouseEvents = function() {
  return this.handleMouseEvents_;
};
goog.ui.Control.prototype.setHandleMouseEvents = function(enable) {
  this.isInDocument() && enable != this.handleMouseEvents_ && this.enableMouseEventHandling_(enable);
  this.handleMouseEvents_ = enable;
};
goog.ui.Control.prototype.getKeyEventTarget = function() {
  return this.renderer_.getKeyEventTarget(this);
};
goog.ui.Control.prototype.getKeyHandler = function() {
  return this.keyHandler_ || (this.keyHandler_ = new goog.events.KeyHandler);
};
goog.ui.Control.prototype.getRenderer = function() {
  return this.renderer_;
};
goog.ui.Control.prototype.setRenderer = function(renderer) {
  if (this.isInDocument()) {
    throw Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  this.getElement() && this.setElementInternal(null);
  this.renderer_ = renderer;
};
goog.ui.Control.prototype.getExtraClassNames = function() {
  return this.extraClassNames_;
};
goog.ui.Control.prototype.addClassName = function(className) {
  className && (this.extraClassNames_ ? goog.array.contains(this.extraClassNames_, className) || this.extraClassNames_.push(className) : this.extraClassNames_ = [className], this.renderer_.enableExtraClassName(this, className, !0));
};
goog.ui.Control.prototype.removeClassName = function(className) {
  className && this.extraClassNames_ && goog.array.remove(this.extraClassNames_, className) && (0 == this.extraClassNames_.length && (this.extraClassNames_ = null), this.renderer_.enableExtraClassName(this, className, !1));
};
goog.ui.Control.prototype.enableClassName = function(className, enable) {
  enable ? this.addClassName(className) : this.removeClassName(className);
};
goog.ui.Control.prototype.createDom = function() {
  var element = this.renderer_.createDom(this);
  this.setElementInternal(element);
  this.renderer_.setAriaRole(element, this.getPreferredAriaRole());
  this.isAllowTextSelection() || this.renderer_.setAllowTextSelection(element, !1);
  this.isVisible() || this.renderer_.setVisible(element, !1);
};
goog.ui.Control.prototype.getPreferredAriaRole = function() {
  return this.preferredAriaRole_;
};
goog.ui.Control.prototype.setPreferredAriaRole = function(role) {
  this.preferredAriaRole_ = role;
};
goog.ui.Control.prototype.getContentElement = function() {
  return this.renderer_.getContentElement(this.getElement());
};
goog.ui.Control.prototype.canDecorate = function(element) {
  return this.renderer_.canDecorate(element);
};
goog.ui.Control.prototype.decorateInternal = function(element) {
  element = this.renderer_.decorate(this, element);
  this.setElementInternal(element);
  this.renderer_.setAriaRole(element, this.getPreferredAriaRole());
  this.isAllowTextSelection() || this.renderer_.setAllowTextSelection(element, !1);
  this.visible_ = "none" != element.style.display;
};
goog.ui.Control.prototype.enterDocument = function() {
  goog.ui.Control.superClass_.enterDocument.call(this);
  this.renderer_.initializeDom(this);
  if (this.supportedStates_ & ~goog.ui.Component.State.DISABLED && (this.isHandleMouseEvents() && this.enableMouseEventHandling_(!0), this.isSupportedState(goog.ui.Component.State.FOCUSED))) {
    var keyTarget = this.getKeyEventTarget();
    if (keyTarget) {
      var keyHandler = this.getKeyHandler();
      keyHandler.attach(keyTarget);
      this.getHandler().listen(keyHandler, goog.events.KeyHandler.EventType.KEY, this.handleKeyEvent).listen(keyTarget, goog.events.EventType.FOCUS, this.handleFocus).listen(keyTarget, goog.events.EventType.BLUR, this.handleBlur);
    }
  }
};
goog.ui.Control.prototype.enableMouseEventHandling_ = function(enable) {
  var handler = this.getHandler(), element = this.getElement();
  enable ? (handler.listen(element, goog.events.EventType.MOUSEOVER, this.handleMouseOver).listen(element, goog.events.EventType.MOUSEDOWN, this.handleMouseDown).listen(element, goog.events.EventType.MOUSEUP, this.handleMouseUp).listen(element, goog.events.EventType.MOUSEOUT, this.handleMouseOut), this.handleContextMenu != goog.nullFunction && handler.listen(element, goog.events.EventType.CONTEXTMENU, this.handleContextMenu), goog.userAgent.IE && handler.listen(element, goog.events.EventType.DBLCLICK, 
  this.handleDblClick)) : (handler.unlisten(element, goog.events.EventType.MOUSEOVER, this.handleMouseOver).unlisten(element, goog.events.EventType.MOUSEDOWN, this.handleMouseDown).unlisten(element, goog.events.EventType.MOUSEUP, this.handleMouseUp).unlisten(element, goog.events.EventType.MOUSEOUT, this.handleMouseOut), this.handleContextMenu != goog.nullFunction && handler.unlisten(element, goog.events.EventType.CONTEXTMENU, this.handleContextMenu), goog.userAgent.IE && handler.unlisten(element, 
  goog.events.EventType.DBLCLICK, this.handleDblClick));
};
goog.ui.Control.prototype.exitDocument = function() {
  goog.ui.Control.superClass_.exitDocument.call(this);
  this.keyHandler_ && this.keyHandler_.detach();
  this.isVisible() && this.isEnabled() && this.renderer_.setFocusable(this, !1);
};
goog.ui.Control.prototype.disposeInternal = function() {
  goog.ui.Control.superClass_.disposeInternal.call(this);
  this.keyHandler_ && (this.keyHandler_.dispose(), delete this.keyHandler_);
  delete this.renderer_;
  this.extraClassNames_ = this.content_ = null;
};
goog.ui.Control.prototype.getContent = function() {
  return this.content_;
};
goog.ui.Control.prototype.setContent = function(content) {
  this.renderer_.setContent(this.getElement(), content);
  this.setContentInternal(content);
};
goog.ui.Control.prototype.setContentInternal = function(content) {
  this.content_ = content;
};
goog.ui.Control.prototype.getCaption = function() {
  var content = this.getContent();
  if (!content) {
    return "";
  }
  var caption = goog.isString(content) ? content : goog.isArray(content) ? goog.array.map(content, goog.dom.getRawTextContent).join("") : goog.dom.getTextContent(content);
  return goog.string.collapseBreakingSpaces(caption);
};
goog.ui.Control.prototype.setRightToLeft = function(rightToLeft) {
  goog.ui.Control.superClass_.setRightToLeft.call(this, rightToLeft);
  var element = this.getElement();
  element && this.renderer_.setRightToLeft(element, rightToLeft);
};
goog.ui.Control.prototype.isAllowTextSelection = function() {
  return this.allowTextSelection_;
};
goog.ui.Control.prototype.setAllowTextSelection = function(allow) {
  this.allowTextSelection_ = allow;
  var element = this.getElement();
  element && this.renderer_.setAllowTextSelection(element, allow);
};
goog.ui.Control.prototype.isVisible = function() {
  return this.visible_;
};
goog.ui.Control.prototype.setVisible = function(visible, opt_force) {
  if (opt_force || this.visible_ != visible && this.dispatchEvent(visible ? goog.ui.Component.EventType.SHOW : goog.ui.Component.EventType.HIDE)) {
    var element = this.getElement();
    element && this.renderer_.setVisible(element, visible);
    this.isEnabled() && this.renderer_.setFocusable(this, visible);
    this.visible_ = visible;
    return!0;
  }
  return!1;
};
goog.ui.Control.prototype.isEnabled = function() {
  return!this.hasState(goog.ui.Component.State.DISABLED);
};
goog.ui.Control.prototype.isParentDisabled_ = function() {
  var parent = this.getParent();
  return!!parent && "function" == typeof parent.isEnabled && !parent.isEnabled();
};
goog.ui.Control.prototype.setEnabled = function(enable) {
  !this.isParentDisabled_() && this.isTransitionAllowed(goog.ui.Component.State.DISABLED, !enable) && (enable || (this.setActive(!1), this.setHighlighted(!1)), this.isVisible() && this.renderer_.setFocusable(this, enable), this.setState(goog.ui.Component.State.DISABLED, !enable, !0));
};
goog.ui.Control.prototype.isHighlighted = function() {
  return this.hasState(goog.ui.Component.State.HOVER);
};
goog.ui.Control.prototype.setHighlighted = function(highlight) {
  this.isTransitionAllowed(goog.ui.Component.State.HOVER, highlight) && this.setState(goog.ui.Component.State.HOVER, highlight);
};
goog.ui.Control.prototype.isActive = function() {
  return this.hasState(goog.ui.Component.State.ACTIVE);
};
goog.ui.Control.prototype.setActive = function(active) {
  this.isTransitionAllowed(goog.ui.Component.State.ACTIVE, active) && this.setState(goog.ui.Component.State.ACTIVE, active);
};
goog.ui.Control.prototype.isSelected = function() {
  return this.hasState(goog.ui.Component.State.SELECTED);
};
goog.ui.Control.prototype.setSelected = function(select) {
  this.isTransitionAllowed(goog.ui.Component.State.SELECTED, select) && this.setState(goog.ui.Component.State.SELECTED, select);
};
goog.ui.Control.prototype.isChecked = function() {
  return this.hasState(goog.ui.Component.State.CHECKED);
};
goog.ui.Control.prototype.setChecked = function(check) {
  this.isTransitionAllowed(goog.ui.Component.State.CHECKED, check) && this.setState(goog.ui.Component.State.CHECKED, check);
};
goog.ui.Control.prototype.isFocused = function() {
  return this.hasState(goog.ui.Component.State.FOCUSED);
};
goog.ui.Control.prototype.setFocused = function(focused) {
  this.isTransitionAllowed(goog.ui.Component.State.FOCUSED, focused) && this.setState(goog.ui.Component.State.FOCUSED, focused);
};
goog.ui.Control.prototype.isOpen = function() {
  return this.hasState(goog.ui.Component.State.OPENED);
};
goog.ui.Control.prototype.setOpen = function(open) {
  this.isTransitionAllowed(goog.ui.Component.State.OPENED, open) && this.setState(goog.ui.Component.State.OPENED, open);
};
goog.ui.Control.prototype.getState = function() {
  return this.state_;
};
goog.ui.Control.prototype.hasState = function(state) {
  return!!(this.state_ & state);
};
goog.ui.Control.prototype.setState = function(state, enable, opt_calledFrom) {
  opt_calledFrom || state != goog.ui.Component.State.DISABLED ? this.isSupportedState(state) && enable != this.hasState(state) && (this.renderer_.setState(this, state, enable), this.state_ = enable ? this.state_ | state : this.state_ & ~state) : this.setEnabled(!enable);
};
goog.ui.Control.prototype.setStateInternal = function(state) {
  this.state_ = state;
};
goog.ui.Control.prototype.isSupportedState = function(state) {
  return!!(this.supportedStates_ & state);
};
goog.ui.Control.prototype.setSupportedState = function(state, support) {
  if (this.isInDocument() && this.hasState(state) && !support) {
    throw Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  !support && this.hasState(state) && this.setState(state, !1);
  this.supportedStates_ = support ? this.supportedStates_ | state : this.supportedStates_ & ~state;
};
goog.ui.Control.prototype.isAutoState = function(state) {
  return!!(this.autoStates_ & state) && this.isSupportedState(state);
};
goog.ui.Control.prototype.setAutoStates = function(states, enable) {
  this.autoStates_ = enable ? this.autoStates_ | states : this.autoStates_ & ~states;
};
goog.ui.Control.prototype.setDispatchTransitionEvents = function(states, enable) {
  this.statesWithTransitionEvents_ = enable ? this.statesWithTransitionEvents_ | states : this.statesWithTransitionEvents_ & ~states;
};
goog.ui.Control.prototype.isTransitionAllowed = function(state, enable) {
  return this.isSupportedState(state) && this.hasState(state) != enable && (!(this.statesWithTransitionEvents_ & state) || this.dispatchEvent(goog.ui.Component.getStateTransitionEvent(state, enable))) && !this.isDisposed();
};
goog.ui.Control.prototype.handleMouseOver = function(e) {
  !goog.ui.Control.isMouseEventWithinElement_(e, this.getElement()) && this.dispatchEvent(goog.ui.Component.EventType.ENTER) && this.isEnabled() && this.isAutoState(goog.ui.Component.State.HOVER) && this.setHighlighted(!0);
};
goog.ui.Control.prototype.handleMouseOut = function(e) {
  !goog.ui.Control.isMouseEventWithinElement_(e, this.getElement()) && this.dispatchEvent(goog.ui.Component.EventType.LEAVE) && (this.isAutoState(goog.ui.Component.State.ACTIVE) && this.setActive(!1), this.isAutoState(goog.ui.Component.State.HOVER) && this.setHighlighted(!1));
};
goog.ui.Control.prototype.handleContextMenu = goog.nullFunction;
goog.ui.Control.isMouseEventWithinElement_ = function(e, elem) {
  return!!e.relatedTarget && goog.dom.contains(elem, e.relatedTarget);
};
goog.ui.Control.prototype.handleMouseDown = function(e) {
  this.isEnabled() && (this.isAutoState(goog.ui.Component.State.HOVER) && this.setHighlighted(!0), e.isMouseActionButton() && (this.isAutoState(goog.ui.Component.State.ACTIVE) && this.setActive(!0), this.renderer_.isFocusable(this) && this.getKeyEventTarget().focus()));
  !this.isAllowTextSelection() && e.isMouseActionButton() && e.preventDefault();
};
goog.ui.Control.prototype.handleMouseUp = function(e) {
  this.isEnabled() && (this.isAutoState(goog.ui.Component.State.HOVER) && this.setHighlighted(!0), this.isActive() && this.performActionInternal(e) && this.isAutoState(goog.ui.Component.State.ACTIVE) && this.setActive(!1));
};
goog.ui.Control.prototype.handleDblClick = function(e) {
  this.isEnabled() && this.performActionInternal(e);
};
goog.ui.Control.prototype.performActionInternal = function(e) {
  this.isAutoState(goog.ui.Component.State.CHECKED) && this.setChecked(!this.isChecked());
  this.isAutoState(goog.ui.Component.State.SELECTED) && this.setSelected(!0);
  this.isAutoState(goog.ui.Component.State.OPENED) && this.setOpen(!this.isOpen());
  var actionEvent = new goog.events.Event(goog.ui.Component.EventType.ACTION, this);
  e && (actionEvent.altKey = e.altKey, actionEvent.ctrlKey = e.ctrlKey, actionEvent.metaKey = e.metaKey, actionEvent.shiftKey = e.shiftKey, actionEvent.platformModifierKey = e.platformModifierKey);
  return this.dispatchEvent(actionEvent);
};
goog.ui.Control.prototype.handleFocus = function() {
  this.isAutoState(goog.ui.Component.State.FOCUSED) && this.setFocused(!0);
};
goog.ui.Control.prototype.handleBlur = function() {
  this.isAutoState(goog.ui.Component.State.ACTIVE) && this.setActive(!1);
  this.isAutoState(goog.ui.Component.State.FOCUSED) && this.setFocused(!1);
};
goog.ui.Control.prototype.handleKeyEvent = function(e) {
  return this.isVisible() && this.isEnabled() && this.handleKeyEventInternal(e) ? (e.preventDefault(), e.stopPropagation(), !0) : !1;
};
goog.ui.Control.prototype.handleKeyEventInternal = function(e) {
  return e.keyCode == goog.events.KeyCodes.ENTER && this.performActionInternal(e);
};
goog.ui.registry.setDefaultRenderer(goog.ui.Control, goog.ui.ControlRenderer);
goog.ui.registry.setDecoratorByClassName(goog.ui.ControlRenderer.CSS_CLASS, function() {
  return new goog.ui.Control(null);
});
// INPUT (javascript/closure/ui/menuitemrenderer.js)
goog.ui.MenuItemRenderer = function() {
  this.classNameCache_ = [];
};
goog.inherits(goog.ui.MenuItemRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.MenuItemRenderer);
goog.ui.MenuItemRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-menuitem";
goog.ui.MenuItemRenderer.CompositeCssClassIndex_ = {HOVER:0, CHECKBOX:1, CONTENT:2};
goog.ui.MenuItemRenderer.prototype.getCompositeCssClass_ = function(index) {
  var result = this.classNameCache_[index];
  if (!result) {
    switch(index) {
      case goog.ui.MenuItemRenderer.CompositeCssClassIndex_.HOVER:
        result = this.getStructuralCssClass() + "-highlight";
        break;
      case goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CHECKBOX:
        result = this.getStructuralCssClass() + "-checkbox";
        break;
      case goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CONTENT:
        result = this.getStructuralCssClass() + "-content";
    }
    this.classNameCache_[index] = result;
  }
  return result;
};
goog.ui.MenuItemRenderer.prototype.getAriaRole = function() {
  return goog.a11y.aria.Role.MENU_ITEM;
};
goog.ui.MenuItemRenderer.prototype.createDom = function(item) {
  var element = item.getDomHelper().createDom("div", this.getClassNames(item).join(" "), this.createContent(item.getContent(), item.getDomHelper()));
  this.setEnableCheckBoxStructure(item, element, item.isSupportedState(goog.ui.Component.State.SELECTED) || item.isSupportedState(goog.ui.Component.State.CHECKED));
  return element;
};
goog.ui.MenuItemRenderer.prototype.getContentElement = function(element) {
  return element && element.firstChild;
};
goog.ui.MenuItemRenderer.prototype.decorate = function(item, element) {
  goog.asserts.assert(element);
  this.hasContentStructure(element) || element.appendChild(this.createContent(element.childNodes, item.getDomHelper()));
  goog.dom.classlist.contains(element, "aAAaGVIZSENTINELaAAa-option") && (item.setCheckable(!0), this.setCheckable(item, element, !0));
  return goog.ui.MenuItemRenderer.superClass_.decorate.call(this, item, element);
};
goog.ui.MenuItemRenderer.prototype.setContent = function(element, content) {
  var contentElement = this.getContentElement(element), checkBoxElement = this.hasCheckBoxStructure(element) ? contentElement.firstChild : null;
  goog.ui.MenuItemRenderer.superClass_.setContent.call(this, element, content);
  checkBoxElement && !this.hasCheckBoxStructure(element) && contentElement.insertBefore(checkBoxElement, contentElement.firstChild || null);
};
goog.ui.MenuItemRenderer.prototype.hasContentStructure = function(element) {
  var child = goog.dom.getFirstElementChild(element), contentClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CONTENT);
  return!!child && goog.dom.classlist.contains(child, contentClassName);
};
goog.ui.MenuItemRenderer.prototype.createContent = function(content, dom) {
  var contentClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CONTENT);
  return dom.createDom("div", contentClassName, content);
};
goog.ui.MenuItemRenderer.prototype.setSelectable = function(item, element, selectable) {
  item && element && this.setEnableCheckBoxStructure(item, element, selectable);
};
goog.ui.MenuItemRenderer.prototype.setCheckable = function(item, element, checkable) {
  item && element && this.setEnableCheckBoxStructure(item, element, checkable);
};
goog.ui.MenuItemRenderer.prototype.hasCheckBoxStructure = function(element) {
  var contentElement = this.getContentElement(element);
  if (contentElement) {
    var child = contentElement.firstChild, checkboxClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CHECKBOX);
    return!!child && goog.dom.isElement(child) && goog.dom.classlist.contains(child, checkboxClassName);
  }
  return!1;
};
goog.ui.MenuItemRenderer.prototype.setEnableCheckBoxStructure = function(item, element, enable) {
  this.setAriaRole(element, item.getPreferredAriaRole());
  this.setAriaStates(item, element);
  if (enable != this.hasCheckBoxStructure(element)) {
    goog.dom.classlist.enable(element, "aAAaGVIZSENTINELaAAa-option", enable);
    var contentElement = this.getContentElement(element);
    if (enable) {
      var checkboxClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CHECKBOX);
      contentElement.insertBefore(item.getDomHelper().createDom("div", checkboxClassName), contentElement.firstChild || null);
    } else {
      contentElement.removeChild(contentElement.firstChild);
    }
  }
};
goog.ui.MenuItemRenderer.prototype.getClassForState = function(state) {
  switch(state) {
    case goog.ui.Component.State.HOVER:
      return this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.HOVER);
    case goog.ui.Component.State.CHECKED:
    ;
    case goog.ui.Component.State.SELECTED:
      return "aAAaGVIZSENTINELaAAa-option-selected";
    default:
      return goog.ui.MenuItemRenderer.superClass_.getClassForState.call(this, state);
  }
};
goog.ui.MenuItemRenderer.prototype.getStateFromClass = function(className) {
  var hoverClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.HOVER);
  switch(className) {
    case "aAAaGVIZSENTINELaAAa-option-selected":
      return goog.ui.Component.State.CHECKED;
    case hoverClassName:
      return goog.ui.Component.State.HOVER;
    default:
      return goog.ui.MenuItemRenderer.superClass_.getStateFromClass.call(this, className);
  }
};
goog.ui.MenuItemRenderer.prototype.getCssClass = function() {
  return goog.ui.MenuItemRenderer.CSS_CLASS;
};
// INPUT (javascript/closure/ui/menuitem.js)
goog.ui.MenuItem = function(content, opt_model, opt_domHelper, opt_renderer) {
  goog.ui.Control.call(this, content, opt_renderer || goog.ui.MenuItemRenderer.getInstance(), opt_domHelper);
  this.setValue(opt_model);
};
goog.inherits(goog.ui.MenuItem, goog.ui.Control);
goog.tagUnsealableClass(goog.ui.MenuItem);
goog.ui.MenuItem.MNEMONIC_WRAPPER_CLASS_ = "aAAaGVIZSENTINELaAAa-menuitem-mnemonic-separator";
goog.ui.MenuItem.ACCELERATOR_CLASS = "aAAaGVIZSENTINELaAAa-menuitem-accel";
goog.ui.MenuItem.prototype.getValue = function() {
  var model = this.getModel();
  return null != model ? model : this.getCaption();
};
goog.ui.MenuItem.prototype.setValue = function(value) {
  this.setModel(value);
};
goog.ui.MenuItem.prototype.setSupportedState = function(state, support) {
  goog.ui.MenuItem.superClass_.setSupportedState.call(this, state, support);
  switch(state) {
    case goog.ui.Component.State.SELECTED:
      this.setSelectableInternal_(support);
      break;
    case goog.ui.Component.State.CHECKED:
      this.setCheckableInternal_(support);
  }
};
goog.ui.MenuItem.prototype.setSelectable = function(selectable) {
  this.setSupportedState(goog.ui.Component.State.SELECTED, selectable);
};
goog.ui.MenuItem.prototype.setSelectableInternal_ = function(selectable) {
  this.isChecked() && !selectable && this.setChecked(!1);
  var element = this.getElement();
  element && this.getRenderer().setSelectable(this, element, selectable);
};
goog.ui.MenuItem.prototype.setCheckable = function(checkable) {
  this.setSupportedState(goog.ui.Component.State.CHECKED, checkable);
};
goog.ui.MenuItem.prototype.setCheckableInternal_ = function(checkable) {
  var element = this.getElement();
  element && this.getRenderer().setCheckable(this, element, checkable);
};
goog.ui.MenuItem.prototype.getCaption = function() {
  var content = this.getContent();
  if (goog.isArray(content)) {
    var acceleratorClass = goog.ui.MenuItem.ACCELERATOR_CLASS, mnemonicWrapClass = goog.ui.MenuItem.MNEMONIC_WRAPPER_CLASS_, caption = goog.array.map(content, function(node) {
      return goog.dom.isElement(node) && (goog.dom.classlist.contains(node, acceleratorClass) || goog.dom.classlist.contains(node, mnemonicWrapClass)) ? "" : goog.dom.getRawTextContent(node);
    }).join("");
    return goog.string.collapseBreakingSpaces(caption);
  }
  return goog.ui.MenuItem.superClass_.getCaption.call(this);
};
goog.ui.MenuItem.prototype.handleMouseUp = function(e) {
  var parentMenu = this.getParent();
  if (parentMenu) {
    var oldCoords = parentMenu.openingCoords;
    parentMenu.openingCoords = null;
    if (oldCoords && goog.isNumber(e.clientX)) {
      var newCoords = new goog.math.Coordinate(e.clientX, e.clientY);
      if (goog.math.Coordinate.equals(oldCoords, newCoords)) {
        return;
      }
    }
  }
  goog.ui.MenuItem.superClass_.handleMouseUp.call(this, e);
};
goog.ui.MenuItem.prototype.handleKeyEventInternal = function(e) {
  return e.keyCode == this.getMnemonic() && this.performActionInternal(e) ? !0 : goog.ui.MenuItem.superClass_.handleKeyEventInternal.call(this, e);
};
goog.ui.MenuItem.prototype.getMnemonic = function() {
  return this.mnemonicKey_;
};
goog.ui.registry.setDecoratorByClassName(goog.ui.MenuItemRenderer.CSS_CLASS, function() {
  return new goog.ui.MenuItem(null);
});
goog.ui.MenuItem.prototype.getPreferredAriaRole = function() {
  return this.isSupportedState(goog.ui.Component.State.CHECKED) ? goog.a11y.aria.Role.MENU_ITEM_CHECKBOX : this.isSupportedState(goog.ui.Component.State.SELECTED) ? goog.a11y.aria.Role.MENU_ITEM_RADIO : goog.ui.MenuItem.superClass_.getPreferredAriaRole.call(this);
};
goog.ui.MenuItem.prototype.getParent = function() {
  return goog.ui.Control.prototype.getParent.call(this);
};
goog.ui.MenuItem.prototype.getParentEventTarget = function() {
  return goog.ui.Control.prototype.getParentEventTarget.call(this);
};
// INPUT (javascript/closure/positioning/menuanchoredposition.js)
goog.positioning.MenuAnchoredPosition = function(anchorElement, corner, opt_adjust, opt_resize) {
  goog.positioning.AnchoredViewportPosition.call(this, anchorElement, corner, opt_adjust || opt_resize);
  if (opt_adjust || opt_resize) {
    var overflowX = goog.positioning.Overflow.ADJUST_X_EXCEPT_OFFSCREEN, overflowY = opt_resize ? goog.positioning.Overflow.RESIZE_HEIGHT : goog.positioning.Overflow.ADJUST_Y_EXCEPT_OFFSCREEN;
    this.setLastResortOverflow(overflowX | overflowY);
  }
};
goog.inherits(goog.positioning.MenuAnchoredPosition, goog.positioning.AnchoredViewportPosition);
// INPUT (javascript/closure/useragent/product.js)
goog.userAgent.product = {};
goog.userAgent.product.ASSUME_FIREFOX = !1;
goog.userAgent.product.ASSUME_CAMINO = !1;
goog.userAgent.product.ASSUME_IPHONE = !1;
goog.userAgent.product.ASSUME_IPAD = !1;
goog.userAgent.product.ASSUME_ANDROID = !1;
goog.userAgent.product.ASSUME_CHROME = !1;
goog.userAgent.product.ASSUME_SAFARI = !1;
goog.userAgent.product.PRODUCT_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_OPERA || goog.userAgent.product.ASSUME_FIREFOX || goog.userAgent.product.ASSUME_CAMINO || goog.userAgent.product.ASSUME_IPHONE || goog.userAgent.product.ASSUME_IPAD || goog.userAgent.product.ASSUME_ANDROID || goog.userAgent.product.ASSUME_CHROME || goog.userAgent.product.ASSUME_SAFARI;
goog.userAgent.product.init_ = function() {
  goog.userAgent.product.detectedFirefox_ = !1;
  goog.userAgent.product.detectedCamino_ = !1;
  goog.userAgent.product.detectedIphone_ = !1;
  goog.userAgent.product.detectedIpad_ = !1;
  goog.userAgent.product.detectedAndroid_ = !1;
  goog.userAgent.product.detectedChrome_ = !1;
  goog.userAgent.product.detectedSafari_ = !1;
  var ua = goog.userAgent.getUserAgentString();
  ua && (-1 != ua.indexOf("Firefox") ? goog.userAgent.product.detectedFirefox_ = !0 : -1 != ua.indexOf("Camino") ? goog.userAgent.product.detectedCamino_ = !0 : -1 != ua.indexOf("iPhone") || -1 != ua.indexOf("iPod") ? goog.userAgent.product.detectedIphone_ = !0 : -1 != ua.indexOf("iPad") ? goog.userAgent.product.detectedIpad_ = !0 : -1 != ua.indexOf("Chrome") ? goog.userAgent.product.detectedChrome_ = !0 : -1 != ua.indexOf("Android") ? goog.userAgent.product.detectedAndroid_ = !0 : -1 != ua.indexOf("Safari") && 
  (goog.userAgent.product.detectedSafari_ = !0));
};
goog.userAgent.product.PRODUCT_KNOWN_ || goog.userAgent.product.init_();
goog.userAgent.product.OPERA = goog.userAgent.OPERA;
goog.userAgent.product.IE = goog.userAgent.IE;
goog.userAgent.product.FIREFOX = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_FIREFOX : goog.userAgent.product.detectedFirefox_;
goog.userAgent.product.CAMINO = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_CAMINO : goog.userAgent.product.detectedCamino_;
goog.userAgent.product.IPHONE = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPHONE : goog.userAgent.product.detectedIphone_;
goog.userAgent.product.IPAD = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPAD : goog.userAgent.product.detectedIpad_;
goog.userAgent.product.ANDROID = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_ANDROID : goog.userAgent.product.detectedAndroid_;
goog.userAgent.product.CHROME = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_CHROME : goog.userAgent.product.detectedChrome_;
goog.userAgent.product.SAFARI = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_SAFARI : goog.userAgent.product.detectedSafari_;
// INPUT (javascript/closure/ui/buttonside.js)
goog.ui.ButtonSide = {NONE:0, START:1, END:2, BOTH:3};
// INPUT (javascript/closure/ui/buttonrenderer.js)
goog.ui.ButtonRenderer = function() {
};
goog.inherits(goog.ui.ButtonRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.ButtonRenderer);
goog.ui.ButtonRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-button";
goog.ui.ButtonRenderer.prototype.getAriaRole = function() {
  return goog.a11y.aria.Role.BUTTON;
};
goog.ui.ButtonRenderer.prototype.updateAriaState = function(element, state, enable) {
  switch(state) {
    case goog.ui.Component.State.SELECTED:
    ;
    case goog.ui.Component.State.CHECKED:
      goog.asserts.assert(element, "The button DOM element cannot be null.");
      goog.a11y.aria.setState(element, goog.a11y.aria.State.PRESSED, enable);
      break;
    default:
    ;
    case goog.ui.Component.State.OPENED:
    ;
    case goog.ui.Component.State.DISABLED:
      goog.ui.ButtonRenderer.superClass_.updateAriaState.call(this, element, state, enable);
  }
};
goog.ui.ButtonRenderer.prototype.createDom = function(button) {
  var element = goog.ui.ButtonRenderer.superClass_.createDom.call(this, button);
  this.setTooltip(element, button.getTooltip());
  var value = button.getValue();
  value && this.setValue(element, value);
  button.isSupportedState(goog.ui.Component.State.CHECKED) && this.updateAriaState(element, goog.ui.Component.State.CHECKED, button.isChecked());
  return element;
};
goog.ui.ButtonRenderer.prototype.decorate = function(button, element) {
  element = goog.ui.ButtonRenderer.superClass_.decorate.call(this, button, element);
  button.setValueInternal(this.getValue(element));
  button.setTooltipInternal(this.getTooltip(element));
  button.isSupportedState(goog.ui.Component.State.CHECKED) && this.updateAriaState(element, goog.ui.Component.State.CHECKED, button.isChecked());
  return element;
};
goog.ui.ButtonRenderer.prototype.getValue = goog.nullFunction;
goog.ui.ButtonRenderer.prototype.setValue = goog.nullFunction;
goog.ui.ButtonRenderer.prototype.getTooltip = function(element) {
  return element.title;
};
goog.ui.ButtonRenderer.prototype.setTooltip = function(element, tooltip) {
  element && (tooltip ? element.title = tooltip : element.removeAttribute("title"));
};
goog.ui.ButtonRenderer.prototype.setCollapsed = function(button, sides) {
  var isRtl = button.isRightToLeft(), collapseLeftClassName = this.getStructuralCssClass() + "-collapse-left", collapseRightClassName = this.getStructuralCssClass() + "-collapse-right";
  button.enableClassName(isRtl ? collapseRightClassName : collapseLeftClassName, !!(sides & goog.ui.ButtonSide.START));
  button.enableClassName(isRtl ? collapseLeftClassName : collapseRightClassName, !!(sides & goog.ui.ButtonSide.END));
};
goog.ui.ButtonRenderer.prototype.getCssClass = function() {
  return goog.ui.ButtonRenderer.CSS_CLASS;
};
// INPUT (javascript/closure/ui/nativebuttonrenderer.js)
goog.ui.NativeButtonRenderer = function() {
};
goog.inherits(goog.ui.NativeButtonRenderer, goog.ui.ButtonRenderer);
goog.addSingletonGetter(goog.ui.NativeButtonRenderer);
goog.ui.NativeButtonRenderer.prototype.getAriaRole = function() {
};
goog.ui.NativeButtonRenderer.prototype.createDom = function(button) {
  this.setUpNativeButton_(button);
  return button.getDomHelper().createDom("button", {"class":this.getClassNames(button).join(" "), disabled:!button.isEnabled(), title:button.getTooltip() || "", value:button.getValue() || ""}, button.getCaption() || "");
};
goog.ui.NativeButtonRenderer.prototype.canDecorate = function(element) {
  return "BUTTON" == element.tagName || "INPUT" == element.tagName && ("button" == element.type || "submit" == element.type || "reset" == element.type);
};
goog.ui.NativeButtonRenderer.prototype.decorate = function(button, element) {
  this.setUpNativeButton_(button);
  if (element.disabled) {
    var disabledClassName = goog.asserts.assertString(this.getClassForState(goog.ui.Component.State.DISABLED));
    goog.dom.classlist.add(element, disabledClassName);
  }
  return goog.ui.NativeButtonRenderer.superClass_.decorate.call(this, button, element);
};
goog.ui.NativeButtonRenderer.prototype.initializeDom = function(button) {
  button.getHandler().listen(button.getElement(), goog.events.EventType.CLICK, button.performActionInternal);
};
goog.ui.NativeButtonRenderer.prototype.setAllowTextSelection = goog.nullFunction;
goog.ui.NativeButtonRenderer.prototype.setRightToLeft = goog.nullFunction;
goog.ui.NativeButtonRenderer.prototype.isFocusable = function(button) {
  return button.isEnabled();
};
goog.ui.NativeButtonRenderer.prototype.setFocusable = goog.nullFunction;
goog.ui.NativeButtonRenderer.prototype.setState = function(button, state, enable) {
  goog.ui.NativeButtonRenderer.superClass_.setState.call(this, button, state, enable);
  var element = button.getElement();
  element && state == goog.ui.Component.State.DISABLED && (element.disabled = enable);
};
goog.ui.NativeButtonRenderer.prototype.getValue = function(element) {
  return element.value;
};
goog.ui.NativeButtonRenderer.prototype.setValue = function(element, value) {
  element && (element.value = value);
};
goog.ui.NativeButtonRenderer.prototype.updateAriaState = goog.nullFunction;
goog.ui.NativeButtonRenderer.prototype.setUpNativeButton_ = function(button) {
  button.setHandleMouseEvents(!1);
  button.setAutoStates(goog.ui.Component.State.ALL, !1);
  button.setSupportedState(goog.ui.Component.State.FOCUSED, !1);
};
// INPUT (javascript/closure/ui/button.js)
goog.ui.Button = function(opt_content, opt_renderer, opt_domHelper) {
  goog.ui.Control.call(this, opt_content, opt_renderer || goog.ui.NativeButtonRenderer.getInstance(), opt_domHelper);
};
goog.inherits(goog.ui.Button, goog.ui.Control);
goog.tagUnsealableClass(goog.ui.Button);
goog.ui.Button.Side = goog.ui.ButtonSide;
goog.ui.Button.prototype.getValue = function() {
  return this.value_;
};
goog.ui.Button.prototype.setValue = function(value) {
  this.value_ = value;
  var renderer = this.getRenderer();
  renderer.setValue(this.getElement(), value);
};
goog.ui.Button.prototype.setValueInternal = function(value) {
  this.value_ = value;
};
goog.ui.Button.prototype.getTooltip = function() {
  return this.tooltip_;
};
goog.ui.Button.prototype.setTooltip = function(tooltip) {
  this.tooltip_ = tooltip;
  this.getRenderer().setTooltip(this.getElement(), tooltip);
};
goog.ui.Button.prototype.setTooltipInternal = function(tooltip) {
  this.tooltip_ = tooltip;
};
goog.ui.Button.prototype.setCollapsed = function(sides) {
  this.getRenderer().setCollapsed(this, sides);
};
goog.ui.Button.prototype.disposeInternal = function() {
  goog.ui.Button.superClass_.disposeInternal.call(this);
  delete this.value_;
  delete this.tooltip_;
};
goog.ui.Button.prototype.enterDocument = function() {
  goog.ui.Button.superClass_.enterDocument.call(this);
  if (this.isSupportedState(goog.ui.Component.State.FOCUSED)) {
    var keyTarget = this.getKeyEventTarget();
    keyTarget && this.getHandler().listen(keyTarget, goog.events.EventType.KEYUP, this.handleKeyEventInternal);
  }
};
goog.ui.Button.prototype.handleKeyEventInternal = function(e) {
  return e.keyCode == goog.events.KeyCodes.ENTER && e.type == goog.events.KeyHandler.EventType.KEY || e.keyCode == goog.events.KeyCodes.SPACE && e.type == goog.events.EventType.KEYUP ? this.performActionInternal(e) : e.keyCode == goog.events.KeyCodes.SPACE;
};
goog.ui.registry.setDecoratorByClassName(goog.ui.ButtonRenderer.CSS_CLASS, function() {
  return new goog.ui.Button(null);
});
// INPUT (javascript/closure/ui/containerrenderer.js)
goog.ui.ContainerRenderer = function(opt_ariaRole) {
  this.ariaRole_ = opt_ariaRole;
};
goog.addSingletonGetter(goog.ui.ContainerRenderer);
goog.ui.ContainerRenderer.getCustomRenderer = function(ctor, cssClassName) {
  var renderer = new ctor;
  renderer.getCssClass = function() {
    return cssClassName;
  };
  return renderer;
};
goog.ui.ContainerRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-container";
goog.ui.ContainerRenderer.prototype.getAriaRole = function() {
  return this.ariaRole_;
};
goog.ui.ContainerRenderer.prototype.enableTabIndex = function(element, enable) {
  element && (element.tabIndex = enable ? 0 : -1);
};
goog.ui.ContainerRenderer.prototype.createDom = function(container) {
  return container.getDomHelper().createDom("div", this.getClassNames(container).join(" "));
};
goog.ui.ContainerRenderer.prototype.getContentElement = function(element) {
  return element;
};
goog.ui.ContainerRenderer.prototype.canDecorate = function(element) {
  return "DIV" == element.tagName;
};
goog.ui.ContainerRenderer.prototype.decorate = function(container, element) {
  element.id && container.setId(element.id);
  var baseClass = this.getCssClass(), hasBaseClass = !1, classNames = goog.dom.classlist.get(element);
  classNames && goog.array.forEach(classNames, function(className) {
    className == baseClass ? hasBaseClass = !0 : className && this.setStateFromClassName(container, className, baseClass);
  }, this);
  hasBaseClass || goog.dom.classlist.add(element, baseClass);
  this.decorateChildren(container, this.getContentElement(element));
  return element;
};
goog.ui.ContainerRenderer.prototype.setStateFromClassName = function(container, className, baseClass) {
  className == baseClass + "-disabled" ? container.setEnabled(!1) : className == baseClass + "-horizontal" ? container.setOrientation(goog.ui.Container.Orientation.HORIZONTAL) : className == baseClass + "-vertical" && container.setOrientation(goog.ui.Container.Orientation.VERTICAL);
};
goog.ui.ContainerRenderer.prototype.decorateChildren = function(container, element, opt_firstChild) {
  if (element) {
    for (var node = opt_firstChild || element.firstChild, next;node && node.parentNode == element;) {
      next = node.nextSibling;
      if (node.nodeType == goog.dom.NodeType.ELEMENT) {
        var child = this.getDecoratorForChild(node);
        child && (child.setElementInternal(node), container.isEnabled() || child.setEnabled(!1), container.addChild(child), child.decorate(node));
      } else {
        node.nodeValue && "" != goog.string.trim(node.nodeValue) || element.removeChild(node);
      }
      node = next;
    }
  }
};
goog.ui.ContainerRenderer.prototype.getDecoratorForChild = function(element) {
  return goog.ui.registry.getDecorator(element);
};
goog.ui.ContainerRenderer.prototype.initializeDom = function(container) {
  var elem = container.getElement();
  goog.asserts.assert(elem, "The container DOM element cannot be null.");
  goog.style.setUnselectable(elem, !0, goog.userAgent.GECKO);
  goog.userAgent.IE && (elem.hideFocus = !0);
  var ariaRole = this.getAriaRole();
  ariaRole && goog.a11y.aria.setRole(elem, ariaRole);
};
goog.ui.ContainerRenderer.prototype.getKeyEventTarget = function(container) {
  return container.getElement();
};
goog.ui.ContainerRenderer.prototype.getCssClass = function() {
  return goog.ui.ContainerRenderer.CSS_CLASS;
};
goog.ui.ContainerRenderer.prototype.getClassNames = function(container) {
  var baseClass = this.getCssClass(), isHorizontal = container.getOrientation() == goog.ui.Container.Orientation.HORIZONTAL, classNames = [baseClass, isHorizontal ? baseClass + "-horizontal" : baseClass + "-vertical"];
  container.isEnabled() || classNames.push(baseClass + "-disabled");
  return classNames;
};
goog.ui.ContainerRenderer.prototype.getDefaultOrientation = function() {
  return goog.ui.Container.Orientation.VERTICAL;
};
// INPUT (javascript/closure/ui/container.js)
goog.ui.Container = function(opt_orientation, opt_renderer, opt_domHelper) {
  goog.ui.Component.call(this, opt_domHelper);
  this.renderer_ = opt_renderer || goog.ui.ContainerRenderer.getInstance();
  this.orientation_ = opt_orientation || this.renderer_.getDefaultOrientation();
};
goog.inherits(goog.ui.Container, goog.ui.Component);
goog.tagUnsealableClass(goog.ui.Container);
goog.ui.Container.EventType = {AFTER_SHOW:"aftershow", AFTER_HIDE:"afterhide"};
goog.ui.Container.Orientation = {HORIZONTAL:"horizontal", VERTICAL:"vertical"};
goog.ui.Container.prototype.keyEventTarget_ = null;
goog.ui.Container.prototype.keyHandler_ = null;
goog.ui.Container.prototype.renderer_ = null;
goog.ui.Container.prototype.orientation_ = null;
goog.ui.Container.prototype.visible_ = !0;
goog.ui.Container.prototype.enabled_ = !0;
goog.ui.Container.prototype.focusable_ = !0;
goog.ui.Container.prototype.highlightedIndex_ = -1;
goog.ui.Container.prototype.openItem_ = null;
goog.ui.Container.prototype.mouseButtonPressed_ = !1;
goog.ui.Container.prototype.allowFocusableChildren_ = !1;
goog.ui.Container.prototype.openFollowsHighlight_ = !0;
goog.ui.Container.prototype.childElementIdMap_ = null;
goog.ui.Container.prototype.getKeyEventTarget = function() {
  return this.keyEventTarget_ || this.renderer_.getKeyEventTarget(this);
};
goog.ui.Container.prototype.getKeyHandler = function() {
  return this.keyHandler_ || (this.keyHandler_ = new goog.events.KeyHandler(this.getKeyEventTarget()));
};
goog.ui.Container.prototype.getRenderer = function() {
  return this.renderer_;
};
goog.ui.Container.prototype.setRenderer = function(renderer) {
  if (this.getElement()) {
    throw Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  this.renderer_ = renderer;
};
goog.ui.Container.prototype.createDom = function() {
  this.setElementInternal(this.renderer_.createDom(this));
};
goog.ui.Container.prototype.getContentElement = function() {
  return this.renderer_.getContentElement(this.getElement());
};
goog.ui.Container.prototype.canDecorate = function(element) {
  return this.renderer_.canDecorate(element);
};
goog.ui.Container.prototype.decorateInternal = function(element) {
  this.setElementInternal(this.renderer_.decorate(this, element));
  "none" == element.style.display && (this.visible_ = !1);
};
goog.ui.Container.prototype.enterDocument = function() {
  goog.ui.Container.superClass_.enterDocument.call(this);
  this.forEachChild(function(child) {
    child.isInDocument() && this.registerChildId_(child);
  }, this);
  var elem = this.getElement();
  this.renderer_.initializeDom(this);
  this.setVisible(this.visible_, !0);
  this.getHandler().listen(this, goog.ui.Component.EventType.ENTER, this.handleEnterItem).listen(this, goog.ui.Component.EventType.HIGHLIGHT, this.handleHighlightItem).listen(this, goog.ui.Component.EventType.UNHIGHLIGHT, this.handleUnHighlightItem).listen(this, goog.ui.Component.EventType.OPEN, this.handleOpenItem).listen(this, goog.ui.Component.EventType.CLOSE, this.handleCloseItem).listen(elem, goog.events.EventType.MOUSEDOWN, this.handleMouseDown).listen(goog.dom.getOwnerDocument(elem), goog.events.EventType.MOUSEUP, 
  this.handleDocumentMouseUp).listen(elem, [goog.events.EventType.MOUSEDOWN, goog.events.EventType.MOUSEUP, goog.events.EventType.MOUSEOVER, goog.events.EventType.MOUSEOUT, goog.events.EventType.CONTEXTMENU], this.handleChildMouseEvents);
  this.isFocusable() && this.enableFocusHandling_(!0);
};
goog.ui.Container.prototype.enableFocusHandling_ = function(enable) {
  var handler = this.getHandler(), keyTarget = this.getKeyEventTarget();
  enable ? handler.listen(keyTarget, goog.events.EventType.FOCUS, this.handleFocus).listen(keyTarget, goog.events.EventType.BLUR, this.handleBlur).listen(this.getKeyHandler(), goog.events.KeyHandler.EventType.KEY, this.handleKeyEvent) : handler.unlisten(keyTarget, goog.events.EventType.FOCUS, this.handleFocus).unlisten(keyTarget, goog.events.EventType.BLUR, this.handleBlur).unlisten(this.getKeyHandler(), goog.events.KeyHandler.EventType.KEY, this.handleKeyEvent);
};
goog.ui.Container.prototype.exitDocument = function() {
  this.setHighlightedIndex(-1);
  this.openItem_ && this.openItem_.setOpen(!1);
  this.mouseButtonPressed_ = !1;
  goog.ui.Container.superClass_.exitDocument.call(this);
};
goog.ui.Container.prototype.disposeInternal = function() {
  goog.ui.Container.superClass_.disposeInternal.call(this);
  this.keyHandler_ && (this.keyHandler_.dispose(), this.keyHandler_ = null);
  this.renderer_ = this.openItem_ = this.childElementIdMap_ = this.keyEventTarget_ = null;
};
goog.ui.Container.prototype.handleEnterItem = function() {
  return!0;
};
goog.ui.Container.prototype.handleHighlightItem = function(e) {
  var index = this.indexOfChild(e.target);
  if (-1 < index && index != this.highlightedIndex_) {
    var item = this.getHighlighted();
    item && item.setHighlighted(!1);
    this.highlightedIndex_ = index;
    item = this.getHighlighted();
    this.isMouseButtonPressed() && item.setActive(!0);
    this.openFollowsHighlight_ && this.openItem_ && item != this.openItem_ && (item.isSupportedState(goog.ui.Component.State.OPENED) ? item.setOpen(!0) : this.openItem_.setOpen(!1));
  }
  var element = this.getElement();
  goog.asserts.assert(element, "The DOM element for the container cannot be null.");
  null != e.target.getElement() && goog.a11y.aria.setState(element, goog.a11y.aria.State.ACTIVEDESCENDANT, e.target.getElement().id);
};
goog.ui.Container.prototype.handleUnHighlightItem = function(e) {
  e.target == this.getHighlighted() && (this.highlightedIndex_ = -1);
  var element = this.getElement();
  goog.asserts.assert(element, "The DOM element for the container cannot be null.");
  goog.a11y.aria.removeState(element, goog.a11y.aria.State.ACTIVEDESCENDANT);
};
goog.ui.Container.prototype.handleOpenItem = function(e) {
  var item = e.target;
  item && item != this.openItem_ && item.getParent() == this && (this.openItem_ && this.openItem_.setOpen(!1), this.openItem_ = item);
};
goog.ui.Container.prototype.handleCloseItem = function(e) {
  e.target == this.openItem_ && (this.openItem_ = null);
};
goog.ui.Container.prototype.handleMouseDown = function(e) {
  this.enabled_ && this.setMouseButtonPressed(!0);
  var keyTarget = this.getKeyEventTarget();
  keyTarget && goog.dom.isFocusableTabIndex(keyTarget) ? keyTarget.focus() : e.preventDefault();
};
goog.ui.Container.prototype.handleDocumentMouseUp = function() {
  this.setMouseButtonPressed(!1);
};
goog.ui.Container.prototype.handleChildMouseEvents = function(e) {
  var control = this.getOwnerControl(e.target);
  if (control) {
    switch(e.type) {
      case goog.events.EventType.MOUSEDOWN:
        control.handleMouseDown(e);
        break;
      case goog.events.EventType.MOUSEUP:
        control.handleMouseUp(e);
        break;
      case goog.events.EventType.MOUSEOVER:
        control.handleMouseOver(e);
        break;
      case goog.events.EventType.MOUSEOUT:
        control.handleMouseOut(e);
        break;
      case goog.events.EventType.CONTEXTMENU:
        control.handleContextMenu(e);
    }
  }
};
goog.ui.Container.prototype.getOwnerControl = function(node) {
  if (this.childElementIdMap_) {
    for (var elem = this.getElement();node && node !== elem;) {
      var id = node.id;
      if (id in this.childElementIdMap_) {
        return this.childElementIdMap_[id];
      }
      node = node.parentNode;
    }
  }
  return null;
};
goog.ui.Container.prototype.handleFocus = function() {
};
goog.ui.Container.prototype.handleBlur = function() {
  this.setHighlightedIndex(-1);
  this.setMouseButtonPressed(!1);
  this.openItem_ && this.openItem_.setOpen(!1);
};
goog.ui.Container.prototype.handleKeyEvent = function(e) {
  return this.isEnabled() && this.isVisible() && (0 != this.getChildCount() || this.keyEventTarget_) && this.handleKeyEventInternal(e) ? (e.preventDefault(), e.stopPropagation(), !0) : !1;
};
goog.ui.Container.prototype.handleKeyEventInternal = function(e) {
  var highlighted = this.getHighlighted();
  if (highlighted && "function" == typeof highlighted.handleKeyEvent && highlighted.handleKeyEvent(e) || this.openItem_ && this.openItem_ != highlighted && "function" == typeof this.openItem_.handleKeyEvent && this.openItem_.handleKeyEvent(e)) {
    return!0;
  }
  if (e.shiftKey || e.ctrlKey || e.metaKey || e.altKey) {
    return!1;
  }
  switch(e.keyCode) {
    case goog.events.KeyCodes.ESC:
      if (this.isFocusable()) {
        this.getKeyEventTarget().blur();
      } else {
        return!1;
      }
      break;
    case goog.events.KeyCodes.HOME:
      this.highlightFirst();
      break;
    case goog.events.KeyCodes.END:
      this.highlightLast();
      break;
    case goog.events.KeyCodes.UP:
      if (this.orientation_ == goog.ui.Container.Orientation.VERTICAL) {
        this.highlightPrevious();
      } else {
        return!1;
      }
      break;
    case goog.events.KeyCodes.LEFT:
      if (this.orientation_ == goog.ui.Container.Orientation.HORIZONTAL) {
        this.isRightToLeft() ? this.highlightNext() : this.highlightPrevious();
      } else {
        return!1;
      }
      break;
    case goog.events.KeyCodes.DOWN:
      if (this.orientation_ == goog.ui.Container.Orientation.VERTICAL) {
        this.highlightNext();
      } else {
        return!1;
      }
      break;
    case goog.events.KeyCodes.RIGHT:
      if (this.orientation_ == goog.ui.Container.Orientation.HORIZONTAL) {
        this.isRightToLeft() ? this.highlightPrevious() : this.highlightNext();
      } else {
        return!1;
      }
      break;
    default:
      return!1;
  }
  return!0;
};
goog.ui.Container.prototype.registerChildId_ = function(child) {
  var childElem = child.getElement(), id = childElem.id || (childElem.id = child.getId());
  this.childElementIdMap_ || (this.childElementIdMap_ = {});
  this.childElementIdMap_[id] = child;
};
goog.ui.Container.prototype.addChild = function(child, opt_render) {
  goog.asserts.assertInstanceof(child, goog.ui.Control, "The child of a container must be a control");
  goog.ui.Container.superClass_.addChild.call(this, child, opt_render);
};
goog.ui.Container.prototype.addChildAt = function(control, index, opt_render) {
  goog.asserts.assertInstanceof(control, goog.ui.Control);
  control.setDispatchTransitionEvents(goog.ui.Component.State.HOVER, !0);
  control.setDispatchTransitionEvents(goog.ui.Component.State.OPENED, !0);
  !this.isFocusable() && this.isFocusableChildrenAllowed() || control.setSupportedState(goog.ui.Component.State.FOCUSED, !1);
  control.setHandleMouseEvents(!1);
  var srcIndex = control.getParent() == this ? this.indexOfChild(control) : -1;
  goog.ui.Container.superClass_.addChildAt.call(this, control, index, opt_render);
  control.isInDocument() && this.isInDocument() && this.registerChildId_(control);
  this.updateHighlightedIndex_(srcIndex, index);
};
goog.ui.Container.prototype.updateHighlightedIndex_ = function(fromIndex, toIndex) {
  -1 == fromIndex && (fromIndex = this.getChildCount());
  fromIndex == this.highlightedIndex_ ? this.highlightedIndex_ = Math.min(this.getChildCount() - 1, toIndex) : fromIndex > this.highlightedIndex_ && toIndex <= this.highlightedIndex_ ? this.highlightedIndex_++ : fromIndex < this.highlightedIndex_ && toIndex > this.highlightedIndex_ && this.highlightedIndex_--;
};
goog.ui.Container.prototype.removeChild = function(control, opt_unrender) {
  control = goog.isString(control) ? this.getChild(control) : control;
  goog.asserts.assertInstanceof(control, goog.ui.Control);
  if (control) {
    var index = this.indexOfChild(control);
    -1 != index && (index == this.highlightedIndex_ ? (control.setHighlighted(!1), this.highlightedIndex_ = -1) : index < this.highlightedIndex_ && this.highlightedIndex_--);
    var childElem = control.getElement();
    childElem && childElem.id && this.childElementIdMap_ && goog.object.remove(this.childElementIdMap_, childElem.id);
  }
  control = goog.ui.Container.superClass_.removeChild.call(this, control, opt_unrender);
  control.setHandleMouseEvents(!0);
  return control;
};
goog.ui.Container.prototype.getOrientation = function() {
  return this.orientation_;
};
goog.ui.Container.prototype.setOrientation = function(orientation) {
  if (this.getElement()) {
    throw Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  this.orientation_ = orientation;
};
goog.ui.Container.prototype.isVisible = function() {
  return this.visible_;
};
goog.ui.Container.prototype.setVisible = function(visible, opt_force) {
  if (opt_force || this.visible_ != visible && this.dispatchEvent(visible ? goog.ui.Component.EventType.SHOW : goog.ui.Component.EventType.HIDE)) {
    this.visible_ = visible;
    var elem = this.getElement();
    elem && (goog.style.setElementShown(elem, visible), this.isFocusable() && this.renderer_.enableTabIndex(this.getKeyEventTarget(), this.enabled_ && this.visible_), opt_force || this.dispatchEvent(this.visible_ ? goog.ui.Container.EventType.AFTER_SHOW : goog.ui.Container.EventType.AFTER_HIDE));
    return!0;
  }
  return!1;
};
goog.ui.Container.prototype.isEnabled = function() {
  return this.enabled_;
};
goog.ui.Container.prototype.setEnabled = function(enable) {
  this.enabled_ != enable && this.dispatchEvent(enable ? goog.ui.Component.EventType.ENABLE : goog.ui.Component.EventType.DISABLE) && (enable ? (this.enabled_ = !0, this.forEachChild(function(child) {
    child.wasDisabled ? delete child.wasDisabled : child.setEnabled(!0);
  })) : (this.forEachChild(function(child) {
    child.isEnabled() ? child.setEnabled(!1) : child.wasDisabled = !0;
  }), this.enabled_ = !1, this.setMouseButtonPressed(!1)), this.isFocusable() && this.renderer_.enableTabIndex(this.getKeyEventTarget(), enable && this.visible_));
};
goog.ui.Container.prototype.isFocusable = function() {
  return this.focusable_;
};
goog.ui.Container.prototype.setFocusable = function(focusable) {
  focusable != this.focusable_ && this.isInDocument() && this.enableFocusHandling_(focusable);
  this.focusable_ = focusable;
  this.enabled_ && this.visible_ && this.renderer_.enableTabIndex(this.getKeyEventTarget(), focusable);
};
goog.ui.Container.prototype.isFocusableChildrenAllowed = function() {
  return this.allowFocusableChildren_;
};
goog.ui.Container.prototype.setHighlightedIndex = function(index) {
  var child = this.getChildAt(index);
  child ? child.setHighlighted(!0) : -1 < this.highlightedIndex_ && this.getHighlighted().setHighlighted(!1);
};
goog.ui.Container.prototype.setHighlighted = function(item) {
  this.setHighlightedIndex(this.indexOfChild(item));
};
goog.ui.Container.prototype.getHighlighted = function() {
  return this.getChildAt(this.highlightedIndex_);
};
goog.ui.Container.prototype.highlightFirst = function() {
  this.highlightHelper(function(index, max) {
    return(index + 1) % max;
  }, this.getChildCount() - 1);
};
goog.ui.Container.prototype.highlightLast = function() {
  this.highlightHelper(function(index, max) {
    index--;
    return 0 > index ? max - 1 : index;
  }, 0);
};
goog.ui.Container.prototype.highlightNext = function() {
  this.highlightHelper(function(index, max) {
    return(index + 1) % max;
  }, this.highlightedIndex_);
};
goog.ui.Container.prototype.highlightPrevious = function() {
  this.highlightHelper(function(index, max) {
    index--;
    return 0 > index ? max - 1 : index;
  }, this.highlightedIndex_);
};
goog.ui.Container.prototype.highlightHelper = function(fn, startIndex) {
  for (var curIndex = 0 > startIndex ? this.indexOfChild(this.openItem_) : startIndex, numItems = this.getChildCount(), curIndex = fn.call(this, curIndex, numItems), visited = 0;visited <= numItems;) {
    var control = this.getChildAt(curIndex);
    if (control && this.canHighlightItem(control)) {
      return this.setHighlightedIndexFromKeyEvent(curIndex), !0;
    }
    visited++;
    curIndex = fn.call(this, curIndex, numItems);
  }
  return!1;
};
goog.ui.Container.prototype.canHighlightItem = function(item) {
  return item.isVisible() && item.isEnabled() && item.isSupportedState(goog.ui.Component.State.HOVER);
};
goog.ui.Container.prototype.setHighlightedIndexFromKeyEvent = function(index) {
  this.setHighlightedIndex(index);
};
goog.ui.Container.prototype.isMouseButtonPressed = function() {
  return this.mouseButtonPressed_;
};
goog.ui.Container.prototype.setMouseButtonPressed = function(pressed) {
  this.mouseButtonPressed_ = pressed;
};
// INPUT (javascript/closure/ui/menuheaderrenderer.js)
goog.ui.MenuHeaderRenderer = function() {
};
goog.inherits(goog.ui.MenuHeaderRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.MenuHeaderRenderer);
goog.ui.MenuHeaderRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-menuheader";
goog.ui.MenuHeaderRenderer.prototype.getCssClass = function() {
  return goog.ui.MenuHeaderRenderer.CSS_CLASS;
};
// INPUT (javascript/closure/ui/menuheader.js)
goog.ui.MenuHeader = function(content, opt_domHelper, opt_renderer) {
  goog.ui.Control.call(this, content, opt_renderer || goog.ui.MenuHeaderRenderer.getInstance(), opt_domHelper);
  this.setSupportedState(goog.ui.Component.State.DISABLED, !1);
  this.setSupportedState(goog.ui.Component.State.HOVER, !1);
  this.setSupportedState(goog.ui.Component.State.ACTIVE, !1);
  this.setSupportedState(goog.ui.Component.State.FOCUSED, !1);
  this.setStateInternal(goog.ui.Component.State.DISABLED);
};
goog.inherits(goog.ui.MenuHeader, goog.ui.Control);
goog.ui.registry.setDecoratorByClassName(goog.ui.MenuHeaderRenderer.CSS_CLASS, function() {
  return new goog.ui.MenuHeader(null);
});
// INPUT (javascript/closure/ui/menuseparatorrenderer.js)
goog.ui.MenuSeparatorRenderer = function() {
};
goog.inherits(goog.ui.MenuSeparatorRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.MenuSeparatorRenderer);
goog.ui.MenuSeparatorRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-menuseparator";
goog.ui.MenuSeparatorRenderer.prototype.createDom = function(separator) {
  return separator.getDomHelper().createDom("div", this.getCssClass());
};
goog.ui.MenuSeparatorRenderer.prototype.decorate = function(separator, element) {
  element.id && separator.setId(element.id);
  if ("HR" == element.tagName) {
    var hr = element;
    element = this.createDom(separator);
    goog.dom.insertSiblingBefore(element, hr);
    goog.dom.removeNode(hr);
  } else {
    goog.dom.classlist.add(element, this.getCssClass());
  }
  return element;
};
goog.ui.MenuSeparatorRenderer.prototype.setContent = function() {
};
goog.ui.MenuSeparatorRenderer.prototype.getCssClass = function() {
  return goog.ui.MenuSeparatorRenderer.CSS_CLASS;
};
// INPUT (javascript/closure/ui/separator.js)
goog.ui.Separator = function(opt_renderer, opt_domHelper) {
  goog.ui.Control.call(this, null, opt_renderer || goog.ui.MenuSeparatorRenderer.getInstance(), opt_domHelper);
  this.setSupportedState(goog.ui.Component.State.DISABLED, !1);
  this.setSupportedState(goog.ui.Component.State.HOVER, !1);
  this.setSupportedState(goog.ui.Component.State.ACTIVE, !1);
  this.setSupportedState(goog.ui.Component.State.FOCUSED, !1);
  this.setStateInternal(goog.ui.Component.State.DISABLED);
};
goog.inherits(goog.ui.Separator, goog.ui.Control);
goog.ui.Separator.prototype.enterDocument = function() {
  goog.ui.Separator.superClass_.enterDocument.call(this);
  var element = this.getElement();
  goog.asserts.assert(element, "The DOM element for the separator cannot be null.");
  goog.a11y.aria.setRole(element, "separator");
};
goog.ui.registry.setDecoratorByClassName(goog.ui.MenuSeparatorRenderer.CSS_CLASS, function() {
  return new goog.ui.Separator;
});
// INPUT (javascript/closure/ui/menurenderer.js)
goog.ui.MenuRenderer = function(opt_ariaRole) {
  goog.ui.ContainerRenderer.call(this, opt_ariaRole || goog.a11y.aria.Role.MENU);
};
goog.inherits(goog.ui.MenuRenderer, goog.ui.ContainerRenderer);
goog.addSingletonGetter(goog.ui.MenuRenderer);
goog.ui.MenuRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-menu";
goog.ui.MenuRenderer.prototype.canDecorate = function(element) {
  return "UL" == element.tagName || goog.ui.MenuRenderer.superClass_.canDecorate.call(this, element);
};
goog.ui.MenuRenderer.prototype.getDecoratorForChild = function(element) {
  return "HR" == element.tagName ? new goog.ui.Separator : goog.ui.MenuRenderer.superClass_.getDecoratorForChild.call(this, element);
};
goog.ui.MenuRenderer.prototype.containsElement = function(menu, element) {
  return goog.dom.contains(menu.getElement(), element);
};
goog.ui.MenuRenderer.prototype.getCssClass = function() {
  return goog.ui.MenuRenderer.CSS_CLASS;
};
goog.ui.MenuRenderer.prototype.initializeDom = function(container) {
  goog.ui.MenuRenderer.superClass_.initializeDom.call(this, container);
  var element = container.getElement();
  goog.asserts.assert(element, "The menu DOM element cannot be null.");
  goog.a11y.aria.setState(element, goog.a11y.aria.State.HASPOPUP, "true");
};
// INPUT (javascript/closure/ui/menuseparator.js)
goog.ui.MenuSeparator = function(opt_domHelper) {
  goog.ui.Separator.call(this, goog.ui.MenuSeparatorRenderer.getInstance(), opt_domHelper);
};
goog.inherits(goog.ui.MenuSeparator, goog.ui.Separator);
goog.ui.registry.setDecoratorByClassName(goog.ui.MenuSeparatorRenderer.CSS_CLASS, function() {
  return new goog.ui.Separator;
});
// INPUT (javascript/closure/ui/menu.js)
goog.ui.Menu = function(opt_domHelper, opt_renderer) {
  goog.ui.Container.call(this, goog.ui.Container.Orientation.VERTICAL, opt_renderer || goog.ui.MenuRenderer.getInstance(), opt_domHelper);
  this.setFocusable(!1);
};
goog.inherits(goog.ui.Menu, goog.ui.Container);
goog.tagUnsealableClass(goog.ui.Menu);
goog.ui.Menu.EventType = {BEFORE_SHOW:goog.ui.Component.EventType.BEFORE_SHOW, SHOW:goog.ui.Component.EventType.SHOW, BEFORE_HIDE:goog.ui.Component.EventType.HIDE, HIDE:goog.ui.Component.EventType.HIDE};
goog.ui.Menu.CSS_CLASS = goog.ui.MenuRenderer.CSS_CLASS;
goog.ui.Menu.prototype.allowAutoFocus_ = !0;
goog.ui.Menu.prototype.allowHighlightDisabled_ = !1;
goog.ui.Menu.prototype.getCssClass = function() {
  return this.getRenderer().getCssClass();
};
goog.ui.Menu.prototype.containsElement = function(element) {
  if (this.getRenderer().containsElement(this, element)) {
    return!0;
  }
  for (var i = 0, count = this.getChildCount();i < count;i++) {
    var child = this.getChildAt(i);
    if ("function" == typeof child.containsElement && child.containsElement(element)) {
      return!0;
    }
  }
  return!1;
};
goog.ui.Menu.prototype.addItem = function(item) {
  this.addChild(item, !0);
};
goog.ui.Menu.prototype.addItemAt = function(item, n) {
  this.addChildAt(item, n, !0);
};
goog.ui.Menu.prototype.removeItem = function(item) {
  var removedChild = this.removeChild(item, !0);
  removedChild && removedChild.dispose();
};
goog.ui.Menu.prototype.getItemAt = function(n) {
  return this.getChildAt(n);
};
goog.ui.Menu.prototype.getItemCount = function() {
  return this.getChildCount();
};
goog.ui.Menu.prototype.getItems = function() {
  var children = [];
  this.forEachChild(function(child) {
    children.push(child);
  });
  return children;
};
goog.ui.Menu.prototype.setPosition = function(x, opt_y) {
  var visible = this.isVisible();
  visible || goog.style.setElementShown(this.getElement(), !0);
  goog.style.setPageOffset(this.getElement(), x, opt_y);
  visible || goog.style.setElementShown(this.getElement(), !1);
};
goog.ui.Menu.prototype.getPosition = function() {
  return this.isVisible() ? goog.style.getPageOffset(this.getElement()) : null;
};
goog.ui.Menu.prototype.setAllowAutoFocus = function(allow) {
  (this.allowAutoFocus_ = allow) && this.setFocusable(!0);
};
goog.ui.Menu.prototype.setAllowHighlightDisabled = function(allow) {
  this.allowHighlightDisabled_ = allow;
};
goog.ui.Menu.prototype.setVisible = function(show, opt_force, opt_e) {
  var visibilityChanged = goog.ui.Menu.superClass_.setVisible.call(this, show, opt_force);
  visibilityChanged && show && this.isInDocument() && this.allowAutoFocus_ && this.getKeyEventTarget().focus();
  this.openingCoords = show && opt_e && goog.isNumber(opt_e.clientX) ? new goog.math.Coordinate(opt_e.clientX, opt_e.clientY) : null;
  return visibilityChanged;
};
goog.ui.Menu.prototype.handleEnterItem = function(e) {
  this.allowAutoFocus_ && this.getKeyEventTarget().focus();
  return goog.ui.Menu.superClass_.handleEnterItem.call(this, e);
};
goog.ui.Menu.prototype.canHighlightItem = function(item) {
  return(this.allowHighlightDisabled_ || item.isEnabled()) && item.isVisible() && item.isSupportedState(goog.ui.Component.State.HOVER);
};
goog.ui.Menu.prototype.decorateInternal = function(element) {
  this.decorateContent(element);
  goog.ui.Menu.superClass_.decorateInternal.call(this, element);
};
goog.ui.Menu.prototype.handleKeyEventInternal = function(e) {
  var handled = goog.ui.Menu.superClass_.handleKeyEventInternal.call(this, e);
  handled || this.forEachChild(function(menuItem) {
    !handled && menuItem.getMnemonic && menuItem.getMnemonic() == e.keyCode && (this.isEnabled() && this.setHighlighted(menuItem), handled = menuItem.handleKeyEvent(e));
  }, this);
  return handled;
};
goog.ui.Menu.prototype.setHighlightedIndex = function(index) {
  goog.ui.Menu.superClass_.setHighlightedIndex.call(this, index);
  var child = this.getChildAt(index);
  child && goog.style.scrollIntoContainerView(child.getElement(), this.getElement());
};
goog.ui.Menu.prototype.decorateContent = function(element) {
  for (var renderer = this.getRenderer(), contentElements = this.getDomHelper().getElementsByTagNameAndClass("div", renderer.getCssClass() + "-content", element), length = contentElements.length, i = 0;i < length;i++) {
    renderer.decorateChildren(this, contentElements[i]);
  }
};
// INPUT (javascript/closure/ui/cssnames.js)
goog.ui.INLINE_BLOCK_CLASSNAME = "aAAaGVIZSENTINELaAAa-inline-block";
// INPUT (javascript/closure/ui/custombuttonrenderer.js)
goog.ui.CustomButtonRenderer = function() {
};
goog.inherits(goog.ui.CustomButtonRenderer, goog.ui.ButtonRenderer);
goog.addSingletonGetter(goog.ui.CustomButtonRenderer);
goog.ui.CustomButtonRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-custom-button";
goog.ui.CustomButtonRenderer.prototype.createDom = function(control) {
  var button = control, classNames = this.getClassNames(button), attributes = {"class":goog.ui.INLINE_BLOCK_CLASSNAME + " " + classNames.join(" ")}, buttonElement = button.getDomHelper().createDom("div", attributes, this.createButton(button.getContent(), button.getDomHelper()));
  this.setTooltip(buttonElement, button.getTooltip());
  this.setAriaStates(button, buttonElement);
  return buttonElement;
};
goog.ui.CustomButtonRenderer.prototype.getAriaRole = function() {
  return goog.a11y.aria.Role.BUTTON;
};
goog.ui.CustomButtonRenderer.prototype.getContentElement = function(element) {
  return element && element.firstChild && element.firstChild.firstChild;
};
goog.ui.CustomButtonRenderer.prototype.createButton = function(content, dom) {
  return dom.createDom("div", goog.ui.INLINE_BLOCK_CLASSNAME + " " + (this.getCssClass() + "-outer-box"), dom.createDom("div", goog.ui.INLINE_BLOCK_CLASSNAME + " " + (this.getCssClass() + "-inner-box"), content));
};
goog.ui.CustomButtonRenderer.prototype.canDecorate = function(element) {
  return "DIV" == element.tagName;
};
goog.ui.CustomButtonRenderer.prototype.hasBoxStructure = function(button, element) {
  var outer = button.getDomHelper().getFirstElementChild(element), outerClassName = this.getCssClass() + "-outer-box";
  if (outer && goog.dom.classlist.contains(outer, outerClassName)) {
    var inner = button.getDomHelper().getFirstElementChild(outer), innerClassName = this.getCssClass() + "-inner-box";
    if (inner && goog.dom.classlist.contains(inner, innerClassName)) {
      return!0;
    }
  }
  return!1;
};
goog.ui.CustomButtonRenderer.prototype.decorate = function(control, element) {
  goog.asserts.assert(element);
  var button = control;
  goog.ui.CustomButtonRenderer.trimTextNodes_(element, !0);
  goog.ui.CustomButtonRenderer.trimTextNodes_(element, !1);
  this.hasBoxStructure(button, element) || element.appendChild(this.createButton(element.childNodes, button.getDomHelper()));
  goog.dom.classlist.addAll(element, [goog.ui.INLINE_BLOCK_CLASSNAME, this.getCssClass()]);
  return goog.ui.CustomButtonRenderer.superClass_.decorate.call(this, button, element);
};
goog.ui.CustomButtonRenderer.prototype.getCssClass = function() {
  return goog.ui.CustomButtonRenderer.CSS_CLASS;
};
goog.ui.CustomButtonRenderer.trimTextNodes_ = function(element, fromStart) {
  if (element) {
    for (var node = fromStart ? element.firstChild : element.lastChild, next;node && node.parentNode == element;) {
      next = fromStart ? node.nextSibling : node.previousSibling;
      if (node.nodeType == goog.dom.NodeType.TEXT) {
        var text = node.nodeValue;
        if ("" == goog.string.trim(text)) {
          element.removeChild(node);
        } else {
          node.nodeValue = fromStart ? goog.string.trimLeft(text) : goog.string.trimRight(text);
          break;
        }
      } else {
        break;
      }
      node = next;
    }
  }
};
// INPUT (javascript/closure/ui/menubuttonrenderer.js)
goog.ui.MenuButtonRenderer = function() {
};
goog.inherits(goog.ui.MenuButtonRenderer, goog.ui.CustomButtonRenderer);
goog.addSingletonGetter(goog.ui.MenuButtonRenderer);
goog.ui.MenuButtonRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-menu-button";
goog.ui.MenuButtonRenderer.prototype.getContentElement = function(element) {
  return goog.ui.MenuButtonRenderer.superClass_.getContentElement.call(this, element && element.firstChild);
};
goog.ui.MenuButtonRenderer.prototype.decorate = function(control, element) {
  var button = control, menuElem = goog.dom.getElementsByTagNameAndClass("*", goog.ui.MenuRenderer.CSS_CLASS, element)[0];
  if (menuElem) {
    goog.style.setElementShown(menuElem, !1);
    goog.dom.appendChild(goog.dom.getOwnerDocument(menuElem).body, menuElem);
    var menu = new goog.ui.Menu;
    menu.decorate(menuElem);
    button.setMenu(menu);
  }
  return goog.ui.MenuButtonRenderer.superClass_.decorate.call(this, button, element);
};
goog.ui.MenuButtonRenderer.prototype.createButton = function(content, dom) {
  return goog.ui.MenuButtonRenderer.superClass_.createButton.call(this, [this.createCaption(content, dom), this.createDropdown(dom)], dom);
};
goog.ui.MenuButtonRenderer.prototype.createCaption = function(content, dom) {
  return goog.ui.MenuButtonRenderer.wrapCaption(content, this.getCssClass(), dom);
};
goog.ui.MenuButtonRenderer.wrapCaption = function(content, cssClass, dom) {
  return dom.createDom("div", goog.ui.INLINE_BLOCK_CLASSNAME + " " + (cssClass + "-caption"), content);
};
goog.ui.MenuButtonRenderer.prototype.createDropdown = function(dom) {
  return dom.createDom("div", goog.ui.INLINE_BLOCK_CLASSNAME + " " + (this.getCssClass() + "-dropdown"), "\u00a0");
};
goog.ui.MenuButtonRenderer.prototype.getCssClass = function() {
  return goog.ui.MenuButtonRenderer.CSS_CLASS;
};
// INPUT (javascript/closure/ui/menubutton.js)
goog.ui.MenuButton = function(opt_content, opt_menu, opt_renderer, opt_domHelper, opt_menuRenderer) {
  goog.ui.Button.call(this, opt_content, opt_renderer || goog.ui.MenuButtonRenderer.getInstance(), opt_domHelper);
  this.setSupportedState(goog.ui.Component.State.OPENED, !0);
  this.menuPosition_ = new goog.positioning.MenuAnchoredPosition(null, goog.positioning.Corner.BOTTOM_START);
  opt_menu && this.setMenu(opt_menu);
  this.menuMargin_ = null;
  this.timer_ = new goog.Timer(500);
  !goog.userAgent.product.IPHONE && !goog.userAgent.product.IPAD || goog.userAgent.isVersionOrHigher("533.17.9") || this.setFocusablePopupMenu(!0);
  this.menuRenderer_ = opt_menuRenderer || goog.ui.MenuRenderer.getInstance();
};
goog.inherits(goog.ui.MenuButton, goog.ui.Button);
goog.tagUnsealableClass(goog.ui.MenuButton);
goog.ui.MenuButton.prototype.isFocusablePopupMenu_ = !1;
goog.ui.MenuButton.prototype.renderMenuAsSibling_ = !1;
goog.ui.MenuButton.prototype.enterDocument = function() {
  goog.ui.MenuButton.superClass_.enterDocument.call(this);
  this.attachKeyDownEventListener_(!0);
  this.menu_ && this.attachMenuEventListeners_(this.menu_, !0);
  goog.a11y.aria.setState(this.getElementStrict(), goog.a11y.aria.State.HASPOPUP, !!this.menu_);
};
goog.ui.MenuButton.prototype.exitDocument = function() {
  goog.ui.MenuButton.superClass_.exitDocument.call(this);
  this.attachKeyDownEventListener_(!1);
  if (this.menu_) {
    this.setOpen(!1);
    this.menu_.exitDocument();
    this.attachMenuEventListeners_(this.menu_, !1);
    var menuElement = this.menu_.getElement();
    menuElement && goog.dom.removeNode(menuElement);
  }
};
goog.ui.MenuButton.prototype.disposeInternal = function() {
  goog.ui.MenuButton.superClass_.disposeInternal.call(this);
  this.menu_ && (this.menu_.dispose(), delete this.menu_);
  delete this.positionElement_;
  this.timer_.dispose();
};
goog.ui.MenuButton.prototype.handleMouseDown = function(e) {
  goog.ui.MenuButton.superClass_.handleMouseDown.call(this, e);
  this.isActive() && (this.setOpen(!this.isOpen(), e), this.menu_ && this.menu_.setMouseButtonPressed(this.isOpen()));
};
goog.ui.MenuButton.prototype.handleMouseUp = function(e) {
  goog.ui.MenuButton.superClass_.handleMouseUp.call(this, e);
  this.menu_ && !this.isActive() && this.menu_.setMouseButtonPressed(!1);
};
goog.ui.MenuButton.prototype.performActionInternal = function() {
  this.setActive(!1);
  return!0;
};
goog.ui.MenuButton.prototype.handleDocumentMouseDown = function(e) {
  this.menu_ && this.menu_.isVisible() && !this.containsElement(e.target) && this.setOpen(!1);
};
goog.ui.MenuButton.prototype.containsElement = function(element) {
  return element && goog.dom.contains(this.getElement(), element) || this.menu_ && this.menu_.containsElement(element) || !1;
};
goog.ui.MenuButton.prototype.handleKeyEventInternal = function(e) {
  if (e.keyCode == goog.events.KeyCodes.SPACE) {
    if (e.preventDefault(), e.type != goog.events.EventType.KEYUP) {
      return!0;
    }
  } else {
    if (e.type != goog.events.KeyHandler.EventType.KEY) {
      return!1;
    }
  }
  if (this.menu_ && this.menu_.isVisible()) {
    var handledByMenu = this.menu_.handleKeyEvent(e);
    return e.keyCode == goog.events.KeyCodes.ESC ? (this.setOpen(!1), !0) : handledByMenu;
  }
  return e.keyCode == goog.events.KeyCodes.DOWN || e.keyCode == goog.events.KeyCodes.UP || e.keyCode == goog.events.KeyCodes.SPACE || e.keyCode == goog.events.KeyCodes.ENTER ? (this.setOpen(!0, e), !0) : !1;
};
goog.ui.MenuButton.prototype.handleMenuAction = function() {
  this.setOpen(!1);
};
goog.ui.MenuButton.prototype.handleMenuBlur = function() {
  this.isActive() || this.setOpen(!1);
};
goog.ui.MenuButton.prototype.handleBlur = function(e) {
  this.isFocusablePopupMenu() || this.setOpen(!1);
  goog.ui.MenuButton.superClass_.handleBlur.call(this, e);
};
goog.ui.MenuButton.prototype.getMenu = function() {
  this.menu_ || this.setMenu(new goog.ui.Menu(this.getDomHelper(), this.menuRenderer_));
  return this.menu_ || null;
};
goog.ui.MenuButton.prototype.setMenu = function(menu) {
  var oldMenu = this.menu_;
  menu != oldMenu && (oldMenu && (this.setOpen(!1), this.isInDocument() && this.attachMenuEventListeners_(oldMenu, !1), delete this.menu_), this.isInDocument() && goog.a11y.aria.setState(this.getElementStrict(), goog.a11y.aria.State.HASPOPUP, !!menu), menu && (this.menu_ = menu, menu.setParent(this), menu.setVisible(!1), menu.setAllowAutoFocus(this.isFocusablePopupMenu()), this.isInDocument() && this.attachMenuEventListeners_(menu, !0)));
  return oldMenu;
};
goog.ui.MenuButton.prototype.addItem = function(item) {
  this.getMenu().addChild(item, !0);
};
goog.ui.MenuButton.prototype.addItemAt = function(item, index) {
  this.getMenu().addChildAt(item, index, !0);
};
goog.ui.MenuButton.prototype.removeItem = function(item) {
  var child = this.getMenu().removeChild(item, !0);
  child && child.dispose();
};
goog.ui.MenuButton.prototype.getItemAt = function(index) {
  return this.menu_ ? this.menu_.getChildAt(index) : null;
};
goog.ui.MenuButton.prototype.getItemCount = function() {
  return this.menu_ ? this.menu_.getChildCount() : 0;
};
goog.ui.MenuButton.prototype.setVisible = function(visible, opt_force) {
  var visibilityChanged = goog.ui.MenuButton.superClass_.setVisible.call(this, visible, opt_force);
  visibilityChanged && !this.isVisible() && this.setOpen(!1);
  return visibilityChanged;
};
goog.ui.MenuButton.prototype.setEnabled = function(enable) {
  goog.ui.MenuButton.superClass_.setEnabled.call(this, enable);
  this.isEnabled() || this.setOpen(!1);
};
goog.ui.MenuButton.prototype.isScrollOnOverflow = function() {
  return this.menuPosition_.getLastResortOverflow && !!(this.menuPosition_.getLastResortOverflow() & goog.positioning.Overflow.RESIZE_HEIGHT);
};
goog.ui.MenuButton.prototype.isFocusablePopupMenu = function() {
  return this.isFocusablePopupMenu_;
};
goog.ui.MenuButton.prototype.setFocusablePopupMenu = function(focusable) {
  this.isFocusablePopupMenu_ = focusable;
};
goog.ui.MenuButton.prototype.showMenu = function() {
  this.setOpen(!0);
};
goog.ui.MenuButton.prototype.hideMenu = function() {
  this.setOpen(!1);
};
goog.ui.MenuButton.prototype.setOpen = function(open, opt_e) {
  goog.ui.MenuButton.superClass_.setOpen.call(this, open);
  if (this.menu_ && this.hasState(goog.ui.Component.State.OPENED) == open) {
    if (open) {
      if (!this.menu_.isInDocument()) {
        if (this.renderMenuAsSibling_) {
          var nextElementSibling = goog.dom.getNextElementSibling(this.getElement());
          nextElementSibling ? this.menu_.renderBefore(nextElementSibling) : this.menu_.render(this.getElement().parentNode);
        } else {
          this.menu_.render();
        }
      }
      this.viewportBox_ = goog.style.getVisibleRectForElement(this.getElement());
      this.buttonRect_ = goog.style.getBounds(this.getElement());
      this.positionMenu();
      var focus = !!opt_e && (opt_e.keyCode == goog.events.KeyCodes.DOWN || opt_e.keyCode == goog.events.KeyCodes.UP);
      this.menu_.setHighlightedIndex(focus ? 0 : -1);
    } else {
      this.setActive(!1);
      this.menu_.setMouseButtonPressed(!1);
      var element = this.getElement();
      element && (goog.a11y.aria.setState(element, goog.a11y.aria.State.ACTIVEDESCENDANT, ""), goog.a11y.aria.setState(element, goog.a11y.aria.State.OWNS, ""));
      if (goog.isDefAndNotNull(this.originalSize_)) {
        this.originalSize_ = void 0;
        var elem = this.menu_.getElement();
        elem && goog.style.setSize(elem, "", "");
      }
    }
    this.menu_.setVisible(open, !1, opt_e);
    this.isDisposed() || this.attachPopupListeners_(open);
  }
};
goog.ui.MenuButton.prototype.positionMenu = function() {
  if (this.menu_.isInDocument()) {
    var positionElement = this.positionElement_ || this.getElement(), position = this.menuPosition_;
    this.menuPosition_.element = positionElement;
    var elem = this.menu_.getElement();
    this.menu_.isVisible() || (elem.style.visibility = "hidden", goog.style.setElementShown(elem, !0));
    !this.originalSize_ && this.isScrollOnOverflow() && (this.originalSize_ = goog.style.getSize(elem));
    var popupCorner = goog.positioning.flipCornerVertical(position.corner);
    position.reposition(elem, popupCorner, this.menuMargin_, this.originalSize_);
    this.menu_.isVisible() || (goog.style.setElementShown(elem, !1), elem.style.visibility = "visible");
  }
};
goog.ui.MenuButton.prototype.onTick_ = function() {
  var currentButtonRect = goog.style.getBounds(this.getElement()), currentViewport = goog.style.getVisibleRectForElement(this.getElement());
  goog.math.Rect.equals(this.buttonRect_, currentButtonRect) && goog.math.Box.equals(this.viewportBox_, currentViewport) || (this.buttonRect_ = currentButtonRect, this.viewportBox_ = currentViewport, this.positionMenu());
};
goog.ui.MenuButton.prototype.attachMenuEventListeners_ = function(menu, attach) {
  var handler = this.getHandler(), method = attach ? handler.listen : handler.unlisten;
  method.call(handler, menu, goog.ui.Component.EventType.ACTION, this.handleMenuAction);
  method.call(handler, menu, goog.ui.Component.EventType.CLOSE, this.handleCloseItem);
  method.call(handler, menu, goog.ui.Component.EventType.HIGHLIGHT, this.handleHighlightItem);
  method.call(handler, menu, goog.ui.Component.EventType.UNHIGHLIGHT, this.handleUnHighlightItem);
};
goog.ui.MenuButton.prototype.attachKeyDownEventListener_ = function(attach) {
  var handler = this.getHandler(), method = attach ? handler.listen : handler.unlisten;
  method.call(handler, this.getElement(), goog.events.EventType.KEYDOWN, this.handleKeyDownEvent_);
};
goog.ui.MenuButton.prototype.handleHighlightItem = function(e) {
  var targetEl = e.target.getElement();
  targetEl && this.setAriaActiveDescendant_(targetEl);
};
goog.ui.MenuButton.prototype.handleKeyDownEvent_ = function(e) {
  this.isSupportedState(goog.ui.Component.State.FOCUSED) && this.getKeyEventTarget() && this.menu_ && this.menu_.isVisible() && e.stopPropagation();
};
goog.ui.MenuButton.prototype.handleUnHighlightItem = function() {
  if (!this.menu_.getHighlighted()) {
    var element = this.getElement();
    goog.asserts.assert(element, "The menu button DOM element cannot be null.");
    goog.a11y.aria.setState(element, goog.a11y.aria.State.ACTIVEDESCENDANT, "");
    goog.a11y.aria.setState(element, goog.a11y.aria.State.OWNS, "");
  }
};
goog.ui.MenuButton.prototype.handleCloseItem = function(e) {
  if (this.isOpen() && e.target instanceof goog.ui.MenuItem) {
    var menuItem = e.target, menuItemEl = menuItem.getElement();
    menuItem.isVisible() && menuItem.isHighlighted() && null != menuItemEl && this.setAriaActiveDescendant_(menuItemEl);
  }
};
goog.ui.MenuButton.prototype.setAriaActiveDescendant_ = function(targetEl) {
  var element = this.getElement();
  goog.asserts.assert(element, "The menu button DOM element cannot be null.");
  var targetActiveDescendant = goog.a11y.aria.getActiveDescendant(targetEl), activeDescendant = targetActiveDescendant || targetEl;
  if (!activeDescendant.id) {
    var idGenerator = goog.ui.IdGenerator.getInstance();
    activeDescendant.id = idGenerator.getNextUniqueId();
  }
  goog.a11y.aria.setActiveDescendant(element, activeDescendant);
  goog.a11y.aria.setState(element, goog.a11y.aria.State.OWNS, activeDescendant.id);
};
goog.ui.MenuButton.prototype.attachPopupListeners_ = function(attach) {
  var handler = this.getHandler(), method = attach ? handler.listen : handler.unlisten;
  method.call(handler, this.getDomHelper().getDocument(), goog.events.EventType.MOUSEDOWN, this.handleDocumentMouseDown, !0);
  this.isFocusablePopupMenu() && method.call(handler, this.menu_, goog.ui.Component.EventType.BLUR, this.handleMenuBlur);
  method.call(handler, this.timer_, goog.Timer.TICK, this.onTick_);
  attach ? this.timer_.start() : this.timer_.stop();
};
goog.ui.registry.setDecoratorByClassName(goog.ui.MenuButtonRenderer.CSS_CLASS, function() {
  return new goog.ui.MenuButton(null);
});
// INPUT (javascript/closure/ui/selectionmodel.js)
goog.ui.SelectionModel = function(opt_items) {
  goog.events.EventTarget.call(this);
  this.items_ = [];
  this.addItems(opt_items);
};
goog.inherits(goog.ui.SelectionModel, goog.events.EventTarget);
goog.tagUnsealableClass(goog.ui.SelectionModel);
goog.ui.SelectionModel.prototype.selectedItem_ = null;
goog.ui.SelectionModel.prototype.selectionHandler_ = null;
goog.ui.SelectionModel.prototype.setSelectionHandler = function(handler) {
  this.selectionHandler_ = handler;
};
goog.ui.SelectionModel.prototype.getItemCount = function() {
  return this.items_.length;
};
goog.ui.SelectionModel.prototype.indexOfItem = function(item) {
  return item ? goog.array.indexOf(this.items_, item) : -1;
};
goog.ui.SelectionModel.prototype.getItemAt = function(index) {
  return this.items_[index] || null;
};
goog.ui.SelectionModel.prototype.addItems = function(items) {
  items && (goog.array.forEach(items, function(item) {
    this.selectItem_(item, !1);
  }, this), goog.array.extend(this.items_, items));
};
goog.ui.SelectionModel.prototype.addItem = function(item) {
  this.addItemAt(item, this.getItemCount());
};
goog.ui.SelectionModel.prototype.addItemAt = function(item, index) {
  item && (this.selectItem_(item, !1), goog.array.insertAt(this.items_, item, index));
};
goog.ui.SelectionModel.prototype.removeItem = function(item) {
  item && goog.array.remove(this.items_, item) && item == this.selectedItem_ && (this.selectedItem_ = null, this.dispatchEvent(goog.events.EventType.SELECT));
};
goog.ui.SelectionModel.prototype.getSelectedItem = function() {
  return this.selectedItem_;
};
goog.ui.SelectionModel.prototype.getItems = function() {
  return goog.array.clone(this.items_);
};
goog.ui.SelectionModel.prototype.setSelectedItem = function(item) {
  item != this.selectedItem_ && (this.selectItem_(this.selectedItem_, !1), this.selectedItem_ = item, this.selectItem_(item, !0));
  this.dispatchEvent(goog.events.EventType.SELECT);
};
goog.ui.SelectionModel.prototype.getSelectedIndex = function() {
  return this.indexOfItem(this.selectedItem_);
};
goog.ui.SelectionModel.prototype.setSelectedIndex = function(index) {
  this.setSelectedItem(this.getItemAt(index));
};
goog.ui.SelectionModel.prototype.clear = function() {
  goog.array.clear(this.items_);
  this.selectedItem_ = null;
};
goog.ui.SelectionModel.prototype.disposeInternal = function() {
  goog.ui.SelectionModel.superClass_.disposeInternal.call(this);
  delete this.items_;
  this.selectedItem_ = null;
};
goog.ui.SelectionModel.prototype.selectItem_ = function(item, select) {
  item && ("function" == typeof this.selectionHandler_ ? this.selectionHandler_(item, select) : "function" == typeof item.setSelected && item.setSelected(select));
};
// INPUT (javascript/closure/ui/select.js)
goog.ui.Select = function(opt_caption, opt_menu, opt_renderer, opt_domHelper, opt_menuRenderer) {
  goog.ui.MenuButton.call(this, opt_caption, opt_menu, opt_renderer, opt_domHelper, opt_menuRenderer || new goog.ui.MenuRenderer(goog.a11y.aria.Role.LISTBOX));
  this.defaultCaption_ = this.getContent();
  this.initialAriaLabel_ = null;
  this.setPreferredAriaRole(goog.a11y.aria.Role.LISTBOX);
};
goog.inherits(goog.ui.Select, goog.ui.MenuButton);
goog.tagUnsealableClass(goog.ui.Select);
goog.ui.Select.prototype.selectionModel_ = null;
goog.ui.Select.prototype.enterDocument = function() {
  goog.ui.Select.superClass_.enterDocument.call(this);
  this.updateCaption();
  this.listenToSelectionModelEvents_();
};
goog.ui.Select.prototype.decorateInternal = function(element) {
  goog.ui.Select.superClass_.decorateInternal.call(this, element);
  var caption = this.getCaption();
  caption ? this.setDefaultCaption(caption) : this.getSelectedItem() || this.setSelectedIndex(0);
};
goog.ui.Select.prototype.disposeInternal = function() {
  goog.ui.Select.superClass_.disposeInternal.call(this);
  this.selectionModel_ && (this.selectionModel_.dispose(), this.selectionModel_ = null);
  this.defaultCaption_ = null;
};
goog.ui.Select.prototype.handleMenuAction = function(e) {
  this.setSelectedItem(e.target);
  goog.ui.Select.superClass_.handleMenuAction.call(this, e);
  e.stopPropagation();
  this.dispatchEvent(goog.ui.Component.EventType.ACTION);
};
goog.ui.Select.prototype.handleSelectionChange = function() {
  var item = this.getSelectedItem();
  goog.ui.Select.superClass_.setValue.call(this, item && item.getValue());
  this.updateCaption();
};
goog.ui.Select.prototype.setMenu = function(menu) {
  var oldMenu = goog.ui.Select.superClass_.setMenu.call(this, menu);
  menu != oldMenu && (this.selectionModel_ && this.selectionModel_.clear(), menu && (this.selectionModel_ ? menu.forEachChild(function(child) {
    this.setCorrectAriaRole_(child);
    this.selectionModel_.addItem(child);
  }, this) : this.createSelectionModel_(menu)));
  return oldMenu;
};
goog.ui.Select.prototype.setDefaultCaption = function(caption) {
  this.defaultCaption_ = caption;
  this.updateCaption();
};
goog.ui.Select.prototype.addItem = function(item) {
  this.setCorrectAriaRole_(item);
  goog.ui.Select.superClass_.addItem.call(this, item);
  this.selectionModel_ ? this.selectionModel_.addItem(item) : this.createSelectionModel_(this.getMenu());
  this.updateAriaActiveDescendant_();
};
goog.ui.Select.prototype.addItemAt = function(item, index) {
  this.setCorrectAriaRole_(item);
  goog.ui.Select.superClass_.addItemAt.call(this, item, index);
  this.selectionModel_ ? this.selectionModel_.addItemAt(item, index) : this.createSelectionModel_(this.getMenu());
};
goog.ui.Select.prototype.removeItem = function(item) {
  goog.ui.Select.superClass_.removeItem.call(this, item);
  this.selectionModel_ && this.selectionModel_.removeItem(item);
};
goog.ui.Select.prototype.setSelectedItem = function(item) {
  if (this.selectionModel_) {
    var prevItem = this.getSelectedItem();
    this.selectionModel_.setSelectedItem(item);
    item != prevItem && this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
  }
};
goog.ui.Select.prototype.setSelectedIndex = function(index) {
  this.selectionModel_ && this.setSelectedItem(this.selectionModel_.getItemAt(index));
};
goog.ui.Select.prototype.setValue = function(value) {
  if (goog.isDefAndNotNull(value) && this.selectionModel_) {
    for (var i = 0, item;item = this.selectionModel_.getItemAt(i);i++) {
      if (item && "function" == typeof item.getValue && item.getValue() == value) {
        this.setSelectedItem(item);
        return;
      }
    }
  }
  this.setSelectedItem(null);
};
goog.ui.Select.prototype.getValue = function() {
  var selectedItem = this.getSelectedItem();
  return selectedItem ? selectedItem.getValue() : null;
};
goog.ui.Select.prototype.getSelectedItem = function() {
  return this.selectionModel_ ? this.selectionModel_.getSelectedItem() : null;
};
goog.ui.Select.prototype.getSelectedIndex = function() {
  return this.selectionModel_ ? this.selectionModel_.getSelectedIndex() : -1;
};
goog.ui.Select.prototype.createSelectionModel_ = function(opt_component) {
  this.selectionModel_ = new goog.ui.SelectionModel;
  opt_component && opt_component.forEachChild(function(child) {
    this.setCorrectAriaRole_(child);
    this.selectionModel_.addItem(child);
  }, this);
  this.listenToSelectionModelEvents_();
};
goog.ui.Select.prototype.listenToSelectionModelEvents_ = function() {
  this.selectionModel_ && this.getHandler().listen(this.selectionModel_, goog.events.EventType.SELECT, this.handleSelectionChange);
};
goog.ui.Select.prototype.updateCaption = function() {
  var item = this.getSelectedItem();
  this.setContent(item ? item.getCaption() : this.defaultCaption_);
  var contentElement = this.getRenderer().getContentElement(this.getElement());
  if (contentElement && this.getDomHelper().isElement(contentElement)) {
    null == this.initialAriaLabel_ && (this.initialAriaLabel_ = goog.a11y.aria.getLabel(contentElement));
    var itemElement = item ? item.getElement() : null;
    goog.a11y.aria.setLabel(contentElement, itemElement ? goog.a11y.aria.getLabel(itemElement) : this.initialAriaLabel_);
    this.updateAriaActiveDescendant_();
  }
};
goog.ui.Select.prototype.updateAriaActiveDescendant_ = function() {
  var renderer = this.getRenderer();
  if (renderer) {
    var contentElement = renderer.getContentElement(this.getElement());
    if (contentElement) {
      var buttonElement = this.getElementStrict();
      contentElement.id || (contentElement.id = goog.ui.IdGenerator.getInstance().getNextUniqueId());
      goog.a11y.aria.setRole(contentElement, goog.a11y.aria.Role.OPTION);
      goog.a11y.aria.setState(buttonElement, goog.a11y.aria.State.ACTIVEDESCENDANT, contentElement.id);
      if (this.selectionModel_) {
        var items = this.selectionModel_.getItems(), menuItemCount = goog.array.count(items, function(item) {
          return item instanceof goog.ui.MenuItem;
        });
        goog.a11y.aria.setState(contentElement, goog.a11y.aria.State.SETSIZE, menuItemCount);
        goog.a11y.aria.setState(contentElement, goog.a11y.aria.State.POSINSET, 1 + this.selectionModel_.getSelectedIndex());
      }
    }
  }
};
goog.ui.Select.prototype.setCorrectAriaRole_ = function(item) {
  item.setPreferredAriaRole(item instanceof goog.ui.MenuItem ? goog.a11y.aria.Role.OPTION : goog.a11y.aria.Role.SEPARATOR);
};
goog.ui.Select.prototype.setOpen = function(open, opt_e) {
  goog.ui.Select.superClass_.setOpen.call(this, open, opt_e);
  this.isOpen() ? this.getMenu().setHighlightedIndex(this.getSelectedIndex()) : this.updateAriaActiveDescendant_();
};
goog.ui.registry.setDecoratorByClassName("aAAaGVIZSENTINELaAAa-select", function() {
  return new goog.ui.Select(null);
});
// INPUT (javascript/gviz/devel/jsapi/packages/util/toolbar/toolbar.js)
gviz.Toolbar = function(container, components) {
  this.dom_ = goog.dom.getDomHelper();
  this.container_ = container;
  this.callbacksArray_ = [];
  this.draw_(components);
};
gviz.Toolbar.prototype.selectElement_ = null;
gviz.Toolbar.cssPrefix_ = "google-visualization-toolbar";
gviz.Toolbar.CSS_ = {TOOLBAR:gviz.Toolbar.cssPrefix_, EXPORT_IGOOGLE:gviz.Toolbar.cssPrefix_ + "-export-igoogle", EXPORT_DATA:gviz.Toolbar.cssPrefix_ + "-export-data", HTML_CODE:gviz.Toolbar.cssPrefix_ + "-html-code", DIALOG:gviz.Toolbar.cssPrefix_ + "-dialog", SMALL_DIALOG:gviz.Toolbar.cssPrefix_ + "-small-dialog", BIG_DIALOG:gviz.Toolbar.cssPrefix_ + "-big-dialog", HTML_CODE_EXPLANATION:gviz.Toolbar.cssPrefix_ + "-html-code-explanation", OK_BUTTON:gviz.Toolbar.cssPrefix_ + "-ok-button", CAPTION_TABLE:gviz.Toolbar.cssPrefix_ + 
"-caption-table"};
gviz.Toolbar.DIALOG_TYPES_ = {HTML_CODE:2, JS_CODE:3};
gviz.Toolbar.openDialog_ = function(type, attributes) {
  var dom = goog.dom.getDomHelper(), dialog, content, idForRange = null;
  switch(type) {
    case gviz.Toolbar.DIALOG_TYPES_.HTML_CODE:
      dialog = new goog.ui.Dialog(gviz.Toolbar.CSS_.SMALL_DIALOG);
      idForRange = "range" + dialog.getId();
      content = dom.createDom("div", null, dom.createDom("div", {"class":gviz.Toolbar.CSS_.HTML_CODE_EXPLANATION}, "Copy-Paste this code to an HTML page"), dom.createDom("br", null), dom.createDom("pre", null, dom.createDom("div", {id:idForRange}, attributes.message)));
      break;
    case gviz.Toolbar.DIALOG_TYPES_.JS_CODE:
      dialog = new goog.ui.Dialog(gviz.Toolbar.CSS_.BIG_DIALOG);
      content = dom.createDom("div", null, dom.createDom("div", {"class":gviz.Toolbar.CSS_.HTML_CODE_EXPLANATION}, "Copy-Paste this code to an HTML page"), dom.createDom("br", null));
      var splittedMessage = attributes.message, lineElement = dom.createDom("div", null, dom.createDom("pre", null, splittedMessage));
      dom.appendChild(content, lineElement);
  }
  dialog.setContent(content.innerHTML);
  dialog.getTitleTextElement().innerHTML = "Google Visualization";
  dialog.getButtonElement().innerHTML = "";
  dialog.setVisible(!0);
  if (idForRange) {
    var div = goog.dom.getElement(idForRange);
    goog.dom.Range.createFromNodes(div, 0, div, 1).select();
  }
};
gviz.Toolbar.prototype.draw_ = function(components) {
  components = components || [];
  var container = this.container_, dom = this.dom_;
  dom.removeChildren(container);
  if (!container) {
    throw Error("Container is not defined");
  }
  var span = dom.createDom("span", null), defaultCaption = [dom.createDom("span", null, "Chart options")];
  this.selectElement_ = new goog.ui.Select(defaultCaption);
  if (components) {
    for (var i = 0;i < components.length;i++) {
      var toolbarComponent = null, component = components[i], type = component.type, dataSource = component.datasource, gadget = component.gadget, userPrefs = component.userprefs, visualization$$0 = component.visualization, packageName = component["package"], style = component.style || "width: 700px; height: 500px;";
      switch(type) {
        case "csv":
          toolbarComponent = this.createComponent_(i, goog.partial(function(dataSource) {
            window.open((new goog.Uri(dataSource)).setParameterValue("tqx", "out:csv;"), "Google_Visualization");
          }, dataSource), "Export data as CSV", gviz.Toolbar.CSS_.EXPORT_DATA);
          break;
        case "htmlcode":
          toolbarComponent = this.createComponent_(i, goog.partial(function(gadget, dataSource) {
            var message = '<iframe style="' + style + '" src="http://www.google.com/ig/ifr?url=' + encodeURIComponent(gadget) + "&up__table_query_url=" + encodeURIComponent(dataSource) + gviz.Toolbar.encodeGadgetUserPrefs(userPrefs) + '" />';
            gviz.Toolbar.openDialog_(gviz.Toolbar.DIALOG_TYPES_.HTML_CODE, {message:message});
          }, gadget, dataSource), "Publish to web page", gviz.Toolbar.CSS_.HTML_CODE);
          break;
        case "jscode":
          toolbarComponent = this.createComponent_(i, goog.partial(function(dataSource, packageName, visualization) {
            var message = '<html>\n <head>\n  <title>Google Visualization API</title>\n  <script type="text/javascript" src="http://www.google.com/jsapi">\x3c/script>\n  <script type="text/javascript">\n   google.load(\'visualization\', \'1\', {packages: [\'' + encodeURIComponent(packageName) + "']});\n\n   function drawVisualization() {\n    new google.visualization.Query('" + dataSource + "').send(\n     function(response) {\n      new " + encodeURIComponent(visualization) + '(\n       document.getElementById(\'visualization\')).\n        draw(response.getDataTable(), null);\n      });\n   }\n\n   google.setOnLoadCallback(drawVisualization);\n  \x3c/script>\n </head>\n <body>\n  <div id="visualization" style="width: 500px; height: 500px;"></div>\n </body>\n</html>';
            gviz.Toolbar.openDialog_(gviz.Toolbar.DIALOG_TYPES_.JS_CODE, {message:message});
          }, dataSource, packageName, visualization$$0), "Javascript code", gviz.Toolbar.CSS_.HTML_CODE);
          break;
        case "html":
          toolbarComponent = this.createComponent_(i, goog.partial(function(dataSource) {
            window.open((new goog.Uri(dataSource)).setParameterValue("tqx", "out:html;"), "Google_Visualization");
          }, dataSource), "Export data as HTML", gviz.Toolbar.CSS_.EXPORT_DATA);
          break;
        case "igoogle":
          toolbarComponent = this.createComponent_(i, goog.partial(function(gadget, dataSource, userPrefs) {
            window.open("http://www.google.com/ig/adde?moduleurl=" + encodeURIComponent(gadget) + "&up__table_query_url=" + encodeURIComponent(dataSource) + gviz.Toolbar.encodeGadgetUserPrefs(userPrefs));
          }, gadget, dataSource, userPrefs), "Add to iGoogle", gviz.Toolbar.CSS_.EXPORT_IGOOGLE);
          break;
        default:
          throw Error("No such toolbar component as: " + component.toSource());;
      }
      toolbarComponent && this.selectElement_.addItem(toolbarComponent);
    }
  }
  goog.events.listen(this.selectElement_, goog.ui.Component.EventType.ACTION, goog.bind(this.handleSubmit_, this));
  this.selectElement_.render(span);
  dom.appendChild(container, span);
};
gviz.Toolbar.prototype.setDefaultSelectCaption_ = function() {
  this.selectElement_.setSelectedIndex(-1);
};
gviz.Toolbar.prototype.handleSubmit_ = function() {
  var i = this.selectElement_.getSelectedIndex();
  this.callbacksArray_[i]();
  this.setDefaultSelectCaption_();
};
gviz.Toolbar.prototype.createComponent_ = function(id, callback, text) {
  var menuItem = new goog.ui.MenuItem(text);
  this.callbacksArray_[id] = callback;
  return menuItem;
};
gviz.Toolbar.encodeGadgetUserPrefs = function(gadgetUserPrefs) {
  if (!gadgetUserPrefs) {
    return "";
  }
  var out = "", pref;
  for (pref in gadgetUserPrefs) {
    out += "&up_" + pref + "=" + encodeURIComponent(gadgetUserPrefs[pref]);
  }
  return out;
};
google.visualization.drawToolbar = function(container, components) {
  new gviz.Toolbar(container, components);
};
// INPUT (javascript/closure/ui/checkboxrenderer.js)
goog.ui.CheckboxRenderer = function() {
};
goog.inherits(goog.ui.CheckboxRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.CheckboxRenderer);
goog.ui.CheckboxRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-checkbox";
goog.ui.CheckboxRenderer.prototype.createDom = function(checkbox) {
  var element = checkbox.getDomHelper().createDom("span", this.getClassNames(checkbox).join(" ")), state = checkbox.getChecked();
  this.setCheckboxState(element, state);
  return element;
};
goog.ui.CheckboxRenderer.prototype.decorate = function(checkbox, element) {
  element = goog.ui.CheckboxRenderer.superClass_.decorate.call(this, checkbox, element);
  goog.asserts.assert(element);
  var classes = goog.dom.classlist.get(element), checked = goog.ui.Checkbox.State.UNCHECKED;
  goog.array.contains(classes, this.getClassForCheckboxState(goog.ui.Checkbox.State.UNDETERMINED)) ? checked = goog.ui.Checkbox.State.UNDETERMINED : goog.array.contains(classes, this.getClassForCheckboxState(goog.ui.Checkbox.State.CHECKED)) ? checked = goog.ui.Checkbox.State.CHECKED : goog.array.contains(classes, this.getClassForCheckboxState(goog.ui.Checkbox.State.UNCHECKED)) && (checked = goog.ui.Checkbox.State.UNCHECKED);
  checkbox.setCheckedInternal(checked);
  goog.asserts.assert(element, "The element cannot be null.");
  goog.a11y.aria.setState(element, goog.a11y.aria.State.CHECKED, this.ariaStateFromCheckState_(checked));
  return element;
};
goog.ui.CheckboxRenderer.prototype.getAriaRole = function() {
  return goog.a11y.aria.Role.CHECKBOX;
};
goog.ui.CheckboxRenderer.prototype.setCheckboxState = function(element, state$$0) {
  if (element) {
    goog.asserts.assert(element);
    var classToAdd = this.getClassForCheckboxState(state$$0);
    goog.asserts.assert(classToAdd);
    goog.asserts.assert(element);
    goog.dom.classlist.contains(element, classToAdd) || (goog.object.forEach(goog.ui.Checkbox.State, function(state) {
      var className = this.getClassForCheckboxState(state);
      goog.asserts.assert(element);
      goog.dom.classlist.enable(element, className, className == classToAdd);
    }, this), goog.a11y.aria.setState(element, goog.a11y.aria.State.CHECKED, this.ariaStateFromCheckState_(state$$0)));
  }
};
goog.ui.CheckboxRenderer.prototype.ariaStateFromCheckState_ = function(state) {
  return state == goog.ui.Checkbox.State.UNDETERMINED ? "mixed" : state == goog.ui.Checkbox.State.CHECKED ? "true" : "false";
};
goog.ui.CheckboxRenderer.prototype.getCssClass = function() {
  return goog.ui.CheckboxRenderer.CSS_CLASS;
};
goog.ui.CheckboxRenderer.prototype.getClassForCheckboxState = function(state) {
  var baseClass = this.getStructuralCssClass();
  if (state == goog.ui.Checkbox.State.CHECKED) {
    return baseClass + "-checked";
  }
  if (state == goog.ui.Checkbox.State.UNCHECKED) {
    return baseClass + "-unchecked";
  }
  if (state == goog.ui.Checkbox.State.UNDETERMINED) {
    return baseClass + "-undetermined";
  }
  throw Error("Invalid checkbox state: " + state);
};
// INPUT (javascript/closure/ui/checkbox.js)
goog.ui.Checkbox = function(opt_checked, opt_domHelper, opt_renderer) {
  var renderer = opt_renderer || goog.ui.CheckboxRenderer.getInstance();
  goog.ui.Control.call(this, null, renderer, opt_domHelper);
  this.checked_ = goog.isDef(opt_checked) ? opt_checked : goog.ui.Checkbox.State.UNCHECKED;
};
goog.inherits(goog.ui.Checkbox, goog.ui.Control);
goog.tagUnsealableClass(goog.ui.Checkbox);
goog.ui.Checkbox.State = {CHECKED:!0, UNCHECKED:!1, UNDETERMINED:null};
goog.ui.Checkbox.prototype.label_ = null;
goog.ui.Checkbox.prototype.getChecked = function() {
  return this.checked_;
};
goog.ui.Checkbox.prototype.isChecked = function() {
  return this.checked_ == goog.ui.Checkbox.State.CHECKED;
};
goog.ui.Checkbox.prototype.isUndetermined = function() {
  return this.checked_ == goog.ui.Checkbox.State.UNDETERMINED;
};
goog.ui.Checkbox.prototype.setChecked = function(checked) {
  checked != this.checked_ && (this.checked_ = checked, this.getRenderer().setCheckboxState(this.getElement(), this.checked_));
};
goog.ui.Checkbox.prototype.setCheckedInternal = function(checked) {
  this.checked_ = checked;
};
goog.ui.Checkbox.prototype.setLabel = function(label) {
  this.isInDocument() ? (this.exitDocument(), this.label_ = label, this.enterDocument()) : this.label_ = label;
};
goog.ui.Checkbox.prototype.toggle = function() {
  this.setChecked(this.checked_ ? goog.ui.Checkbox.State.UNCHECKED : goog.ui.Checkbox.State.CHECKED);
};
goog.ui.Checkbox.prototype.enterDocument = function() {
  goog.ui.Checkbox.superClass_.enterDocument.call(this);
  if (this.isHandleMouseEvents()) {
    var handler = this.getHandler();
    this.label_ && handler.listen(this.label_, goog.events.EventType.CLICK, this.handleClickOrSpace_).listen(this.label_, goog.events.EventType.MOUSEOVER, this.handleMouseOver).listen(this.label_, goog.events.EventType.MOUSEOUT, this.handleMouseOut).listen(this.label_, goog.events.EventType.MOUSEDOWN, this.handleMouseDown).listen(this.label_, goog.events.EventType.MOUSEUP, this.handleMouseUp);
    handler.listen(this.getElement(), goog.events.EventType.CLICK, this.handleClickOrSpace_);
  }
  if (this.label_) {
    this.label_.id || (this.label_.id = this.makeId("lbl"));
    var checkboxElement = this.getElement();
    goog.asserts.assert(checkboxElement, "The checkbox DOM element cannot be null.");
    goog.a11y.aria.setState(checkboxElement, goog.a11y.aria.State.LABELLEDBY, this.label_.id);
  }
};
goog.ui.Checkbox.prototype.setEnabled = function(enabled) {
  goog.ui.Checkbox.superClass_.setEnabled.call(this, enabled);
  var el = this.getElement();
  el && (el.tabIndex = this.isEnabled() ? 0 : -1);
};
goog.ui.Checkbox.prototype.handleClickOrSpace_ = function(e) {
  e.stopPropagation();
  var eventType = this.checked_ ? goog.ui.Component.EventType.UNCHECK : goog.ui.Component.EventType.CHECK;
  this.isEnabled() && !e.target.href && this.dispatchEvent(eventType) && (e.preventDefault(), this.toggle(), this.dispatchEvent(goog.ui.Component.EventType.CHANGE));
};
goog.ui.Checkbox.prototype.handleKeyEventInternal = function(e) {
  e.keyCode == goog.events.KeyCodes.SPACE && this.handleClickOrSpace_(e);
  return!1;
};
goog.ui.registry.setDecoratorByClassName(goog.ui.CheckboxRenderer.CSS_CLASS, function() {
  return new goog.ui.Checkbox;
});
// INPUT (javascript/closure/events/mousewheelhandler.js)
goog.events.MouseWheelHandler = function(element, opt_capture) {
  goog.events.EventTarget.call(this);
  this.element_ = element;
  var rtlElement = goog.dom.isElement(this.element_) ? this.element_ : this.element_ ? this.element_.body : null;
  this.isRtl_ = !!rtlElement && goog.style.isRightToLeft(rtlElement);
  var type = goog.userAgent.GECKO ? "DOMMouseScroll" : "mousewheel";
  this.listenKey_ = goog.events.listen(this.element_, type, this, opt_capture);
};
goog.inherits(goog.events.MouseWheelHandler, goog.events.EventTarget);
goog.events.MouseWheelHandler.EventType = {MOUSEWHEEL:"mousewheel"};
goog.events.MouseWheelHandler.prototype.handleEvent = function(e) {
  var deltaX = 0, deltaY = 0, detail = 0, be = e.getBrowserEvent();
  if ("mousewheel" == be.type) {
    var wheelDeltaScaleFactor = 1;
    if (goog.userAgent.IE || goog.userAgent.WEBKIT && (goog.userAgent.WINDOWS || goog.userAgent.isVersionOrHigher("532.0"))) {
      wheelDeltaScaleFactor = 40;
    }
    detail = goog.events.MouseWheelHandler.smartScale_(-be.wheelDelta, wheelDeltaScaleFactor);
    goog.isDef(be.wheelDeltaX) ? (deltaX = goog.events.MouseWheelHandler.smartScale_(-be.wheelDeltaX, wheelDeltaScaleFactor), deltaY = goog.events.MouseWheelHandler.smartScale_(-be.wheelDeltaY, wheelDeltaScaleFactor)) : deltaY = detail;
  } else {
    detail = be.detail, 100 < detail ? detail = 3 : -100 > detail && (detail = -3), goog.isDef(be.axis) && be.axis === be.HORIZONTAL_AXIS ? deltaX = detail : deltaY = detail;
  }
  goog.isNumber(this.maxDeltaX_) && (deltaX = goog.math.clamp(deltaX, -this.maxDeltaX_, this.maxDeltaX_));
  goog.isNumber(this.maxDeltaY_) && (deltaY = goog.math.clamp(deltaY, -this.maxDeltaY_, this.maxDeltaY_));
  this.isRtl_ && (deltaX = -deltaX);
  var newEvent = new goog.events.MouseWheelEvent(detail, be, deltaX, deltaY);
  this.dispatchEvent(newEvent);
};
goog.events.MouseWheelHandler.smartScale_ = function(mouseWheelDelta, scaleFactor) {
  return goog.userAgent.WEBKIT && (goog.userAgent.MAC || goog.userAgent.LINUX) && 0 != mouseWheelDelta % scaleFactor ? mouseWheelDelta : mouseWheelDelta / scaleFactor;
};
goog.events.MouseWheelHandler.prototype.disposeInternal = function() {
  goog.events.MouseWheelHandler.superClass_.disposeInternal.call(this);
  goog.events.unlistenByKey(this.listenKey_);
  this.listenKey_ = null;
};
goog.events.MouseWheelEvent = function(detail, browserEvent, deltaX, deltaY) {
  goog.events.BrowserEvent.call(this, browserEvent);
  this.type = goog.events.MouseWheelHandler.EventType.MOUSEWHEEL;
  this.detail = detail;
  this.deltaX = deltaX;
  this.deltaY = deltaY;
};
goog.inherits(goog.events.MouseWheelEvent, goog.events.BrowserEvent);
// INPUT (javascript/closure/fx/transitionbase.js)
goog.fx.TransitionBase = function() {
  goog.events.EventTarget.call(this);
  this.state_ = goog.fx.TransitionBase.State.STOPPED;
  this.endTime = this.startTime = null;
};
goog.inherits(goog.fx.TransitionBase, goog.events.EventTarget);
goog.fx.TransitionBase.State = {STOPPED:0, PAUSED:-1, PLAYING:1};
goog.fx.TransitionBase.prototype.getStateInternal = function() {
  return this.state_;
};
goog.fx.TransitionBase.prototype.setStatePlaying = function() {
  this.state_ = goog.fx.TransitionBase.State.PLAYING;
};
goog.fx.TransitionBase.prototype.setStatePaused = function() {
  this.state_ = goog.fx.TransitionBase.State.PAUSED;
};
goog.fx.TransitionBase.prototype.setStateStopped = function() {
  this.state_ = goog.fx.TransitionBase.State.STOPPED;
};
goog.fx.TransitionBase.prototype.isPlaying = function() {
  return this.state_ == goog.fx.TransitionBase.State.PLAYING;
};
goog.fx.TransitionBase.prototype.isPaused = function() {
  return this.state_ == goog.fx.TransitionBase.State.PAUSED;
};
goog.fx.TransitionBase.prototype.isStopped = function() {
  return this.state_ == goog.fx.TransitionBase.State.STOPPED;
};
goog.fx.TransitionBase.prototype.onBegin = function() {
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.BEGIN);
};
goog.fx.TransitionBase.prototype.onEnd = function() {
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.END);
};
goog.fx.TransitionBase.prototype.onFinish = function() {
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.FINISH);
};
goog.fx.TransitionBase.prototype.onPause = function() {
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.PAUSE);
};
goog.fx.TransitionBase.prototype.onPlay = function() {
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.PLAY);
};
goog.fx.TransitionBase.prototype.onResume = function() {
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.RESUME);
};
goog.fx.TransitionBase.prototype.onStop = function() {
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.STOP);
};
goog.fx.TransitionBase.prototype.dispatchAnimationEvent = function(type) {
  this.dispatchEvent(type);
};
// INPUT (javascript/closure/fx/animationqueue.js)
goog.fx.AnimationQueue = function() {
  goog.fx.TransitionBase.call(this);
  this.queue = [];
};
goog.inherits(goog.fx.AnimationQueue, goog.fx.TransitionBase);
goog.fx.AnimationQueue.prototype.add = function(animation) {
  goog.asserts.assert(this.isStopped(), "Not allowed to add animations to a running animation queue.");
  goog.array.contains(this.queue, animation) || (this.queue.push(animation), goog.events.listen(animation, goog.fx.Transition.EventType.FINISH, this.onAnimationFinish, !1, this));
};
goog.fx.AnimationQueue.prototype.remove = function(animation) {
  goog.asserts.assert(this.isStopped(), "Not allowed to remove animations from a running animation queue.");
  goog.array.remove(this.queue, animation) && goog.events.unlisten(animation, goog.fx.Transition.EventType.FINISH, this.onAnimationFinish, !1, this);
};
goog.fx.AnimationQueue.prototype.disposeInternal = function() {
  goog.array.forEach(this.queue, function(animation) {
    animation.dispose();
  });
  this.queue.length = 0;
  goog.fx.AnimationQueue.superClass_.disposeInternal.call(this);
};
goog.fx.AnimationParallelQueue = function() {
  goog.fx.AnimationQueue.call(this);
  this.finishedCounter_ = 0;
};
goog.inherits(goog.fx.AnimationParallelQueue, goog.fx.AnimationQueue);
goog.fx.AnimationParallelQueue.prototype.play = function(opt_restart) {
  if (0 == this.queue.length) {
    return!1;
  }
  if (opt_restart || this.isStopped()) {
    this.finishedCounter_ = 0, this.onBegin();
  } else {
    if (this.isPlaying()) {
      return!1;
    }
  }
  this.onPlay();
  if (this.isPaused()) {
    this.onResume();
  }
  var resuming = this.isPaused() && !opt_restart;
  this.startTime = goog.now();
  this.endTime = null;
  this.setStatePlaying();
  goog.array.forEach(this.queue, function(anim) {
    resuming && !anim.isPaused() || anim.play(opt_restart);
  });
  return!0;
};
goog.fx.AnimationParallelQueue.prototype.pause = function() {
  this.isPlaying() && (goog.array.forEach(this.queue, function(anim) {
    anim.isPlaying() && anim.pause();
  }), this.setStatePaused(), this.onPause());
};
goog.fx.AnimationParallelQueue.prototype.stop = function(opt_gotoEnd) {
  goog.array.forEach(this.queue, function(anim) {
    anim.isStopped() || anim.stop(opt_gotoEnd);
  });
  this.setStateStopped();
  this.endTime = goog.now();
  this.onStop();
  this.onEnd();
};
goog.fx.AnimationParallelQueue.prototype.onAnimationFinish = function() {
  this.finishedCounter_++;
  this.finishedCounter_ == this.queue.length && (this.endTime = goog.now(), this.setStateStopped(), this.onFinish(), this.onEnd());
};
goog.fx.AnimationSerialQueue = function() {
  goog.fx.AnimationQueue.call(this);
  this.current_ = 0;
};
goog.inherits(goog.fx.AnimationSerialQueue, goog.fx.AnimationQueue);
goog.fx.AnimationSerialQueue.prototype.play = function(opt_restart) {
  if (0 == this.queue.length) {
    return!1;
  }
  if (opt_restart || this.isStopped()) {
    this.current_ < this.queue.length && !this.queue[this.current_].isStopped() && this.queue[this.current_].stop(!1), this.current_ = 0, this.onBegin();
  } else {
    if (this.isPlaying()) {
      return!1;
    }
  }
  this.onPlay();
  if (this.isPaused()) {
    this.onResume();
  }
  this.startTime = goog.now();
  this.endTime = null;
  this.setStatePlaying();
  this.queue[this.current_].play(opt_restart);
  return!0;
};
goog.fx.AnimationSerialQueue.prototype.pause = function() {
  this.isPlaying() && (this.queue[this.current_].pause(), this.setStatePaused(), this.onPause());
};
goog.fx.AnimationSerialQueue.prototype.stop = function(opt_gotoEnd) {
  this.setStateStopped();
  this.endTime = goog.now();
  if (opt_gotoEnd) {
    for (var i = this.current_;i < this.queue.length;++i) {
      var anim = this.queue[i];
      anim.isStopped() && anim.play();
      anim.isStopped() || anim.stop(!0);
    }
  } else {
    this.current_ < this.queue.length && this.queue[this.current_].stop(!1);
  }
  this.onStop();
  this.onEnd();
};
goog.fx.AnimationSerialQueue.prototype.onAnimationFinish = function() {
  this.isPlaying() && (this.current_++, this.current_ < this.queue.length ? this.queue[this.current_].play() : (this.endTime = goog.now(), this.setStateStopped(), this.onFinish(), this.onEnd()));
};
// INPUT (javascript/closure/async/animationdelay.js)
goog.async.AnimationDelay = function(listener, opt_window, opt_handler) {
  goog.Disposable.call(this);
  this.listener_ = listener;
  this.handler_ = opt_handler;
  this.win_ = opt_window || window;
  this.callback_ = goog.bind(this.doAction_, this);
};
goog.inherits(goog.async.AnimationDelay, goog.Disposable);
goog.async.AnimationDelay.prototype.id_ = null;
goog.async.AnimationDelay.prototype.usingListeners_ = !1;
goog.async.AnimationDelay.TIMEOUT = 20;
goog.async.AnimationDelay.MOZ_BEFORE_PAINT_EVENT_ = "MozBeforePaint";
goog.async.AnimationDelay.prototype.start = function() {
  this.stop();
  this.usingListeners_ = !1;
  var raf = this.getRaf_(), cancelRaf = this.getCancelRaf_();
  raf && !cancelRaf && this.win_.mozRequestAnimationFrame ? (this.id_ = goog.events.listen(this.win_, goog.async.AnimationDelay.MOZ_BEFORE_PAINT_EVENT_, this.callback_), this.win_.mozRequestAnimationFrame(null), this.usingListeners_ = !0) : this.id_ = raf && cancelRaf ? raf.call(this.win_, this.callback_) : this.win_.setTimeout(goog.functions.lock(this.callback_), goog.async.AnimationDelay.TIMEOUT);
};
goog.async.AnimationDelay.prototype.stop = function() {
  if (this.isActive()) {
    var raf = this.getRaf_(), cancelRaf = this.getCancelRaf_();
    raf && !cancelRaf && this.win_.mozRequestAnimationFrame ? goog.events.unlistenByKey(this.id_) : raf && cancelRaf ? cancelRaf.call(this.win_, this.id_) : this.win_.clearTimeout(this.id_);
  }
  this.id_ = null;
};
goog.async.AnimationDelay.prototype.fire = function() {
  this.stop();
  this.doAction_();
};
goog.async.AnimationDelay.prototype.isActive = function() {
  return null != this.id_;
};
goog.async.AnimationDelay.prototype.doAction_ = function() {
  this.usingListeners_ && this.id_ && goog.events.unlistenByKey(this.id_);
  this.id_ = null;
  this.listener_.call(this.handler_, goog.now());
};
goog.async.AnimationDelay.prototype.disposeInternal = function() {
  this.stop();
  goog.async.AnimationDelay.superClass_.disposeInternal.call(this);
};
goog.async.AnimationDelay.prototype.getRaf_ = function() {
  var win = this.win_;
  return win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || null;
};
goog.async.AnimationDelay.prototype.getCancelRaf_ = function() {
  var win = this.win_;
  return win.cancelRequestAnimationFrame || win.webkitCancelRequestAnimationFrame || win.mozCancelRequestAnimationFrame || win.oCancelRequestAnimationFrame || win.msCancelRequestAnimationFrame || null;
};
// INPUT (javascript/closure/async/delay.js)
goog.async.Delay = function(listener, opt_interval, opt_handler) {
  goog.Disposable.call(this);
  this.listener_ = listener;
  this.interval_ = opt_interval || 0;
  this.handler_ = opt_handler;
  this.callback_ = goog.bind(this.doAction_, this);
};
goog.inherits(goog.async.Delay, goog.Disposable);
goog.Delay = goog.async.Delay;
goog.async.Delay.prototype.id_ = 0;
goog.async.Delay.prototype.disposeInternal = function() {
  goog.async.Delay.superClass_.disposeInternal.call(this);
  this.stop();
  delete this.listener_;
  delete this.handler_;
};
goog.async.Delay.prototype.start = function(opt_interval) {
  this.stop();
  this.id_ = goog.Timer.callOnce(this.callback_, goog.isDef(opt_interval) ? opt_interval : this.interval_);
};
goog.async.Delay.prototype.stop = function() {
  this.isActive() && goog.Timer.clear(this.id_);
  this.id_ = 0;
};
goog.async.Delay.prototype.fire = function() {
  this.stop();
  this.doAction_();
};
goog.async.Delay.prototype.isActive = function() {
  return 0 != this.id_;
};
goog.async.Delay.prototype.doAction_ = function() {
  this.id_ = 0;
  this.listener_ && this.listener_.call(this.handler_);
};
// INPUT (javascript/closure/fx/anim/anim.js)
goog.fx.anim = {};
goog.fx.anim.Animated = function() {
};
goog.fx.anim.TIMEOUT = goog.async.AnimationDelay.TIMEOUT;
goog.fx.anim.activeAnimations_ = {};
goog.fx.anim.animationWindow_ = null;
goog.fx.anim.animationDelay_ = null;
goog.fx.anim.registerAnimation = function(animation) {
  var uid = goog.getUid(animation);
  uid in goog.fx.anim.activeAnimations_ || (goog.fx.anim.activeAnimations_[uid] = animation);
  goog.fx.anim.requestAnimationFrame_();
};
goog.fx.anim.unregisterAnimation = function(animation) {
  var uid = goog.getUid(animation);
  delete goog.fx.anim.activeAnimations_[uid];
  goog.object.isEmpty(goog.fx.anim.activeAnimations_) && goog.fx.anim.cancelAnimationFrame_();
};
goog.fx.anim.tearDown = function() {
  goog.fx.anim.animationWindow_ = null;
  goog.dispose(goog.fx.anim.animationDelay_);
  goog.fx.anim.animationDelay_ = null;
  goog.fx.anim.activeAnimations_ = {};
};
goog.fx.anim.setAnimationWindow = function(animationWindow) {
  var hasTimer = goog.fx.anim.animationDelay_ && goog.fx.anim.animationDelay_.isActive();
  goog.dispose(goog.fx.anim.animationDelay_);
  goog.fx.anim.animationDelay_ = null;
  goog.fx.anim.animationWindow_ = animationWindow;
  hasTimer && goog.fx.anim.requestAnimationFrame_();
};
goog.fx.anim.requestAnimationFrame_ = function() {
  goog.fx.anim.animationDelay_ || (goog.fx.anim.animationDelay_ = goog.fx.anim.animationWindow_ ? new goog.async.AnimationDelay(function(now) {
    goog.fx.anim.cycleAnimations_(now);
  }, goog.fx.anim.animationWindow_) : new goog.async.Delay(function() {
    goog.fx.anim.cycleAnimations_(goog.now());
  }, goog.fx.anim.TIMEOUT));
  var delay = goog.fx.anim.animationDelay_;
  delay.isActive() || delay.start();
};
goog.fx.anim.cancelAnimationFrame_ = function() {
  goog.fx.anim.animationDelay_ && goog.fx.anim.animationDelay_.stop();
};
goog.fx.anim.cycleAnimations_ = function(now) {
  goog.object.forEach(goog.fx.anim.activeAnimations_, function(anim) {
    anim.onAnimationFrame(now);
  });
  goog.object.isEmpty(goog.fx.anim.activeAnimations_) || goog.fx.anim.requestAnimationFrame_();
};
// INPUT (javascript/closure/fx/animation.js)
goog.fx.Animation = function(start, end, duration, opt_acc) {
  goog.fx.TransitionBase.call(this);
  if (!goog.isArray(start) || !goog.isArray(end)) {
    throw Error("Start and end parameters must be arrays");
  }
  if (start.length != end.length) {
    throw Error("Start and end points must be the same length");
  }
  this.startPoint = start;
  this.endPoint = end;
  this.duration = duration;
  this.accel_ = opt_acc;
  this.coords = [];
  this.useRightPositioningForRtl_ = !1;
};
goog.inherits(goog.fx.Animation, goog.fx.TransitionBase);
goog.fx.Animation.prototype.enableRightPositioningForRtl = function(useRightPositioningForRtl) {
  this.useRightPositioningForRtl_ = useRightPositioningForRtl;
};
goog.fx.Animation.prototype.isRightPositioningForRtlEnabled = function() {
  return this.useRightPositioningForRtl_;
};
goog.fx.Animation.EventType = {PLAY:goog.fx.Transition.EventType.PLAY, BEGIN:goog.fx.Transition.EventType.BEGIN, RESUME:goog.fx.Transition.EventType.RESUME, END:goog.fx.Transition.EventType.END, STOP:goog.fx.Transition.EventType.STOP, FINISH:goog.fx.Transition.EventType.FINISH, PAUSE:goog.fx.Transition.EventType.PAUSE, ANIMATE:"animate", DESTROY:"destroy"};
goog.fx.Animation.TIMEOUT = goog.fx.anim.TIMEOUT;
goog.fx.Animation.State = goog.fx.TransitionBase.State;
goog.fx.Animation.setAnimationWindow = function(animationWindow) {
  goog.fx.anim.setAnimationWindow(animationWindow);
};
goog.fx.Animation.prototype.progress = 0;
goog.fx.Animation.prototype.play = function(opt_restart) {
  if (opt_restart || this.isStopped()) {
    this.progress = 0, this.coords = this.startPoint;
  } else {
    if (this.isPlaying()) {
      return!1;
    }
  }
  goog.fx.anim.unregisterAnimation(this);
  var now = goog.now();
  this.startTime = now;
  this.isPaused() && (this.startTime -= this.duration * this.progress);
  this.endTime = this.startTime + this.duration;
  if (!this.progress) {
    this.onBegin();
  }
  this.onPlay();
  if (this.isPaused()) {
    this.onResume();
  }
  this.setStatePlaying();
  goog.fx.anim.registerAnimation(this);
  this.cycle(now);
  return!0;
};
goog.fx.Animation.prototype.stop = function(opt_gotoEnd) {
  goog.fx.anim.unregisterAnimation(this);
  this.setStateStopped();
  opt_gotoEnd && (this.progress = 1);
  this.updateCoords_(this.progress);
  this.onStop();
  this.onEnd();
};
goog.fx.Animation.prototype.pause = function() {
  this.isPlaying() && (goog.fx.anim.unregisterAnimation(this), this.setStatePaused(), this.onPause());
};
goog.fx.Animation.prototype.getProgress = function() {
  return this.progress;
};
goog.fx.Animation.prototype.disposeInternal = function() {
  this.isStopped() || this.stop(!1);
  this.onDestroy();
  goog.fx.Animation.superClass_.disposeInternal.call(this);
};
goog.fx.Animation.prototype.destroy = function() {
  this.dispose();
};
goog.fx.Animation.prototype.onAnimationFrame = function(now) {
  this.cycle(now);
};
goog.fx.Animation.prototype.cycle = function(now) {
  this.progress = (now - this.startTime) / (this.endTime - this.startTime);
  1 <= this.progress && (this.progress = 1);
  this.updateCoords_(this.progress);
  if (1 == this.progress) {
    this.setStateStopped(), goog.fx.anim.unregisterAnimation(this), this.onFinish(), this.onEnd();
  } else {
    if (this.isPlaying()) {
      this.onAnimate();
    }
  }
};
goog.fx.Animation.prototype.updateCoords_ = function(t) {
  goog.isFunction(this.accel_) && (t = this.accel_(t));
  this.coords = Array(this.startPoint.length);
  for (var i = 0;i < this.startPoint.length;i++) {
    this.coords[i] = (this.endPoint[i] - this.startPoint[i]) * t + this.startPoint[i];
  }
};
goog.fx.Animation.prototype.onAnimate = function() {
  this.dispatchAnimationEvent(goog.fx.Animation.EventType.ANIMATE);
};
goog.fx.Animation.prototype.onDestroy = function() {
  this.dispatchAnimationEvent(goog.fx.Animation.EventType.DESTROY);
};
goog.fx.Animation.prototype.dispatchAnimationEvent = function(type) {
  this.dispatchEvent(new goog.fx.AnimationEvent(type, this));
};
goog.fx.AnimationEvent = function(type, anim) {
  goog.events.Event.call(this, type);
  this.coords = anim.coords;
  this.x = anim.coords[0];
  this.y = anim.coords[1];
  this.z = anim.coords[2];
  this.duration = anim.duration;
  this.progress = anim.getProgress();
  this.state = anim.getStateInternal();
  this.anim = anim;
};
goog.inherits(goog.fx.AnimationEvent, goog.events.Event);
// INPUT (javascript/closure/fx/dom.js)
goog.fx.dom = {};
goog.fx.dom.PredefinedEffect = function(element, start, end, time, opt_acc) {
  goog.fx.Animation.call(this, start, end, time, opt_acc);
  this.element = element;
};
goog.inherits(goog.fx.dom.PredefinedEffect, goog.fx.Animation);
goog.fx.dom.PredefinedEffect.prototype.updateStyle = goog.nullFunction;
goog.fx.dom.PredefinedEffect.prototype.isRightToLeft = function() {
  goog.isDef(this.rightToLeft_) || (this.rightToLeft_ = goog.style.isRightToLeft(this.element));
  return this.rightToLeft_;
};
goog.fx.dom.PredefinedEffect.prototype.onAnimate = function() {
  this.updateStyle();
  goog.fx.dom.PredefinedEffect.superClass_.onAnimate.call(this);
};
goog.fx.dom.PredefinedEffect.prototype.onEnd = function() {
  this.updateStyle();
  goog.fx.dom.PredefinedEffect.superClass_.onEnd.call(this);
};
goog.fx.dom.PredefinedEffect.prototype.onBegin = function() {
  this.updateStyle();
  goog.fx.dom.PredefinedEffect.superClass_.onBegin.call(this);
};
goog.fx.dom.Slide = function(element, start, end, time, opt_acc) {
  if (2 != start.length || 2 != end.length) {
    throw Error("Start and end points must be 2D");
  }
  goog.fx.dom.PredefinedEffect.apply(this, arguments);
};
goog.inherits(goog.fx.dom.Slide, goog.fx.dom.PredefinedEffect);
goog.fx.dom.Slide.prototype.updateStyle = function() {
  var pos = this.isRightPositioningForRtlEnabled() && this.isRightToLeft() ? "right" : "left";
  this.element.style[pos] = Math.round(this.coords[0]) + "px";
  this.element.style.top = Math.round(this.coords[1]) + "px";
};
goog.fx.dom.SlideFrom = function(element, end, time, opt_acc) {
  var offsetLeft = this.isRightPositioningForRtlEnabled() ? goog.style.bidi.getOffsetStart(element) : element.offsetLeft, start = [offsetLeft, element.offsetTop];
  goog.fx.dom.Slide.call(this, element, start, end, time, opt_acc);
};
goog.inherits(goog.fx.dom.SlideFrom, goog.fx.dom.Slide);
goog.fx.dom.SlideFrom.prototype.onBegin = function() {
  var offsetLeft = this.isRightPositioningForRtlEnabled() ? goog.style.bidi.getOffsetStart(this.element) : this.element.offsetLeft;
  this.startPoint = [offsetLeft, this.element.offsetTop];
  goog.fx.dom.SlideFrom.superClass_.onBegin.call(this);
};
goog.fx.dom.Swipe = function(element, start, end, time, opt_acc) {
  if (2 != start.length || 2 != end.length) {
    throw Error("Start and end points must be 2D");
  }
  goog.fx.dom.PredefinedEffect.apply(this, arguments);
  this.maxWidth_ = Math.max(this.endPoint[0], this.startPoint[0]);
  this.maxHeight_ = Math.max(this.endPoint[1], this.startPoint[1]);
};
goog.inherits(goog.fx.dom.Swipe, goog.fx.dom.PredefinedEffect);
goog.fx.dom.Swipe.prototype.updateStyle = function() {
  var x = this.coords[0], y = this.coords[1];
  this.clip_(Math.round(x), Math.round(y), this.maxWidth_, this.maxHeight_);
  this.element.style.width = Math.round(x) + "px";
  var marginX = this.isRightPositioningForRtlEnabled() && this.isRightToLeft() ? "marginRight" : "marginLeft";
  this.element.style[marginX] = Math.round(x) - this.maxWidth_ + "px";
  this.element.style.marginTop = Math.round(y) - this.maxHeight_ + "px";
};
goog.fx.dom.Swipe.prototype.clip_ = function(x, y, w, h) {
  this.element.style.clip = "rect(" + (h - y) + "px " + w + "px " + h + "px " + (w - x) + "px)";
};
goog.fx.dom.Scroll = function(element, start, end, time, opt_acc) {
  if (2 != start.length || 2 != end.length) {
    throw Error("Start and end points must be 2D");
  }
  goog.fx.dom.PredefinedEffect.apply(this, arguments);
};
goog.inherits(goog.fx.dom.Scroll, goog.fx.dom.PredefinedEffect);
goog.fx.dom.Scroll.prototype.updateStyle = function() {
  this.isRightPositioningForRtlEnabled() ? goog.style.bidi.setScrollOffset(this.element, Math.round(this.coords[0])) : this.element.scrollLeft = Math.round(this.coords[0]);
  this.element.scrollTop = Math.round(this.coords[1]);
};
goog.fx.dom.Resize = function(element, start, end, time, opt_acc) {
  if (2 != start.length || 2 != end.length) {
    throw Error("Start and end points must be 2D");
  }
  goog.fx.dom.PredefinedEffect.apply(this, arguments);
};
goog.inherits(goog.fx.dom.Resize, goog.fx.dom.PredefinedEffect);
goog.fx.dom.Resize.prototype.updateStyle = function() {
  this.element.style.width = Math.round(this.coords[0]) + "px";
  this.element.style.height = Math.round(this.coords[1]) + "px";
};
goog.fx.dom.ResizeWidth = function(element, start, end, time, opt_acc) {
  goog.fx.dom.PredefinedEffect.call(this, element, [start], [end], time, opt_acc);
};
goog.inherits(goog.fx.dom.ResizeWidth, goog.fx.dom.PredefinedEffect);
goog.fx.dom.ResizeWidth.prototype.updateStyle = function() {
  this.element.style.width = Math.round(this.coords[0]) + "px";
};
goog.fx.dom.ResizeHeight = function(element, start, end, time, opt_acc) {
  goog.fx.dom.PredefinedEffect.call(this, element, [start], [end], time, opt_acc);
};
goog.inherits(goog.fx.dom.ResizeHeight, goog.fx.dom.PredefinedEffect);
goog.fx.dom.ResizeHeight.prototype.updateStyle = function() {
  this.element.style.height = Math.round(this.coords[0]) + "px";
};
goog.fx.dom.Fade = function(element, start, end, time, opt_acc) {
  goog.isNumber(start) && (start = [start]);
  goog.isNumber(end) && (end = [end]);
  goog.fx.dom.PredefinedEffect.call(this, element, start, end, time, opt_acc);
  if (1 != start.length || 1 != end.length) {
    throw Error("Start and end points must be 1D");
  }
};
goog.inherits(goog.fx.dom.Fade, goog.fx.dom.PredefinedEffect);
goog.fx.dom.Fade.prototype.updateStyle = function() {
  goog.style.setOpacity(this.element, this.coords[0]);
};
goog.fx.dom.Fade.prototype.show = function() {
  this.element.style.display = "";
};
goog.fx.dom.Fade.prototype.hide = function() {
  this.element.style.display = "none";
};
goog.fx.dom.FadeOut = function(element, time, opt_acc) {
  goog.fx.dom.Fade.call(this, element, 1, 0, time, opt_acc);
};
goog.inherits(goog.fx.dom.FadeOut, goog.fx.dom.Fade);
goog.fx.dom.FadeIn = function(element, time, opt_acc) {
  goog.fx.dom.Fade.call(this, element, 0, 1, time, opt_acc);
};
goog.inherits(goog.fx.dom.FadeIn, goog.fx.dom.Fade);
goog.fx.dom.FadeOutAndHide = function(element, time, opt_acc) {
  goog.fx.dom.Fade.call(this, element, 1, 0, time, opt_acc);
};
goog.inherits(goog.fx.dom.FadeOutAndHide, goog.fx.dom.Fade);
goog.fx.dom.FadeOutAndHide.prototype.onBegin = function() {
  this.show();
  goog.fx.dom.FadeOutAndHide.superClass_.onBegin.call(this);
};
goog.fx.dom.FadeOutAndHide.prototype.onEnd = function() {
  this.hide();
  goog.fx.dom.FadeOutAndHide.superClass_.onEnd.call(this);
};
goog.fx.dom.FadeInAndShow = function(element, time, opt_acc) {
  goog.fx.dom.Fade.call(this, element, 0, 1, time, opt_acc);
};
goog.inherits(goog.fx.dom.FadeInAndShow, goog.fx.dom.Fade);
goog.fx.dom.FadeInAndShow.prototype.onBegin = function() {
  this.show();
  goog.fx.dom.FadeInAndShow.superClass_.onBegin.call(this);
};
goog.fx.dom.BgColorTransform = function(element, start, end, time, opt_acc) {
  if (3 != start.length || 3 != end.length) {
    throw Error("Start and end points must be 3D");
  }
  goog.fx.dom.PredefinedEffect.apply(this, arguments);
};
goog.inherits(goog.fx.dom.BgColorTransform, goog.fx.dom.PredefinedEffect);
goog.fx.dom.BgColorTransform.prototype.setColor = function() {
  for (var coordsAsInts = [], i = 0;i < this.coords.length;i++) {
    coordsAsInts[i] = Math.round(this.coords[i]);
  }
  var color = "rgb(" + coordsAsInts.join(",") + ")";
  this.element.style.backgroundColor = color;
};
goog.fx.dom.BgColorTransform.prototype.updateStyle = function() {
  this.setColor();
};
goog.fx.dom.bgColorFadeIn = function(element, start, time, opt_eventHandler) {
  function setBgColor() {
    element.style.backgroundColor = initialBgColor;
  }
  var initialBgColor = element.style.backgroundColor || "", computedBgColor = goog.style.getBackgroundColor(element), end;
  end = computedBgColor && "transparent" != computedBgColor && "rgba(0, 0, 0, 0)" != computedBgColor ? goog.color.hexToRgb(goog.color.parse(computedBgColor).hex) : [255, 255, 255];
  var anim = new goog.fx.dom.BgColorTransform(element, start, end, time);
  opt_eventHandler ? opt_eventHandler.listen(anim, goog.fx.Transition.EventType.END, setBgColor) : goog.events.listen(anim, goog.fx.Transition.EventType.END, setBgColor);
  anim.play();
};
goog.fx.dom.ColorTransform = function(element, start, end, time, opt_acc) {
  if (3 != start.length || 3 != end.length) {
    throw Error("Start and end points must be 3D");
  }
  goog.fx.dom.PredefinedEffect.apply(this, arguments);
};
goog.inherits(goog.fx.dom.ColorTransform, goog.fx.dom.PredefinedEffect);
goog.fx.dom.ColorTransform.prototype.updateStyle = function() {
  for (var coordsAsInts = [], i = 0;i < this.coords.length;i++) {
    coordsAsInts[i] = Math.round(this.coords[i]);
  }
  var color = "rgb(" + coordsAsInts.join(",") + ")";
  this.element.style.color = color;
};
// INPUT (javascript/closure/ui/rangemodel.js)
goog.ui.RangeModel = function() {
  goog.events.EventTarget.call(this);
};
goog.inherits(goog.ui.RangeModel, goog.events.EventTarget);
goog.tagUnsealableClass(goog.ui.RangeModel);
goog.ui.RangeModel.prototype.value_ = 0;
goog.ui.RangeModel.prototype.minimum_ = 0;
goog.ui.RangeModel.prototype.maximum_ = 100;
goog.ui.RangeModel.prototype.extent_ = 0;
goog.ui.RangeModel.prototype.step_ = 1;
goog.ui.RangeModel.prototype.isChanging_ = !1;
goog.ui.RangeModel.prototype.mute_ = !1;
goog.ui.RangeModel.prototype.setMute = function(muteValue) {
  this.mute_ = muteValue;
};
goog.ui.RangeModel.prototype.setValue = function(value) {
  value = this.roundToStepWithMin(value);
  this.value_ != value && (this.value_ = value + this.extent_ > this.maximum_ ? this.maximum_ - this.extent_ : value < this.minimum_ ? this.minimum_ : value, this.isChanging_ || this.mute_ || this.dispatchEvent(goog.ui.Component.EventType.CHANGE));
};
goog.ui.RangeModel.prototype.getValue = function() {
  return this.roundToStepWithMin(this.value_);
};
goog.ui.RangeModel.prototype.setExtent = function(extent) {
  extent = this.roundToStepWithMin(extent);
  this.extent_ != extent && (this.extent_ = 0 > extent ? 0 : this.value_ + extent > this.maximum_ ? this.maximum_ - this.value_ : extent, this.isChanging_ || this.mute_ || this.dispatchEvent(goog.ui.Component.EventType.CHANGE));
};
goog.ui.RangeModel.prototype.getExtent = function() {
  return this.roundToStep(this.extent_);
};
goog.ui.RangeModel.prototype.setMinimum = function(minimum) {
  if (this.minimum_ != minimum) {
    var oldIsChanging = this.isChanging_;
    this.isChanging_ = !0;
    this.minimum_ = minimum;
    minimum + this.extent_ > this.maximum_ && (this.extent_ = this.maximum_ - this.minimum_);
    minimum > this.value_ && this.setValue(minimum);
    minimum > this.maximum_ && (this.extent_ = 0, this.setMaximum(minimum), this.setValue(minimum));
    (this.isChanging_ = oldIsChanging) || this.mute_ || this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
  }
};
goog.ui.RangeModel.prototype.getMinimum = function() {
  return this.roundToStepWithMin(this.minimum_);
};
goog.ui.RangeModel.prototype.setMaximum = function(maximum) {
  maximum = this.roundToStepWithMin(maximum);
  if (this.maximum_ != maximum) {
    var oldIsChanging = this.isChanging_;
    this.isChanging_ = !0;
    this.maximum_ = maximum;
    maximum < this.value_ + this.extent_ && this.setValue(maximum - this.extent_);
    maximum < this.minimum_ && (this.extent_ = 0, this.setMinimum(maximum), this.setValue(this.maximum_));
    maximum < this.minimum_ + this.extent_ && (this.extent_ = this.maximum_ - this.minimum_);
    (this.isChanging_ = oldIsChanging) || this.mute_ || this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
  }
};
goog.ui.RangeModel.prototype.getMaximum = function() {
  return this.roundToStepWithMin(this.maximum_);
};
goog.ui.RangeModel.prototype.getStep = function() {
  return this.step_;
};
goog.ui.RangeModel.prototype.setStep = function(step) {
  if (this.step_ != step) {
    this.step_ = step;
    var oldIsChanging = this.isChanging_;
    this.isChanging_ = !0;
    this.setMaximum(this.getMaximum());
    this.setExtent(this.getExtent());
    this.setValue(this.getValue());
    (this.isChanging_ = oldIsChanging) || this.mute_ || this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
  }
};
goog.ui.RangeModel.prototype.roundToStepWithMin = function(value) {
  return null == this.step_ ? value : this.minimum_ + Math.round((value - this.minimum_) / this.step_) * this.step_;
};
goog.ui.RangeModel.prototype.roundToStep = function(value) {
  return null == this.step_ ? value : Math.round(value / this.step_) * this.step_;
};
// INPUT (javascript/closure/ui/sliderbase.js)
goog.ui.SliderBase = function(opt_domHelper, opt_labelFn) {
  goog.ui.Component.call(this, opt_domHelper);
  this.additionalAnimations_ = null;
  this.rangeModel = new goog.ui.RangeModel;
  this.labelFn_ = opt_labelFn || goog.functions.NULL;
  goog.events.listen(this.rangeModel, goog.ui.Component.EventType.CHANGE, this.handleRangeModelChange, !1, this);
};
goog.inherits(goog.ui.SliderBase, goog.ui.Component);
goog.tagUnsealableClass(goog.ui.SliderBase);
goog.ui.SliderBase.EventType = {DRAG_VALUE_START:"a", DRAG_VALUE_END:"b", DRAG_EXTENT_START:"c", DRAG_EXTENT_END:"d", DRAG_START:"e", DRAG_END:"f"};
goog.ui.SliderBase.Orientation = {VERTICAL:"vertical", HORIZONTAL:"horizontal"};
goog.ui.SliderBase.prototype.orientation_ = goog.ui.SliderBase.Orientation.HORIZONTAL;
goog.ui.SliderBase.MOUSE_DOWN_INCREMENT_INTERVAL_ = 200;
goog.ui.SliderBase.ANIMATION_INTERVAL_ = 100;
goog.ui.SliderBase.prototype.isAnimating_ = !1;
goog.ui.SliderBase.prototype.moveToPointEnabled_ = !1;
goog.ui.SliderBase.prototype.blockIncrement_ = 10;
goog.ui.SliderBase.prototype.minExtent_ = 0;
goog.ui.SliderBase.prototype.isHandleMouseWheel_ = !0;
goog.ui.SliderBase.prototype.mouseDownTime_ = 0;
goog.ui.SliderBase.prototype.MOUSE_DOWN_DELAY_ = 1E3;
goog.ui.SliderBase.prototype.enabled_ = !0;
goog.ui.SliderBase.prototype.flipForRtl_ = !1;
goog.ui.SliderBase.prototype.createDom = function() {
  goog.ui.SliderBase.superClass_.createDom.call(this);
  var element = this.getDomHelper().createDom("div", this.getCssClass(this.orientation_));
  this.decorateInternal(element);
};
goog.ui.SliderBase.SLIDER_DRAGGING_CSS_CLASS_ = "aAAaGVIZSENTINELaAAa-slider-dragging";
goog.ui.SliderBase.THUMB_DRAGGING_CSS_CLASS_ = "aAAaGVIZSENTINELaAAa-slider-thumb-dragging";
goog.ui.SliderBase.DISABLED_CSS_CLASS_ = "aAAaGVIZSENTINELaAAa-slider-disabled";
goog.ui.SliderBase.prototype.decorateInternal = function(element) {
  goog.ui.SliderBase.superClass_.decorateInternal.call(this, element);
  goog.asserts.assert(element);
  goog.dom.classlist.add(element, this.getCssClass(this.orientation_));
  this.createThumbs();
  this.setAriaRoles();
};
goog.ui.SliderBase.prototype.enterDocument = function() {
  goog.ui.SliderBase.superClass_.enterDocument.call(this);
  this.valueDragger_ = new goog.fx.Dragger(this.valueThumb);
  this.extentDragger_ = new goog.fx.Dragger(this.extentThumb);
  this.valueDragger_.enableRightPositioningForRtl(this.flipForRtl_);
  this.extentDragger_.enableRightPositioningForRtl(this.flipForRtl_);
  this.valueDragger_.defaultAction = this.extentDragger_.defaultAction = goog.nullFunction;
  this.keyHandler_ = new goog.events.KeyHandler(this.getElement());
  this.enableEventHandlers_(!0);
  this.getElement().tabIndex = 0;
  this.updateUi_();
};
goog.ui.SliderBase.prototype.enableEventHandlers_ = function(enable) {
  enable ? (this.getHandler().listen(this.valueDragger_, goog.fx.Dragger.EventType.BEFOREDRAG, this.handleBeforeDrag_).listen(this.extentDragger_, goog.fx.Dragger.EventType.BEFOREDRAG, this.handleBeforeDrag_).listen(this.valueDragger_, [goog.fx.Dragger.EventType.START, goog.fx.Dragger.EventType.END], this.handleThumbDragStartEnd_).listen(this.extentDragger_, [goog.fx.Dragger.EventType.START, goog.fx.Dragger.EventType.END], this.handleThumbDragStartEnd_).listen(this.keyHandler_, goog.events.KeyHandler.EventType.KEY, 
  this.handleKeyDown_).listen(this.getElement(), goog.events.EventType.CLICK, this.handleMouseDownAndClick_).listen(this.getElement(), goog.events.EventType.MOUSEDOWN, this.handleMouseDownAndClick_), this.isHandleMouseWheel() && this.enableMouseWheelHandling_(!0)) : (this.getHandler().unlisten(this.valueDragger_, goog.fx.Dragger.EventType.BEFOREDRAG, this.handleBeforeDrag_).unlisten(this.extentDragger_, goog.fx.Dragger.EventType.BEFOREDRAG, this.handleBeforeDrag_).unlisten(this.valueDragger_, [goog.fx.Dragger.EventType.START, 
  goog.fx.Dragger.EventType.END], this.handleThumbDragStartEnd_).unlisten(this.extentDragger_, [goog.fx.Dragger.EventType.START, goog.fx.Dragger.EventType.END], this.handleThumbDragStartEnd_).unlisten(this.keyHandler_, goog.events.KeyHandler.EventType.KEY, this.handleKeyDown_).unlisten(this.getElement(), goog.events.EventType.CLICK, this.handleMouseDownAndClick_).unlisten(this.getElement(), goog.events.EventType.MOUSEDOWN, this.handleMouseDownAndClick_), this.isHandleMouseWheel() && this.enableMouseWheelHandling_(!1));
};
goog.ui.SliderBase.prototype.exitDocument = function() {
  goog.ui.SliderBase.superClass_.exitDocument.call(this);
  goog.disposeAll(this.valueDragger_, this.extentDragger_, this.keyHandler_, this.mouseWheelHandler_);
};
goog.ui.SliderBase.prototype.handleBeforeDrag_ = function(e) {
  var thumbToDrag = e.dragger == this.valueDragger_ ? this.valueThumb : this.extentThumb, value;
  if (this.orientation_ == goog.ui.SliderBase.Orientation.VERTICAL) {
    var availHeight = this.getElement().clientHeight - thumbToDrag.offsetHeight;
    value = (availHeight - e.top) / availHeight * (this.getMaximum() - this.getMinimum()) + this.getMinimum();
  } else {
    var availWidth = this.getElement().clientWidth - thumbToDrag.offsetWidth;
    value = e.left / availWidth * (this.getMaximum() - this.getMinimum()) + this.getMinimum();
  }
  value = e.dragger == this.valueDragger_ ? Math.min(Math.max(value, this.getMinimum()), this.getValue() + this.getExtent()) : Math.min(Math.max(value, this.getValue()), this.getMaximum());
  this.setThumbPosition_(thumbToDrag, value);
};
goog.ui.SliderBase.prototype.handleThumbDragStartEnd_ = function(e) {
  var isDragStart = e.type == goog.fx.Dragger.EventType.START;
  goog.dom.classlist.enable(goog.asserts.assertElement(this.getElement()), goog.ui.SliderBase.SLIDER_DRAGGING_CSS_CLASS_, isDragStart);
  goog.dom.classlist.enable(goog.asserts.assertElement(e.target.handle), goog.ui.SliderBase.THUMB_DRAGGING_CSS_CLASS_, isDragStart);
  var isValueDragger = e.dragger == this.valueDragger_;
  isDragStart ? (this.dispatchEvent(goog.ui.SliderBase.EventType.DRAG_START), this.dispatchEvent(isValueDragger ? goog.ui.SliderBase.EventType.DRAG_VALUE_START : goog.ui.SliderBase.EventType.DRAG_EXTENT_START)) : (this.dispatchEvent(goog.ui.SliderBase.EventType.DRAG_END), this.dispatchEvent(isValueDragger ? goog.ui.SliderBase.EventType.DRAG_VALUE_END : goog.ui.SliderBase.EventType.DRAG_EXTENT_END));
};
goog.ui.SliderBase.prototype.handleKeyDown_ = function(e) {
  var handled = !0;
  switch(e.keyCode) {
    case goog.events.KeyCodes.HOME:
      this.animatedSetValue(this.getMinimum());
      break;
    case goog.events.KeyCodes.END:
      this.animatedSetValue(this.getMaximum());
      break;
    case goog.events.KeyCodes.PAGE_UP:
      this.moveThumbs(this.getBlockIncrement());
      break;
    case goog.events.KeyCodes.PAGE_DOWN:
      this.moveThumbs(-this.getBlockIncrement());
      break;
    case goog.events.KeyCodes.LEFT:
      var sign = this.flipForRtl_ && this.isRightToLeft() ? 1 : -1;
      this.moveThumbs(e.shiftKey ? sign * this.getBlockIncrement() : sign * this.getUnitIncrement());
      break;
    case goog.events.KeyCodes.DOWN:
      this.moveThumbs(e.shiftKey ? -this.getBlockIncrement() : -this.getUnitIncrement());
      break;
    case goog.events.KeyCodes.RIGHT:
      sign = this.flipForRtl_ && this.isRightToLeft() ? -1 : 1;
      this.moveThumbs(e.shiftKey ? sign * this.getBlockIncrement() : sign * this.getUnitIncrement());
      break;
    case goog.events.KeyCodes.UP:
      this.moveThumbs(e.shiftKey ? this.getBlockIncrement() : this.getUnitIncrement());
      break;
    default:
      handled = !1;
  }
  handled && e.preventDefault();
};
goog.ui.SliderBase.prototype.handleMouseDownAndClick_ = function(e) {
  this.getElement().focus && this.getElement().focus();
  var target = e.target;
  if (!goog.dom.contains(this.valueThumb, target) && !goog.dom.contains(this.extentThumb, target)) {
    var isClick = e.type == goog.events.EventType.CLICK;
    isClick && goog.now() < this.mouseDownTime_ + this.MOUSE_DOWN_DELAY_ || (isClick || (this.mouseDownTime_ = goog.now()), this.moveToPointEnabled_ ? this.animatedSetValue(this.getValueFromMousePosition(e)) : this.startBlockIncrementing_(e));
  }
};
goog.ui.SliderBase.prototype.handleMouseWheel_ = function(e) {
  var direction = 0 < e.detail ? -1 : 1;
  this.moveThumbs(direction * this.getUnitIncrement());
  e.preventDefault();
};
goog.ui.SliderBase.prototype.startBlockIncrementing_ = function(e) {
  this.storeMousePos_(e);
  this.thumbToMove_ = this.getClosestThumb_(this.getValueFromMousePosition(e));
  this.incrementing_ = this.orientation_ == goog.ui.SliderBase.Orientation.VERTICAL ? this.lastMousePosition_ < this.thumbToMove_.offsetTop : this.lastMousePosition_ > this.getOffsetStart_(this.thumbToMove_) + this.thumbToMove_.offsetWidth;
  var doc = goog.dom.getOwnerDocument(this.getElement());
  this.getHandler().listen(doc, goog.events.EventType.MOUSEUP, this.stopBlockIncrementing_, !0).listen(this.getElement(), goog.events.EventType.MOUSEMOVE, this.storeMousePos_);
  this.incTimer_ || (this.incTimer_ = new goog.Timer(goog.ui.SliderBase.MOUSE_DOWN_INCREMENT_INTERVAL_), this.getHandler().listen(this.incTimer_, goog.Timer.TICK, this.handleTimerTick_));
  this.handleTimerTick_();
  this.incTimer_.start();
};
goog.ui.SliderBase.prototype.handleTimerTick_ = function() {
  var value;
  if (this.orientation_ == goog.ui.SliderBase.Orientation.VERTICAL) {
    var mouseY = this.lastMousePosition_, thumbY = this.thumbToMove_.offsetTop;
    if (this.incrementing_) {
      mouseY < thumbY && (value = this.getThumbPosition_(this.thumbToMove_) + this.getBlockIncrement());
    } else {
      var thumbH = this.thumbToMove_.offsetHeight;
      mouseY > thumbY + thumbH && (value = this.getThumbPosition_(this.thumbToMove_) - this.getBlockIncrement());
    }
  } else {
    var mouseX = this.lastMousePosition_, thumbX = this.getOffsetStart_(this.thumbToMove_);
    if (this.incrementing_) {
      var thumbW = this.thumbToMove_.offsetWidth;
      mouseX > thumbX + thumbW && (value = this.getThumbPosition_(this.thumbToMove_) + this.getBlockIncrement());
    } else {
      mouseX < thumbX && (value = this.getThumbPosition_(this.thumbToMove_) - this.getBlockIncrement());
    }
  }
  goog.isDef(value) && this.setThumbPosition_(this.thumbToMove_, value);
};
goog.ui.SliderBase.prototype.stopBlockIncrementing_ = function() {
  this.incTimer_ && this.incTimer_.stop();
  var doc = goog.dom.getOwnerDocument(this.getElement());
  this.getHandler().unlisten(doc, goog.events.EventType.MOUSEUP, this.stopBlockIncrementing_, !0).unlisten(this.getElement(), goog.events.EventType.MOUSEMOVE, this.storeMousePos_);
};
goog.ui.SliderBase.prototype.getRelativeMousePos_ = function(e) {
  var coord = goog.style.getRelativePosition(e, this.getElement());
  return this.orientation_ == goog.ui.SliderBase.Orientation.VERTICAL ? coord.y : this.flipForRtl_ && this.isRightToLeft() ? this.getElement().clientWidth - coord.x : coord.x;
};
goog.ui.SliderBase.prototype.storeMousePos_ = function(e) {
  this.lastMousePosition_ = this.getRelativeMousePos_(e);
};
goog.ui.SliderBase.prototype.getValueFromMousePosition = function(e) {
  var min = this.getMinimum(), max = this.getMaximum();
  if (this.orientation_ == goog.ui.SliderBase.Orientation.VERTICAL) {
    var thumbH = this.valueThumb.offsetHeight, availH = this.getElement().clientHeight - thumbH, y = this.getRelativeMousePos_(e) - thumbH / 2;
    return(max - min) * (availH - y) / availH + min;
  }
  var thumbW = this.valueThumb.offsetWidth, availW = this.getElement().clientWidth - thumbW, x = this.getRelativeMousePos_(e) - thumbW / 2;
  return(max - min) * x / availW + min;
};
goog.ui.SliderBase.prototype.getThumbPosition_ = function(thumb) {
  if (thumb == this.valueThumb) {
    return this.rangeModel.getValue();
  }
  if (thumb == this.extentThumb) {
    return this.rangeModel.getValue() + this.rangeModel.getExtent();
  }
  throw Error("Illegal thumb element. Neither minThumb nor maxThumb");
};
goog.ui.SliderBase.prototype.moveThumbs = function(delta) {
  Math.abs(delta) < this.getStep() && (delta = goog.math.sign(delta) * this.getStep());
  var newMinPos = this.getThumbPosition_(this.valueThumb) + delta, newMaxPos = this.getThumbPosition_(this.extentThumb) + delta, newMinPos = goog.math.clamp(newMinPos, this.getMinimum(), this.getMaximum() - this.minExtent_), newMaxPos = goog.math.clamp(newMaxPos, this.getMinimum() + this.minExtent_, this.getMaximum());
  this.setValueAndExtent(newMinPos, newMaxPos - newMinPos);
};
goog.ui.SliderBase.prototype.setThumbPosition_ = function(thumb, position) {
  var roundedPosition = this.rangeModel.roundToStepWithMin(position), value = thumb == this.valueThumb ? roundedPosition : this.rangeModel.getValue(), end = thumb == this.extentThumb ? roundedPosition : this.rangeModel.getValue() + this.rangeModel.getExtent();
  value >= this.getMinimum() && end >= value + this.minExtent_ && this.getMaximum() >= end && this.setValueAndExtent(value, end - value);
};
goog.ui.SliderBase.prototype.setValueAndExtent = function(value, extent) {
  this.getMinimum() <= value && value <= this.getMaximum() - extent && this.minExtent_ <= extent && extent <= this.getMaximum() - value && (value != this.getValue() || extent != this.getExtent()) && (this.rangeModel.setMute(!0), this.rangeModel.setExtent(0), this.rangeModel.setValue(value), this.rangeModel.setExtent(extent), this.rangeModel.setMute(!1), this.handleRangeModelChange(null));
};
goog.ui.SliderBase.prototype.getMinimum = function() {
  return this.rangeModel.getMinimum();
};
goog.ui.SliderBase.prototype.setMinimum = function(min) {
  this.rangeModel.setMinimum(min);
};
goog.ui.SliderBase.prototype.getMaximum = function() {
  return this.rangeModel.getMaximum();
};
goog.ui.SliderBase.prototype.setMaximum = function(max) {
  this.rangeModel.setMaximum(max);
};
goog.ui.SliderBase.prototype.getValueThumb = function() {
  return this.valueThumb;
};
goog.ui.SliderBase.prototype.getExtentThumb = function() {
  return this.extentThumb;
};
goog.ui.SliderBase.prototype.getClosestThumb_ = function(position) {
  return position <= this.rangeModel.getValue() + this.rangeModel.getExtent() / 2 ? this.valueThumb : this.extentThumb;
};
goog.ui.SliderBase.prototype.handleRangeModelChange = function() {
  this.updateUi_();
  this.updateAriaStates();
  this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
};
goog.ui.SliderBase.prototype.updateUi_ = function() {
  if (this.valueThumb && !this.isAnimating_) {
    var minCoord = this.getThumbCoordinateForValue(this.getThumbPosition_(this.valueThumb)), maxCoord = this.getThumbCoordinateForValue(this.getThumbPosition_(this.extentThumb));
    if (this.orientation_ == goog.ui.SliderBase.Orientation.VERTICAL) {
      if (this.valueThumb.style.top = minCoord.y + "px", this.extentThumb.style.top = maxCoord.y + "px", this.rangeHighlight) {
        var highlightPositioning = this.calculateRangeHighlightPositioning_(maxCoord.y, minCoord.y, this.valueThumb.offsetHeight);
        this.rangeHighlight.style.top = highlightPositioning.offset + "px";
        this.rangeHighlight.style.height = highlightPositioning.size + "px";
      }
    } else {
      var pos = this.flipForRtl_ && this.isRightToLeft() ? "right" : "left";
      this.valueThumb.style[pos] = minCoord.x + "px";
      this.extentThumb.style[pos] = maxCoord.x + "px";
      this.rangeHighlight && (highlightPositioning = this.calculateRangeHighlightPositioning_(minCoord.x, maxCoord.x, this.valueThumb.offsetWidth), this.rangeHighlight.style[pos] = highlightPositioning.offset + "px", this.rangeHighlight.style.width = highlightPositioning.size + "px");
    }
  }
};
goog.ui.SliderBase.prototype.calculateRangeHighlightPositioning_ = function(firstThumbPos, secondThumbPos, thumbSize) {
  var highlightInset = Math.ceil(thumbSize / 2), size = secondThumbPos - firstThumbPos + thumbSize - 2 * highlightInset;
  return{offset:firstThumbPos + highlightInset, size:Math.max(size, 0)};
};
goog.ui.SliderBase.prototype.getThumbCoordinateForValue = function(val) {
  var coord = new goog.math.Coordinate;
  if (this.valueThumb) {
    var min = this.getMinimum(), max = this.getMaximum(), ratio = val == min && min == max ? 0 : (val - min) / (max - min);
    if (this.orientation_ == goog.ui.SliderBase.Orientation.VERTICAL) {
      var thumbHeight = this.valueThumb.offsetHeight, h = this.getElement().clientHeight - thumbHeight, bottom = Math.round(ratio * h);
      coord.x = this.getOffsetStart_(this.valueThumb);
      coord.y = h - bottom;
    } else {
      var w = this.getElement().clientWidth - this.valueThumb.offsetWidth, left = Math.round(ratio * w);
      coord.x = left;
      coord.y = this.valueThumb.offsetTop;
    }
  }
  return coord;
};
goog.ui.SliderBase.prototype.animatedSetValue = function(v) {
  v = goog.math.clamp(v, this.getMinimum(), this.getMaximum());
  this.isAnimating_ && this.currentAnimation_.stop(!0);
  var animations = new goog.fx.AnimationParallelQueue, end, thumb = this.getClosestThumb_(v), previousValue = this.getValue(), previousExtent = this.getExtent(), previousThumbValue = this.getThumbPosition_(thumb), previousCoord = this.getThumbCoordinateForValue(previousThumbValue), stepSize = this.getStep();
  if (Math.abs(v - previousThumbValue) < stepSize) {
    var delta = v > previousThumbValue ? stepSize : -stepSize;
    v = previousThumbValue + delta;
    v = goog.math.clamp(v, this.getMinimum(), this.getMaximum());
  }
  this.setThumbPosition_(thumb, v);
  var coord = this.getThumbCoordinateForValue(this.getThumbPosition_(thumb));
  end = this.orientation_ == goog.ui.SliderBase.Orientation.VERTICAL ? [this.getOffsetStart_(thumb), coord.y] : [coord.x, thumb.offsetTop];
  var slide = new goog.fx.dom.Slide(thumb, [previousCoord.x, previousCoord.y], end, goog.ui.SliderBase.ANIMATION_INTERVAL_);
  slide.enableRightPositioningForRtl(this.flipForRtl_);
  animations.add(slide);
  this.rangeHighlight && this.addRangeHighlightAnimations_(thumb, previousValue, previousExtent, coord, animations);
  if (this.additionalAnimations_) {
    var additionalAnimations = this.additionalAnimations_.createAnimations(previousValue, v, goog.ui.SliderBase.ANIMATION_INTERVAL_);
    goog.array.forEach(additionalAnimations, function(animation) {
      animations.add(animation);
    });
  }
  this.currentAnimation_ = animations;
  this.getHandler().listen(animations, goog.fx.Transition.EventType.END, this.endAnimation_);
  this.isAnimating_ = !0;
  animations.play(!1);
};
goog.ui.SliderBase.prototype.addRangeHighlightAnimations_ = function(thumb, previousValue, previousExtent, newCoord, animations) {
  var previousMinCoord = this.getThumbCoordinateForValue(previousValue), previousMaxCoord = this.getThumbCoordinateForValue(previousValue + previousExtent), minCoord = previousMinCoord, maxCoord = previousMaxCoord;
  thumb == this.valueThumb ? minCoord = newCoord : maxCoord = newCoord;
  if (this.orientation_ == goog.ui.SliderBase.Orientation.VERTICAL) {
    var previousHighlightPositioning = this.calculateRangeHighlightPositioning_(previousMaxCoord.y, previousMinCoord.y, this.valueThumb.offsetHeight), highlightPositioning = this.calculateRangeHighlightPositioning_(maxCoord.y, minCoord.y, this.valueThumb.offsetHeight), slide = new goog.fx.dom.Slide(this.rangeHighlight, [this.getOffsetStart_(this.rangeHighlight), previousHighlightPositioning.offset], [this.getOffsetStart_(this.rangeHighlight), highlightPositioning.offset], goog.ui.SliderBase.ANIMATION_INTERVAL_), 
    resizeHeight = new goog.fx.dom.ResizeHeight(this.rangeHighlight, previousHighlightPositioning.size, highlightPositioning.size, goog.ui.SliderBase.ANIMATION_INTERVAL_);
    slide.enableRightPositioningForRtl(this.flipForRtl_);
    resizeHeight.enableRightPositioningForRtl(this.flipForRtl_);
    animations.add(slide);
    animations.add(resizeHeight);
  } else {
    var previousHighlightPositioning = this.calculateRangeHighlightPositioning_(previousMinCoord.x, previousMaxCoord.x, this.valueThumb.offsetWidth), highlightPositioning = this.calculateRangeHighlightPositioning_(minCoord.x, maxCoord.x, this.valueThumb.offsetWidth), slide = new goog.fx.dom.Slide(this.rangeHighlight, [previousHighlightPositioning.offset, this.rangeHighlight.offsetTop], [highlightPositioning.offset, this.rangeHighlight.offsetTop], goog.ui.SliderBase.ANIMATION_INTERVAL_), resizeWidth = 
    new goog.fx.dom.ResizeWidth(this.rangeHighlight, previousHighlightPositioning.size, highlightPositioning.size, goog.ui.SliderBase.ANIMATION_INTERVAL_);
    slide.enableRightPositioningForRtl(this.flipForRtl_);
    resizeWidth.enableRightPositioningForRtl(this.flipForRtl_);
    animations.add(slide);
    animations.add(resizeWidth);
  }
};
goog.ui.SliderBase.prototype.endAnimation_ = function() {
  this.isAnimating_ = !1;
};
goog.ui.SliderBase.prototype.setOrientation = function(orient) {
  if (this.orientation_ != orient) {
    var oldCss = this.getCssClass(this.orientation_), newCss = this.getCssClass(orient);
    this.orientation_ = orient;
    if (this.getElement()) {
      goog.dom.classlist.swap(goog.asserts.assert(this.getElement()), oldCss, newCss);
      var pos = this.flipForRtl_ && this.isRightToLeft() ? "right" : "left";
      this.valueThumb.style[pos] = this.valueThumb.style.top = "";
      this.extentThumb.style[pos] = this.extentThumb.style.top = "";
      this.rangeHighlight && (this.rangeHighlight.style[pos] = this.rangeHighlight.style.top = "", this.rangeHighlight.style.width = this.rangeHighlight.style.height = "");
      this.updateUi_();
    }
  }
};
goog.ui.SliderBase.prototype.getOrientation = function() {
  return this.orientation_;
};
goog.ui.SliderBase.prototype.disposeInternal = function() {
  goog.ui.SliderBase.superClass_.disposeInternal.call(this);
  this.incTimer_ && this.incTimer_.dispose();
  delete this.incTimer_;
  this.currentAnimation_ && this.currentAnimation_.dispose();
  delete this.currentAnimation_;
  delete this.valueThumb;
  delete this.extentThumb;
  this.rangeHighlight && delete this.rangeHighlight;
  this.rangeModel.dispose();
  delete this.rangeModel;
  this.keyHandler_ && (this.keyHandler_.dispose(), delete this.keyHandler_);
  this.mouseWheelHandler_ && (this.mouseWheelHandler_.dispose(), delete this.mouseWheelHandler_);
  this.valueDragger_ && (this.valueDragger_.dispose(), delete this.valueDragger_);
  this.extentDragger_ && (this.extentDragger_.dispose(), delete this.extentDragger_);
};
goog.ui.SliderBase.prototype.getBlockIncrement = function() {
  return this.blockIncrement_;
};
goog.ui.SliderBase.prototype.setBlockIncrement = function(value) {
  this.blockIncrement_ = value;
};
goog.ui.SliderBase.prototype.unitIncrement_ = 1;
goog.ui.SliderBase.prototype.getUnitIncrement = function() {
  return this.unitIncrement_;
};
goog.ui.SliderBase.prototype.setUnitIncrement = function(value) {
  this.unitIncrement_ = value;
};
goog.ui.SliderBase.prototype.getStep = function() {
  return this.rangeModel.getStep();
};
goog.ui.SliderBase.prototype.setStep = function(step) {
  this.rangeModel.setStep(step);
};
goog.ui.SliderBase.prototype.getValue = function() {
  return this.rangeModel.getValue();
};
goog.ui.SliderBase.prototype.setValue = function(value) {
  this.setThumbPosition_(this.valueThumb, value);
};
goog.ui.SliderBase.prototype.getExtent = function() {
  return this.rangeModel.getExtent();
};
goog.ui.SliderBase.prototype.setExtent = function(extent) {
  this.setThumbPosition_(this.extentThumb, this.rangeModel.getValue() + extent);
};
goog.ui.SliderBase.prototype.setVisible = function(visible) {
  goog.style.setElementShown(this.getElement(), visible);
  visible && this.updateUi_();
};
goog.ui.SliderBase.prototype.setAriaRoles = function() {
  var el = this.getElement();
  goog.asserts.assert(el, "The DOM element for the slider base cannot be null.");
  goog.a11y.aria.setRole(el, goog.a11y.aria.Role.SLIDER);
  this.updateAriaStates();
};
goog.ui.SliderBase.prototype.updateAriaStates = function() {
  var element = this.getElement();
  element && (goog.a11y.aria.setState(element, goog.a11y.aria.State.VALUEMIN, this.getMinimum()), goog.a11y.aria.setState(element, goog.a11y.aria.State.VALUEMAX, this.getMaximum()), goog.a11y.aria.setState(element, goog.a11y.aria.State.VALUENOW, this.getValue()), goog.a11y.aria.setState(element, goog.a11y.aria.State.VALUETEXT, this.getTextValue() || ""));
};
goog.ui.SliderBase.prototype.isHandleMouseWheel = function() {
  return this.isHandleMouseWheel_;
};
goog.ui.SliderBase.prototype.enableMouseWheelHandling_ = function(enable) {
  enable ? (this.mouseWheelHandler_ || (this.mouseWheelHandler_ = new goog.events.MouseWheelHandler(this.getElement())), this.getHandler().listen(this.mouseWheelHandler_, goog.events.MouseWheelHandler.EventType.MOUSEWHEEL, this.handleMouseWheel_)) : this.getHandler().unlisten(this.mouseWheelHandler_, goog.events.MouseWheelHandler.EventType.MOUSEWHEEL, this.handleMouseWheel_);
};
goog.ui.SliderBase.prototype.setEnabled = function(enable) {
  if (this.enabled_ != enable) {
    var eventType = enable ? goog.ui.Component.EventType.ENABLE : goog.ui.Component.EventType.DISABLE;
    this.dispatchEvent(eventType) && (this.enabled_ = enable, this.enableEventHandlers_(enable), enable || this.stopBlockIncrementing_(), goog.dom.classlist.enable(goog.asserts.assert(this.getElement()), goog.ui.SliderBase.DISABLED_CSS_CLASS_, !enable));
  }
};
goog.ui.SliderBase.prototype.isEnabled = function() {
  return this.enabled_;
};
goog.ui.SliderBase.prototype.getOffsetStart_ = function(element) {
  return this.flipForRtl_ ? goog.style.bidi.getOffsetStart(element) : element.offsetLeft;
};
goog.ui.SliderBase.prototype.getTextValue = function() {
  return this.labelFn_(this.getValue());
};
goog.ui.SliderBase.AnimationFactory = function() {
};
// INPUT (javascript/closure/ui/slider.js)
goog.ui.Slider = function(opt_domHelper, opt_labelFn) {
  goog.ui.SliderBase.call(this, opt_domHelper, opt_labelFn);
  this.rangeModel.setExtent(0);
};
goog.inherits(goog.ui.Slider, goog.ui.SliderBase);
goog.tagUnsealableClass(goog.ui.Slider);
goog.ui.Slider.Orientation = goog.ui.SliderBase.Orientation;
goog.ui.Slider.CSS_CLASS_PREFIX = "aAAaGVIZSENTINELaAAa-slider";
goog.ui.Slider.THUMB_CSS_CLASS = goog.ui.Slider.CSS_CLASS_PREFIX + "-thumb";
goog.ui.Slider.prototype.getCssClass = function(orient) {
  return orient == goog.ui.SliderBase.Orientation.VERTICAL ? goog.ui.Slider.CSS_CLASS_PREFIX + "-vertical" : goog.ui.Slider.CSS_CLASS_PREFIX + "-horizontal";
};
goog.ui.Slider.prototype.createThumbs = function() {
  var element = this.getElement(), thumb = goog.dom.getElementsByTagNameAndClass(null, goog.ui.Slider.THUMB_CSS_CLASS, element)[0];
  thumb || (thumb = this.createThumb_(), element.appendChild(thumb));
  this.valueThumb = this.extentThumb = thumb;
};
goog.ui.Slider.prototype.createThumb_ = function() {
  var thumb = this.getDomHelper().createDom("div", goog.ui.Slider.THUMB_CSS_CLASS);
  goog.a11y.aria.setRole(thumb, goog.a11y.aria.Role.BUTTON);
  return thumb;
};
// INPUT (javascript/gviz/devel/jsapi/packages/util/toolbar/googleapis_exports.js)
goog.exportSymbol("google.visualization.drawToolbar", google.visualization.drawToolbar);
// INPUT (javascript/closure/style/transition.js)
goog.style.transition = {};
goog.style.transition.set = function(element, properties) {
  goog.isArray(properties) || (properties = [properties]);
  goog.asserts.assert(0 < properties.length, "At least one Css3Property should be specified.");
  var values = goog.array.map(properties, function(p) {
    if (goog.isString(p)) {
      return p;
    }
    goog.asserts.assertObject(p, "Expected css3 property to be an object.");
    var propString = p.property + " " + p.duration + "s " + p.timing + " " + p.delay + "s";
    goog.asserts.assert(p.property && goog.isNumber(p.duration) && p.timing && goog.isNumber(p.delay), "Unexpected css3 property value: %s", propString);
    return propString;
  });
  goog.style.transition.setPropertyValue_(element, values.join(","));
};
goog.style.transition.removeAll = function(element) {
  goog.style.transition.setPropertyValue_(element, "");
};
goog.style.transition.isSupported = goog.functions.cacheReturnValue(function() {
  if (goog.userAgent.IE) {
    return goog.userAgent.isVersionOrHigher("10.0");
  }
  var el = document.createElement("div"), vendorPrefix = goog.dom.vendor.getVendorPrefix(), style = {transition:"opacity 1s linear"};
  vendorPrefix && (style[vendorPrefix + "-transition"] = "opacity 1s linear");
  goog.dom.safe.setInnerHtml(el, goog.html.SafeHtml.create("div", {style:style}));
  var testElement = el.firstChild;
  goog.asserts.assert(testElement.nodeType == Node.ELEMENT_NODE);
  return "" != goog.style.getStyle(testElement, "transition");
});
goog.style.transition.setPropertyValue_ = function(element, transitionValue) {
  goog.style.setStyle(element, "transition", transitionValue);
};
// INPUT (javascript/closure/fx/css3/transition.js)
goog.fx.css3 = {};
goog.fx.css3.Transition = function(element, duration, initialStyle, finalStyle, transitions) {
  goog.fx.TransitionBase.call(this);
  this.element_ = element;
  this.duration_ = duration;
  this.initialStyle_ = initialStyle;
  this.finalStyle_ = finalStyle;
  this.transitions_ = goog.isArray(transitions) ? transitions : [transitions];
};
goog.inherits(goog.fx.css3.Transition, goog.fx.TransitionBase);
goog.fx.css3.Transition.prototype.play = function() {
  if (this.isPlaying()) {
    return!1;
  }
  this.onBegin();
  this.onPlay();
  this.startTime = goog.now();
  this.setStatePlaying();
  if (goog.style.transition.isSupported()) {
    return goog.style.setStyle(this.element_, this.initialStyle_), this.timerId_ = goog.Timer.callOnce(this.play_, void 0, this), !0;
  }
  this.stop_(!1);
  return!1;
};
goog.fx.css3.Transition.prototype.play_ = function() {
  goog.style.transition.set(this.element_, this.transitions_);
  goog.style.setStyle(this.element_, this.finalStyle_);
  this.timerId_ = goog.Timer.callOnce(goog.bind(this.stop_, this, !1), 1E3 * this.duration_);
};
goog.fx.css3.Transition.prototype.stop = function() {
  this.isPlaying() && this.stop_(!0);
};
goog.fx.css3.Transition.prototype.stop_ = function(stopped) {
  goog.style.transition.removeAll(this.element_);
  goog.Timer.clear(this.timerId_);
  goog.style.setStyle(this.element_, this.finalStyle_);
  this.endTime = goog.now();
  this.setStateStopped();
  if (stopped) {
    this.onStop();
  } else {
    this.onFinish();
  }
  this.onEnd();
};
goog.fx.css3.Transition.prototype.disposeInternal = function() {
  this.stop();
  goog.fx.css3.Transition.superClass_.disposeInternal.call(this);
};
goog.fx.css3.Transition.prototype.pause = function() {
  goog.asserts.assert(!1, "Css3 transitions does not support pause action.");
};
// INPUT (javascript/closure/fx/css3/fx.js)
goog.fx.css3.fade = function(element, duration, timing, startOpacity, endOpacity) {
  return new goog.fx.css3.Transition(element, duration, {opacity:startOpacity}, {opacity:endOpacity}, {property:"opacity", duration:duration, timing:timing, delay:0});
};
goog.fx.css3.fadeIn = function(element, duration) {
  return goog.fx.css3.fade(element, duration, "ease-out", 0, 1);
};
goog.fx.css3.fadeOut = function(element, duration) {
  return goog.fx.css3.fade(element, duration, "ease-in", 1, 0);
};
// INPUT (javascript/gviz/devel/canviz/text-measure-function.js)
// INPUT (javascript/gviz/devel/jsapi/common/tooltip/tooltipdefinition.js)
gviz.util.tooltip = {};
gviz.util.tooltip.BodyEntryType = {LINE:"line", SEPARATOR:"separator", HTML:"html"};
gviz.util.tooltip.BodyItemType = {TEXT:"text", SQUARE:"square"};
// INPUT (javascript/gviz/devel/jsapi/common/selection.js)
gviz.util.Selection = function() {
  this.selectedRows_ = new goog.structs.Set;
  this.selectedColumns_ = new goog.structs.Set;
  this.selectedCells_ = new goog.structs.Set;
};
gviz.util.Selection.CELL_INDEXES_SEPARATOR_ = ",";
gviz.util.Selection.propertyName_ = {ROW:"row", COLUMN:"column"};
gviz.util.Selection.prototype.clear = function() {
  this.selectedRows_ = new goog.structs.Set;
  this.selectedColumns_ = new goog.structs.Set;
  this.selectedCells_ = new goog.structs.Set;
};
gviz.util.Selection.prototype.clone = function() {
  var cloned = new gviz.util.Selection;
  cloned.selectedRows_ = new goog.structs.Set(this.selectedRows_.getValues());
  cloned.selectedColumns_ = new goog.structs.Set(this.selectedColumns_.getValues());
  cloned.selectedCells_ = new goog.structs.Set(this.selectedCells_.getValues());
  return cloned;
};
gviz.util.Selection.prototype.equals = function(other) {
  return this.selectedRows_.equals(other.selectedRows_) && this.selectedColumns_.equals(other.selectedColumns_) && this.selectedCells_.equals(other.selectedCells_);
};
gviz.util.Selection.prototype.getIndexes_ = function(propertyName) {
  var selectedProperties = propertyName == gviz.util.Selection.propertyName_.ROW ? this.selectedRows_ : this.selectedColumns_, selection = [];
  goog.iter.forEach(selectedProperties, function(ind) {
    selection.push(parseInt(ind, 10));
  });
  return selection;
};
gviz.util.Selection.prototype.getRowIndexes = function() {
  return this.getIndexes_(gviz.util.Selection.propertyName_.ROW);
};
gviz.util.Selection.prototype.getColumnIndexes = function() {
  return this.getIndexes_(gviz.util.Selection.propertyName_.COLUMN);
};
gviz.util.Selection.prototype.getCells = function() {
  var selection = [];
  goog.iter.forEach(this.selectedCells_, function(ind) {
    var indexes = ind.split(gviz.util.Selection.CELL_INDEXES_SEPARATOR_);
    selection.push({row:parseInt(indexes[0], 10), column:parseInt(indexes[1], 10)});
  });
  return selection;
};
gviz.util.Selection.prototype.getSelection = function() {
  for (var selection = [], rowIndexes = this.getRowIndexes(), columnIndexes = this.getColumnIndexes(), cellIndexes = this.getCells(), i = 0;i < rowIndexes.length;i++) {
    var o = {};
    o[gviz.util.Selection.propertyName_.ROW] = rowIndexes[i];
    o[gviz.util.Selection.propertyName_.COLUMN] = null;
    selection.push(o);
  }
  for (i = 0;i < columnIndexes.length;i++) {
    o = {}, o[gviz.util.Selection.propertyName_.ROW] = null, o[gviz.util.Selection.propertyName_.COLUMN] = columnIndexes[i], selection.push(o);
  }
  for (i = 0;i < cellIndexes.length;i++) {
    o = {}, o[gviz.util.Selection.propertyName_.ROW] = cellIndexes[i].row, o[gviz.util.Selection.propertyName_.COLUMN] = cellIndexes[i].column, selection.push(o);
  }
  return selection;
};
gviz.util.Selection.prototype.contains_ = function(propertyName, indexes) {
  return propertyName == gviz.util.Selection.propertyName_.ROW ? this.containsRow(indexes[0]) : propertyName == gviz.util.Selection.propertyName_.COLUMN ? this.containsColumn(indexes[0]) : this.containsCell(indexes[0], indexes[1]);
};
gviz.util.Selection.prototype.containsRow = function(index) {
  return this.selectedRows_.contains(String(index));
};
gviz.util.Selection.prototype.containsColumn = function(index) {
  return this.selectedColumns_.contains(String(index));
};
gviz.util.Selection.prototype.containsCell = function(rowIndex, colIndex) {
  return this.selectedCells_.contains(String(rowIndex + gviz.util.Selection.CELL_INDEXES_SEPARATOR_ + colIndex));
};
gviz.util.Selection.prototype.add_ = function(propertyName, indexes) {
  if (this.contains_(propertyName, indexes)) {
    return!1;
  }
  propertyName == gviz.util.Selection.propertyName_.ROW ? this.selectedRows_.add(String(indexes[0])) : propertyName == gviz.util.Selection.propertyName_.COLUMN ? this.selectedColumns_.add(String(indexes[0])) : this.selectedCells_.add(String(indexes[0] + gviz.util.Selection.CELL_INDEXES_SEPARATOR_ + indexes[1]));
  return!0;
};
gviz.util.Selection.prototype.addRow = function(index) {
  return this.add_(gviz.util.Selection.propertyName_.ROW, [index]);
};
gviz.util.Selection.prototype.addColumn = function(index) {
  return this.add_(gviz.util.Selection.propertyName_.COLUMN, [index]);
};
gviz.util.Selection.prototype.addCell = function(rowIndex, colIndex) {
  return this.add_("cell", [rowIndex, colIndex]);
};
gviz.util.Selection.prototype.toggleRow = function(index, opt_isSingleSelect) {
  var contains = this.containsRow(index);
  opt_isSingleSelect && this.clear();
  contains ? this.removeRow(index) : this.addRow(index);
  return!contains;
};
gviz.util.Selection.prototype.toggleColumn = function(index, opt_isSingleSelect) {
  var contains = this.containsColumn(index);
  opt_isSingleSelect && this.clear();
  contains ? this.removeColumn(index) : this.addColumn(index);
  return!contains;
};
gviz.util.Selection.prototype.toggleCell = function(rowIndex, colIndex, opt_isSingleSelect) {
  var contains = this.containsCell(rowIndex, colIndex);
  opt_isSingleSelect && this.clear();
  contains ? this.removeCell(rowIndex, colIndex) : this.addCell(rowIndex, colIndex);
  return!contains;
};
gviz.util.Selection.prototype.removeRow = function(index) {
  if (!this.containsRow(index)) {
    return!1;
  }
  this.selectedRows_.remove(String(index));
  return!0;
};
gviz.util.Selection.prototype.removeColumn = function(index) {
  if (!this.containsColumn(index)) {
    return!1;
  }
  this.selectedColumns_.remove(String(index));
  return!0;
};
gviz.util.Selection.prototype.removeCell = function(rowIndex, colIndex) {
  if (!this.containsCell(rowIndex, colIndex)) {
    return!1;
  }
  this.selectedCells_.remove(String(rowIndex + gviz.util.Selection.CELL_INDEXES_SEPARATOR_ + colIndex));
  return!0;
};
gviz.util.Selection.prototype.removeAllCells = function() {
  this.selectedCells_ = new goog.structs.Set;
};
gviz.util.Selection.prototype.setSelection = function(newSelection) {
  var newRowsSelectionSet = new goog.structs.Set, newColumnsSelectionSet = new goog.structs.Set, newCellsSelectionSet = new goog.structs.Set;
  newSelection || (newSelection = []);
  for (var i = 0;i < newSelection.length;i++) {
    var item = newSelection[i];
    null != item.row && null != item.column ? newCellsSelectionSet.add(String(item.row + gviz.util.Selection.CELL_INDEXES_SEPARATOR_ + item.column)) : null != item.row ? newRowsSelectionSet.add(String(item.row)) : null != item.column && newColumnsSelectionSet.add(String(item.column));
  }
  var addedRowsSet = this.getSetDifference_(newRowsSelectionSet, this.selectedRows_), addedColumnsSet = this.getSetDifference_(newColumnsSelectionSet, this.selectedColumns_), addedCellsSet = this.getSetDifference_(newCellsSelectionSet, this.selectedCells_), removedRowsSet = this.getSetDifference_(this.selectedRows_, newRowsSelectionSet), removedColumnsSet = this.getSetDifference_(this.selectedColumns_, newColumnsSelectionSet), removedCellsSet = this.getSetDifference_(this.selectedCells_, newCellsSelectionSet);
  this.selectedRows_ = newRowsSelectionSet;
  this.selectedColumns_ = newColumnsSelectionSet;
  this.selectedCells_ = newCellsSelectionSet;
  var addedSelection = new gviz.util.Selection;
  addedSelection.selectedRows_ = addedRowsSet;
  addedSelection.selectedColumns_ = addedColumnsSet;
  addedSelection.selectedCells_ = addedCellsSet;
  var removedSelection = new gviz.util.Selection;
  removedSelection.selectedRows_ = removedRowsSet;
  removedSelection.selectedColumns_ = removedColumnsSet;
  removedSelection.selectedCells_ = removedCellsSet;
  return new gviz.util.SelectionChange(addedSelection, removedSelection);
};
gviz.util.Selection.prototype.getSetDifference_ = function(firstSet, secondSet) {
  return firstSet.difference(secondSet);
};
gviz.util.SelectionChange = function(added, removed) {
  this.added_ = added;
  this.removed_ = removed;
};
gviz.util.SelectionChange.prototype.getAdded = function() {
  return this.added_;
};
gviz.util.SelectionChange.prototype.getRemoved = function() {
  return this.removed_;
};
// INPUT (javascript/closure/ui/custombutton.js)
goog.ui.CustomButton = function(content, opt_renderer, opt_domHelper) {
  goog.ui.Button.call(this, content, opt_renderer || goog.ui.CustomButtonRenderer.getInstance(), opt_domHelper);
};
goog.inherits(goog.ui.CustomButton, goog.ui.Button);
goog.ui.registry.setDecoratorByClassName(goog.ui.CustomButtonRenderer.CSS_CLASS, function() {
  return new goog.ui.CustomButton(null);
});
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/table/tablerow.js)
gviz.table = {};
gviz.table.TableRow = function(dataRowIndex, UIRowIndex, pageRowIndex, displayNumber) {
  this.dataRowIndex_ = dataRowIndex;
  this.UIRowIndex_ = UIRowIndex;
  this.pageRowIndex_ = pageRowIndex;
  this.displayNumber_ = displayNumber;
};
gviz.table.TableRow.prototype.isSelected_ = !1;
gviz.table.TableRow.prototype.setSelected = function(selected) {
  this.isSelected_ = selected;
};
gviz.table.TableRow.prototype.setEven = function() {
};
gviz.table.TableRow.prototype.isSelected = function() {
  return this.isSelected_;
};
gviz.table.TableRow.prototype.getDataRowIndex = function() {
  return this.dataRowIndex_;
};
gviz.table.TableRow.prototype.getUIRowIndex = function() {
  return this.UIRowIndex_;
};
gviz.table.TableRow.prototype.getPageRowIndex = function() {
  return this.pageRowIndex_;
};
gviz.table.TableRow.prototype.getDisplayNumber = function() {
  return this.displayNumber_;
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/table/pagemanager.js)
gviz.table.PageManager = function(dataView, options) {
  this.dataView_ = dataView;
  var dataViewNumberOfRows = dataView.getNumberOfRows(), pageSize = dataViewNumberOfRows;
  options.page && "disable" != options.page && (pageSize = options.pageSize || 10);
  this.pageSize_ = pageSize;
  this.numberOfPages_ = 0 < dataViewNumberOfRows ? Math.ceil(dataViewNumberOfRows / this.pageSize_) : 1;
  this.firstRowDisplayNumber_ = goog.isDefAndNotNull(options.firstRowNumber) ? options.firstRowNumber : 1;
  this.enableLocalSort_ = !options.sort || "enable" == options.sort;
};
gviz.table.PageManager.prototype.dataView_ = null;
gviz.table.PageManager.prototype.currentPageIndex_ = 0;
gviz.table.PageManager.prototype.sortedIndexes_ = null;
gviz.table.PageManager.prototype.sortColumnIndex_ = -1;
gviz.table.PageManager.prototype.isSortDescending_ = !1;
gviz.table.PageManager.prototype.pageRowIndexByDataRowIndex_ = null;
gviz.table.PageManager.prototype.setPageIndex = function(pageIndex) {
  return 0 <= pageIndex && pageIndex < this.numberOfPages_ ? (this.currentPageIndex_ = pageIndex, !0) : !1;
};
gviz.table.PageManager.prototype.calculateTableRowsInCurrentPage = function() {
  for (var range = this.calculatePageRangeInUIRowIndexes_(), page = [], pageIndexToDataIndex = {}, ind = range.start;ind <= range.end;ind++) {
    var tableRow = this.getTableRowByUIRowIndex_(ind);
    pageIndexToDataIndex[tableRow.getDataRowIndex()] = tableRow.getPageRowIndex();
    page.push(tableRow);
  }
  this.pageRowIndexByDataRowIndex_ = pageIndexToDataIndex;
  return page;
};
gviz.table.PageManager.prototype.getCurrentPageIndex = function() {
  return this.currentPageIndex_;
};
gviz.table.PageManager.prototype.getTableRowsInRangeByUIRows = function(uiStartRowIndex, uiEndRowIndex) {
  for (var rows = [], ind = uiStartRowIndex;ind <= uiEndRowIndex;ind++) {
    var tableRow = this.getTableRowByUIRowIndex_(ind);
    rows.push(tableRow);
  }
  return rows;
};
gviz.table.PageManager.prototype.setSort = function(sortColumnIndex, isDescending) {
  this.sortColumnIndex_ = sortColumnIndex;
  this.isSortDescending_ = isDescending;
  this.calculateSortedIndexes_();
};
gviz.table.PageManager.prototype.getSortInfo = function() {
  var info = {column:this.getSortColumnIndex(), ascending:this.getSortOrder(), sortedIndexes:this.getSortedIndexes()};
  return info;
};
gviz.table.PageManager.prototype.getSortedIndexes = function() {
  return this.sortedIndexes_;
};
gviz.table.PageManager.prototype.getSortColumnIndex = function() {
  return this.sortColumnIndex_;
};
gviz.table.PageManager.prototype.getSortOrder = function() {
  return!this.isSortDescending_;
};
gviz.table.PageManager.prototype.getFirstTableRowInPage = function() {
  return this.getTableRowByUIRowIndex_(this.calculatePageRangeInUIRowIndexes_().start);
};
gviz.table.PageManager.prototype.getPageRowIndexByDataRowIndex = function(dataRowIndex) {
  this.pageRowIndexByDataRowIndex_ || this.calculateTableRowsInCurrentPage();
  var pageIndex = this.pageRowIndexByDataRowIndex_[dataRowIndex];
  return null != pageIndex ? pageIndex : -1;
};
gviz.table.PageManager.prototype.calculatePageRangeInUIRowIndexes_ = function() {
  var first = this.pageSize_ * this.currentPageIndex_, last = first + this.pageSize_ - 1, last = Math.min(this.dataView_.getNumberOfRows() - 1, last);
  return new goog.math.Range(first, last);
};
gviz.table.PageManager.prototype.getTableRowByUIRowIndex_ = function(uiRowIndex) {
  var sortedIndexes = this.sortedIndexes_, firstRowDisplayNumber = this.firstRowDisplayNumber_, firstUIRowIndex = this.calculatePageRangeInUIRowIndexes_().start, rowDisplayNumber = uiRowIndex + firstRowDisplayNumber, pageRowIndex = uiRowIndex - firstUIRowIndex, dataRowIndex = sortedIndexes ? sortedIndexes[uiRowIndex] : uiRowIndex;
  return new gviz.table.TableRow(dataRowIndex, uiRowIndex, pageRowIndex, rowDisplayNumber);
};
gviz.table.PageManager.prototype.calculateSortedIndexes_ = function() {
  if (this.enableLocalSort_ && -1 != this.sortColumnIndex_) {
    var sortedIndexes = this.dataView_.getSortedRows([{column:this.sortColumnIndex_, desc:this.isSortDescending_}]), viewRows = this.dataView_.getViewRows(), sortedViewRows = goog.array.map(sortedIndexes, function(i) {
      return viewRows[i];
    }, this);
    this.dataView_.setRows(sortedViewRows);
    this.sortedIndexes_ = this.sortedIndexes_ ? goog.array.map(sortedIndexes, function(i) {
      return this.sortedIndexes_[i];
    }, this) : sortedIndexes;
  } else {
    this.sortedIndexes_ = null;
  }
};
gviz.table.PageManager.prototype.getNumberOfPages = function() {
  return this.numberOfPages_;
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/table/table.js)
google.visualization.Table = function(container) {
  google.visualization.AbstractVisualization.call(this, container);
  this.dom_ = goog.dom.getDomHelper();
  this.selectedRows_ = new gviz.util.Selection;
  this.headerRows_ = {};
};
goog.inherits(google.visualization.Table, google.visualization.AbstractVisualization);
google.visualization.Table.WAIT_FOR_CSS_MAX_ITERATIONS_ = 10;
google.visualization.Table.CSS_WAIT_INCREMENT_ = 200;
google.visualization.Table.CSSPREFIX_ = "google-visualization-table-";
google.visualization.Table.CSS_DEFAULT_ = {TABLE:google.visualization.Table.CSSPREFIX_ + "table", TR_HEAD:google.visualization.Table.CSSPREFIX_ + "tr-head", TR_EVEN:google.visualization.Table.CSSPREFIX_ + "tr-even", TR_ODD:google.visualization.Table.CSSPREFIX_ + "tr-odd", TR_SELECTED:google.visualization.Table.CSSPREFIX_ + "tr-sel", TR_MOUSEOVER:google.visualization.Table.CSSPREFIX_ + "tr-over", TH:google.visualization.Table.CSSPREFIX_ + "th gradient", TH_WEBKIT:google.visualization.Table.CSSPREFIX_ + 
"th-webkit gradient", TD:google.visualization.Table.CSSPREFIX_ + "td", TD_NUMBER:google.visualization.Table.CSSPREFIX_ + "td-number", TD_CENTER:google.visualization.Table.CSSPREFIX_ + "td-center", TD_BOOLEAN:google.visualization.Table.CSSPREFIX_ + "td-bool", TD_FREEZE_RIGHTMOST:google.visualization.Table.CSSPREFIX_ + "td-freeze-rightmost", SEQ:google.visualization.Table.CSSPREFIX_ + "seq", SORT:google.visualization.Table.CSSPREFIX_ + "sorthdr", SORTIND:google.visualization.Table.CSSPREFIX_ + "sortind", 
PAGE_DIV:google.visualization.Table.CSSPREFIX_ + "div-page", PAGE_NUMBERS:google.visualization.Table.CSSPREFIX_ + "page-numbers", PAGE_NUMBER:"page-number gradient"};
google.visualization.Table.CLASSNAME_TO_OPTION_NAME_ = {TR_HEAD:"headerRow", TR_EVEN:"tableRow", TR_ODD:"oddTableRow", TR_SELECTED:"selectedTableRow", TR_MOUSEOVER:"hoverTableRow", TH:"headerCell", TD:"tableCell", SEQ:"rowNumberCell"};
google.visualization.Table.PANE_TYPE_ = {HEADER:"h", FROZEN_TABLE:"ft", FROZEN_HEADER:"fh"};
google.visualization.Table.PANE_NAME_ = {TOP_LEVEL:"top-level", FIXED_HEADERS:"fixed-headers", FROZEN_COLUMNS:"frozen-columns", FROZEN_COLUMN_HEADERS:"frozen-column-headers"};
google.visualization.Table.NON_STRICT_ = "-nonstrict";
google.visualization.Table.TRANSPARENT_STYLE_ = {"background-image":"none", backgroundColor:"transparent", borderColor:"transparent"};
google.visualization.Table.TRANSPARENT_STYLE_IE6_ = {"background-image":"none", backgroundColor:"transparent"};
google.visualization.Table.HIDDEN_STYLE_ = {visibility:"hidden"};
google.visualization.Table.RIGHT_BORDER_STYLE_ = {borderRight:"2px solid gray"};
google.visualization.Table.DEFAULT_SCROLLBAR_WIDTH_ = 16;
google.visualization.Table.LEFT_ARROW_IMG_ = gviz.util.VisCommon.getModulePath() + "/table/arrow_left.gif";
google.visualization.Table.RIGHT_ARROW_IMG_ = gviz.util.VisCommon.getModulePath() + "/table/arrow_right.gif";
google.visualization.Table.prototype.firstTimeRendered_ = !0;
google.visualization.Table.prototype.checkCssLoadedDiv_ = null;
google.visualization.Table.prototype.cssClassNames_ = null;
google.visualization.Table.prototype.lastSelectedTableRow_ = null;
google.visualization.Table.prototype.dataTable_ = null;
google.visualization.Table.prototype.dataView_ = null;
google.visualization.Table.prototype.options_ = null;
google.visualization.Table.prototype.pageManager_ = null;
google.visualization.Table.prototype.page_ = null;
google.visualization.Table.prototype.htmlTable_ = null;
google.visualization.Table.prototype.htmlFrozenColumnsTable_ = null;
google.visualization.Table.prototype.numFrozenColumns_ = -1;
google.visualization.Table.prototype.hasRows_ = !1;
google.visualization.Table.prototype.scrollpane_ = null;
google.visualization.Table.prototype.prevButton_ = null;
google.visualization.Table.prototype.nextButton_ = null;
google.visualization.Table.prototype.scrollLeftStartPosition_ = 0;
google.visualization.Table.prototype.eventHandler_ = null;
google.visualization.Table.prototype.drawInternal = function(asyncWrapper, dataTable, opt_options) {
  var container = this.container, options = opt_options || {};
  if (!container) {
    throw Error("Container is not defined");
  }
  if (!dataTable) {
    throw Error("Data table is not defined");
  }
  this.dataTable_ = dataTable;
  this.dataView_ = new google.visualization.DataView(this.dataTable_);
  this.options_ = options;
  this.hasRows_ = 0 < this.dataView_.getNumberOfRows();
  this.pageManager_ = new gviz.table.PageManager(this.dataView_, this.options_);
  if (this.hasRows_) {
    options.startPage && this.pageManager_.setPageIndex(options.startPage);
    if ("disable" != options.sort && null != options.sortColumn) {
      var sortAscending = options.sortAscending, sortAscending = goog.isDefAndNotNull(sortAscending) ? sortAscending : !0;
      this.pageManager_.setSort(options.sortColumn, !sortAscending);
    }
    this.lastSelectedTableRow_ = this.pageManager_.getFirstTableRowInPage();
  }
  this.scrollLeftStartPosition_ = options.scrollLeftStartPosition || 0;
  var numFrozenColumns = google.visualization.Table.getRealValueWithDefault(options.frozenColumns, -1);
  0 != numFrozenColumns || options.showRowNumber || (numFrozenColumns = -1);
  numFrozenColumns >= this.dataView_.getNumberOfColumns() && (numFrozenColumns = -1);
  -1 > numFrozenColumns && (numFrozenColumns = -1);
  this.numFrozenColumns_ = numFrozenColumns;
  this.cssClassNames_ = goog.object.clone(google.visualization.Table.CSS_DEFAULT_);
  -1 == numFrozenColumns && this.setCustomClassNames_();
  var isCssLoaded = !0;
  this.firstTimeRendered_ && (isCssLoaded = this.checkCssLoaded_(), this.firstTimeRendered_ = !1);
  this.redraw_();
  isCssLoaded ? (goog.dom.removeNode(this.checkCssLoadedDiv_), this.triggerReadyEvent_()) : this.waitForCss_(0);
};
google.visualization.Table.prototype.triggerReadyEvent_ = function() {
  google.visualization.events.trigger(this, "ready", null);
};
google.visualization.Table.prototype.getSortInfo = function() {
  return this.pageManager_ ? this.pageManager_.getSortInfo() : null;
};
google.visualization.Table.prototype.redraw_ = function(opt_reuseHeaders) {
  opt_reuseHeaders || (this.headerRows_ = {});
  var dataView = this.dataView_, options = this.options_, container = this.container, panes = [], dom = this.dom_, pane, cssClassNames = this.cssClassNames_, keepScrollPosition = options.keepScrollPosition, scrollLeft = this.scrollLeftStartPosition_, scrollTop = 0;
  keepScrollPosition && this.scrollpane_ && (scrollLeft = this.scrollpane_.scrollLeft, scrollTop = this.scrollpane_.scrollTop);
  this.page_ = null;
  this.clear_();
  this.eventHandler_ = new goog.events.EventHandler;
  var containerStyleWidth = container.style.width, containerStyleHeight = container.style.height, width = containerStyleWidth || options.width || 0, height = containerStyleHeight || options.height || 0, width = google.visualization.Table.addUnitsIfRequired_(width), height = google.visualization.Table.addUnitsIfRequired_(height), colTypes = google.visualization.Table.getColumnTypes_(dataView), tdClassNames = google.visualization.Table.getTDCssClassNames_(dataView, cssClassNames), headerRow = this.createHeaderRow_(!0, 
  google.visualization.Table.PANE_NAME_.TOP_LEVEL), table = this.htmlTable_ = this.createTable_(headerRow, options, tdClassNames, colTypes), scrollpane = this.scrollpane_ = dom.createDom("div", {style:"position: relative;"}, table);
  width && goog.style.setStyle(scrollpane, {overflow:"auto", width:width});
  var contentElement = dom.createDom("div", {style:"position: relative;"}, scrollpane);
  height && (goog.style.setStyle(scrollpane, {overflow:"auto", height:height}), pane = this.createPane_({matchLeft:!0}, google.visualization.Table.PANE_NAME_.FIXED_HEADERS), panes.push({pane:pane, type:google.visualization.Table.PANE_TYPE_.HEADER}));
  var numFrozenColumns = this.numFrozenColumns_, createFrozenColumnsTable = width && 0 < dataView.getNumberOfColumns() && 0 < dataView.getNumberOfRows() && -1 < numFrozenColumns;
  createFrozenColumnsTable && (pane = this.createPane_({matchTop:!0, frozenColumns:numFrozenColumns}, google.visualization.Table.PANE_NAME_.FROZEN_COLUMNS), this.htmlFrozenColumnsTable_ = pane.firstChild, panes.push({pane:pane, type:google.visualization.Table.PANE_TYPE_.FROZEN_TABLE}), height && (pane = this.createPane_({frozenColumns:numFrozenColumns, headerFreezeOnly:!0}, google.visualization.Table.PANE_NAME_.FROZEN_COLUMN_HEADERS), panes.push({pane:pane, type:google.visualization.Table.PANE_TYPE_.FROZEN_HEADER})));
  contentElement.style.visibility = "hidden";
  dom.appendChild(container, contentElement);
  var hasPages = this.hasRows_ && 1 < this.pageManager_.getNumberOfPages(), pagingButtonsConfiguration = options.pagingButtonsConfiguration, pagingButtonsRequired = goog.isDefAndNotNull(pagingButtonsConfiguration) && "auto" != pagingButtonsConfiguration || hasPages;
  if (pagingButtonsRequired && options.page && "disable" != options.page) {
    var offsetHeight = contentElement.offsetHeight;
    this.createPagingControls_(contentElement);
    height && (height = offsetHeight - (contentElement.offsetHeight - offsetHeight), goog.style.setStyle(scrollpane, "height", height + "px"));
  }
  !options.rtlTable || pagingButtonsRequired || width || height || (this.htmlTable_.style.direction = "rtl");
  var frozenWidth = 0;
  if (createFrozenColumnsTable) {
    var frozenCells = numFrozenColumns + (options.showRowNumber ? 1 : 0), nodes = headerRow.childNodes, frozenWidth = 2 + goog.style.getPosition(nodes[frozenCells]).x
  }
  var isVerticalScroll = scrollpane.clientHeight < scrollpane.scrollHeight, isHorizontalScroll = scrollpane.clientWidth < scrollpane.scrollWidth;
  if (height && !width) {
    var tableWidth = this.htmlTable_.clientWidth;
    if (isVerticalScroll) {
      var scrollBarWidth = google.visualization.Table.getScrollbarWidth_() || google.visualization.Table.DEFAULT_SCROLLBAR_WIDTH_;
      goog.style.setStyle(scrollpane, {width:tableWidth + scrollBarWidth + "px"});
    } else {
      goog.style.setStyle(scrollpane, {width:tableWidth + "px"});
    }
  }
  var strechTableWidth = 0;
  0 < scrollpane.clientWidth - table.clientWidth && (strechTableWidth = scrollpane.clientWidth, goog.style.setStyle(table, "width", strechTableWidth + "px"));
  for (var p = 0;p < panes.length;p++) {
    var currPane = panes[p].pane, type = panes[p].type;
    if (strechTableWidth) {
      var currTable = currPane.firstChild;
      goog.style.setStyle(currTable, "width", scrollpane.clientWidth + "px");
    }
    switch(type) {
      case google.visualization.Table.PANE_TYPE_.HEADER:
        isVerticalScroll && (goog.style.setStyle(currPane, {height:headerRow.clientHeight + "px", width:scrollpane.clientWidth + "px"}), dom.appendChild(contentElement, currPane));
        break;
      case google.visualization.Table.PANE_TYPE_.FROZEN_TABLE:
        isHorizontalScroll && (goog.style.setStyle(currPane, {height:scrollpane.clientHeight + "px", width:frozenWidth + "px"}), dom.appendChild(contentElement, currPane));
        break;
      case google.visualization.Table.PANE_TYPE_.FROZEN_HEADER:
        isVerticalScroll && isHorizontalScroll && (goog.style.setStyle(currPane, {height:headerRow.clientHeight + "px", width:frozenWidth + "px"}), dom.appendChild(contentElement, currPane));
    }
  }
  scrollpane.scrollTop = scrollTop;
  scrollpane.scrollLeft = scrollLeft;
  contentElement.style.visibility = "";
};
google.visualization.Table.prototype.createPane_ = function(paneOptions, tag) {
  var dom = this.dom_, options = this.options_, cssClassNames = this.cssClassNames_, scrollpane = this.scrollpane_, dataView = this.dataView_, colTypes = google.visualization.Table.getColumnTypes_(dataView), tdClassNames = google.visualization.Table.getTDCssClassNames_(dataView, cssClassNames), numFrozenColumns = paneOptions.frozenColumns, showFunction = google.visualization.Table.showNothing_, headerRow = this.createHeaderRow_(!0, tag);
  if (0 <= numFrozenColumns) {
    var startIndex = numFrozenColumns + (options.showRowNumber ? 1 : 0);
    goog.style.setStyle(headerRow.childNodes[startIndex - 1], google.visualization.Table.RIGHT_BORDER_STYLE_);
    google.visualization.Table.setElementTransparent_(headerRow);
    for (var nodes = headerRow.childNodes, c = startIndex;c < nodes.length;c++) {
      google.visualization.Table.setElementHidden_(nodes[c]);
    }
    google.visualization.Table.getRealValueWithDefault(paneOptions.headerFreezeOnly, !1) || (showFunction = google.visualization.Table.showFrozenColumns_(numFrozenColumns));
  }
  var fixedHeaderTable = this.createTable_(headerRow, options, tdClassNames, colTypes, showFunction);
  goog.style.setStyle(fixedHeaderTable, {backgroundColor:"transparent"});
  var pane = dom.createDom("div", {style:"position: absolute; top: 0; left: 0; overflow: hidden;"}, fixedHeaderTable);
  paneOptions.matchLeft && this.eventHandler_.listen(scrollpane, goog.events.EventType.SCROLL, goog.partial(google.visualization.Table.matchScrollLeft_, scrollpane, pane));
  paneOptions.matchTop && this.eventHandler_.listen(scrollpane, goog.events.EventType.SCROLL, goog.partial(google.visualization.Table.matchScrollTop_, scrollpane, pane));
  return pane;
};
google.visualization.Table.prototype.createTable_ = function(headerRow, options, tdClass, colTypes, opt_setAdditionalStyle) {
  var setAdditionalStyle = opt_setAdditionalStyle || goog.nullFunction, dataView = this.dataView_, dataTable = this.dataTable_, dom = this.dom_, cssClassNames = this.cssClassNames_, table = dom.createDom("table", {"class":cssClassNames.TABLE, cellspacing:"0"}), thead = dom.createDom("thead");
  dom.appendChild(table, thead);
  dom.appendChild(thead, headerRow);
  var tbody = dom.createDom("tbody");
  dom.appendChild(table, tbody);
  var numberFormatter = new google.visualization.NumberFormat({fractionDigits:0, pattern:"#"}), td, className;
  null == this.page_ && (this.page_ = this.hasRows_ ? this.pageManager_.calculateTableRowsInCurrentPage() : []);
  for (var page = this.page_, evenRow = !0, alternatingRowStyle = options.alternatingRowStyle, alternatingRowStyle = goog.isDefAndNotNull(alternatingRowStyle) ? alternatingRowStyle : !0, i = 0;i < page.length;i++) {
    var tableRow = page[i], dataRowIndex = tableRow.getDataRowIndex(), rowColor = dataTable.getRowProperty(dataRowIndex, "rowColor");
    className = rowColor ? "" : alternatingRowStyle ? evenRow ? cssClassNames.TR_EVEN : cssClassNames.TR_ODD : cssClassNames.TR_EVEN;
    tableRow.setEven(evenRow);
    var evenRow = !evenRow, tr = dom.createDom("tr", {"class":className});
    this.selectedRows_.containsRow(dataRowIndex) && (tr.className = cssClassNames.TR_SELECTED, tableRow.setSelected(!0));
    rowColor && (tr.style.backgroundColor = rowColor);
    this.eventHandler_.listen(tr, goog.events.EventType.MOUSEDOWN, goog.bind(this.handleRowMouseDown_, this, tableRow));
    this.eventHandler_.listen(tr, goog.events.EventType.MOUSEOVER, goog.bind(this.handleRowMouseOver_, this, tableRow));
    this.eventHandler_.listen(tr, goog.events.EventType.MOUSEOUT, goog.bind(this.handleRowMouseOut_, this, tableRow));
    dom.appendChild(tbody, tr);
    if (options.showRowNumber) {
      var rnClassName = cssClassNames.TD + " " + cssClassNames.SEQ;
      td = dom.createDom("td", {"class":rnClassName});
      dom.appendChild(tr, td);
      dom.appendChild(td, dom.createTextNode(numberFormatter.formatValue(tableRow.getDisplayNumber())));
      setAdditionalStyle(td, i, -1);
    }
    for (var c = 0, numColumns = dataView.getNumberOfColumns();c < numColumns;) {
      var r = tableRow.getDataRowIndex(), tdOptions = {}, classNames = tdClass[c], customClasses = dataTable.getProperty(r, c, "className");
      customClasses && (classNames = customClasses);
      tdOptions["class"] = classNames;
      var colSpan = dataTable.getProperty(r, c, "__td-colSpan");
      (colSpan = colSpan && Math.min(colSpan, numColumns - c)) && 1 < colSpan ? tdOptions.colSpan = colSpan : colSpan = 1;
      td = dom.createDom("td", tdOptions);
      dom.appendChild(tr, td);
      var v = dataTable.getValue(r, c), fv = dataTable.getFormattedValue(r, c);
      null == v ? fv = goog.string.isEmptySafe(fv) ? "\u00a0" : fv : "boolean" == colTypes[c] && (fv = v ? "\u2714" : "\u2717");
      if (options.allowHtml) {
        td.innerHTML = fv;
        var styles = dataTable.getProperty(r, c, "style");
        styles && (td.style.cssText = styles);
      } else {
        dom.appendChild(td, dom.createTextNode(fv));
      }
      setAdditionalStyle(td, i, c);
      c += colSpan;
    }
    setAdditionalStyle(tr, i);
  }
  return table;
};
google.visualization.Table.prototype.createHeaderRow_ = function(addClickHandler, tag) {
  var dataView = this.dataView_, options = this.options_ || {}, cssClassNames = this.cssClassNames_, enableSortIndicators = "disable" != options.sort && 0 < dataView.getNumberOfRows(), updateHeaders = goog.bind(function(headerRow) {
    for (var cells = headerRow.childNodes, sortOrderClasses = ["unsorted", "sort-descending", "sort-ascending"], c = 0;c < cells.length;c++) {
      var th = cells[c], index = th.index;
      addClickHandler && null != index && this.eventHandler_.listen(th, goog.events.EventType.CLICK, goog.bind(this.handleHeaderClick_, this, index), !0);
      goog.dom.classlist.removeAll(th, sortOrderClasses);
      if (enableSortIndicators) {
        var sortThisColumn = this.pageManager_.getSortColumnIndex() === index, sortOrderClass = sortOrderClasses[sortThisColumn ? this.pageManager_.getSortOrder() ? 2 : 1 : 0];
        goog.dom.classlist.add(th, sortOrderClass);
      }
    }
  }, this);
  if (this.headerRows_[tag]) {
    var tr = this.headerRows_[tag];
    updateHeaders(tr);
    return tr;
  }
  var dom = this.dom_, numColumns = dataView.getNumberOfColumns(), tr = dom.createDom("tr", {"class":cssClassNames.TR_HEAD, tag:tag}), th, useWebKitHack = goog.userAgent.WEBKIT && options.height && cssClassNames.TH == google.visualization.Table.CSS_DEFAULT_.TH;
  if (options.showRowNumber && 0 < dataView.getNumberOfColumns()) {
    var headerClassName = cssClassNames.TH;
    useWebKitHack && (headerClassName = cssClassNames.TH_WEBKIT);
    th = dom.createDom("th", {"class":headerClassName});
    dom.appendChild(tr, th);
    th.innerHTML = "&nbsp;";
  }
  for (var c$$0 = 0;c$$0 < numColumns;c$$0++) {
    var className = cssClassNames.TH;
    useWebKitHack && (className = cssClassNames.TH_WEBKIT);
    th = dom.createDom("th", {"class":className, index:c$$0});
    dom.appendChild(tr, th);
    var label = dataView.getColumnLabel(c$$0);
    options.allowHtml ? th.innerHTML = label : dom.appendChild(th, dom.createTextNode(label));
    enableSortIndicators && dom.appendChild(th, dom.createDom("span", {"class":cssClassNames.SORTIND}));
  }
  updateHeaders(tr);
  return this.headerRows_[tag] = tr;
};
google.visualization.Table.prototype.createPagingControls_ = function(contentElement) {
  var options = this.options_, dom = this.dom_, cssClassNames = this.cssClassNames_, pagingSymbols = goog.isDefAndNotNull(options.pagingSymbols) ? options.pagingSymbols : {}, prevSymbol = pagingSymbols.prev, nextSymbol = pagingSymbols.next, allowHtml = !!options.allowHtml, prevSymbol = prevSymbol ? allowHtml ? dom.htmlToDocumentFragment(prevSymbol) : prevSymbol : dom.createDom("img", {src:google.visualization.Table.LEFT_ARROW_IMG_, alt:"previous", style:"height: 8px; width: 8px"}), nextSymbol = nextSymbol ? 
  allowHtml ? dom.htmlToDocumentFragment(nextSymbol) : nextSymbol : dom.createDom("img", {src:google.visualization.Table.RIGHT_ARROW_IMG_, alt:"next", style:"height: 8px; width: 8px"});
  goog.dispose(this.prevButton_);
  goog.dispose(this.nextButton_);
  var prev = this.prevButton_ = new goog.ui.CustomButton(prevSymbol), next = this.nextButton_ = new goog.ui.CustomButton(nextSymbol);
  prev.setCollapsed(goog.ui.ButtonSide.END);
  next.setCollapsed(goog.ui.ButtonSide.START);
  this.eventHandler_.listen(prev, goog.ui.Component.EventType.ACTION, goog.bind(this.handlePaging_, this, !1));
  this.eventHandler_.listen(next, goog.ui.Component.EventType.ACTION, goog.bind(this.handlePaging_, this, !0));
  this.configurePagingButtons_();
  var pagingElement = dom.createDom("div", cssClassNames.PAGE_DIV);
  dom.appendChild(contentElement, pagingElement);
  prev.render(pagingElement);
  next.render(pagingElement);
  var pnDom = dom.createDom("div", {"class":cssClassNames.PAGE_NUMBERS});
  dom.appendChild(pagingElement, pnDom);
  var makePageNumLink = goog.bind(function(n, opt_additionalClassName) {
    var className = cssClassNames.PAGE_NUMBER;
    opt_additionalClassName && (className += " " + opt_additionalClassName);
    var numLink = dom.createDom("a", {href:"javascript:void(0)", "class":className});
    numLink.innerHTML = String(n + 1);
    this.eventHandler_.listen(numLink, goog.events.EventType.CLICK, goog.bind(this.handleGotoPage_, this, n));
    dom.appendChild(pnDom, numLink);
  }, this), pageCnt = this.pageManager_.getNumberOfPages(), currentPage = this.pageManager_.getCurrentPageIndex();
  goog.array.forEach(this.makePageRangeLinks_(0, currentPage - 1), function(p) {
    makePageNumLink(p);
  });
  makePageNumLink(currentPage, "current");
  goog.array.forEach(this.makePageRangeLinks_(currentPage + 1, pageCnt - 1), function(p) {
    makePageNumLink(p);
  });
};
google.visualization.Table.prototype.makePageRangeLinks_ = function(n1, n2) {
  var pages = [];
  if (n1 + 10 > n2) {
    for (var n = n1;n <= n2;n++) {
      pages.push(n);
    }
  } else {
    var left = n1;
    pages.push(left);
    var right = n2;
    pages.push(right);
    for (var pow10 = 10;left < right;) {
      left = pow10 * Math.ceil((left + 2) / pow10) - 1, left < right && pages.push(left), right = pow10 * Math.floor(right / pow10) - 1, left < right && pages.push(right), pow10 *= 10;
    }
    goog.array.sort(pages);
  }
  return pages;
};
google.visualization.Table.prototype.setCustomClassNames_ = function() {
  var customCssNames = this.cssClassNames_, optionsClassNames = this.options_.cssClassNames;
  if (optionsClassNames) {
    optionsClassNames[google.visualization.Table.CLASSNAME_TO_OPTION_NAME_.TH] && (customCssNames.TR_HEAD += google.visualization.Table.NON_STRICT_);
    if (optionsClassNames[google.visualization.Table.CLASSNAME_TO_OPTION_NAME_.TD] || optionsClassNames[google.visualization.Table.CLASSNAME_TO_OPTION_NAME_.SEQ]) {
      customCssNames.TR_EVEN += google.visualization.Table.NON_STRICT_, customCssNames.TR_ODD += google.visualization.Table.NON_STRICT_, customCssNames.TR_SELECTED += google.visualization.Table.NON_STRICT_, customCssNames.TR_MOUSEOVER += google.visualization.Table.NON_STRICT_;
    }
    for (var name in google.visualization.Table.CLASSNAME_TO_OPTION_NAME_) {
      var optionName = google.visualization.Table.CLASSNAME_TO_OPTION_NAME_[name], optionClassName = optionsClassNames[optionName];
      optionClassName && (customCssNames[name] = optionClassName);
    }
  }
};
google.visualization.Table.prototype.handlePaging_ = function(isNext) {
  var pageCnt = this.pageManager_.getNumberOfPages(), currentPage = this.pageManager_.getCurrentPageIndex(), nextPage = isNext ? Math.min(pageCnt, currentPage + 1) : Math.max(0, currentPage - 1);
  this.handleGotoPage_(nextPage);
};
google.visualization.Table.prototype.handleGotoPage_ = function(pageNum) {
  var pagingEnabled = "enable" == this.options_.page;
  pagingEnabled && (this.pageManager_.setPageIndex(pageNum), this.storeScrollPosition_(), this.redraw_(!0));
  this.configurePagingButtons_();
  google.visualization.events.trigger(this, "page", {page:pageNum});
};
google.visualization.Table.prototype.configurePagingButtons_ = function() {
  var pagingButtonsConfiguration = this.options_.pagingButtonsConfiguration || "auto", currentPage = this.pageManager_.getCurrentPageIndex(), next = this.nextButton_, prev = this.prevButton_;
  next.setEnabled(!0);
  prev.setEnabled(!0);
  switch(pagingButtonsConfiguration) {
    case "prev":
      next.setEnabled(!1);
      break;
    case "next":
      prev.setEnabled(!1);
      break;
    case "both":
      break;
    default:
      0 == currentPage && prev.setEnabled(!1), currentPage == this.pageManager_.getNumberOfPages() - 1 && next.setEnabled(!1);
  }
};
google.visualization.Table.matchScrollLeft_ = function(source, target) {
  target.scrollLeft = source.scrollLeft;
};
google.visualization.Table.matchScrollTop_ = function(source, target) {
  target.scrollTop = source.scrollTop;
};
google.visualization.Table.prototype.checkCssLoaded_ = function() {
  var checkDiv = this.checkCssLoadedDiv_;
  if (!checkDiv) {
    var container = this.container, checkDiv = goog.dom.createDom("div", {style:"position: absolute; top: -5000px;", "class":"google-visualization-table-loadtest"}, goog.dom.createTextNode("\u00a0"));
    goog.dom.appendChild(container, checkDiv);
    this.checkCssLoadedDiv_ = checkDiv;
  }
  var paddingLeft = goog.style.getPaddingBox(checkDiv).left;
  return "6" == paddingLeft;
};
google.visualization.Table.prototype.waitForCss_ = function(counter) {
  if (counter < google.visualization.Table.WAIT_FOR_CSS_MAX_ITERATIONS_) {
    if (this.checkCssLoaded_()) {
      this.draw(this.dataView_, this.options_);
    } else {
      var waitTime = counter * google.visualization.Table.CSS_WAIT_INCREMENT_;
      counter++;
      setTimeout(goog.bind(this.waitForCss_, this, counter), waitTime);
    }
  } else {
    goog.dom.removeNode(this.checkCssLoadedDiv_), this.triggerReadyEvent_();
  }
};
google.visualization.Table.prototype.getSelection = function() {
  return this.selectedRows_.getSelection();
};
google.visualization.Table.prototype.setSelection = function(selection) {
  if (this.dataTable_) {
    var changes = this.selectedRows_.setSelection(selection), page = this.page_;
    this.lastSelectedTableRow_ = this.pageManager_.getFirstTableRowInPage();
    for (var htmlTableRows = this.getHtmlTableRows_(), htmlfrozenTableRows = this.getHtmlfrozenColumnsTableRows_(), tr, trFreeze, cssClassNames = this.cssClassNames_, removedRowIndexes = changes.getRemoved().getRowIndexes(), i = 0;i < removedRowIndexes.length;i++) {
      var dataRowInd = removedRowIndexes[i], pageRowInd = this.pageManager_.getPageRowIndexByDataRowIndex(dataRowInd);
      if (-1 != pageRowInd) {
        var tableRow = page[pageRowInd];
        tableRow.setSelected(!1);
        (tr = htmlTableRows[pageRowInd + 1]) && goog.dom.classlist.remove(tr, cssClassNames.TR_SELECTED);
        (trFreeze = htmlfrozenTableRows && htmlfrozenTableRows[pageRowInd + 1]) && goog.dom.classlist.remove(trFreeze, cssClassNames.TR_SELECTED);
      }
    }
    for (var addedRowIndexes = changes.getAdded().getRowIndexes(), i = 0;i < addedRowIndexes.length;i++) {
      dataRowInd = addedRowIndexes[i], pageRowInd = this.pageManager_.getPageRowIndexByDataRowIndex(dataRowInd), -1 != pageRowInd && (tableRow = page[pageRowInd], tableRow.setSelected(!0), (tr = htmlTableRows[pageRowInd + 1]) && goog.dom.classlist.add(tr, cssClassNames.TR_SELECTED), (trFreeze = htmlfrozenTableRows && htmlfrozenTableRows[pageRowInd + 1]) && goog.dom.classlist.add(trFreeze, cssClassNames.TR_SELECTED));
    }
  }
};
google.visualization.Table.prototype.handleRowMouseDown_ = function(tableRow, e) {
  var selectedRows, lastSelectedTableRow = this.lastSelectedTableRow_, currDataRowIndex = tableRow.getDataRowIndex(), platformModifierKeyState = goog.userAgent.MAC ? e.metaKey : e.ctrlKey;
  if (e.shiftKey) {
    e.preventDefault();
    var start = Math.min(tableRow.getUIRowIndex(), lastSelectedTableRow.getUIRowIndex()), end = Math.max(tableRow.getUIRowIndex(), lastSelectedTableRow.getUIRowIndex());
    selectedRows = platformModifierKeyState ? this.selectedRows_.getSelection() : [];
    for (var rows = this.pageManager_.getTableRowsInRangeByUIRows(start, end), i = 0;i < rows.length;i++) {
      selectedRows.push({row:rows[i].getDataRowIndex()});
    }
  } else {
    if (platformModifierKeyState) {
      if (e.preventDefault(), selectedRows = this.selectedRows_.getSelection(), this.selectedRows_.containsRow(currDataRowIndex)) {
        var newSelectionForRemove = new gviz.util.Selection;
        newSelectionForRemove.setSelection(selectedRows);
        newSelectionForRemove.removeRow(currDataRowIndex);
        selectedRows = newSelectionForRemove.getSelection();
      } else {
        selectedRows.push({row:currDataRowIndex});
      }
    } else {
      selectedRows = this.selectedRows_.containsRow(currDataRowIndex) ? null : [{row:currDataRowIndex}];
    }
  }
  this.setSelection(selectedRows);
  this.lastSelectedTableRow_ = e.shiftKey ? lastSelectedTableRow : tableRow;
  google.visualization.events.trigger(this, "select", {});
};
google.visualization.Table.prototype.handleRowMouseOver_ = function(tableRow) {
  var tableRows = this.getHtmlTableRows_(), cssClassNames = this.cssClassNames_, pageRowIndex = tableRow.getPageRowIndex(), tr = tableRows[pageRowIndex + 1];
  tr && goog.dom.classlist.add(tr, cssClassNames.TR_MOUSEOVER);
  var frozenTableRows = this.getHtmlfrozenColumnsTableRows_();
  (tr = frozenTableRows && frozenTableRows[pageRowIndex + 1]) && goog.dom.classlist.add(tr, cssClassNames.TR_MOUSEOVER);
};
google.visualization.Table.prototype.handleRowMouseOut_ = function(tableRow) {
  var tableRows = this.getHtmlTableRows_(), pageRowIndex = tableRow.getPageRowIndex(), cssClassNames = this.cssClassNames_, tr = tableRows[pageRowIndex + 1];
  tr && goog.dom.classlist.remove(tr, cssClassNames.TR_MOUSEOVER);
  var frozenTableRows = this.getHtmlfrozenColumnsTableRows_();
  (tr = frozenTableRows && frozenTableRows[pageRowIndex + 1]) && goog.dom.classlist.remove(tr, cssClassNames.TR_MOUSEOVER);
};
google.visualization.Table.prototype.getHtmlTableRows_ = function() {
  return this.htmlTable_.firstChild.childNodes;
};
google.visualization.Table.prototype.getHtmlfrozenColumnsTableRows_ = function() {
  return this.htmlFrozenColumnsTable_ ? this.htmlFrozenColumnsTable_.firstChild.childNodes : null;
};
google.visualization.Table.prototype.handleHeaderClick_ = function(colInd) {
  var pageManager = this.pageManager_, sortAscending = pageManager.getSortOrder(), sortColumnIndex = pageManager.getSortColumnIndex(), sortAscending = sortColumnIndex == colInd ? !sortAscending : !0;
  "event" != this.options_.sort ? (pageManager.setSort(colInd, !sortAscending), this.pageManager_.setPageIndex(0), this.lastSelectedTableRow_ = this.pageManager_.getFirstTableRowInPage(), this.storeScrollPosition_(), this.redraw_(!0), google.visualization.events.trigger(this, "sort", this.pageManager_.getSortInfo())) : google.visualization.events.trigger(this, "sort", {column:colInd, ascending:sortAscending, sortedIndexes:null});
};
google.visualization.Table.prototype.storeScrollPosition_ = function() {
  var scrollpane = this.scrollpane_;
  scrollpane && (this.scrollLeftStartPosition_ = scrollpane.scrollLeft);
};
google.visualization.Table.prototype.clear_ = function() {
  goog.dispose(this.eventHandler_);
  this.eventHandler_ = null;
  this.dom_.removeChildren(this.container);
  goog.dispose(this.prevButton_);
  this.prevButton_ = null;
  goog.dispose(this.nextButton_);
  this.nextButton_ = null;
};
google.visualization.Table.prototype.clearChart = function() {
  this.clear_();
  this.selectedRows_.clear();
  this.pageManager_ = null;
};
google.visualization.Table.addUnitsIfRequired_ = function(dimension) {
  if (goog.string.isEmptySafe(dimension)) {
    return dimension;
  }
  var res = dimension;
  goog.string.isNumeric(dimension) && "0" !== String(dimension) && (res += "px");
  return res;
};
google.visualization.Table.getTDCssClassNames_ = function(dataView, cssClassNames) {
  for (var tdClassNames = [], c = 0;c < dataView.getNumberOfColumns();c++) {
    var cellClassName = cssClassNames.TD, type = dataView.getColumnType(c);
    switch(type) {
      case "boolean":
        cellClassName += " " + cssClassNames.TD_BOOLEAN;
        break;
      case "number":
        cellClassName += " " + cssClassNames.TD_NUMBER;
        break;
      case "date":
      ;
      case "datetime":
      ;
      case "timeofday":
        cellClassName += " " + cssClassNames.TD_CENTER;
    }
    tdClassNames.push(cellClassName);
  }
  return tdClassNames;
};
google.visualization.Table.getRealValueWithDefault = function(val, defaultValue) {
  return goog.isDefAndNotNull(val) ? val : defaultValue;
};
google.visualization.Table.getColumnTypes_ = function(dataView) {
  for (var colTypes = [], c = 0;c < dataView.getNumberOfColumns();c++) {
    colTypes.push(dataView.getColumnType(c));
  }
  return colTypes;
};
google.visualization.Table.showNothing_ = function(element) {
  google.visualization.Table.setElementHidden_(element);
};
google.visualization.Table.showFrozenColumns_ = function(numColumns) {
  return function(element, row, opt_col) {
    "TR" == element.tagName ? google.visualization.Table.setElementTransparent_(element) : opt_col == numColumns - 1 ? goog.style.setStyle(element, google.visualization.Table.RIGHT_BORDER_STYLE_) : opt_col >= numColumns && google.visualization.Table.setElementHidden_(element);
  };
};
google.visualization.Table.showTransparentTable_ = function(element) {
  google.visualization.Table.setElementTransparent_(element);
};
google.visualization.Table.setElementHidden_ = function(element) {
  goog.style.setStyle(element, google.visualization.Table.HIDDEN_STYLE_);
  google.visualization.Table.setElementTransparent_(element);
};
google.visualization.Table.setElementTransparent_ = function(element) {
  goog.userAgent.IE && 7 > goog.userAgent.VERSION ? goog.style.setStyle(element, google.visualization.Table.TRANSPARENT_STYLE_IE6_) : goog.style.setStyle(element, google.visualization.Table.TRANSPARENT_STYLE_);
  "TD" == element.tagName && (goog.style.setStyle(element, "color", "transparent"), goog.style.setOpacity(element, 0));
};
google.visualization.Table.getScrollbarWidth_ = function() {
  var dom = goog.dom.getDomHelper(), div = dom.createDom("div", {style:"position: absolute; top: -5000px; width: 100px; overflow: scroll;"}, dom.createDom("div", {style:"width: 200px;"}));
  dom.appendChild(goog.global.document.body, div);
  var width = div.offsetWidth - div.clientWidth;
  dom.removeNode(div);
  return width;
};
// INPUT (javascript/closure/structs/inversionmap.js)
goog.structs.InversionMap = function(rangeArray, valueArray, opt_delta) {
  this.rangeArray = null;
  if (rangeArray.length != valueArray.length) {
    return null;
  }
  this.storeInversion_(rangeArray, opt_delta);
  this.values = valueArray;
};
goog.structs.InversionMap.prototype.storeInversion_ = function(rangeArray, opt_delta) {
  this.rangeArray = rangeArray;
  for (var i = 1;i < rangeArray.length;i++) {
    null == rangeArray[i] ? rangeArray[i] = rangeArray[i - 1] + 1 : opt_delta && (rangeArray[i] += rangeArray[i - 1]);
  }
};
goog.structs.InversionMap.prototype.at = function(intKey) {
  var index = this.getLeast(intKey);
  return 0 > index ? null : this.values[index];
};
goog.structs.InversionMap.prototype.getLeast = function(intKey) {
  for (var arr = this.rangeArray, low = 0, high = arr.length;8 < high - low;) {
    var mid = high + low >> 1;
    arr[mid] <= intKey ? low = mid : high = mid;
  }
  for (;low < high && !(intKey < arr[low]);++low) {
  }
  return low - 1;
};
// INPUT (javascript/closure/i18n/graphemebreak.js)
goog.i18n.GraphemeBreak = {};
goog.i18n.GraphemeBreak.property = {ANY:0, CONTROL:1, EXTEND:2, PREPEND:3, SPACING_MARK:4, INDIC_CONSONANT:5, VIRAMA:6, L:7, V:8, T:9, LV:10, LVT:11, CR:12, LF:13, REGIONAL_INDICATOR:14};
goog.i18n.GraphemeBreak.inversions_ = null;
goog.i18n.GraphemeBreak.applyLegacyBreakRules_ = function(prop_a, prop_b) {
  var prop = goog.i18n.GraphemeBreak.property;
  return prop_a == prop.CR && prop_b == prop.LF ? !1 : prop_a == prop.CONTROL || prop_a == prop.CR || prop_a == prop.LF || prop_b == prop.CONTROL || prop_b == prop.CR || prop_b == prop.LF ? !0 : prop_a == prop.L && (prop_b == prop.L || prop_b == prop.V || prop_b == prop.LV || prop_b == prop.LVT) || !(prop_a != prop.LV && prop_a != prop.V || prop_b != prop.V && prop_b != prop.T) || (prop_a == prop.LVT || prop_a == prop.T) && prop_b == prop.T || prop_b == prop.EXTEND || prop_b == prop.VIRAMA || prop_a == 
  prop.VIRAMA && prop_b == prop.INDIC_CONSONANT ? !1 : !0;
};
goog.i18n.GraphemeBreak.getBreakProp_ = function(acode) {
  if (44032 <= acode && 55203 >= acode) {
    var prop = goog.i18n.GraphemeBreak.property;
    return 16 == acode % 28 ? prop.LV : prop.LVT;
  }
  goog.i18n.GraphemeBreak.inversions_ || (goog.i18n.GraphemeBreak.inversions_ = new goog.structs.InversionMap([0, 10, 1, 2, 1, 18, 95, 33, 13, 1, 594, 112, 275, 7, 263, 45, 1, 1, 1, 2, 1, 2, 1, 1, 56, 5, 11, 11, 48, 21, 16, 1, 101, 7, 1, 1, 6, 2, 2, 1, 4, 33, 1, 1, 1, 30, 27, 91, 11, 58, 9, 34, 4, 1, 9, 1, 3, 1, 5, 43, 3, 136, 31, 1, 17, 37, 1, 1, 1, 1, 3, 8, 4, 1, 2, 1, 7, 8, 2, 2, 21, 8, 1, 2, 17, 39, 1, 1, 1, 2, 6, 6, 1, 9, 5, 4, 2, 2, 12, 2, 15, 2, 1, 17, 39, 2, 3, 12, 4, 8, 6, 17, 2, 3, 14, 
  1, 17, 39, 1, 1, 3, 8, 4, 1, 20, 2, 29, 1, 2, 17, 39, 1, 1, 2, 1, 6, 6, 9, 6, 4, 2, 2, 13, 1, 16, 1, 18, 41, 1, 1, 1, 12, 1, 9, 1, 41, 3, 17, 37, 4, 3, 5, 7, 8, 3, 2, 8, 2, 30, 2, 17, 39, 1, 1, 1, 1, 2, 1, 3, 1, 5, 1, 8, 9, 1, 3, 2, 30, 2, 17, 38, 3, 1, 2, 5, 7, 1, 9, 1, 10, 2, 30, 2, 22, 48, 5, 1, 2, 6, 7, 19, 2, 13, 46, 2, 1, 1, 1, 6, 1, 12, 8, 50, 46, 2, 1, 1, 1, 9, 11, 6, 14, 2, 58, 2, 27, 1, 1, 1, 1, 1, 4, 2, 49, 14, 1, 4, 1, 1, 2, 5, 48, 9, 1, 57, 33, 12, 4, 1, 6, 1, 2, 2, 2, 1, 16, 2, 4, 
  2, 2, 4, 3, 1, 3, 2, 7, 3, 4, 13, 1, 1, 1, 2, 6, 1, 1, 14, 1, 98, 96, 72, 88, 349, 3, 931, 15, 2, 1, 14, 15, 2, 1, 14, 15, 2, 15, 15, 14, 35, 17, 2, 1, 7, 8, 1, 2, 9, 1, 1, 9, 1, 45, 3, 155, 1, 87, 31, 3, 4, 2, 9, 1, 6, 3, 20, 19, 29, 44, 9, 3, 2, 1, 69, 23, 2, 3, 4, 45, 6, 2, 1, 1, 1, 8, 1, 1, 1, 2, 8, 6, 13, 128, 4, 1, 14, 33, 1, 1, 5, 1, 1, 5, 1, 1, 1, 7, 31, 9, 12, 2, 1, 7, 23, 1, 4, 2, 2, 2, 2, 2, 11, 3, 2, 36, 2, 1, 1, 2, 3, 1, 1, 3, 2, 12, 36, 8, 8, 2, 2, 21, 3, 128, 3, 1, 13, 1, 7, 4, 1, 
  4, 2, 1, 203, 64, 523, 1, 2, 2, 24, 7, 49, 16, 96, 33, 3070, 3, 141, 1, 96, 32, 554, 6, 105, 2, 30164, 4, 1, 10, 33, 1, 80, 2, 272, 1, 3, 1, 4, 1, 23, 2, 2, 1, 24, 30, 4, 4, 3, 8, 1, 1, 13, 2, 16, 34, 16, 1, 27, 18, 24, 24, 4, 8, 2, 23, 11, 1, 1, 12, 32, 3, 1, 5, 3, 3, 36, 1, 2, 4, 2, 1, 3, 1, 69, 35, 6, 2, 2, 2, 2, 12, 1, 8, 1, 1, 18, 16, 1, 3, 6, 1, 5, 48, 1, 1, 3, 2, 2, 5, 2, 1, 1, 32, 9, 1, 2, 2, 5, 1, 1, 201, 14, 2, 1, 1, 9, 8, 2, 1, 2, 1, 2, 1, 1, 1, 18, 11184, 27, 49, 1028, 1024, 6942, 1, 
  737, 16, 16, 7, 216, 1, 158, 2, 89, 3, 513, 1, 2051, 15, 40, 7, 1, 1472, 1, 1, 1, 53, 14, 1, 57, 2, 1, 45, 3, 4, 2, 1, 1, 2, 1, 66, 3, 36, 5, 1, 6, 2, 75, 2, 1, 48, 3, 9, 1, 1, 1258, 1, 1, 1, 2, 6, 1, 1, 22681, 62, 4, 25042, 1, 1, 3, 3, 1, 5, 8, 8, 2, 7, 30, 4, 148, 3, 8097, 26, 790017, 255], [1, 13, 1, 12, 1, 0, 1, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 1, 0, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 4, 0, 5, 2, 4, 2, 
  0, 4, 2, 4, 6, 4, 0, 2, 5, 0, 2, 0, 5, 2, 4, 0, 5, 2, 0, 2, 4, 2, 4, 6, 0, 2, 5, 0, 2, 0, 5, 0, 2, 4, 0, 5, 2, 4, 2, 6, 2, 5, 0, 2, 0, 2, 4, 0, 5, 2, 0, 4, 2, 4, 6, 0, 2, 0, 2, 4, 0, 5, 2, 0, 2, 4, 2, 4, 6, 2, 5, 0, 2, 0, 5, 0, 2, 0, 5, 2, 4, 2, 4, 6, 0, 2, 0, 4, 0, 5, 0, 2, 4, 2, 6, 2, 5, 0, 2, 0, 4, 0, 5, 2, 0, 4, 2, 4, 2, 4, 2, 4, 2, 6, 2, 5, 0, 2, 0, 4, 0, 5, 0, 2, 4, 2, 4, 6, 0, 2, 0, 2, 0, 4, 0, 5, 6, 2, 4, 2, 4, 2, 4, 0, 5, 0, 2, 0, 4, 2, 6, 0, 2, 0, 5, 0, 2, 0, 4, 2, 0, 2, 0, 5, 0, 2, 0, 
  2, 0, 2, 0, 2, 0, 4, 5, 2, 4, 2, 6, 0, 2, 0, 2, 0, 2, 0, 5, 0, 2, 4, 2, 0, 6, 4, 2, 5, 0, 5, 0, 4, 2, 5, 2, 5, 0, 5, 0, 5, 2, 5, 2, 0, 4, 2, 0, 2, 5, 0, 2, 0, 7, 8, 9, 0, 2, 0, 5, 2, 6, 0, 5, 2, 6, 0, 5, 2, 0, 5, 2, 5, 0, 2, 4, 2, 4, 2, 4, 2, 6, 2, 0, 2, 0, 2, 0, 2, 0, 5, 2, 4, 2, 4, 2, 4, 2, 0, 5, 0, 5, 0, 4, 0, 4, 0, 5, 2, 4, 0, 5, 0, 5, 4, 2, 4, 2, 6, 0, 2, 0, 2, 4, 2, 0, 2, 4, 0, 5, 2, 4, 2, 4, 2, 4, 2, 4, 6, 5, 0, 2, 0, 2, 4, 0, 5, 4, 2, 4, 2, 6, 4, 5, 0, 5, 0, 5, 0, 2, 4, 2, 4, 2, 4, 2, 6, 
  0, 5, 4, 2, 4, 2, 0, 5, 0, 2, 0, 2, 4, 2, 0, 2, 0, 4, 2, 0, 2, 0, 1, 2, 1, 0, 1, 0, 1, 0, 2, 0, 2, 0, 6, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 6, 5, 2, 5, 4, 2, 4, 0, 5, 0, 5, 0, 5, 0, 5, 0, 4, 0, 5, 4, 6, 0, 2, 0, 5, 0, 2, 0, 5, 2, 4, 6, 0, 7, 2, 4, 0, 5, 0, 5, 2, 4, 2, 4, 2, 4, 6, 0, 5, 2, 4, 2, 4, 2, 0, 2, 0, 2, 4, 0, 5, 0, 5, 0, 5, 0, 5, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 5, 4, 2, 4, 0, 4, 6, 0, 5, 0, 5, 0, 5, 0, 4, 2, 4, 2, 4, 0, 4, 6, 0, 11, 8, 9, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 
  2, 0, 1, 0, 2, 0, 2, 0, 2, 6, 0, 4, 2, 4, 0, 2, 6, 0, 2, 4, 0, 4, 2, 4, 6, 2, 0, 1, 0, 2, 0, 2, 4, 2, 6, 0, 2, 4, 0, 4, 2, 4, 6, 0, 2, 4, 2, 4, 2, 6, 2, 0, 4, 2, 0, 2, 4, 2, 0, 4, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 14, 0, 1, 2], !0));
  return goog.i18n.GraphemeBreak.inversions_.at(acode);
};
goog.i18n.GraphemeBreak.hasGraphemeBreak = function(a, b, opt_extended) {
  var prop_a = goog.i18n.GraphemeBreak.getBreakProp_(a), prop_b = goog.i18n.GraphemeBreak.getBreakProp_(b), prop = goog.i18n.GraphemeBreak.property;
  return goog.i18n.GraphemeBreak.applyLegacyBreakRules_(prop_a, prop_b) && !(opt_extended && (prop_a == prop.PREPEND || prop_b == prop.SPACING_MARK));
};
// INPUT (javascript/closure/format/format.js)
goog.format = {};
goog.format.fileSize = function(bytes, opt_decimals) {
  return goog.format.numBytesToString(bytes, opt_decimals, !1);
};
goog.format.isConvertableScaledNumber = function(val) {
  return goog.format.SCALED_NUMERIC_RE_.test(val);
};
goog.format.stringToNumericValue = function(stringValue) {
  return goog.string.endsWith(stringValue, "B") ? goog.format.stringToNumericValue_(stringValue, goog.format.NUMERIC_SCALES_BINARY_) : goog.format.stringToNumericValue_(stringValue, goog.format.NUMERIC_SCALES_SI_);
};
goog.format.stringToNumBytes = function(stringValue) {
  return goog.format.stringToNumericValue_(stringValue, goog.format.NUMERIC_SCALES_BINARY_);
};
goog.format.numericValueToString = function(val, opt_decimals) {
  return goog.format.numericValueToString_(val, goog.format.NUMERIC_SCALES_SI_, opt_decimals);
};
goog.format.numBytesToString = function(val, opt_decimals, opt_suffix, opt_useSeparator) {
  var suffix = "";
  if (!goog.isDef(opt_suffix) || opt_suffix) {
    suffix = "B";
  }
  return goog.format.numericValueToString_(val, goog.format.NUMERIC_SCALES_BINARY_, opt_decimals, suffix, opt_useSeparator);
};
goog.format.stringToNumericValue_ = function(stringValue, conversion) {
  var match = stringValue.match(goog.format.SCALED_NUMERIC_RE_);
  if (!match) {
    return NaN;
  }
  var val = match[1] * conversion[match[2]];
  return val;
};
goog.format.numericValueToString_ = function(val, conversion, opt_decimals, opt_suffix, opt_useSeparator) {
  var prefixes = goog.format.NUMERIC_SCALE_PREFIXES_, orig_val = val, symbol = "", separator = "", scale = 1;
  0 > val && (val = -val);
  for (var i = 0;i < prefixes.length;i++) {
    var unit = prefixes[i], scale = conversion[unit];
    if (val >= scale || 1 >= scale && val > .1 * scale) {
      symbol = unit;
      break;
    }
  }
  symbol ? (opt_suffix && (symbol += opt_suffix), opt_useSeparator && (separator = " ")) : scale = 1;
  var ex = Math.pow(10, goog.isDef(opt_decimals) ? opt_decimals : 2);
  return Math.round(orig_val / scale * ex) / ex + separator + symbol;
};
goog.format.SCALED_NUMERIC_RE_ = /^([-]?\d+\.?\d*)([K,M,G,T,P,k,m,u,n]?)[B]?$/;
goog.format.NUMERIC_SCALE_PREFIXES_ = "P T G M K  m u n".split(" ");
goog.format.NUMERIC_SCALES_SI_ = {"":1, n:1E-9, u:1E-6, m:.001, k:1E3, K:1E3, M:1E6, G:1E9, T:1E12, P:1E15};
goog.format.NUMERIC_SCALES_BINARY_ = {"":1, n:Math.pow(1024, -3), u:Math.pow(1024, -2), m:1 / 1024, k:1024, K:1024, M:Math.pow(1024, 2), G:Math.pow(1024, 3), T:Math.pow(1024, 4), P:Math.pow(1024, 5)};
goog.format.FIRST_GRAPHEME_EXTEND_ = 768;
goog.format.isTreatedAsBreakingSpace_ = function(charCode) {
  return charCode <= goog.format.WbrToken_.SPACE || 4096 <= charCode && (8192 <= charCode && 8198 >= charCode || 8200 <= charCode && 8203 >= charCode || 5760 == charCode || 6158 == charCode || 8232 == charCode || 8233 == charCode || 8287 == charCode || 12288 == charCode);
};
goog.format.isInvisibleFormattingCharacter_ = function(charCode) {
  return 8204 <= charCode && 8207 >= charCode || 8234 <= charCode && 8238 >= charCode;
};
goog.format.insertWordBreaksGeneric_ = function(str, hasGraphemeBreak, opt_maxlen) {
  var maxlen = opt_maxlen || 10;
  if (maxlen > str.length) {
    return str;
  }
  for (var rv = [], n = 0, nestingCharCode = 0, lastDumpPosition = 0, charCode = 0, i = 0;i < str.length;i++) {
    var lastCharCode = charCode, charCode = str.charCodeAt(i), isPotentiallyGraphemeExtending = charCode >= goog.format.FIRST_GRAPHEME_EXTEND_ && !hasGraphemeBreak(lastCharCode, charCode, !0);
    n >= maxlen && !goog.format.isTreatedAsBreakingSpace_(charCode) && !isPotentiallyGraphemeExtending && (rv.push(str.substring(lastDumpPosition, i), goog.format.WORD_BREAK_HTML), lastDumpPosition = i, n = 0);
    nestingCharCode ? charCode == goog.format.WbrToken_.GT && nestingCharCode == goog.format.WbrToken_.LT ? nestingCharCode = 0 : charCode == goog.format.WbrToken_.SEMI_COLON && nestingCharCode == goog.format.WbrToken_.AMP && (nestingCharCode = 0, n++) : charCode == goog.format.WbrToken_.LT || charCode == goog.format.WbrToken_.AMP ? nestingCharCode = charCode : goog.format.isTreatedAsBreakingSpace_(charCode) ? n = 0 : goog.format.isInvisibleFormattingCharacter_(charCode) || n++;
  }
  rv.push(str.substr(lastDumpPosition));
  return rv.join("");
};
goog.format.insertWordBreaks = function(str, opt_maxlen) {
  return goog.format.insertWordBreaksGeneric_(str, goog.i18n.GraphemeBreak.hasGraphemeBreak, opt_maxlen);
};
goog.format.conservativelyHasGraphemeBreak_ = function(lastCharCode, charCode) {
  return 1024 <= charCode && 1315 > charCode;
};
goog.format.insertWordBreaksBasic = function(str, opt_maxlen) {
  return goog.format.insertWordBreaksGeneric_(str, goog.format.conservativelyHasGraphemeBreak_, opt_maxlen);
};
goog.format.IS_IE8_OR_ABOVE_ = goog.userAgent.IE && goog.userAgent.isVersionOrHigher(8);
goog.format.WORD_BREAK_HTML = goog.userAgent.WEBKIT ? "<wbr></wbr>" : goog.userAgent.OPERA ? "&shy;" : goog.format.IS_IE8_OR_ABOVE_ ? "&#8203;" : "<wbr>";
goog.format.WbrToken_ = {LT:60, GT:62, AMP:38, SEMI_COLON:59, SPACE:32};
// INPUT (javascript/closure/i18n/bidiformatter.js)
goog.i18n.BidiFormatter = function(contextDir, opt_alwaysSpan) {
  this.contextDir_ = goog.i18n.bidi.toDir(contextDir, !0);
  this.alwaysSpan_ = !!opt_alwaysSpan;
};
goog.i18n.BidiFormatter.prototype.getContextDir = function() {
  return this.contextDir_;
};
goog.i18n.BidiFormatter.prototype.estimateDirection = goog.i18n.bidi.estimateDirection;
goog.i18n.BidiFormatter.prototype.areDirectionalitiesOpposite_ = function(dir1, dir2) {
  return 0 > dir1 * dir2;
};
goog.i18n.BidiFormatter.prototype.dirResetIfNeeded_ = function(str, dir, opt_isHtml, opt_dirReset) {
  return opt_dirReset && (this.areDirectionalitiesOpposite_(dir, this.contextDir_) || this.contextDir_ == goog.i18n.bidi.Dir.LTR && goog.i18n.bidi.endsWithRtl(str, opt_isHtml) || this.contextDir_ == goog.i18n.bidi.Dir.RTL && goog.i18n.bidi.endsWithLtr(str, opt_isHtml)) ? this.contextDir_ == goog.i18n.bidi.Dir.LTR ? goog.i18n.bidi.Format.LRM : goog.i18n.bidi.Format.RLM : "";
};
goog.i18n.BidiFormatter.prototype.dirAttrValue = function(str, opt_isHtml) {
  return this.knownDirAttrValue(this.estimateDirection(str, opt_isHtml));
};
goog.i18n.BidiFormatter.prototype.knownDirAttrValue = function(dir) {
  var resolvedDir = dir == goog.i18n.bidi.Dir.NEUTRAL ? this.contextDir_ : dir;
  return resolvedDir == goog.i18n.bidi.Dir.RTL ? "rtl" : "ltr";
};
goog.i18n.BidiFormatter.prototype.knownDirAttr = function(dir) {
  return dir != this.contextDir_ ? dir == goog.i18n.bidi.Dir.RTL ? 'dir="rtl"' : dir == goog.i18n.bidi.Dir.LTR ? 'dir="ltr"' : "" : "";
};
goog.i18n.BidiFormatter.prototype.spanWrapSafeHtmlWithKnownDir = function(dir, html, opt_dirReset) {
  null == dir && (dir = this.estimateDirection(goog.html.SafeHtml.unwrap(html), !0));
  return this.spanWrapWithKnownDir_(dir, html, opt_dirReset);
};
goog.i18n.BidiFormatter.prototype.spanWrapWithKnownDir_ = function(dir, html, opt_dirReset) {
  opt_dirReset = opt_dirReset || void 0 == opt_dirReset;
  var result, dirCondition = dir != goog.i18n.bidi.Dir.NEUTRAL && dir != this.contextDir_;
  if (this.alwaysSpan_ || dirCondition) {
    var dirAttribute;
    dirCondition && (dirAttribute = dir == goog.i18n.bidi.Dir.RTL ? "rtl" : "ltr");
    result = goog.html.SafeHtml.create("span", {dir:dirAttribute}, html);
  } else {
    result = html;
  }
  var str = goog.html.SafeHtml.unwrap(html);
  return result = goog.html.SafeHtml.concatWithDir(goog.i18n.bidi.Dir.NEUTRAL, result, this.dirResetIfNeeded_(str, dir, !0, opt_dirReset));
};
goog.i18n.BidiFormatter.prototype.unicodeWrapWithKnownDir = function(dir, str, opt_isHtml, opt_dirReset) {
  null == dir && (dir = this.estimateDirection(str, opt_isHtml));
  return this.unicodeWrapWithKnownDir_(dir, str, opt_isHtml, opt_dirReset);
};
goog.i18n.BidiFormatter.prototype.unicodeWrapWithKnownDir_ = function(dir, str, opt_isHtml, opt_dirReset) {
  opt_dirReset = opt_dirReset || void 0 == opt_dirReset;
  var result = [];
  dir != goog.i18n.bidi.Dir.NEUTRAL && dir != this.contextDir_ ? (result.push(dir == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.Format.RLE : goog.i18n.bidi.Format.LRE), result.push(str), result.push(goog.i18n.bidi.Format.PDF)) : result.push(str);
  result.push(this.dirResetIfNeeded_(str, dir, opt_isHtml, opt_dirReset));
  return result.join("");
};
goog.i18n.BidiFormatter.prototype.markAfterKnownDir = function(dir, str, opt_isHtml) {
  null == dir && (dir = this.estimateDirection(str, opt_isHtml));
  return this.dirResetIfNeeded_(str, dir, opt_isHtml, !0);
};
// INPUT (javascript/closure/html/safescript.js)
goog.html.SafeScript = function() {
  this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = "";
  this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
};
goog.html.SafeScript.prototype.implementsGoogStringTypedString = !0;
goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeScript.fromConstant = function(script) {
  var scriptString = goog.string.Const.unwrap(script);
  return 0 === scriptString.length ? goog.html.SafeScript.EMPTY : goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(scriptString);
};
goog.html.SafeScript.prototype.getTypedStringValue = function() {
  return this.privateDoNotAccessOrElseSafeScriptWrappedValue_;
};
goog.DEBUG && (goog.html.SafeScript.prototype.toString = function() {
  return "SafeScript{" + this.privateDoNotAccessOrElseSafeScriptWrappedValue_ + "}";
});
goog.html.SafeScript.unwrap = function(safeScript) {
  if (safeScript instanceof goog.html.SafeScript && safeScript.constructor === goog.html.SafeScript && safeScript.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
    return safeScript.privateDoNotAccessOrElseSafeScriptWrappedValue_;
  }
  goog.asserts.fail("expected object of type SafeScript, got '" + safeScript + "'");
  return "type_error:SafeScript";
};
goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse = function(script) {
  var safeScript = new goog.html.SafeScript;
  safeScript.privateDoNotAccessOrElseSafeScriptWrappedValue_ = script;
  return safeScript;
};
goog.html.SafeScript.EMPTY = goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("");
// INPUT (javascript/closure/html/safestylesheet.js)
goog.html.SafeStyleSheet = function() {
  this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = "";
  this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
};
goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString = !0;
goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeStyleSheet.fromConstant = function(styleSheet) {
  var styleSheetString = goog.string.Const.unwrap(styleSheet);
  if (0 === styleSheetString.length) {
    return goog.html.SafeStyleSheet.EMPTY;
  }
  goog.asserts.assert(!goog.string.contains(styleSheetString, "<"), "Forbidden '<' character in style sheet string: " + styleSheetString);
  return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheetString);
};
goog.html.SafeStyleSheet.prototype.getTypedStringValue = function() {
  return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
};
goog.DEBUG && (goog.html.SafeStyleSheet.prototype.toString = function() {
  return "SafeStyleSheet{" + this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ + "}";
});
goog.html.SafeStyleSheet.unwrap = function(safeStyleSheet) {
  if (safeStyleSheet instanceof goog.html.SafeStyleSheet && safeStyleSheet.constructor === goog.html.SafeStyleSheet && safeStyleSheet.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {
    return safeStyleSheet.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
  }
  goog.asserts.fail("expected object of type SafeStyleSheet, got '" + safeStyleSheet + "'");
  return "type_error:SafeStyleSheet";
};
goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse = function(styleSheet) {
  var safeStyleSheet = new goog.html.SafeStyleSheet;
  safeStyleSheet.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = styleSheet;
  return safeStyleSheet;
};
goog.html.SafeStyleSheet.EMPTY = goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse("");
// INPUT (javascript/closure/html/uncheckedconversions.js)
goog.html.uncheckedconversions = {};
goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract = function(justification, html, opt_dir) {
  goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
  goog.asserts.assert(!goog.string.isEmpty(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(html, opt_dir || null);
};
goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract = function(justification, script) {
  goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
  goog.asserts.assert(0 < goog.string.trim(goog.string.Const.unwrap(justification)).length, "must provide non-empty justification");
  return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(script);
};
goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract = function(justification, style) {
  goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
  goog.asserts.assert(!goog.string.isEmpty(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
  return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style);
};
goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract = function(justification, styleSheet) {
  goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
  goog.asserts.assert(!goog.string.isEmpty(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
  return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheet);
};
goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract = function(justification, url) {
  goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
  goog.asserts.assert(!goog.string.isEmpty(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
};
goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract = function(justification, url) {
  goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
  goog.asserts.assert(!goog.string.isEmpty(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
  return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(url);
};
// INPUT (javascript/closure/soy/data.js)
goog.soy = {};
goog.soy.data = {};
goog.soy.data.SanitizedContentKind = {HTML:goog.DEBUG ? {sanitizedContentKindHtml:!0} : {}, JS:goog.DEBUG ? {sanitizedContentJsChars:!0} : {}, URI:goog.DEBUG ? {sanitizedContentUri:!0} : {}, ATTRIBUTES:goog.DEBUG ? {sanitizedContentHtmlAttribute:!0} : {}, CSS:goog.DEBUG ? {sanitizedContentCss:!0} : {}, TEXT:goog.DEBUG ? {sanitizedContentKindText:!0} : {}};
goog.soy.data.SanitizedContent = function() {
  throw Error("Do not instantiate directly");
};
goog.soy.data.SanitizedContent.prototype.contentDir = null;
goog.soy.data.SanitizedContent.prototype.getContent = function() {
  return this.content;
};
goog.soy.data.SanitizedContent.prototype.toString = function() {
  return this.content;
};
goog.soy.data.SanitizedContent.prototype.toSafeHtml = function() {
  if (this.contentKind === goog.soy.data.SanitizedContentKind.TEXT) {
    return goog.html.SafeHtml.htmlEscape(this.toString());
  }
  if (this.contentKind !== goog.soy.data.SanitizedContentKind.HTML) {
    throw Error("Sanitized content was not of kind TEXT or HTML.");
  }
  return goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Soy SanitizedContent of kind HTML produces SafeHtml-contract-compliant value."), this.toString(), this.contentDir);
};
// INPUT (javascript/closure/soy/soy.js)
goog.soy.REQUIRE_STRICT_AUTOESCAPE = !1;
goog.soy.renderElement = function(element, template, opt_templateData, opt_injectedData) {
  goog.asserts.assert(template, "Soy template may not be null.");
  element.innerHTML = goog.soy.ensureTemplateOutputHtml_(template(opt_templateData || goog.soy.defaultTemplateData_, void 0, opt_injectedData));
};
goog.soy.renderAsFragment = function(template, opt_templateData, opt_injectedData, opt_domHelper) {
  goog.asserts.assert(template, "Soy template may not be null.");
  var dom = opt_domHelper || goog.dom.getDomHelper(), html = goog.soy.ensureTemplateOutputHtml_(template(opt_templateData || goog.soy.defaultTemplateData_, void 0, opt_injectedData));
  goog.soy.assertFirstTagValid_(html);
  return dom.htmlToDocumentFragment(html);
};
goog.soy.renderAsElement = function(template, opt_templateData, opt_injectedData, opt_domHelper) {
  goog.asserts.assert(template, "Soy template may not be null.");
  var dom = opt_domHelper || goog.dom.getDomHelper(), wrapper = dom.createElement(goog.dom.TagName.DIV), html = goog.soy.ensureTemplateOutputHtml_(template(opt_templateData || goog.soy.defaultTemplateData_, void 0, opt_injectedData));
  goog.soy.assertFirstTagValid_(html);
  wrapper.innerHTML = html;
  if (1 == wrapper.childNodes.length) {
    var firstChild = wrapper.firstChild;
    if (firstChild.nodeType == goog.dom.NodeType.ELEMENT) {
      return firstChild;
    }
  }
  return wrapper;
};
goog.soy.ensureTemplateOutputHtml_ = function(templateResult) {
  if (!goog.soy.REQUIRE_STRICT_AUTOESCAPE && !goog.isObject(templateResult)) {
    return String(templateResult);
  }
  if (templateResult instanceof goog.soy.data.SanitizedContent) {
    var ContentKind = goog.soy.data.SanitizedContentKind;
    if (templateResult.contentKind === ContentKind.HTML) {
      return goog.asserts.assertString(templateResult.getContent());
    }
    if (templateResult.contentKind === ContentKind.TEXT) {
      return goog.string.htmlEscape(templateResult.getContent());
    }
  }
  goog.asserts.fail("Soy template output is unsafe for use as HTML: " + templateResult);
  return "zSoyz";
};
goog.soy.assertFirstTagValid_ = function(html) {
  if (goog.asserts.ENABLE_ASSERTS) {
    var matches = html.match(goog.soy.INVALID_TAG_TO_RENDER_);
    goog.asserts.assert(!matches, "This template starts with a %s, which cannot be a child of a <div>, as required by soy internals. Consider using goog.soy.renderElement instead.\nTemplate output: %s", matches && matches[0], html);
  }
};
goog.soy.INVALID_TAG_TO_RENDER_ = /^<(body|caption|col|colgroup|head|html|tr|td|tbody|thead|tfoot)>/i;
goog.soy.defaultTemplateData_ = {};
// INPUT (javascript/template/soy/soyutils_usegoog.js)
var soy = {esc:{}}, soydata = {SanitizedJsStrChars:{}, VERY_UNSAFE:{}};
soy.StringBuilder = goog.string.StringBuffer;
soydata.SanitizedContentKind = goog.soy.data.SanitizedContentKind;
soydata.isContentKind = function(value, contentKind) {
  return null != value && value.contentKind === contentKind;
};
soydata.getContentDir = function(value) {
  if (null != value) {
    switch(value.contentDir) {
      case goog.i18n.bidi.Dir.LTR:
        return goog.i18n.bidi.Dir.LTR;
      case goog.i18n.bidi.Dir.RTL:
        return goog.i18n.bidi.Dir.RTL;
      case goog.i18n.bidi.Dir.NEUTRAL:
        return goog.i18n.bidi.Dir.NEUTRAL;
    }
  }
  return null;
};
soydata.SanitizedHtml = function() {
  goog.soy.data.SanitizedContent.call(this);
};
goog.inherits(soydata.SanitizedHtml, goog.soy.data.SanitizedContent);
soydata.SanitizedHtml.prototype.contentKind = soydata.SanitizedContentKind.HTML;
soydata.SanitizedHtml.from = function(value) {
  return null != value && value.contentKind === soydata.SanitizedContentKind.HTML ? (goog.asserts.assert(value.constructor === soydata.SanitizedHtml), value) : value instanceof goog.html.SafeHtml ? soydata.VERY_UNSAFE.ordainSanitizedHtml(goog.html.SafeHtml.unwrap(value), value.getDirection()) : soydata.VERY_UNSAFE.ordainSanitizedHtml(soy.esc.$$escapeHtmlHelper(String(value)), soydata.getContentDir(value));
};
soydata.SanitizedJs = function() {
  goog.soy.data.SanitizedContent.call(this);
};
goog.inherits(soydata.SanitizedJs, goog.soy.data.SanitizedContent);
soydata.SanitizedJs.prototype.contentKind = soydata.SanitizedContentKind.JS;
soydata.SanitizedJs.prototype.contentDir = goog.i18n.bidi.Dir.LTR;
soydata.SanitizedUri = function() {
  goog.soy.data.SanitizedContent.call(this);
};
goog.inherits(soydata.SanitizedUri, goog.soy.data.SanitizedContent);
soydata.SanitizedUri.prototype.contentKind = soydata.SanitizedContentKind.URI;
soydata.SanitizedUri.prototype.contentDir = goog.i18n.bidi.Dir.LTR;
soydata.SanitizedHtmlAttribute = function() {
  goog.soy.data.SanitizedContent.call(this);
};
goog.inherits(soydata.SanitizedHtmlAttribute, goog.soy.data.SanitizedContent);
soydata.SanitizedHtmlAttribute.prototype.contentKind = soydata.SanitizedContentKind.ATTRIBUTES;
soydata.SanitizedHtmlAttribute.prototype.contentDir = goog.i18n.bidi.Dir.LTR;
soydata.SanitizedCss = function() {
  goog.soy.data.SanitizedContent.call(this);
};
goog.inherits(soydata.SanitizedCss, goog.soy.data.SanitizedContent);
soydata.SanitizedCss.prototype.contentKind = soydata.SanitizedContentKind.CSS;
soydata.SanitizedCss.prototype.contentDir = goog.i18n.bidi.Dir.LTR;
soydata.UnsanitizedText = function(content, opt_contentDir) {
  this.content = String(content);
  this.contentDir = null != opt_contentDir ? opt_contentDir : null;
};
goog.inherits(soydata.UnsanitizedText, goog.soy.data.SanitizedContent);
soydata.UnsanitizedText.prototype.contentKind = soydata.SanitizedContentKind.TEXT;
soydata.$$EMPTY_STRING_ = {VALUE:""};
soydata.$$makeSanitizedContentFactory_ = function(ctor) {
  function InstantiableCtor(content) {
    this.content = content;
  }
  function sanitizedContentFactory(content, opt_contentDir) {
    var result = new InstantiableCtor(String(content));
    void 0 !== opt_contentDir && (result.contentDir = opt_contentDir);
    return result;
  }
  InstantiableCtor.prototype = ctor.prototype;
  return sanitizedContentFactory;
};
soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_ = function(ctor) {
  function InstantiableCtor(content) {
    this.content = content;
  }
  function sanitizedContentFactory(content) {
    var result = new InstantiableCtor(String(content));
    return result;
  }
  InstantiableCtor.prototype = ctor.prototype;
  return sanitizedContentFactory;
};
soydata.markUnsanitizedText = function(content, opt_contentDir) {
  return new soydata.UnsanitizedText(content, opt_contentDir);
};
soydata.VERY_UNSAFE.ordainSanitizedHtml = soydata.$$makeSanitizedContentFactory_(soydata.SanitizedHtml);
soydata.VERY_UNSAFE.ordainSanitizedJs = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_(soydata.SanitizedJs);
soydata.VERY_UNSAFE.ordainSanitizedUri = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_(soydata.SanitizedUri);
soydata.VERY_UNSAFE.ordainSanitizedHtmlAttribute = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_(soydata.SanitizedHtmlAttribute);
soydata.VERY_UNSAFE.ordainSanitizedCss = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_(soydata.SanitizedCss);
soy.renderElement = goog.soy.renderElement;
soy.renderAsFragment = function(template, opt_templateData, opt_document, opt_injectedData) {
  return goog.soy.renderAsFragment(template, opt_templateData, opt_injectedData, new goog.dom.DomHelper(opt_document));
};
soy.renderAsElement = function(template, opt_templateData, opt_document, opt_injectedData) {
  return goog.soy.renderAsElement(template, opt_templateData, opt_injectedData, new goog.dom.DomHelper(opt_document));
};
soy.$$IS_LOCALE_RTL = goog.i18n.bidi.IS_RTL;
soy.$$augmentMap = function(baseMap, additionalMap) {
  function TempCtor() {
  }
  TempCtor.prototype = baseMap;
  var augmentedMap = new TempCtor, key;
  for (key in additionalMap) {
    augmentedMap[key] = additionalMap[key];
  }
  return augmentedMap;
};
soy.$$checkMapKey = function(key) {
  if ("string" != typeof key) {
    throw Error("Map literal's key expression must evaluate to string (encountered type \"" + typeof key + '").');
  }
  return key;
};
soy.$$getMapKeys = function(map) {
  var mapKeys = [], key;
  for (key in map) {
    mapKeys.push(key);
  }
  return mapKeys;
};
soy.$$getDelTemplateId = function(delTemplateName) {
  return delTemplateName;
};
soy.$$DELEGATE_REGISTRY_PRIORITIES_ = {};
soy.$$DELEGATE_REGISTRY_FUNCTIONS_ = {};
soy.$$registerDelegateFn = function(delTemplateId, delTemplateVariant, delPriority, delFn) {
  var mapKey = "key_" + delTemplateId + ":" + delTemplateVariant, currPriority = soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey];
  if (void 0 === currPriority || delPriority > currPriority) {
    soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey] = delPriority, soy.$$DELEGATE_REGISTRY_FUNCTIONS_[mapKey] = delFn;
  } else {
    if (delPriority == currPriority) {
      throw Error('Encountered two active delegates with the same priority ("' + delTemplateId + ":" + delTemplateVariant + '").');
    }
  }
};
soy.$$getDelegateFn = function(delTemplateId, delTemplateVariant, allowsEmptyDefault) {
  var delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_["key_" + delTemplateId + ":" + delTemplateVariant];
  delFn || "" == delTemplateVariant || (delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_["key_" + delTemplateId + ":"]);
  if (delFn) {
    return delFn;
  }
  if (allowsEmptyDefault) {
    return soy.$$EMPTY_TEMPLATE_FN_;
  }
  throw Error('Found no active impl for delegate call to "' + delTemplateId + ":" + delTemplateVariant + '" (and not allowemptydefault="true").');
};
soy.$$EMPTY_TEMPLATE_FN_ = function() {
  return "";
};
soydata.$$makeSanitizedContentFactoryForInternalBlocks_ = function(ctor) {
  function InstantiableCtor(content) {
    this.content = content;
  }
  function sanitizedContentFactory(content, opt_contentDir) {
    var contentString = String(content);
    if (!contentString) {
      return soydata.$$EMPTY_STRING_.VALUE;
    }
    var result = new InstantiableCtor(contentString);
    void 0 !== opt_contentDir && (result.contentDir = opt_contentDir);
    return result;
  }
  InstantiableCtor.prototype = ctor.prototype;
  return sanitizedContentFactory;
};
soydata.$$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_ = function(ctor) {
  function InstantiableCtor(content) {
    this.content = content;
  }
  function sanitizedContentFactory(content) {
    var contentString = String(content);
    if (!contentString) {
      return soydata.$$EMPTY_STRING_.VALUE;
    }
    var result = new InstantiableCtor(contentString);
    return result;
  }
  InstantiableCtor.prototype = ctor.prototype;
  return sanitizedContentFactory;
};
soydata.$$markUnsanitizedTextForInternalBlocks = function(content, opt_contentDir) {
  var contentString = String(content);
  return contentString ? new soydata.UnsanitizedText(contentString, opt_contentDir) : soydata.$$EMPTY_STRING_.VALUE;
};
soydata.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks = soydata.$$makeSanitizedContentFactoryForInternalBlocks_(soydata.SanitizedHtml);
soydata.VERY_UNSAFE.$$ordainSanitizedJsForInternalBlocks = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_(soydata.SanitizedJs);
soydata.VERY_UNSAFE.$$ordainSanitizedUriForInternalBlocks = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_(soydata.SanitizedUri);
soydata.VERY_UNSAFE.$$ordainSanitizedAttributesForInternalBlocks = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_(soydata.SanitizedHtmlAttribute);
soydata.VERY_UNSAFE.$$ordainSanitizedCssForInternalBlocks = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_(soydata.SanitizedCss);
soy.$$escapeHtml = function(value) {
  return soydata.SanitizedHtml.from(value);
};
soy.$$cleanHtml = function(value) {
  return soydata.isContentKind(value, soydata.SanitizedContentKind.HTML) ? (goog.asserts.assert(value.constructor === soydata.SanitizedHtml), value) : soydata.VERY_UNSAFE.ordainSanitizedHtml(soy.$$stripHtmlTags(value, soy.esc.$$SAFE_TAG_WHITELIST_), soydata.getContentDir(value));
};
soy.$$escapeHtmlRcdata = function(value) {
  return soydata.isContentKind(value, soydata.SanitizedContentKind.HTML) ? (goog.asserts.assert(value.constructor === soydata.SanitizedHtml), soy.esc.$$normalizeHtmlHelper(value.getContent())) : soy.esc.$$escapeHtmlHelper(value);
};
soy.$$HTML5_VOID_ELEMENTS_ = /^<(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\b/;
soy.$$stripHtmlTags = function(value, opt_tagWhitelist) {
  if (!opt_tagWhitelist) {
    return String(value).replace(soy.esc.$$HTML_TAG_REGEX_, "").replace(soy.esc.$$LT_REGEX_, "&lt;");
  }
  var html = String(value).replace(/\[/g, "&#91;"), tags = [], html = html.replace(soy.esc.$$HTML_TAG_REGEX_, function(tok, tagName) {
    if (tagName && (tagName = tagName.toLowerCase(), opt_tagWhitelist.hasOwnProperty(tagName) && opt_tagWhitelist[tagName])) {
      var start = "/" === tok.charAt(1) ? "</" : "<", index = tags.length;
      tags[index] = start + tagName + ">";
      return "[" + index + "]";
    }
    return "";
  }), html = soy.esc.$$normalizeHtmlHelper(html), finalCloseTags = soy.$$balanceTags_(tags), html = html.replace(/\[(\d+)\]/g, function(_, index) {
    return tags[index];
  });
  return html + finalCloseTags;
};
soy.$$balanceTags_ = function(tags) {
  for (var open = [], i = 0, n = tags.length;i < n;++i) {
    var tag = tags[i];
    if ("/" === tag.charAt(1)) {
      for (var openTagIndex = open.length - 1;0 <= openTagIndex && open[openTagIndex] != tag;) {
        openTagIndex--;
      }
      0 > openTagIndex ? tags[i] = "" : (tags[i] = open.slice(openTagIndex).reverse().join(""), open.length = openTagIndex);
    } else {
      soy.$$HTML5_VOID_ELEMENTS_.test(tag) || open.push("</" + tag.substring(1));
    }
  }
  return open.reverse().join("");
};
soy.$$escapeHtmlAttribute = function(value) {
  return soydata.isContentKind(value, soydata.SanitizedContentKind.HTML) ? (goog.asserts.assert(value.constructor === soydata.SanitizedHtml), soy.esc.$$normalizeHtmlHelper(soy.$$stripHtmlTags(value.getContent()))) : soy.esc.$$escapeHtmlHelper(value);
};
soy.$$escapeHtmlAttributeNospace = function(value) {
  return soydata.isContentKind(value, soydata.SanitizedContentKind.HTML) ? (goog.asserts.assert(value.constructor === soydata.SanitizedHtml), soy.esc.$$normalizeHtmlNospaceHelper(soy.$$stripHtmlTags(value.getContent()))) : soy.esc.$$escapeHtmlNospaceHelper(value);
};
soy.$$filterHtmlAttributes = function(value) {
  return soydata.isContentKind(value, soydata.SanitizedContentKind.ATTRIBUTES) ? (goog.asserts.assert(value.constructor === soydata.SanitizedHtmlAttribute), value.getContent().replace(/([^"'\s])$/, "$1 ")) : soy.esc.$$filterHtmlAttributesHelper(value);
};
soy.$$filterHtmlElementName = function(value) {
  return soy.esc.$$filterHtmlElementNameHelper(value);
};
soy.$$escapeJs = function(value) {
  return soy.$$escapeJsString(value);
};
soy.$$escapeJsString = function(value) {
  return soy.esc.$$escapeJsStringHelper(value);
};
soy.$$escapeJsValue = function(value) {
  if (null == value) {
    return " null ";
  }
  if (soydata.isContentKind(value, soydata.SanitizedContentKind.JS)) {
    return goog.asserts.assert(value.constructor === soydata.SanitizedJs), value.getContent();
  }
  switch(typeof value) {
    case "boolean":
    ;
    case "number":
      return " " + value + " ";
    default:
      return "'" + soy.esc.$$escapeJsStringHelper(String(value)) + "'";
  }
};
soy.$$escapeJsRegex = function(value) {
  return soy.esc.$$escapeJsRegexHelper(value);
};
soy.$$problematicUriMarks_ = /['()]/g;
soy.$$pctEncode_ = function(ch) {
  return "%" + ch.charCodeAt(0).toString(16);
};
soy.$$escapeUri = function(value) {
  if (soydata.isContentKind(value, soydata.SanitizedContentKind.URI)) {
    return goog.asserts.assert(value.constructor === soydata.SanitizedUri), soy.$$normalizeUri(value);
  }
  if (value instanceof goog.html.SafeUrl) {
    return soy.$$normalizeUri(goog.html.SafeUrl.unwrap(value));
  }
  var encoded = soy.esc.$$escapeUriHelper(value);
  soy.$$problematicUriMarks_.lastIndex = 0;
  return soy.$$problematicUriMarks_.test(encoded) ? encoded.replace(soy.$$problematicUriMarks_, soy.$$pctEncode_) : encoded;
};
soy.$$normalizeUri = function(value) {
  return soy.esc.$$normalizeUriHelper(value);
};
soy.$$filterNormalizeUri = function(value) {
  return soydata.isContentKind(value, soydata.SanitizedContentKind.URI) ? (goog.asserts.assert(value.constructor === soydata.SanitizedUri), soy.$$normalizeUri(value)) : value instanceof goog.html.SafeUrl ? soy.$$normalizeUri(goog.html.SafeUrl.unwrap(value)) : soy.esc.$$filterNormalizeUriHelper(value);
};
soy.$$filterImageDataUri = function(value) {
  return soydata.VERY_UNSAFE.ordainSanitizedUri(soy.esc.$$filterImageDataUriHelper(value));
};
soy.$$escapeCssString = function(value) {
  return soy.esc.$$escapeCssStringHelper(value);
};
soy.$$filterCssValue = function(value) {
  return soydata.isContentKind(value, soydata.SanitizedContentKind.CSS) ? (goog.asserts.assert(value.constructor === soydata.SanitizedCss), value.getContent()) : null == value ? "" : value instanceof goog.html.SafeStyle ? goog.html.SafeStyle.unwrap(value) : soy.esc.$$filterCssValueHelper(value);
};
soy.$$filterNoAutoescape = function(value) {
  return soydata.isContentKind(value, soydata.SanitizedContentKind.TEXT) ? (goog.asserts.fail("Tainted SanitizedContentKind.TEXT for |noAutoescape: `%s`", [value.getContent()]), "zSoyz") : value;
};
soy.$$changeNewlineToBr = function(value) {
  var result = goog.string.newLineToBr(String(value), !1);
  return soydata.isContentKind(value, soydata.SanitizedContentKind.HTML) ? soydata.VERY_UNSAFE.ordainSanitizedHtml(result, soydata.getContentDir(value)) : result;
};
soy.$$insertWordBreaks = function(value, maxCharsBetweenWordBreaks) {
  var result = goog.format.insertWordBreaks(String(value), maxCharsBetweenWordBreaks);
  return soydata.isContentKind(value, soydata.SanitizedContentKind.HTML) ? soydata.VERY_UNSAFE.ordainSanitizedHtml(result, soydata.getContentDir(value)) : result;
};
soy.$$truncate = function(str, maxLen, doAddEllipsis) {
  str = String(str);
  if (str.length <= maxLen) {
    return str;
  }
  doAddEllipsis && (3 < maxLen ? maxLen -= 3 : doAddEllipsis = !1);
  soy.$$isHighSurrogate_(str.charAt(maxLen - 1)) && soy.$$isLowSurrogate_(str.charAt(maxLen)) && (maxLen -= 1);
  str = str.substring(0, maxLen);
  doAddEllipsis && (str += "...");
  return str;
};
soy.$$isHighSurrogate_ = function(ch) {
  return 55296 <= ch && 56319 >= ch;
};
soy.$$isLowSurrogate_ = function(ch) {
  return 56320 <= ch && 57343 >= ch;
};
soy.$$bidiFormatterCache_ = {};
soy.$$getBidiFormatterInstance_ = function(bidiGlobalDir) {
  return soy.$$bidiFormatterCache_[bidiGlobalDir] || (soy.$$bidiFormatterCache_[bidiGlobalDir] = new goog.i18n.BidiFormatter(bidiGlobalDir));
};
soy.$$bidiTextDir = function(text, opt_isHtml) {
  var contentDir = soydata.getContentDir(text);
  if (null != contentDir) {
    return contentDir;
  }
  var isHtml = opt_isHtml || soydata.isContentKind(text, soydata.SanitizedContentKind.HTML);
  return goog.i18n.bidi.estimateDirection(text + "", isHtml);
};
soy.$$bidiDirAttr = function(bidiGlobalDir, text, opt_isHtml) {
  var formatter = soy.$$getBidiFormatterInstance_(bidiGlobalDir), contentDir = soydata.getContentDir(text);
  if (null == contentDir) {
    var isHtml = opt_isHtml || soydata.isContentKind(text, soydata.SanitizedContentKind.HTML), contentDir = goog.i18n.bidi.estimateDirection(text + "", isHtml)
  }
  return soydata.VERY_UNSAFE.ordainSanitizedHtmlAttribute(formatter.knownDirAttr(contentDir));
};
soy.$$bidiMarkAfter = function(bidiGlobalDir, text, opt_isHtml) {
  var formatter = soy.$$getBidiFormatterInstance_(bidiGlobalDir), isHtml = opt_isHtml || soydata.isContentKind(text, soydata.SanitizedContentKind.HTML);
  return formatter.markAfterKnownDir(soydata.getContentDir(text), text + "", isHtml);
};
soy.$$bidiSpanWrap = function(bidiGlobalDir, text) {
  var formatter = soy.$$getBidiFormatterInstance_(bidiGlobalDir), html = goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Soy |bidiSpanWrap is applied on an autoescaped text."), String(text)), wrappedHtml = formatter.spanWrapSafeHtmlWithKnownDir(soydata.getContentDir(text), html);
  return goog.html.SafeHtml.unwrap(wrappedHtml);
};
soy.$$bidiUnicodeWrap = function(bidiGlobalDir, text) {
  var formatter = soy.$$getBidiFormatterInstance_(bidiGlobalDir), isHtml = soydata.isContentKind(text, soydata.SanitizedContentKind.HTML), wrappedText = formatter.unicodeWrapWithKnownDir(soydata.getContentDir(text), text + "", isHtml), wrappedTextDir = formatter.getContextDir();
  return soydata.isContentKind(text, soydata.SanitizedContentKind.TEXT) ? new soydata.UnsanitizedText(wrappedText, wrappedTextDir) : isHtml ? soydata.VERY_UNSAFE.ordainSanitizedHtml(wrappedText, wrappedTextDir) : wrappedText;
};
soy.esc.$$escapeHtmlHelper = function(v) {
  return goog.string.htmlEscape(String(v));
};
soy.esc.$$escapeUriHelper = function(v) {
  return goog.string.urlEncode(String(v));
};
soy.esc.$$ESCAPE_MAP_FOR_NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_ = {"\x00":"&#0;", "\t":"&#9;", "\n":"&#10;", "\x0B":"&#11;", "\f":"&#12;", "\r":"&#13;", " ":"&#32;", '"':"&quot;", "&":"&amp;", "'":"&#39;", "-":"&#45;", "/":"&#47;", "<":"&lt;", "=":"&#61;", ">":"&gt;", "`":"&#96;", "\u0085":"&#133;", "\u00a0":"&#160;", "\u2028":"&#8232;", "\u2029":"&#8233;"};
soy.esc.$$REPLACER_FOR_NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_ = function(ch) {
  return soy.esc.$$ESCAPE_MAP_FOR_NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_[ch];
};
soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_ = {"\x00":"\\x00", "\b":"\\x08", "\t":"\\t", "\n":"\\n", "\x0B":"\\x0b", "\f":"\\f", "\r":"\\r", '"':"\\x22", $:"\\x24", "&":"\\x26", "'":"\\x27", "(":"\\x28", ")":"\\x29", "*":"\\x2a", "+":"\\x2b", ",":"\\x2c", "-":"\\x2d", ".":"\\x2e", "/":"\\/", ":":"\\x3a", "<":"\\x3c", "=":"\\x3d", ">":"\\x3e", "?":"\\x3f", "[":"\\x5b", "\\":"\\\\", "]":"\\x5d", "^":"\\x5e", "{":"\\x7b", "|":"\\x7c", "}":"\\x7d", "\u0085":"\\x85", "\u2028":"\\u2028", 
"\u2029":"\\u2029"};
soy.esc.$$REPLACER_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_ = function(ch) {
  return soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_[ch];
};
soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_CSS_STRING_ = {"\x00":"\\0 ", "\b":"\\8 ", "\t":"\\9 ", "\n":"\\a ", "\x0B":"\\b ", "\f":"\\c ", "\r":"\\d ", '"':"\\22 ", "&":"\\26 ", "'":"\\27 ", "(":"\\28 ", ")":"\\29 ", "*":"\\2a ", "/":"\\2f ", ":":"\\3a ", ";":"\\3b ", "<":"\\3c ", "=":"\\3d ", ">":"\\3e ", "@":"\\40 ", "\\":"\\5c ", "{":"\\7b ", "}":"\\7d ", "\u0085":"\\85 ", "\u00a0":"\\a0 ", "\u2028":"\\2028 ", "\u2029":"\\2029 "};
soy.esc.$$REPLACER_FOR_ESCAPE_CSS_STRING_ = function(ch) {
  return soy.esc.$$ESCAPE_MAP_FOR_ESCAPE_CSS_STRING_[ch];
};
soy.esc.$$ESCAPE_MAP_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_ = {"\x00":"%00", "\u0001":"%01", "\u0002":"%02", "\u0003":"%03", "\u0004":"%04", "\u0005":"%05", "\u0006":"%06", "\u0007":"%07", "\b":"%08", "\t":"%09", "\n":"%0A", "\x0B":"%0B", "\f":"%0C", "\r":"%0D", "\u000e":"%0E", "\u000f":"%0F", "\u0010":"%10", "\u0011":"%11", "\u0012":"%12", "\u0013":"%13", "\u0014":"%14", "\u0015":"%15", "\u0016":"%16", "\u0017":"%17", "\u0018":"%18", "\u0019":"%19", "\u001a":"%1A", "\u001b":"%1B", "\u001c":"%1C", 
"\u001d":"%1D", "\u001e":"%1E", "\u001f":"%1F", " ":"%20", '"':"%22", "'":"%27", "(":"%28", ")":"%29", "<":"%3C", ">":"%3E", "\\":"%5C", "{":"%7B", "}":"%7D", "\u007f":"%7F", "\u0085":"%C2%85", "\u00a0":"%C2%A0", "\u2028":"%E2%80%A8", "\u2029":"%E2%80%A9", "\uff01":"%EF%BC%81", "\uff03":"%EF%BC%83", "\uff04":"%EF%BC%84", "\uff06":"%EF%BC%86", "\uff07":"%EF%BC%87", "\uff08":"%EF%BC%88", "\uff09":"%EF%BC%89", "\uff0a":"%EF%BC%8A", "\uff0b":"%EF%BC%8B", "\uff0c":"%EF%BC%8C", "\uff0f":"%EF%BC%8F", "\uff1a":"%EF%BC%9A", 
"\uff1b":"%EF%BC%9B", "\uff1d":"%EF%BC%9D", "\uff1f":"%EF%BC%9F", "\uff20":"%EF%BC%A0", "\uff3b":"%EF%BC%BB", "\uff3d":"%EF%BC%BD"};
soy.esc.$$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_ = function(ch) {
  return soy.esc.$$ESCAPE_MAP_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_[ch];
};
soy.esc.$$MATCHER_FOR_NORMALIZE_HTML_ = /[\x00\x22\x27\x3c\x3e]/g;
soy.esc.$$MATCHER_FOR_ESCAPE_HTML_NOSPACE_ = /[\x00\x09-\x0d \x22\x26\x27\x2d\/\x3c-\x3e`\x85\xa0\u2028\u2029]/g;
soy.esc.$$MATCHER_FOR_NORMALIZE_HTML_NOSPACE_ = /[\x00\x09-\x0d \x22\x27\x2d\/\x3c-\x3e`\x85\xa0\u2028\u2029]/g;
soy.esc.$$MATCHER_FOR_ESCAPE_JS_STRING_ = /[\x00\x08-\x0d\x22\x26\x27\/\x3c-\x3e\\\x85\u2028\u2029]/g;
soy.esc.$$MATCHER_FOR_ESCAPE_JS_REGEX_ = /[\x00\x08-\x0d\x22\x24\x26-\/\x3a\x3c-\x3f\x5b-\x5e\x7b-\x7d\x85\u2028\u2029]/g;
soy.esc.$$MATCHER_FOR_ESCAPE_CSS_STRING_ = /[\x00\x08-\x0d\x22\x26-\x2a\/\x3a-\x3e@\\\x7b\x7d\x85\xa0\u2028\u2029]/g;
soy.esc.$$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_ = /[\x00- \x22\x27-\x29\x3c\x3e\\\x7b\x7d\x7f\x85\xa0\u2028\u2029\uff01\uff03\uff04\uff06-\uff0c\uff0f\uff1a\uff1b\uff1d\uff1f\uff20\uff3b\uff3d]/g;
soy.esc.$$FILTER_FOR_FILTER_CSS_VALUE_ = /^(?!-*(?:expression|(?:moz-)?binding))(?:[.#]?-?(?:[_a-z0-9-]+)(?:-[_a-z0-9-]+)*-?|-?(?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+)(?:[a-z]{1,2}|%)?|!important|)$/i;
soy.esc.$$FILTER_FOR_FILTER_NORMALIZE_URI_ = /^(?![^#?]*\/(?:\.|%2E){2}(?:[\/?#]|$))(?:(?:https?|mailto):|[^&:\/?#]*(?:[\/?#]|$))/i;
soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_ = /^data:image\/(?:bmp|gif|jpe?g|png|tiff|webp);base64,[a-z0-9+\/]+=*$/i;
soy.esc.$$FILTER_FOR_FILTER_HTML_ATTRIBUTES_ = /^(?!style|on|action|archive|background|cite|classid|codebase|data|dsync|href|longdesc|src|usemap)(?:[a-z0-9_$:-]*)$/i;
soy.esc.$$FILTER_FOR_FILTER_HTML_ELEMENT_NAME_ = /^(?!script|style|title|textarea|xmp|no)[a-z0-9_$:-]*$/i;
soy.esc.$$normalizeHtmlHelper = function(value) {
  var str = String(value);
  return str.replace(soy.esc.$$MATCHER_FOR_NORMALIZE_HTML_, soy.esc.$$REPLACER_FOR_NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};
soy.esc.$$escapeHtmlNospaceHelper = function(value) {
  var str = String(value);
  return str.replace(soy.esc.$$MATCHER_FOR_ESCAPE_HTML_NOSPACE_, soy.esc.$$REPLACER_FOR_NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};
soy.esc.$$normalizeHtmlNospaceHelper = function(value) {
  var str = String(value);
  return str.replace(soy.esc.$$MATCHER_FOR_NORMALIZE_HTML_NOSPACE_, soy.esc.$$REPLACER_FOR_NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};
soy.esc.$$escapeJsStringHelper = function(value) {
  var str = String(value);
  return str.replace(soy.esc.$$MATCHER_FOR_ESCAPE_JS_STRING_, soy.esc.$$REPLACER_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_);
};
soy.esc.$$escapeJsRegexHelper = function(value) {
  var str = String(value);
  return str.replace(soy.esc.$$MATCHER_FOR_ESCAPE_JS_REGEX_, soy.esc.$$REPLACER_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_);
};
soy.esc.$$escapeCssStringHelper = function(value) {
  var str = String(value);
  return str.replace(soy.esc.$$MATCHER_FOR_ESCAPE_CSS_STRING_, soy.esc.$$REPLACER_FOR_ESCAPE_CSS_STRING_);
};
soy.esc.$$filterCssValueHelper = function(value) {
  var str = String(value);
  return soy.esc.$$FILTER_FOR_FILTER_CSS_VALUE_.test(str) ? str : (goog.asserts.fail("Bad value `%s` for |filterCssValue", [str]), "zSoyz");
};
soy.esc.$$normalizeUriHelper = function(value) {
  var str = String(value);
  return str.replace(soy.esc.$$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_, soy.esc.$$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_);
};
soy.esc.$$filterNormalizeUriHelper = function(value) {
  var str = String(value);
  return soy.esc.$$FILTER_FOR_FILTER_NORMALIZE_URI_.test(str) ? str.replace(soy.esc.$$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_, soy.esc.$$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI_) : (goog.asserts.fail("Bad value `%s` for |filterNormalizeUri", [str]), "#zSoyz");
};
soy.esc.$$filterImageDataUriHelper = function(value) {
  var str = String(value);
  return soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_.test(str) ? str : (goog.asserts.fail("Bad value `%s` for |filterImageDataUri", [str]), "data:image/gif;base64,zSoyz");
};
soy.esc.$$filterHtmlAttributesHelper = function(value) {
  var str = String(value);
  return soy.esc.$$FILTER_FOR_FILTER_HTML_ATTRIBUTES_.test(str) ? str : (goog.asserts.fail("Bad value `%s` for |filterHtmlAttributes", [str]), "zSoyz");
};
soy.esc.$$filterHtmlElementNameHelper = function(value) {
  var str = String(value);
  return soy.esc.$$FILTER_FOR_FILTER_HTML_ELEMENT_NAME_.test(str) ? str : (goog.asserts.fail("Bad value `%s` for |filterHtmlElementName", [str]), "zSoyz");
};
soy.esc.$$HTML_TAG_REGEX_ = /<(?:!|\/?([a-zA-Z][a-zA-Z0-9:\-]*))(?:[^>'"]|"[^"]*"|'[^']*')*>/g;
soy.esc.$$LT_REGEX_ = /</g;
soy.esc.$$SAFE_TAG_WHITELIST_ = {b:1, br:1, em:1, i:1, s:1, sub:1, sup:1, u:1};
// INPUT (javascript/closure/math/matrix.js)
goog.math.Matrix = function(m, opt_n) {
  if (m instanceof goog.math.Matrix) {
    this.array_ = m.toArray();
  } else {
    if (goog.isArrayLike(m) && goog.math.Matrix.isValidArray(m)) {
      this.array_ = goog.array.clone(m);
    } else {
      if (m instanceof goog.math.Size) {
        this.array_ = goog.math.Matrix.createZeroPaddedArray_(m.height, m.width);
      } else {
        if (goog.isNumber(m) && goog.isNumber(opt_n) && 0 < m && 0 < opt_n) {
          this.array_ = goog.math.Matrix.createZeroPaddedArray_(m, opt_n);
        } else {
          throw Error("Invalid argument(s) for Matrix contructor");
        }
      }
    }
  }
  this.size_ = new goog.math.Size(this.array_[0].length, this.array_.length);
};
goog.math.Matrix.createIdentityMatrix = function(n) {
  for (var rv = [], i = 0;i < n;i++) {
    rv[i] = [];
    for (var j = 0;j < n;j++) {
      rv[i][j] = i == j ? 1 : 0;
    }
  }
  return new goog.math.Matrix(rv);
};
goog.math.Matrix.forEach = function(matrix, fn, opt_obj) {
  for (var i = 0;i < matrix.getSize().height;i++) {
    for (var j = 0;j < matrix.getSize().width;j++) {
      fn.call(opt_obj, matrix.array_[i][j], i, j, matrix);
    }
  }
};
goog.math.Matrix.isValidArray = function(arr) {
  for (var len = 0, i = 0;i < arr.length;i++) {
    if (!goog.isArrayLike(arr[i]) || 0 < len && arr[i].length != len) {
      return!1;
    }
    for (var j = 0;j < arr[i].length;j++) {
      if (!goog.isNumber(arr[i][j])) {
        return!1;
      }
    }
    0 == len && (len = arr[i].length);
  }
  return 0 != len;
};
goog.math.Matrix.map = function(matrix, fn, opt_obj) {
  var m = new goog.math.Matrix(matrix.getSize());
  goog.math.Matrix.forEach(matrix, function(value, i, j) {
    m.array_[i][j] = fn.call(opt_obj, value, i, j, matrix);
  });
  return m;
};
goog.math.Matrix.createZeroPaddedArray_ = function(m, n) {
  for (var rv = [], i = 0;i < m;i++) {
    rv[i] = [];
    for (var j = 0;j < n;j++) {
      rv[i][j] = 0;
    }
  }
  return rv;
};
goog.math.Matrix.prototype.add = function(m) {
  if (!goog.math.Size.equals(this.size_, m.getSize())) {
    throw Error("Matrix summation is only supported on arrays of equal size");
  }
  return goog.math.Matrix.map(this, function(val, i, j) {
    return val + m.array_[i][j];
  });
};
goog.math.Matrix.prototype.appendColumns = function(m) {
  if (this.size_.height != m.getSize().height) {
    throw Error("The given matrix has height " + m.size_.height + ", but  needs to have height " + this.size_.height + ".");
  }
  var result = new goog.math.Matrix(this.size_.height, this.size_.width + m.size_.width);
  goog.math.Matrix.forEach(this, function(value, i, j) {
    result.array_[i][j] = value;
  });
  goog.math.Matrix.forEach(m, function(value, i, j) {
    result.array_[i][this.size_.width + j] = value;
  }, this);
  return result;
};
goog.math.Matrix.prototype.equals = function(m, opt_tolerance) {
  if (this.size_.width != m.size_.width || this.size_.height != m.size_.height) {
    return!1;
  }
  for (var tolerance = opt_tolerance || 0, i = 0;i < this.size_.height;i++) {
    for (var j = 0;j < this.size_.width;j++) {
      if (!goog.math.nearlyEquals(this.array_[i][j], m.array_[i][j], tolerance)) {
        return!1;
      }
    }
  }
  return!0;
};
goog.math.Matrix.prototype.getInverse = function() {
  if (!this.isSquare()) {
    throw Error("An inverse can only be taken on a square matrix.");
  }
  if (1 == this.getSize().width) {
    var a = this.getValueAt(0, 0);
    return 0 == a ? null : new goog.math.Matrix([[1 / a]]);
  }
  var identity = goog.math.Matrix.createIdentityMatrix(this.size_.height), mi = this.appendColumns(identity).getReducedRowEchelonForm(), i = mi.getSubmatrixByCoordinates_(0, 0, identity.size_.width - 1, identity.size_.height - 1);
  return i.equals(identity) ? mi.getSubmatrixByCoordinates_(0, identity.size_.width) : null;
};
goog.math.Matrix.prototype.getReducedRowEchelonForm = function() {
  for (var result = new goog.math.Matrix(this), col = 0, row = 0;row < result.size_.height && !(col >= result.size_.width);row++) {
    for (var i = row;0 == result.array_[i][col];) {
      if (i++, i == result.size_.height && (i = row, col++, col == result.size_.width)) {
        return result;
      }
    }
    this.swapRows_(i, row);
    for (var divisor = result.array_[row][col], j = col;j < result.size_.width;j++) {
      result.array_[row][j] /= divisor;
    }
    for (i = 0;i < result.size_.height;i++) {
      if (i != row) {
        for (var multiple = result.array_[i][col], j = col;j < result.size_.width;j++) {
          result.array_[i][j] -= multiple * result.array_[row][j];
        }
      }
    }
    col++;
  }
  return result;
};
goog.math.Matrix.prototype.getSize = function() {
  return this.size_;
};
goog.math.Matrix.prototype.getTranspose = function() {
  var m = new goog.math.Matrix(this.size_.width, this.size_.height);
  goog.math.Matrix.forEach(this, function(value, i, j) {
    m.array_[j][i] = value;
  });
  return m;
};
goog.math.Matrix.prototype.getValueAt = function(i, j) {
  return this.isInBounds_(i, j) ? this.array_[i][j] : null;
};
goog.math.Matrix.prototype.isSquare = function() {
  return this.size_.width == this.size_.height;
};
goog.math.Matrix.prototype.setValueAt = function(i, j, value) {
  if (!this.isInBounds_(i, j)) {
    throw Error("Index out of bounds when setting matrix value, (" + i + "," + j + ") in size (" + this.size_.height + "," + this.size_.width + ")");
  }
  this.array_[i][j] = value;
};
goog.math.Matrix.prototype.multiply = function(m) {
  if (m instanceof goog.math.Matrix) {
    if (this.size_.width != m.getSize().height) {
      throw Error("Invalid matrices for multiplication. Second matrix should have the same number of rows as the first has columns.");
    }
    return this.matrixMultiply_(m);
  }
  if (goog.isNumber(m)) {
    return this.scalarMultiply_(m);
  }
  throw Error("A matrix can only be multiplied by a number or another matrix.");
};
goog.math.Matrix.prototype.subtract = function(m) {
  if (!goog.math.Size.equals(this.size_, m.getSize())) {
    throw Error("Matrix subtraction is only supported on arrays of equal size.");
  }
  return goog.math.Matrix.map(this, function(val, i, j) {
    return val - m.array_[i][j];
  });
};
goog.math.Matrix.prototype.toArray = function() {
  return this.array_;
};
goog.DEBUG && (goog.math.Matrix.prototype.toString = function() {
  var maxLen = 0;
  goog.math.Matrix.forEach(this, function(val) {
    var len = String(val).length;
    len > maxLen && (maxLen = len);
  });
  var sb = [];
  goog.array.forEach(this.array_, function(row) {
    sb.push("[ ");
    goog.array.forEach(row, function(val) {
      var strval = String(val);
      sb.push(goog.string.repeat(" ", maxLen - strval.length) + strval + " ");
    });
    sb.push("]\n");
  });
  return sb.join("");
});
goog.math.Matrix.prototype.getSubmatrixByCoordinates_ = function(i1, j1, opt_i2, opt_j2) {
  var i2 = opt_i2 ? opt_i2 : this.size_.height - 1, j2 = opt_j2 ? opt_j2 : this.size_.width - 1, result = new goog.math.Matrix(i2 - i1 + 1, j2 - j1 + 1);
  goog.math.Matrix.forEach(result, function(value, i, j) {
    result.array_[i][j] = this.array_[i1 + i][j1 + j];
  }, this);
  return result;
};
goog.math.Matrix.prototype.isInBounds_ = function(i, j) {
  return 0 <= i && i < this.size_.height && 0 <= j && j < this.size_.width;
};
goog.math.Matrix.prototype.matrixMultiply_ = function(m) {
  var resultMatrix = new goog.math.Matrix(this.size_.height, m.getSize().width);
  goog.math.Matrix.forEach(resultMatrix, function(val, x, y) {
    for (var newVal = 0, i = 0;i < this.size_.width;i++) {
      newVal += this.getValueAt(x, i) * m.getValueAt(i, y);
    }
    resultMatrix.setValueAt(x, y, newVal);
  }, this);
  return resultMatrix;
};
goog.math.Matrix.prototype.scalarMultiply_ = function(m) {
  return goog.math.Matrix.map(this, function(val) {
    return val * m;
  });
};
goog.math.Matrix.prototype.swapRows_ = function(i1, i2) {
  var tmp = this.array_[i1];
  this.array_[i1] = this.array_[i2];
  this.array_[i2] = tmp;
};
// INPUT (research/infovis/verbal/stats.js)
var verbal = {ID_:function(x) {
  return x;
}, evaluator:function(opt_evaluator) {
  if (void 0 === opt_evaluator) {
    return verbal.ID_;
  }
  if ("function" == typeof opt_evaluator) {
    return opt_evaluator;
  }
  if ("string" == typeof opt_evaluator) {
    return function(x) {
      return x[opt_evaluator];
    };
  }
  throw "Bad type for verbal.evaluator: " + opt_evaluator;
}, sortedCopy:function(x, opt_compareFn) {
  var sorted = x.slice(0);
  goog.array.sort(sorted, opt_compareFn);
  return sorted;
}, sum:function(x, opt_evaluator) {
  var evaluator = verbal.evaluator(opt_evaluator);
  return goog.array.reduce(x, function(sum, val) {
    return sum + evaluator(val);
  }, 0);
}, mean:function(x, opt_evaluator) {
  return verbal.sum(x, opt_evaluator) / x.length;
}, median:function(x) {
  return verbal.quartiles(x)[2];
}, quartiles:function(x) {
  var sorted = verbal.sortedCopy(x);
  return[0, .25, .5, .75, 1].map(function(percentile) {
    var m = percentile * (sorted.length - 1);
    return(sorted[Math.floor(m)] + sorted[Math.ceil(m)]) / 2;
  });
}, standardDeviation:function(x, opt_evaluator) {
  return Math.sqrt(verbal.variance(x, opt_evaluator));
}, variance:function(x, opt_evaluator) {
  var evaluator = verbal.evaluator(opt_evaluator), x2 = verbal.mean(x, function(y) {
    var a = evaluator(y);
    return a * a;
  }), mx = verbal.mean(x, evaluator);
  return Math.max(x2 - mx * mx, 0);
}, skewness:function(x) {
  var mx = verbal.mean(x), mu3 = verbal.mean(x.map(function(xi) {
    return Math.pow(xi - mx, 3);
  }));
  return mu3 / Math.pow(verbal.variance(x), 1.5);
}, max:function(items, opt_f) {
  var f = verbal.evaluator(opt_f), max = null;
  goog.array.forEach(items, function(item) {
    var value = f(item);
    max >= value || (max = value);
  });
  return max;
}, min:function(items, opt_f) {
  var f = verbal.evaluator(opt_f);
  return f(verbal.argmax(items, function(x) {
    return-f(x);
  }));
}, argmax:function(items, f) {
  var evaluator = verbal.evaluator(f), max, maxItem;
  goog.array.forEach(items, function(item) {
    var value = evaluator(item);
    max >= value || (max = value, maxItem = item);
  });
  return maxItem;
}, argmin:function(items, f) {
  var evaluator = verbal.evaluator(f);
  return verbal.argmax(items, function(x) {
    return-evaluator(x);
  });
}};
verbal.INV_SQRT_2PI_ = 1 / Math.sqrt(2 * Math.PI);
verbal.normalDensity = function(x, mean, sigma) {
  if (0 > sigma) {
    throw "Bad normal distribution: sigma = " + sigma + ".";
  }
  if (0 == sigma) {
    return x == mean ? Infinity : 0;
  }
  var z = (x - mean) / sigma;
  return verbal.INV_SQRT_2PI_ * Math.exp(-.5 * z * z) / sigma;
};
verbal.normalCdf = function(x, opt_mean, opt_sigma) {
  var mean = opt_mean || 0, sigma = opt_sigma || 1;
  if (0 == sigma) {
    return x >= mean ? 1 : 0;
  }
  if (0 != mean || 1 != sigma) {
    return verbal.normalCdf((x - mean) / sigma);
  }
  if (0 < x) {
    return 1 - verbal.normalCdf(-x);
  }
  var xAbs = Math.abs(x), expo = Math.exp(-xAbs * xAbs / 2), coefs0 = [.65, 4, 3, 2, 1], coefs1 = [.0352624965998911, .700383064443688, 6.37396220353165, 33.912866078383, 112.079291497871, 221.213596169931, 220.206867912376], coefs2 = [.0883883476483184, 1.75566716318264, 16.064177579207, 86.7807322029461, 296.564248779674, 637.333633378831, 793.826512519948, 440.413735824752];
  if (37 < xAbs) {
    return 0;
  }
  if (7.07106781186547 <= xAbs) {
    var build = 1;
    coefs0.forEach(function(c) {
      build = xAbs + c / build;
    });
    return expo / build / 2.506628274631;
  }
  var build1 = 0, build2 = 0;
  coefs1.forEach(function(c) {
    build1 = build1 * xAbs + c;
  });
  coefs2.forEach(function(c) {
    build2 = build2 * xAbs + c;
  });
  return expo * build1 / build2;
};
verbal.gaussian = function(mean, sigma) {
  if (0 == sigma) {
    return mean;
  }
  var u, v, s;
  do {
    u = 2 * Math.random() - 1, v = 2 * Math.random() - 1, s = u * u + v * v;
  } while (1 <= s || 0 == s);
  return mean + sigma * u * Math.sqrt(-2 * Math.log(s) / s);
};
verbal.AICc = function(k, n, L) {
  return k >= n - 1 ? Infinity : 2 * (k - L + k * (k + 1) / (n - k - 1));
};
verbal.linearRegression = function(yArray, xMatrix) {
  var X = new goog.math.Matrix(xMatrix), y = (new goog.math.Matrix([yArray])).getTranspose(), Xt = X.getTranspose();
  return Xt.multiply(X).getInverse().multiply(Xt).multiply(y).getTranspose().toArray()[0];
};
verbal.freqs = function(items) {
  var freqs = {};
  items.forEach(function(item) {
    freqs[item] = goog.object.get(freqs, item, 0) + 1;
  });
  return freqs;
};
verbal.uniqueItems = function(items) {
  return(new goog.structs.Set(items)).getValues();
};
verbal.mode = function(items) {
  var freqs = verbal.freqs(items), max = verbal.max(goog.object.getValues(freqs));
  return goog.object.getKeys(freqs).filter(function(item) {
    return freqs[item] == max;
  }).map(function(item) {
    return "number" == typeof items[0] ? +item : item;
  });
};
verbal.AbstractStatsModel = function(opt_params) {
  this.params = opt_params || {};
  this.verbosity = this.parameterCount = 0;
  this.name = "AbstractStatsModel";
};
verbal.AbstractStatsModel.prototype.setDefaults = function(defaults) {
  goog.object.forEach(defaults, function(val, key) {
    goog.object.setIfUndefined(this.params, key, val);
  }, this);
};
// INPUT (javascript/gviz/devel/canviz/constants.js)
gviz.canviz.Constants = {};
gviz.canviz.Constants.GOLDEN_RATIO = 1.618;
gviz.canviz.Constants.LOG_10 = Math.log(10);
// INPUT (javascript/gviz/devel/canviz/idutils.js)
gviz.canviz.idutils = {};
gviz.canviz.idutils.generateId = function(tokens) {
  return tokens.join(gviz.canviz.idutils.TOKEN_SEPARATOR);
};
gviz.canviz.idutils.Token = {ACTIONS_MENU_ENTRY:"action", ANNOTATION:"annotation", ANNOTATION_TEXT:"annotationtext", AREA:"area", AXIS_TICK:"axistick", AXIS_TITLE:"axistitle", BAR:"bar", BASELINE:"baseline", BUBBLE:"bubble", CANDLESTICK:"candlestick", CATEGORY_SENSITIVITY_AREA:"categorysensitivityarea", CHART:"chart", CHART_AREA:"chartarea", COLOR_BAR:"colorbar", GRIDLINE:"gridline", HISTOGRAM:"histogram", INTERVAL:"interval", LEGEND:"legend", LEGEND_ENTRY:"legendentry", LEGEND_SCROLL_BUTTON:"legendscrollbutton", 
LINE:"line", MINOR_GRIDLINE:"minorgridline", OVERLAY_BOX:"overlaybox", PATH_INTERVAL:"pathinterval", POINT:"point", POINT_SENSITIVITY_AREA:"pointsensitivityarea", REMOVE_SERIE_BUTTON:"removeseriebutton", SLICE:"slice", STEPPED_AREA_BAR:"steppedareabar", TITLE:"title", TOOLTIP:"tooltip"};
gviz.canviz.idutils.TOKEN_SEPARATOR = "#";
gviz.canviz.idutils.TOKEN_PRECEDENCE = [gviz.canviz.idutils.Token.MINOR_GRIDLINE, gviz.canviz.idutils.Token.GRIDLINE, gviz.canviz.idutils.Token.AREA, gviz.canviz.idutils.Token.STEPPED_AREA_BAR, gviz.canviz.idutils.Token.BAR, gviz.canviz.idutils.Token.PATH_INTERVAL, gviz.canviz.idutils.Token.BASELINE, gviz.canviz.idutils.Token.INTERVAL, gviz.canviz.idutils.Token.LINE, gviz.canviz.idutils.Token.CANDLESTICK, gviz.canviz.idutils.Token.BUBBLE, gviz.canviz.idutils.Token.ANNOTATION, gviz.canviz.idutils.Token.POINT_SENSITIVITY_AREA, 
gviz.canviz.idutils.Token.POINT, gviz.canviz.idutils.Token.TITLE, gviz.canviz.idutils.Token.AXIS_TICK, gviz.canviz.idutils.Token.AXIS_TITLE, gviz.canviz.idutils.Token.CATEGORY_SENSITIVITY_AREA, gviz.canviz.idutils.Token.ANNOTATION_TEXT, gviz.canviz.idutils.Token.LEGEND, gviz.canviz.idutils.Token.LEGEND_SCROLL_BUTTON, gviz.canviz.idutils.Token.LEGEND_ENTRY, gviz.canviz.idutils.Token.COLOR_BAR, gviz.canviz.idutils.Token.TOOLTIP, gviz.canviz.idutils.Token.ACTIONS_MENU_ENTRY];
// INPUT (javascript/gviz/devel/jsapi/common/tooltip/htmldefiner.js)
gviz.util.tooltip.htmldefiner = {};
gviz.util.tooltip.htmldefiner.createTooltipDefinition = function(body, textMeasureFunction, attachHandle, boundaries, anchor, pivot) {
  return{html:gviz.util.tooltip.htmldefiner.toHtml_(body), customHtml:!1, pivot:pivot, anchor:anchor, boundaries:boundaries, spacing:gviz.util.tooltip.htmldefiner.SPACING, margin:gviz.util.tooltip.definer.DEFAULT_MARGINS};
};
gviz.util.tooltip.htmldefiner.toHtml_ = function(body) {
  if (0 == body.entries.length) {
    return{name:"div", content:[], properties:{className:"google-visualization-tooltip"}};
  }
  goog.asserts.assert(1 >= goog.array.filter(body.entries, function(entry) {
    return entry.type == gviz.util.tooltip.BodyEntryType.SEPARATOR;
  }).length);
  var seperatorIndex = goog.array.findIndex(body.entries, function(entry) {
    return entry.type == gviz.util.tooltip.BodyEntryType.SEPARATOR;
  }), entriesHtml;
  if (-1 == seperatorIndex) {
    entriesHtml = gviz.util.tooltip.htmldefiner.tooltipEntriesToHtml_(body.entries);
  } else {
    var tooltipHtml = gviz.util.tooltip.htmldefiner.tooltipEntriesToHtml_(goog.array.slice(body.entries, 0, seperatorIndex)), seperatorHtml = {name:"div", properties:{className:"google-visualization-tooltip-separator"}}, actionsMenuHtml = gviz.util.tooltip.htmldefiner.actionsMenuEntriesToHtml_(goog.array.slice(body.entries, seperatorIndex + 1));
    entriesHtml = goog.array.concat(tooltipHtml, seperatorHtml, actionsMenuHtml);
  }
  return{name:"div", content:entriesHtml, properties:{className:"google-visualization-tooltip"}};
};
gviz.util.tooltip.htmldefiner.tooltipEntriesToHtml_ = function(tooltipEntries) {
  return{name:"ul", properties:{className:"google-visualization-tooltip-item-list"}, content:goog.array.map(tooltipEntries, function(entry) {
    return{name:"li", content:gviz.util.tooltip.htmldefiner.itemListToHtml_(entry.data), properties:{className:"google-visualization-tooltip-item"}};
  })};
};
gviz.util.tooltip.htmldefiner.actionsMenuEntriesToHtml_ = function(actionsMenuEntries) {
  return{name:"ul", properties:{className:"google-visualization-tooltip-action-list"}, content:goog.array.map(actionsMenuEntries, function(entry) {
    return{name:"li", id:gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.ACTIONS_MENU_ENTRY, entry.data.id]), content:gviz.util.tooltip.htmldefiner.itemListToHtml_(entry.data), properties:{className:"google-visualization-tooltip-action"}};
  })};
};
gviz.util.tooltip.htmldefiner.itemListToHtml_ = function(line) {
  return goog.array.map(line.items, function(item, j) {
    switch(item.type) {
      case gviz.util.tooltip.BodyItemType.TEXT:
        return{name:"span", style:gviz.util.tooltip.htmldefiner.textStyleToHtmlStyle_(item.data.style), rawHtml:!!item.html, content:(0 == j ? "" : " ") + item.data.text};
      case gviz.util.tooltip.BodyItemType.SQUARE:
        return{name:"div", style:"background-color:" + (item.data.brush && item.data.brush.getFill()) + ";", properties:{className:"google-visualization-tooltip-square"}};
    }
  });
};
gviz.util.tooltip.htmldefiner.textStyleToHtmlStyle_ = function(textStyle) {
  return "font-family:" + textStyle.fontName + ";color: #333333;margin:0;font-style:" + (textStyle.italic ? "italic" : "none") + ";text-decoration:" + (textStyle.underline ? "underline" : "none") + ";font-weight:" + (textStyle.bold ? "bold" : "none") + ";";
};
gviz.util.tooltip.htmldefiner.SPACING = 20;
// INPUT (javascript/gviz/devel/jsapi/common/tooltip/tooltipdefiner.js)
gviz.util.tooltip.definer = {};
gviz.util.tooltip.definer.createBodyTextLineEntry = function(text, style, opt_titleText, opt_titleStyle, opt_color, opt_opacity, opt_prefixText, opt_isHtml, opt_id) {
  var data = {items:[]};
  if (goog.isDefAndNotNull(opt_color)) {
    var squareItem = gviz.util.tooltip.definer.createBodySquareItem(style.fontSize / 2, gviz.graphics.Brush.createFillBrush(opt_color, opt_opacity));
    data.items.push(squareItem);
  }
  if (goog.isDefAndNotNull(opt_prefixText)) {
    var prefixTextItem = gviz.util.tooltip.definer.createBodyTextItem(opt_prefixText, style);
    data.items.push(prefixTextItem);
  }
  if (goog.isDefAndNotNull(opt_titleText) && "" !== opt_titleText) {
    if (!goog.isDefAndNotNull(opt_titleStyle)) {
      throw Error("Line title is specified without a text style.");
    }
    var textItem = gviz.util.tooltip.definer.createBodyTextItem(opt_titleText + ":", opt_titleStyle);
    data.items.push(textItem);
  }
  textItem = gviz.util.tooltip.definer.createBodyTextItem(text, style, opt_isHtml);
  data.items.push(textItem);
  goog.isDefAndNotNull(opt_id) && (data.id = opt_id, data.background = {brush:gviz.graphics.Brush.TRANSPARENT_BRUSH});
  return{type:gviz.util.tooltip.BodyEntryType.LINE, data:data};
};
gviz.util.tooltip.definer.createCustomBodyTextLineEntry = function(items) {
  var data = {items:goog.array.map(items, function(item) {
    if (goog.isDefAndNotNull(item.text)) {
      return gviz.util.tooltip.definer.createBodyTextItem(item.text, item.style, item.html);
    }
    throw Error("Unrecognized item.");
  })};
  return{type:gviz.util.tooltip.BodyEntryType.LINE, data:data};
};
gviz.util.tooltip.definer.createBodySeparatorEntry = function() {
  return{type:gviz.util.tooltip.BodyEntryType.SEPARATOR, data:{brush:gviz.graphics.Brush.createStrokeBrush(gviz.util.tooltip.definer.SEPARATOR_COLOR, gviz.util.tooltip.definer.SEPARATOR_WIDTH)}};
};
gviz.util.tooltip.definer.createBodyTextItem = function(text, style, opt_customHtml) {
  var bodyItem = {type:gviz.util.tooltip.BodyItemType.TEXT, data:{text:text, style:style}};
  opt_customHtml && (bodyItem.html = !0);
  return bodyItem;
};
gviz.util.tooltip.definer.createBodySquareItem = function(size, brush) {
  return{type:gviz.util.tooltip.BodyItemType.SQUARE, data:{size:size, brush:brush}};
};
gviz.util.tooltip.definer.createTooltipDefinition = function(body, textMeasureFunction, attachHandle, anchor, boundaries, pivot, opt_defaultBaseUnit, opt_isHtml, opt_rtl) {
  if (opt_isHtml) {
    return gviz.util.tooltip.htmldefiner.createTooltipDefinition(body, textMeasureFunction, attachHandle, boundaries, anchor, pivot);
  }
  var baseUnit = gviz.util.tooltip.definer.calcBaseUnit_(body, opt_defaultBaseUnit), tooltipSize = gviz.util.tooltip.definer.calcTooltipSize_(body, baseUnit, textMeasureFunction), outline = gviz.util.tooltip.definer.calcTooltipOutline_(attachHandle, anchor, tooltipSize, baseUnit, boundaries, pivot), bodyLayout = gviz.util.tooltip.definer.calcTooltipBodyLayout_(outline, body, baseUnit, textMeasureFunction, opt_rtl);
  return{outline:outline, bodyLayout:bodyLayout};
};
gviz.util.tooltip.definer.calcBaseUnit_ = function(body, opt_defaultBaseUnit) {
  for (var fontSize = 0, i = 0;i < body.entries.length;i++) {
    var entry = body.entries[i];
    if (entry.type == gviz.util.tooltip.BodyEntryType.LINE) {
      for (var line = entry.data, j = 0;j < line.items.length;j++) {
        var item = line.items[j];
        item.type == gviz.util.tooltip.BodyItemType.TEXT && (fontSize = Math.max(fontSize, item.data.style.fontSize));
      }
    }
  }
  return 0 == fontSize ? (opt_defaultBaseUnit = opt_defaultBaseUnit || 0, goog.asserts.assertNumber(opt_defaultBaseUnit), opt_defaultBaseUnit) : fontSize;
};
gviz.util.tooltip.definer.calcTooltipSize_ = function(body, baseUnit, textMeasureFunction) {
  for (var width = 0, height = 0, i = 0;i < body.entries.length;i++) {
    var entry = body.entries[i];
    switch(entry.type) {
      case gviz.util.tooltip.BodyEntryType.LINE:
        var line = entry.data, lineSize = gviz.util.tooltip.definer.calcLineSize_(line, textMeasureFunction), height = height + (lineSize.height + (0 < i ? lineSize.topMargin : 0)), width = Math.max(width, lineSize.width);
        break;
      case gviz.util.tooltip.BodyEntryType.SEPARATOR:
        var separator = entry.data, height = height + (1.5 * baseUnit + separator.brush.getStrokeWidth());
        break;
      default:
        goog.asserts.fail('Invalid tooltip entry type "' + entry.type + '"');
    }
  }
  var width = Math.max(width, 2 * baseUnit), totalWidth = Math.round(width + 2 * baseUnit / gviz.canviz.Constants.GOLDEN_RATIO), totalHeight = Math.round(height + 2 * baseUnit / gviz.canviz.Constants.GOLDEN_RATIO);
  return new goog.math.Size(totalWidth, totalHeight);
};
gviz.util.tooltip.definer.calcLineSize_ = function(line, textMeasureFunction) {
  for (var width = 0, height = 0, marginHelper = 0, i = 0;i < line.items.length;i++) {
    var item = line.items[i], itemSize = gviz.util.tooltip.definer.calcItemSize_(item, textMeasureFunction), width = width + (itemSize.width + (0 < i ? itemSize.leftMargin : 0)), height = Math.max(height, itemSize.height), marginHelper = Math.max(marginHelper, itemSize.height / 2 + itemSize.topMargin)
  }
  var topMargin = marginHelper - height / 2;
  return{width:width, height:height, topMargin:topMargin};
};
gviz.util.tooltip.definer.calcItemSize_ = function(item, textMeasureFunction) {
  switch(item.type) {
    case gviz.util.tooltip.BodyItemType.TEXT:
      return gviz.util.tooltip.definer.calcTextItemSize_(item.data.text, item.data.style, textMeasureFunction);
    case gviz.util.tooltip.BodyItemType.SQUARE:
      var size = item.data.size, margin = size;
      return{width:size, height:size, topMargin:margin, leftMargin:margin};
    default:
      return goog.asserts.fail('Invalid tooltip item type "' + item.type + '"'), margin = size = item.data.size, {width:size, height:size, topMargin:margin, leftMargin:margin};
  }
};
gviz.util.tooltip.definer.calcTextItemSize_ = function(text, style, textMeasureFunction) {
  return{width:textMeasureFunction ? textMeasureFunction(String(text), style).width : 0, height:style.fontSize, topMargin:style.fontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO), leftMargin:style.fontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO)};
};
gviz.util.tooltip.definer.calcTooltipBodyLayout_ = function(outline, body, baseUnit, textMeasureFunction, opt_rtl) {
  var bodyLayout = {}, outlineInnerMargin = baseUnit / gviz.canviz.Constants.GOLDEN_RATIO, bodyBoundingBox = new goog.math.Box(outline.box.top + outlineInnerMargin, outline.box.right - outlineInnerMargin, outline.box.bottom - outlineInnerMargin, outline.box.left + outlineInnerMargin), entriesLayout = [], entryTop = bodyBoundingBox.top, entryIndex, entriesLen = body.entries.length, alignColumns = !1;
  for (entryIndex = 0;entryIndex < entriesLen;entryIndex++) {
    if (body.entries[entryIndex].alignColumns) {
      alignColumns = !0;
      break;
    }
  }
  var maximumItemsWidthInColumn = [], itemSizeMatrix = [];
  for (entryIndex = 0;entryIndex < entriesLen;entryIndex++) {
    var entry = body.entries[entryIndex];
    if (entry.type === gviz.util.tooltip.BodyEntryType.LINE) {
      var line = entry.data, lineItemsSize = [];
      itemSizeMatrix.push(lineItemsSize);
      for (var itemIndex = 0, lenItems = line.items.length;itemIndex < lenItems;itemIndex++) {
        var item = line.items[itemIndex], itemSize = gviz.util.tooltip.definer.calcItemSize_(item, textMeasureFunction);
        lineItemsSize.push(itemSize);
        if (entry.alignColumns) {
          if (itemIndex > maximumItemsWidthInColumn.length - 1) {
            maximumItemsWidthInColumn.push(itemSize.width);
          } else {
            var oldItemWidth = maximumItemsWidthInColumn[itemIndex];
            maximumItemsWidthInColumn[itemIndex] = Math.max(oldItemWidth, itemSize.width);
          }
        }
      }
    }
  }
  var lineWidthMargin = [], itemWidthMargin = [], lineIndex = 0;
  if (alignColumns) {
    for (entryIndex = 0;entryIndex < entriesLen;entryIndex++) {
      if (entry = body.entries[entryIndex], entry.type == gviz.util.tooltip.BodyEntryType.LINE) {
        var lineItemsMargin = [];
        itemWidthMargin.push(lineItemsMargin);
        var sumOfItemsMargins = 0;
        if (entry.alignColumns) {
          for (line = entry.data, itemIndex = 0, lenItems = line.items.length;itemIndex < lenItems;itemIndex++) {
            var itemSize = itemSizeMatrix[lineIndex][itemIndex], maximumItemWidth = maximumItemsWidthInColumn[itemIndex], margin = maximumItemWidth - itemSize.width;
            lineItemsMargin.push(margin);
            sumOfItemsMargins += margin;
          }
        }
        lineWidthMargin.push(sumOfItemsMargins);
        lineIndex++;
      }
    }
  }
  for (entryIndex = lineIndex = 0;entryIndex < entriesLen;entryIndex++) {
    var entry = body.entries[entryIndex], entryLayout = {entry:entry, data:{}};
    switch(entry.type) {
      case gviz.util.tooltip.BodyEntryType.LINE:
        var line = entry.data, lineLayout = entryLayout.data, lineSize = gviz.util.tooltip.definer.calcLineSize_(line, textMeasureFunction);
        entry.alignColumns && (lineSize.width += lineWidthMargin[lineIndex]);
        var lineTop = entryTop;
        0 < entryIndex && (lineTop += lineSize.topMargin);
        line.background && (lineLayout.background = {box:new goog.math.Box(lineTop - lineSize.topMargin / 2, outline.box.right, lineTop + lineSize.height + lineSize.topMargin, outline.box.left)});
        for (var itemsLayout = [], itemLeft = bodyBoundingBox.left, itemIndex = 0, lenItems = line.items.length;itemIndex < lenItems;itemIndex++) {
          var itemLayout = {}, itemSize = itemSizeMatrix[lineIndex][itemIndex];
          entry.alignColumns && (itemSize.width += itemWidthMargin[lineIndex][itemIndex]);
          0 < itemIndex && (itemLeft += itemSize.leftMargin);
          var itemTop = lineTop + (lineSize.height - itemSize.height) / 2;
          itemLayout.box = new goog.math.Box(Math.round(itemTop), Math.round(itemLeft + itemSize.width), Math.round(itemTop + itemSize.height), Math.round(itemLeft));
          if (opt_rtl) {
            var textXOffset = itemLayout.box.left - bodyBoundingBox.left, targetX = bodyBoundingBox.right - textXOffset, xDiff = targetX - itemLayout.box.left - itemSize.width;
            itemLayout.box.left += xDiff;
            itemLayout.box.right += xDiff;
          }
          itemsLayout.push(itemLayout);
          itemLeft += itemSize.width;
        }
        lineLayout.items = itemsLayout;
        entryTop = lineTop + lineSize.height;
        lineIndex++;
        break;
      case gviz.util.tooltip.BodyEntryType.SEPARATOR:
        var separator = entry.data, separatorLayout = entryLayout.data, separatorY = entryTop + baseUnit + separator.brush.getStrokeWidth() / 2;
        separatorLayout.line = new goog.math.Line(outline.box.left, separatorY, outline.box.right, separatorY);
        entryTop += 1.5 * baseUnit + separator.brush.getStrokeWidth() / 2;
        break;
      default:
        goog.asserts.fail('Invalid tooltip entry type "' + entry.type + '"');
    }
    entriesLayout.push(entryLayout);
  }
  bodyLayout.entries = entriesLayout;
  bodyLayout.rtl = !!opt_rtl;
  return bodyLayout;
};
gviz.util.tooltip.definer.calcTooltipOutline_ = function(attachHandle, anchor, tooltipSize, baseUnit, boundaries, pivot) {
  var hDirection = goog.math.sign(anchor.x - pivot.x), vDirection = goog.math.sign(anchor.y - pivot.y), center = null, center = attachHandle ? new goog.math.Coordinate(anchor.x + hDirection * baseUnit, anchor.y + vDirection * (baseUnit + tooltipSize.height / 2)) : new goog.math.Coordinate(anchor.x + hDirection * tooltipSize.width / 2, anchor.y + vDirection * tooltipSize.height / 2), left = center.x - tooltipSize.width / 2, right = left + tooltipSize.width, top = center.y - tooltipSize.height / 2, 
  bottom = top + tooltipSize.height, outline = {};
  if (attachHandle) {
    var closePoint = new goog.math.Coordinate(center.x, goog.math.lerp(anchor.y, center.y, baseUnit / (baseUnit + tooltipSize.height / 2))), farPoint = new goog.math.Coordinate(goog.math.lerp(center.x, anchor.x, -1), closePoint.y);
    closePoint.x = Math.round(closePoint.x);
    closePoint.y = Math.round(closePoint.y);
    farPoint.x = Math.round(farPoint.x);
    farPoint.y = Math.round(farPoint.y);
    outline.handlePoints = 1 == hDirection * vDirection ? [closePoint, anchor, farPoint] : [farPoint, anchor, closePoint];
  }
  outline.box = new goog.math.Box(Math.round(top), Math.round(right), Math.round(bottom), Math.round(left));
  gviz.util.tooltip.definer.adjustTooltipHorizontally_(outline, boundaries, pivot);
  gviz.util.tooltip.definer.adjustTooltipVertically_(outline, boundaries, pivot);
  return outline;
};
gviz.util.tooltip.definer.adjustTooltipHorizontally_ = function(outline, boundaries, pivot) {
  var DEFAULT_MARGINS = gviz.util.tooltip.definer.DEFAULT_MARGINS, leftBoundary = boundaries.left + DEFAULT_MARGINS, rightBoundary = boundaries.right - DEFAULT_MARGINS;
  if (!(outline.box.left >= leftBoundary && outline.box.right <= rightBoundary)) {
    var flipped = goog.object.unsafeClone(outline);
    gviz.util.tooltip.definer.flipTooltipHorizontally_(flipped, pivot);
    if (flipped.box.left >= leftBoundary && flipped.box.right <= rightBoundary) {
      outline.box = flipped.box, outline.handlePoints = flipped.handlePoints;
    } else {
      if (outline.handlePoints) {
        var CORNER_RADIUS = gviz.util.tooltip.definer.CORNER_RADIUS, handleBoundaries = new goog.math.Range(leftBoundary + CORNER_RADIUS, rightBoundary - CORNER_RADIUS), handleRange = new goog.math.Range(outline.handlePoints[0].x, outline.handlePoints[2].x), flippedHandleRange = new goog.math.Range(flipped.handlePoints[0].x, flipped.handlePoints[2].x);
        !goog.math.Range.contains(handleBoundaries, handleRange) && goog.math.Range.contains(handleBoundaries, flippedHandleRange) && (outline.box = flipped.box, outline.handlePoints = flipped.handlePoints);
      }
      outline.box.right > rightBoundary && (outline.box.left -= outline.box.right - rightBoundary, outline.box.right = rightBoundary);
      outline.box.left < leftBoundary && (outline.box.right += leftBoundary - outline.box.left, outline.box.left = leftBoundary);
    }
  }
};
gviz.util.tooltip.definer.adjustTooltipVertically_ = function(outline, boundaries, pivot) {
  var DEFAULT_MARGINS = gviz.util.tooltip.definer.DEFAULT_MARGINS, topBoundary = boundaries.top + DEFAULT_MARGINS, bottomBoundary = boundaries.bottom - DEFAULT_MARGINS;
  if (!(outline.box.top >= topBoundary && outline.box.bottom <= bottomBoundary)) {
    var flipped = goog.object.unsafeClone(outline);
    gviz.util.tooltip.definer.flipTooltipVertically_(flipped, pivot);
    flipped.box.top >= topBoundary && flipped.box.bottom <= bottomBoundary ? (outline.box = flipped.box, outline.handlePoints = flipped.handlePoints) : (outline.box.bottom > bottomBoundary && (outline.box.top -= outline.box.bottom - bottomBoundary, outline.box.bottom = bottomBoundary), outline.box.top < topBoundary && (outline.box.bottom += topBoundary - outline.box.top, outline.box.top = topBoundary), delete outline.handlePoints);
  }
};
gviz.util.tooltip.definer.flipTooltipHorizontally_ = function(outline, pivot) {
  var originalLeft = outline.box.left;
  outline.box.left = goog.math.lerp(pivot.x, outline.box.right, -1);
  outline.box.right = goog.math.lerp(pivot.x, originalLeft, -1);
  var handlePoints = outline.handlePoints;
  if (handlePoints) {
    var tmp = handlePoints[0];
    handlePoints[0] = handlePoints[2];
    handlePoints[2] = tmp;
    handlePoints[0].x = goog.math.lerp(pivot.x, handlePoints[0].x, -1);
    handlePoints[1].x = goog.math.lerp(pivot.x, handlePoints[1].x, -1);
    handlePoints[2].x = goog.math.lerp(pivot.x, handlePoints[2].x, -1);
  }
};
gviz.util.tooltip.definer.flipTooltipVertically_ = function(outline, pivot) {
  var originalTop = outline.box.top;
  outline.box.top = goog.math.lerp(pivot.y, outline.box.bottom, -1);
  outline.box.bottom = goog.math.lerp(pivot.y, originalTop, -1);
  var handlePoints = outline.handlePoints;
  if (handlePoints) {
    var tmp = handlePoints[0];
    handlePoints[0] = handlePoints[2];
    handlePoints[2] = tmp;
    handlePoints[0].y = goog.math.lerp(pivot.y, handlePoints[0].y, -1);
    handlePoints[1].y = goog.math.lerp(pivot.y, handlePoints[1].y, -1);
    handlePoints[2].y = goog.math.lerp(pivot.y, handlePoints[2].y, -1);
  }
};
gviz.util.tooltip.definer.CORNER_RADIUS = 4;
gviz.util.tooltip.definer.DEFAULT_MARGINS = 5;
gviz.util.tooltip.definer.SEPARATOR_COLOR = "#eee";
gviz.util.tooltip.definer.SEPARATOR_WIDTH = 1;
// INPUT (javascript/gviz/devel/canviz/scheduler.js)
gviz.canviz.Scheduler = function(callback) {
  goog.Disposable.call(this);
  this.callback_ = callback;
  this.countdown_ = Infinity;
  this.last_ = 0;
  var timer = new goog.Timer(15);
  this.registerDisposable(timer);
  goog.events.listen(timer, goog.Timer.TICK, goog.bind(this.tick_, this));
  this.timer_ = timer;
};
goog.inherits(gviz.canviz.Scheduler, goog.Disposable);
gviz.canviz.Scheduler.prototype.updateCountdown = function(countdown) {
  var oldCountdown = this.countdown_;
  this.countdown_ = Math.min(this.countdown_, countdown);
  goog.math.isFiniteNumber(this.countdown_) ? goog.math.isFiniteNumber(oldCountdown) || this.timer_.start() : this.timer_.stop();
};
gviz.canviz.Scheduler.prototype.stopCountdown = function() {
  this.countdown_ = Infinity;
  this.timer_.stop();
};
gviz.canviz.Scheduler.prototype.tick_ = function() {
  var now = goog.now();
  this.countdown_ -= now - this.last_;
  this.last_ = now;
  0 >= this.countdown_ && (this.callback_(), this.countdown_ = Infinity, this.timer_.stop());
};
// INPUT (javascript/gviz/devel/jsapi/common/i18n/break-iterator-interface.js)
gviz.i18n.BreakIteratorInterface = function() {
};
gviz.i18n.BreakIteratorInterface.prototype.adoptText = function() {
};
gviz.i18n.BreakIteratorInterface.prototype.first = function() {
};
gviz.i18n.BreakIteratorInterface.prototype.current = function() {
};
gviz.i18n.BreakIteratorInterface.prototype.next = function() {
};
gviz.i18n.BreakIteratorInterface.prototype.peek = function() {
};
// INPUT (javascript/gviz/devel/jsapi/common/i18n/manual-break-iterator.js)
gviz.i18n.ManualBreakIterator = function() {
  this.cursor_ = this.text_ = null;
};
gviz.i18n.ManualBreakIterator.prototype.adoptText = function(text) {
  this.text_ = text;
};
gviz.i18n.ManualBreakIterator.prototype.first = function() {
  return this.cursor_ = 0;
};
gviz.i18n.ManualBreakIterator.prototype.current = function() {
  return this.cursor_ || 0;
};
gviz.i18n.ManualBreakIterator.prototype.next = function(level) {
  var next = this.peek(level);
  return null == next ? next : this.cursor_ = next;
};
gviz.i18n.ManualBreakIterator.prototype.findNextRegexp_ = function(re) {
  goog.asserts.assert(re.global);
  goog.asserts.assert(!goog.isNull(this.cursor_));
  goog.asserts.assert(!goog.isNull(this.text_));
  re.lastIndex = this.cursor_;
  var result = re.exec(this.text_);
  return!result || 0 > result.index ? this.text_.length : result.index + result[0].length;
};
gviz.i18n.ManualBreakIterator.prototype.findNextHardBreak_ = function() {
  return this.findNextRegexp_(/(\r\n|\n|\r)/g);
};
gviz.i18n.ManualBreakIterator.prototype.findNextSoftBreak_ = function() {
  return this.findNextRegexp_(/([`~!@#$%^&*()_+\-=\[\]\\{}|;\':",\.\/<>?]|[ \t\u2009\u200b]+)/g);
};
gviz.i18n.ManualBreakIterator.prototype.findNextMidwordBreak_ = function() {
  return this.findNextRegexp_(/[\u00ad]/g);
};
gviz.i18n.ManualBreakIterator.prototype.findNextCharacterBreak_ = function() {
  for (var i = this.cursor_ + 1, leni = this.text_.length;i < leni;i++) {
    if (goog.i18n.GraphemeBreak.hasGraphemeBreak(this.text_.charCodeAt(i - 1), this.text_.charCodeAt(i))) {
      return i;
    }
  }
  return this.text_.length;
};
gviz.i18n.ManualBreakIterator.prototype.peek = function(level) {
  goog.asserts.assert(!goog.isNull(this.text_));
  goog.asserts.assert(!goog.isNull(this.cursor_));
  return level === gviz.i18n.constants.HARD_LINE_BREAK ? this.findNextHardBreak_() : level === gviz.i18n.constants.SOFT_LINE_BREAK ? this.findNextSoftBreak_() : level === gviz.i18n.constants.MIDWORD_BREAK ? this.findNextMidwordBreak_() : level === gviz.i18n.constants.CHARACTER_BREAK ? this.findNextCharacterBreak_() : this.text_.length;
};
// INPUT (javascript/gviz/devel/jsapi/common/i18n/constants.js)
gviz.i18n.constants = {};
gviz.i18n.constants.SOFT_HYPHEN = "\u00ad";
gviz.i18n.constants.ELLIPSES = "\u2026";
gviz.i18n.constants.HARD_LINE_BREAK = 0;
gviz.i18n.constants.SOFT_LINE_BREAK = 1;
gviz.i18n.constants.MIDWORD_BREAK = 2;
gviz.i18n.constants.CHARACTER_BREAK = 3;
// INPUT (javascript/gviz/devel/jsapi/common/i18n/level-classifier.js)
gviz.i18n.LevelClassifier = function() {
  this.levelMap_ = {};
};
gviz.i18n.LevelClassifier.prototype.add = function(iteratorType, breakType, level, opt_classifier) {
  goog.asserts.assert(opt_classifier && goog.isArray(level) || !opt_classifier && !goog.isArray(level));
  null == breakType ? this.levelMap_[iteratorType] = opt_classifier ? {classifier:opt_classifier, levels:level} : level : (iteratorType in this.levelMap_ || (this.levelMap_[iteratorType] = {}), this.levelMap_[iteratorType][breakType] = opt_classifier ? {classifier:opt_classifier, levels:level} : level);
};
gviz.i18n.LevelClassifier.prototype.iteratorTypes = function(opt_level) {
  if (null == opt_level) {
    return Object.keys(this.levelMap_);
  }
  var level = opt_level, iteratorTypes = [], iteratorType;
  for (iteratorType in this.levelMap_) {
    var iteratorClassifications = this.levelMap_[iteratorType];
    if ("number" === typeof iteratorClassifications) {
      iteratorClassifications === level && iteratorTypes.push(iteratorType);
    } else {
      if (iteratorClassifications.classifier) {
        0 <= iteratorClassifications.levels.indexOf(level) && iteratorTypes.push(iteratorType);
      } else {
        for (var breakType in iteratorClassifications) {
          var classification = iteratorClassifications[breakType];
          if ("number" === typeof classification) {
            classification === level && iteratorTypes.push(iteratorType);
          } else {
            if (classification.classifier) {
              0 <= classification.levels.indexOf(level) && iteratorTypes.push(iteratorType);
            } else {
              throw "Unknown type";
            }
          }
        }
      }
    }
  }
  return iteratorTypes;
};
gviz.i18n.LevelClassifier.prototype.classify = function(iteratorType, breakType, position) {
  if (!(iteratorType in this.levelMap_)) {
    throw "Error: unknown iterator type " + iteratorType;
  }
  var iteratorClassifications = this.levelMap_[iteratorType];
  if ("number" === typeof iteratorClassifications) {
    return iteratorClassifications;
  }
  if (iteratorClassifications.classifier) {
    return iteratorClassifications.classifier(position);
  }
  if (breakType in iteratorClassifications) {
    iteratorClassifications = iteratorClassifications[breakType];
    if ("number" === typeof iteratorClassifications) {
      return iteratorClassifications;
    }
    if (iteratorClassifications.classifier) {
      return iteratorClassifications.classifier(position);
    }
  }
  return null;
};
// INPUT (javascript/gviz/devel/jsapi/common/i18n/wrapped-v8-break-iterator.js)
gviz.i18n.WrappedV8BreakIterator = function(opt_locales) {
  this.locales_ = opt_locales;
  this.iterators_ = {};
  this.classifier_ = new gviz.i18n.LevelClassifier;
  this.pending_ = {};
  this.text_ = this.cursor_ = null;
  this.classify("line", "number", gviz.i18n.constants.HARD_LINE_BREAK);
  this.classify("line", "none", [gviz.i18n.constants.SOFT_LINE_BREAK, gviz.i18n.constants.MIDWORD_BREAK], goog.bind(function(position) {
    return this.text_[position - 1] === gviz.i18n.constants.SOFT_HYPHEN ? gviz.i18n.constants.MIDWORD_BREAK : gviz.i18n.constants.SOFT_LINE_BREAK;
  }, this));
  this.classify("character", null, gviz.i18n.constants.CHARACTER_BREAK);
};
gviz.i18n.WrappedV8BreakIterator.prototype.adoptText = function(text) {
  this.text_ = text;
  for (var iteratorType in this.iterators_) {
    this.iterators_[iteratorType].adoptText(text);
  }
};
gviz.i18n.WrappedV8BreakIterator.prototype.getIterator_ = function(iteratorType) {
  var iterator = this.iterators_[iteratorType];
  iterator || (iterator = this.iterators_[iteratorType] = new window.Intl.v8BreakIterator(this.locales_, {type:iteratorType}), null != this.text_ && iterator.adoptText(this.text_), null != this.cursor_ && iterator.first());
  return iterator;
};
gviz.i18n.WrappedV8BreakIterator.prototype.classify = function(iteratorType, breakType, level_or_levels, opt_classifier) {
  this.classifier_.add(iteratorType, breakType, level_or_levels, opt_classifier);
};
gviz.i18n.WrappedV8BreakIterator.prototype.getIteratorTypes_ = function(opt_level) {
  return this.classifier_.iteratorTypes(opt_level);
};
gviz.i18n.WrappedV8BreakIterator.prototype.addPending_ = function(iteratorType, breakType, position) {
  var breakLevel = this.classifier_.classify(iteratorType, breakType, position);
  if (null == breakLevel) {
    throw Error("Break type " + breakType + " in " + iteratorType + " iterator was classified as null.");
  }
  breakLevel in this.pending_ || (this.pending_[breakLevel] = []);
  this.pending_[breakLevel].push(position);
};
gviz.i18n.WrappedV8BreakIterator.prototype.advanceIterator_ = function(iteratorType, iterator) {
  iterator.next();
  if (iterator.current() >= this.text_.length) {
    return!0;
  }
  iterator.current() > this.cursor_ && this.addPending_(iteratorType, iterator.breakType(), iterator.current());
  return!1;
};
gviz.i18n.WrappedV8BreakIterator.prototype.advanceUntilPosition_ = function(position) {
  for (var iteratorType in this.iterators_) {
    for (var iterator = this.getIterator_(iteratorType);iterator.current() <= position;) {
      this.advanceIterator_(iteratorType, iterator);
    }
  }
};
gviz.i18n.WrappedV8BreakIterator.prototype.advanceUntilNextLevel_ = function(level) {
  for (var pending = this.pending_[level];pending && 0 < pending.length && pending[0] <= this.cursor_;) {
    pending.shift();
  }
  for (var iterators = this.getIteratorTypes_(level), finishedIterators = {}, endLoop = !1;!(endLoop || this.pending_[level] && 0 !== this.pending_[level].length);) {
    for (var endLoop = !0, i = 0, leni = iterators.length;i < leni;i++) {
      var iteratorType = iterators[i], iterator = this.getIterator_(iteratorType);
      finishedIterators[iteratorType] || (endLoop = !1, this.advanceIterator_(iteratorType, iterator) && (finishedIterators[iteratorType] = !0));
    }
  }
};
gviz.i18n.WrappedV8BreakIterator.prototype.first = function() {
  for (var iteratorTypes = this.getIteratorTypes_(), i = 0, leni = iteratorTypes.length;i < leni;i++) {
    this.getIterator_(iteratorTypes[i]).first();
  }
  this.pending_ = {};
  return this.cursor_ = 0;
};
gviz.i18n.WrappedV8BreakIterator.prototype.current = function() {
  return this.cursor_ || 0;
};
gviz.i18n.WrappedV8BreakIterator.prototype.next = function(level) {
  this.advanceUntilNextLevel_(level);
  var pending = this.pending_[level];
  return null != pending && 0 < pending.length ? (this.cursor_ = pending.shift(), this.advanceUntilPosition_(this.cursor_), this.cursor_) : this.text_.length;
};
gviz.i18n.WrappedV8BreakIterator.prototype.peek = function(level) {
  this.advanceUntilNextLevel_(level);
  var pending = this.pending_[level];
  return null != pending && 0 < pending.length ? pending[0] : this.text_.length;
};
// INPUT (javascript/gviz/devel/jsapi/common/i18n/break-iterator-factory.js)
gviz.i18n.BreakIteratorFactory = function() {
  this.v8BreakIteratorAvailable_ = window.Intl && !!window.Intl.v8BreakIterator;
};
goog.addSingletonGetter(gviz.i18n.BreakIteratorFactory);
gviz.i18n.BreakIteratorFactory.prototype.getBreakIterator = function(opt_locales) {
  return this.v8BreakIteratorAvailable_ ? new gviz.i18n.WrappedV8BreakIterator(opt_locales) : new gviz.i18n.ManualBreakIterator;
};
// INPUT (javascript/gviz/devel/jsapi/common/nightingale/layout/property-metrics.js)
gviz.nightingale.layout = {};
gviz.nightingale.layout.PropertyMetrics = function() {
  this.height_ = this.width_ = this.bottom_ = this.top_ = this.right_ = this.left_ = 0;
};
gviz.nightingale.layout.PropertyMetrics.prototype.updateWidth_ = function() {
  this.width_ = this.left_ + this.right_;
};
gviz.nightingale.layout.PropertyMetrics.prototype.updateHeight_ = function() {
  this.height_ = this.top_ + this.bottom_;
};
gviz.nightingale.layout.PropertyMetrics.prototype.left = function() {
  return this.left_;
};
gviz.nightingale.layout.PropertyMetrics.prototype.top = function() {
  return this.top_;
};
gviz.nightingale.layout.PropertyMetrics.prototype.right = function() {
  return this.right_;
};
gviz.nightingale.layout.PropertyMetrics.prototype.bottom = function() {
  return this.bottom_;
};
gviz.nightingale.layout.PropertyMetrics.prototype.setLeft = function(value) {
  this.left_ = value;
  this.updateWidth_();
  return this;
};
gviz.nightingale.layout.PropertyMetrics.prototype.setTop = function(value) {
  this.top_ = value;
  this.updateHeight_();
  return this;
};
gviz.nightingale.layout.PropertyMetrics.prototype.setRight = function(value) {
  this.right_ = value;
  this.updateWidth_();
  return this;
};
gviz.nightingale.layout.PropertyMetrics.prototype.setBottom = function(value) {
  this.bottom_ = value;
  this.updateHeight_();
  return this;
};
gviz.nightingale.layout.PropertyMetrics.prototype.width = function() {
  return this.width_;
};
gviz.nightingale.layout.PropertyMetrics.prototype.height = function() {
  return this.height_;
};
// INPUT (javascript/gviz/devel/jsapi/common/nightingale/layout/definitions.js)
// INPUT (javascript/gviz/devel/jsapi/common/nightingale/layout/positioned-element.js)
gviz.nightingale.layout.PositionedElement = function(element, metrics, children, left, top, width, height, extra, properties) {
  this.element_ = element;
  this.metrics_ = metrics;
  this.children_ = children;
  this.left_ = left;
  this.top_ = top;
  this.width_ = width;
  this.height_ = height;
  this.extra_ = extra;
  this.properties_ = properties;
};
gviz.nightingale.layout.PositionedElement.prototype.properties = function() {
  return this.properties_;
};
gviz.nightingale.layout.PositionedElement.prototype.property = function(name) {
  return this.properties_[name];
};
gviz.nightingale.layout.PositionedElement.prototype.element = function() {
  return this.element_;
};
gviz.nightingale.layout.PositionedElement.prototype.metrics = function() {
  return this.metrics_;
};
gviz.nightingale.layout.PositionedElement.prototype.children = function() {
  return this.children_;
};
gviz.nightingale.layout.PositionedElement.prototype.left = function() {
  return this.left_;
};
gviz.nightingale.layout.PositionedElement.prototype.top = function() {
  return this.top_;
};
gviz.nightingale.layout.PositionedElement.prototype.width = function() {
  return this.width_;
};
gviz.nightingale.layout.PositionedElement.prototype.height = function() {
  return this.height_;
};
gviz.nightingale.layout.PositionedElement.prototype.extra = function() {
  return this.extra_;
};
gviz.nightingale.layout.PositionedElement.prototype.rect = function() {
  return new goog.math.Rect(this.left_, this.top_, this.width_, this.height_);
};
gviz.nightingale.layout.PositionedElement.prototype.box = function() {
  return new goog.math.Box(this.top_, this.left_ + this.width_, this.top_ + this.height_, this.left_);
};
// INPUT (javascript/gviz/devel/jsapi/common/nightingale/layout/util.js)
gviz.nightingale.layout.util = {};
gviz.nightingale.layout.util.calculateRequestedSize = function(metricsSize, layoutSize, minSize, maxSize) {
  var requestedSize = metricsSize;
  (null == requestedSize || !goog.math.isFiniteNumber(requestedSize) || requestedSize > maxSize) && layoutSize > maxSize && (requestedSize = maxSize);
  (null == requestedSize || !goog.math.isFiniteNumber(requestedSize) || requestedSize < minSize) && layoutSize < minSize && (requestedSize = minSize);
  return requestedSize;
};
gviz.nightingale.layout.util.flattenStyle_ = function(object, prefix, target, opt_concatenationToken) {
  var concatenationToken = null == opt_concatenationToken ? "." : opt_concatenationToken, key;
  for (key in object) {
    if (object.hasOwnProperty(key)) {
      if (object[key] instanceof Object && !(object[key] instanceof Array)) {
        gviz.nightingale.layout.util.flattenStyle_(object[key], prefix.concat(key), target, concatenationToken);
      } else {
        var concatenatedKey = prefix.concat(key).join(concatenationToken);
        target.hasOwnProperty(concatenatedKey) || (target[concatenatedKey] = object[key]);
      }
    }
  }
};
gviz.nightingale.layout.util.flattenStyle = function(object, opt_concatenationToken) {
  var target = {};
  gviz.nightingale.layout.util.flattenStyle_(object, [], target, opt_concatenationToken);
  return target;
};
gviz.nightingale.layout.util.determineNextBreakLevel_ = function(measureText, partialText, breakIterator, lastBreak, width, opt_dontBreakWords) {
  for (var shortestLevel = null, maxBreakLevel = opt_dontBreakWords ? gviz.i18n.constants.MIDWORD_BREAK : gviz.i18n.constants.CHARACTER_BREAK, breakLevel = 0;breakLevel <= maxBreakLevel;breakLevel++) {
    var potentialNextBreak = breakIterator.peek(breakLevel);
    if (null == shortestLevel || potentialNextBreak < shortestLevel.position) {
      shortestLevel = {position:potentialNextBreak, level:breakLevel};
    }
    if (measureText(partialText(lastBreak, potentialNextBreak)) <= width) {
      return breakLevel;
    }
  }
  return shortestLevel && shortestLevel.level || maxBreakLevel;
};
gviz.nightingale.layout.util.generatePartialTextFunction_ = function(text) {
  return function(start, end) {
    var slicedText = goog.string.trim(text.slice(start, end));
    slicedText[slicedText.length - 1] === gviz.i18n.constants.SOFT_HYPHEN && (slicedText = slicedText.slice(0, slicedText.length - 1) + "-");
    return slicedText;
  };
};
gviz.nightingale.layout.util.getTruncatedText_ = function(text, opt_length) {
  var length = null == opt_length ? text.length : opt_length;
  return 0 <= length ? goog.string.trim(text.slice(0, length)) + gviz.i18n.constants.ELLIPSES : "...".slice(0, length);
};
gviz.nightingale.layout.util.truncateText_ = function(measureText, text, width, opt_requireOneChar) {
  var getTruncatedText = gviz.nightingale.layout.util.getTruncatedText_;
  if (measureText(getTruncatedText(text)) <= width) {
    return getTruncatedText(text);
  }
  var breakIterator = gviz.i18n.BreakIteratorFactory.getInstance().getBreakIterator([goog.LOCALE]);
  breakIterator.adoptText(text);
  breakIterator.first();
  var nextBreak = breakIterator.next(gviz.i18n.constants.CHARACTER_BREAK), firstCharFits = measureText(text.slice(0, nextBreak)) <= width;
  if (opt_requireOneChar && !firstCharFits || !opt_requireOneChar && measureText(getTruncatedText(text, nextBreak)) > width) {
    for (var i = 0;-3 <= i && !(text = getTruncatedText(text, i), measureText(text) <= width);i--) {
    }
  } else {
    for (;measureText(getTruncatedText(text, breakIterator.peek(gviz.i18n.constants.CHARACTER_BREAK))) <= width;) {
      nextBreak = breakIterator.next(gviz.i18n.constants.CHARACTER_BREAK);
    }
    if (opt_requireOneChar && measureText(getTruncatedText(text, nextBreak)) > width) {
      for (var partialText = text.slice(0, nextBreak), i = 0;-3 <= i && !(text = partialText + getTruncatedText(text, i), measureText(text) <= width);i--) {
      }
    } else {
      text = getTruncatedText(text, nextBreak);
    }
  }
  return text;
};
gviz.nightingale.layout.util.breakLines_ = function(measureText, text$$0, style, width, maxLines, opt_options) {
  if ("" === text$$0) {
    return{lines:[], truncated:!1};
  }
  var options = {truncate:null == opt_options || null == opt_options.truncate ? !0 : opt_options.truncate, requireOneChar:null == opt_options || null == opt_options.requireOneChar ? !1 : opt_options.requireOneChar, dontBreakWords:null == opt_options || null == opt_options.dontBreakWords ? !1 : opt_options.dontBreakWords}, originalMeasureText = measureText;
  measureText = function(text) {
    return originalMeasureText(text, style).width;
  };
  var breakIterator = gviz.i18n.BreakIteratorFactory.getInstance().getBreakIterator([goog.LOCALE]);
  breakIterator.adoptText(text$$0);
  breakIterator.first();
  for (var wasTruncated = !1, partialText = gviz.nightingale.layout.util.generatePartialTextFunction_(text$$0), needsTruncation = !1, lines = [], lastBreak = 0;;) {
    var nextBreakLevel = gviz.nightingale.layout.util.determineNextBreakLevel_(measureText, partialText, breakIterator, lastBreak, width, options.dontBreakWords), nextBreak = breakIterator.next(nextBreakLevel);
    if (nextBreakLevel !== gviz.i18n.constants.HARD_LINE_BREAK) {
      for (;nextBreak < text$$0.length && measureText(partialText(lastBreak, breakIterator.peek(nextBreakLevel))) <= width;) {
        nextBreak = breakIterator.next(nextBreakLevel);
      }
    }
    lines.push(partialText(lastBreak, nextBreak));
    var lineFits = measureText(lines[lines.length - 1]) <= width;
    if (nextBreak >= text$$0.length || lines.length >= maxLines || !lineFits) {
      (nextBreak < text$$0.length || !lineFits) && options.truncate ? (nextBreakLevel !== gviz.i18n.constants.HARD_LINE_BREAK && (lines[lines.length - 1] = partialText(lastBreak, breakIterator.peek(nextBreakLevel))), needsTruncation = !0) : lines.length < maxLines && nextBreak < text$$0.length && (wasTruncated = !0);
      break;
    }
    lastBreak = nextBreak;
  }
  needsTruncation && (lines[lines.length - 1] = gviz.nightingale.layout.util.truncateText_(measureText, lines[lines.length - 1], width, options.requireOneChar && 1 === lines.length), wasTruncated = !0);
  1 === lines.length && "" === lines[0] && (lines = []);
  return{lines:lines, truncated:wasTruncated};
};
gviz.nightingale.layout.util.breakLines = goog.memoize(gviz.nightingale.layout.util.breakLines_, function(functionUuid, args) {
  for (var argArray = [functionUuid], i = 1, leni = args.length;i < leni;i++) {
    argArray.push(args[i]);
  }
  return goog.json.serialize(argArray);
});
gviz.nightingale.layout.util.walk = function(layout, func, opt_this) {
  for (var stack = [{layout:layout, parent:null}];0 < stack.length;) {
    var item = stack.shift();
    if (!1 === func.call(opt_this, item.layout, item.parent)) {
      break;
    }
    goog.array.forEach(item.layout.children(), function(child) {
      stack.push({layout:child, parent:item.layout});
    });
  }
};
// INPUT (javascript/gviz/devel/canviz/messages.js)
gviz.canviz.Messages = {};
gviz.canviz.Messages.MSG_THOUSAND_SEPARATOR = ",";
gviz.canviz.Messages.MSG_DECIMAL_POINT = ".";
gviz.canviz.Messages.MSG_MISSING_TEXT_INDICATION = "...";
gviz.canviz.Messages.MSG_OTHER = "Other";
gviz.canviz.Messages.MSG_NOT_SUPPORTED = "Your browser does not support charts";
gviz.canviz.Messages.MSG_NO_DATA = "No data";
// INPUT (javascript/gviz/devel/canviz/text-utils.js)
gviz.canviz.textutils = {};
gviz.canviz.textutils.calcTextLayout = function(textMeasureFunction, text$$0, textStyle, width, opt_maxLines, opt_requireOneChar) {
  var maxLines = goog.isDefAndNotNull(opt_maxLines) ? Math.floor(opt_maxLines) : 1, requireOneChar = goog.isDefAndNotNull(opt_requireOneChar) ? opt_requireOneChar : !1;
  if (0 == maxLines) {
    return{lines:[], needTooltip:!1, maxLineWidth:0};
  }
  var simpleTextMeasure = function(text) {
    return textMeasureFunction(text, textStyle);
  }, brokenUpText = gviz.nightingale.layout.util.breakLines(simpleTextMeasure, text$$0, textStyle, width, maxLines, {truncate:!0, requireOneChar:requireOneChar, dontBreakWords:!0});
  return{lines:brokenUpText.lines, needTooltip:brokenUpText.truncated, maxLineWidth:0 < brokenUpText.lines.length ? Math.max.apply(null, goog.array.map(goog.array.map(brokenUpText.lines, simpleTextMeasure), function(obj) {
    return obj.width;
  })) : 0};
};
gviz.canviz.textutils.internalCalcTextLayout_ = function(text, lines, width, remainingLines, requireOneChar, getWidth) {
  var textWidth = getWidth(text);
  if (textWidth <= width) {
    return text && goog.array.extend(lines, text.toString().split("\n")), {tooltipNeeded:!1, maxLineWidth:textWidth};
  }
  if (1 < remainingLines) {
    for (var longestFit = 0, longestFitWidth = 0, i = 1;i < text.length;i++) {
      var character = text.charAt(i);
      if (" " == character || "\n" == character) {
        var substringWidth = getWidth(text.substr(0, i));
        if (substringWidth <= width) {
          if (longestFitWidth = substringWidth, longestFit = i, "\n" == character) {
            break;
          } else {
            continue;
          }
        }
        break;
      }
    }
    if (0 < longestFit) {
      lines.push(text.substr(0, longestFit));
      var otherLines = gviz.canviz.textutils.internalCalcTextLayout_(text.substr(longestFit + 1), lines, width, remainingLines - 1, !1, getWidth);
      return{tooltipNeeded:otherLines.tooltipNeeded, maxLineWidth:Math.max(longestFitWidth, otherLines.maxLineWidth)};
    }
  }
  var ellipsis = gviz.canviz.Messages.MSG_MISSING_TEXT_INDICATION;
  if (requireOneChar) {
    var ellipsisWidth = getWidth(text.substr(0, 1) + ellipsis);
    if (width < ellipsisWidth) {
      for (i = Math.min(text.length, 5);1 <= i;i--) {
        var partialStringWidth = getWidth(text.substr(0, i));
        if (partialStringWidth <= width) {
          return lines.push(text.substr(0, i)), {tooltipNeeded:!0, maxLineWidth:partialStringWidth};
        }
      }
      return{tooltipNeeded:!0, maxLineWidth:0};
    }
  }
  ellipsisWidth = getWidth(ellipsis);
  if (width < ellipsisWidth) {
    for (i = ellipsis.length - 1;1 <= i;i--) {
      var partialEllipsisWidth = getWidth(ellipsis.substr(0, i));
      if (partialEllipsisWidth <= width) {
        return lines.push(ellipsis.substr(0, i)), {tooltipNeeded:!0, maxLineWidth:partialEllipsisWidth};
      }
    }
    return{tooltipNeeded:!0, maxLineWidth:0};
  }
  for (i = text.length - 1;1 <= i;i--) {
    var newText = text.substr(0, i) + ellipsis, newTextWidth = getWidth(newText);
    if (newTextWidth <= width) {
      return lines.push(newText), {tooltipNeeded:!0, maxLineWidth:newTextWidth};
    }
  }
  lines.push(ellipsis);
  return{tooltipNeeded:!0, maxLineWidth:ellipsisWidth};
};
gviz.canviz.textutils.tooltipCssStyle = function(textStyle) {
  var cssStyle = {background:"infobackground", padding:"1px", border:"1px solid infotext"};
  goog.isDefAndNotNull(textStyle.fontSize) && (cssStyle.fontSize = textStyle.fontSize + "px", cssStyle.margin = textStyle.fontSize + "px");
  goog.isDefAndNotNull(textStyle.fontName) && (cssStyle.fontFamily = textStyle.fontName);
  return cssStyle;
};
// INPUT (javascript/gviz/devel/jsapi/fw/rabl-wrapper.js)
gviz.fw.RaBlWrapper = function() {
  this.rabl_ = this.abstractRenderer_ = null;
};
gviz.fw.RaBlWrapper.wrapAbstractRenderer = function(renderer) {
  var result = new gviz.fw.RaBlWrapper;
  result.abstractRenderer_ = renderer;
  return result;
};
gviz.fw.RaBlWrapper.wrapRaBl = function(rabl) {
  var result = new gviz.fw.RaBlWrapper;
  result.rabl_ = rabl;
  return result;
};
gviz.fw.RaBlWrapper.prototype.abstractRenderer = function() {
  if (goog.isDefAndNotNull(this.abstractRenderer_)) {
    return this.abstractRenderer_;
  }
  throw Error("AbstractRenderer not set");
};
gviz.fw.RaBlWrapper.prototype.rabl = function() {
  if (goog.isDefAndNotNull(this.rabl_)) {
    return this.rabl_;
  }
  throw Error("RaBl not set");
};
// INPUT (javascript/gviz/devel/jsapi/fw/factory.js)
gviz.fw.Factory = function() {
};
gviz.fw.Factory.prototype.createBuilder = function() {
};
gviz.fw.Factory.prototype.createChartRenderer = function() {
};
gviz.fw.Factory.prototype.createDefiner = function() {
};
gviz.fw.Factory.prototype.createEventHandler = function() {
};
gviz.fw.Factory.prototype.createEventDispatcher = function() {
};
gviz.fw.Factory.prototype.createInteractivityDefiner = function() {
};
gviz.fw.Factory.prototype.createInteractivityHandlers = function() {
};
gviz.fw.Factory.prototype.createRunner = function() {
};
// INPUT (javascript/gviz/devel/jsapi/fw/definer.js)
gviz.fw.Definer = function() {
};
gviz.fw.Definer.prototype.getDefinition = function() {
};
// INPUT (javascript/gviz/devel/jsapi/fw/feature-id.js)
gviz.fw.FeatureType = {BACKGROUND:"BACKGROUND", ROW_FEATURE:"ROW", COLUMN_FEATURE:"COLUMN", CELL_FEATURE:"CELL", TOOLTIP:"TOOLTIP", LEGEND:"LEGEND"};
gviz.fw.Aspects = {ROW_INDEX:"ROW_INDEX", COLUMN_INDEX:"COLUMN_INDEX", DATE:"DATE", DOMAIN_INDEX:"DOMAIN_INDEX", LAYER:"LAYER", SOURCE:"SOURCE", OBJECT_INDEX:"OBJECT_INDEX", SUBTYPE:"SUBTYPE"};
gviz.fw.FeatureId = function(type, opt_identifiers) {
  this.type_ = type;
  this.identifiers_ = goog.isDefAndNotNull(opt_identifiers) && goog.object.clone(opt_identifiers) || {};
};
gviz.fw.FeatureId.createRowFeatureId = function(rowIndex, opt_subType) {
  var featureId = (new gviz.fw.FeatureId(gviz.fw.FeatureType.ROW_FEATURE)).setAspect(gviz.fw.Aspects.ROW_INDEX, rowIndex);
  goog.isDefAndNotNull(opt_subType) && featureId.setAspect(gviz.fw.Aspects.SUBTYPE, opt_subType);
  return featureId;
};
gviz.fw.FeatureId.createColumnFeatureId = function(columnIndex, opt_subType) {
  var featureId = (new gviz.fw.FeatureId(gviz.fw.FeatureType.COLUMN_FEATURE)).setAspect(gviz.fw.Aspects.COLUMN_INDEX, columnIndex);
  goog.isDefAndNotNull(opt_subType) && featureId.setAspect(gviz.fw.Aspects.SUBTYPE, opt_subType);
  return featureId;
};
gviz.fw.FeatureId.createCellFeatureId = function(colIndex, rowIndex, opt_subType) {
  var featureId = (new gviz.fw.FeatureId(gviz.fw.FeatureType.CELL_FEATURE)).setAspect(gviz.fw.Aspects.ROW_INDEX, rowIndex).setAspect(gviz.fw.Aspects.COLUMN_INDEX, colIndex);
  goog.isDefAndNotNull(opt_subType) && featureId.setAspect(gviz.fw.Aspects.SUBTYPE, opt_subType);
  return featureId;
};
gviz.fw.FeatureId.parse = function(str) {
  var o = goog.json.parse(str);
  return new gviz.fw.FeatureId(o.type_, o.identifiers_);
};
gviz.fw.FeatureId.prototype.clone = function() {
  return gviz.fw.FeatureId.parse(this.serialize());
};
gviz.fw.FeatureId.prototype.equals = function(other) {
  if (!other || this.type_ != other.type_) {
    return!1;
  }
  var myKeys = goog.object.getKeys(this.identifiers_);
  return myKeys.length !== goog.object.getKeys(other.identifiers_).length ? !1 : goog.array.every(goog.array.map(myKeys, goog.bind(function(key) {
    return this.identifiers_[key] === other.identifiers_[key];
  }, this)), goog.functions.identity);
};
gviz.fw.FeatureId.prototype.getAspects = function() {
  var aspects = {}, name;
  for (name in this.identifiers_) {
    aspects[name] = this.identifiers_[name];
  }
  return aspects;
};
gviz.fw.FeatureId.prototype.setAspect = function(name, value) {
  this.identifiers_[name] = value;
  return this;
};
gviz.fw.FeatureId.prototype.getAspect = function(name) {
  return this.identifiers_[name];
};
gviz.fw.FeatureId.prototype.type = function() {
  return this.type_;
};
gviz.fw.FeatureId.prototype.serialize = function() {
  return goog.json.serialize(this);
};
// INPUT (javascript/gviz/devel/jsapi/fw/interaction-events.js)
gviz.fw.interactionEvents = {};
gviz.fw.interactionEvents.OperationType = {HOVER_IN:"hoverIn", HOVER_OUT:"hoverOut", CLICK:"click"};
// INPUT (javascript/gviz/devel/jsapi/fw/render/draw-helper.js)
gviz.fw.render = {};
gviz.fw.render.LayerName = {BACKGROUND:"background", GRID:"grid", LINKS:"links", ROWS:"rows", SELECTED_ROWS:"selectedRows", ROW_LABELS:"rowlabels", FRONT_GRID:"fgrid", TOOLTIP:"tooltip", SELECTED_LABELS:"_selectedLabels", FOCUSED_LABELS:"_focusedLabels"};
gviz.fw.render.LayerName.isSpecialLayer = function(layerName) {
  return "_" === layerName[0];
};
gviz.fw.render.DrawHelper = function() {
};
gviz.fw.render.DrawHelper.prototype.getRenderer = function() {
};
gviz.fw.render.DrawHelper.prototype.drawElement = function() {
};
gviz.fw.render.DrawHelper.prototype.appendElement = function() {
};
gviz.fw.render.DrawHelper.prototype.replaceElement = function() {
};
gviz.fw.render.DrawHelper.prototype.removeElement = function() {
};
// INPUT (javascript/gviz/devel/jsapi/fw/effects.js)
gviz.fw.EffectType = {FOCUS:"focus", SELECTION:"select", TOOLTIP:"tooltip"};
gviz.fw.Effect = function(type, data) {
  this.type = type;
  this.data = data;
};
gviz.fw.TargetedEffect = function(effect, opt_featureId) {
  goog.isString(effect) && (effect = new gviz.fw.Effect(effect, null));
  this.effect = effect;
  this.targets = [];
  opt_featureId && this.targets.push(opt_featureId);
};
gviz.fw.EffectsDiff = function() {
  this.effectsToAdd = [];
  this.effectsToRemove = [];
  this.clearTooltip = !1;
};
// INPUT (javascript/gviz/devel/jsapi/fw/state.js)
gviz.fw.State = function() {
  this.selected = new gviz.util.Selection;
  this.selectFeature = this.tooltipFeature = this.focusedFeature = null;
};
gviz.fw.State.prototype.clone = function() {
  var cloned = new gviz.fw.State;
  cloned.selected = this.selected.clone();
  cloned.focusedFeature = this.focusedFeature ? this.focusedFeature.clone() : null;
  cloned.tooltipFeature = this.tooltipFeature ? this.tooltipFeature.clone() : null;
  cloned.selectFeature = this.selectFeature ? this.selectFeature.clone() : null;
  return cloned;
};
gviz.fw.State.prototype.equals = function(other) {
  return this.selected.equals(other.selected) && (this.focusedFeature ? this.focusedFeature.equals(other.focusedFeature) : !other.focusedFeature) && (this.tooltipFeature ? this.tooltipFeature.equals(other.tooltipFeature) : !other.tooltipFeature) && (this.selectFeature ? this.selectFeature.equals(other.selectFeature) : !other.selectFeature);
};
// INPUT (javascript/gviz/devel/jsapi/fw/interactivity-definer.js)
gviz.fw.InteractivityDefiner = function(handlers) {
  this.state_ = null;
  this.effects_ = [];
  this.handlers_ = handlers;
};
gviz.fw.InteractivityDefiner.prototype.calcEffectsDiff = function(state) {
  goog.asserts.assert(this.state_);
  if (this.state_.equals(state)) {
    return{clearTooltip:!1, effectsToAdd:[], effectsToRemove:[]};
  }
  var oldEffects = this.effects_, newEffects = this.calcEffects(state), result = this.compareEffects_(newEffects, oldEffects);
  return result;
};
gviz.fw.InteractivityDefiner.prototype.calcEffects = function(state) {
  if (!goog.isDefAndNotNull(this.handlers_)) {
    return[];
  }
  var effects = goog.array.reduce(this.handlers_, function(result, handler) {
    goog.array.extend(result, handler.calcEffects(state));
    return result;
  }, [], this);
  this.effects_ = effects;
  this.state_ = state.clone();
  return effects;
};
gviz.fw.InteractivityDefiner.prototype.compareEffects_ = function(newEffects, currentEffects) {
  var newEffectsSet = this.buildEffectsSet_(newEffects), currentEffectsSet = this.buildEffectsSet_(currentEffects), effectsToAddSet = newEffectsSet.difference(currentEffectsSet), effectsToRemoveSet = currentEffectsSet.difference(newEffectsSet), result = new gviz.fw.EffectsDiff;
  result.effectsToAdd = this.parseEffectsSet_(effectsToAddSet);
  result.effectsToRemove = this.parseEffectsSet_(effectsToRemoveSet);
  return result;
};
gviz.fw.InteractivityDefiner.prototype.buildEffectsSet_ = function(effects) {
  var serializedEffects = goog.array.map(effects, function(effect) {
    return goog.json.serialize(effect);
  });
  return new goog.structs.Set(serializedEffects);
};
gviz.fw.InteractivityDefiner.prototype.parseEffectsSet_ = function(effectsSet) {
  var serializedEffects = effectsSet.getValues();
  return goog.array.map(serializedEffects, function(serializedEffect) {
    var effect = goog.json.parse(serializedEffect);
    effect.targets = goog.array.map(effect.targets, function(o) {
      return new gviz.fw.FeatureId(o.type_, o.identifiers_);
    });
    return effect;
  });
};
// INPUT (javascript/gviz/devel/jsapi/fw/interactivity/handler.js)
gviz.fw.interactivity = {};
gviz.fw.interactivity.BaseHandler = function(featureTypes, operationTypes) {
  this.featureTypes = new goog.structs.Set(featureTypes);
  this.operationTypes = new goog.structs.Set(operationTypes);
};
gviz.fw.interactivity.BaseHandler.prototype.eventApplies = function(featureId, operationType) {
  return this.featureTypes.contains(featureId.type()) && this.operationTypes.contains(operationType);
};
// INPUT (javascript/gviz/devel/jsapi/fw/interactivity/focus-handler.js)
gviz.fw.interactivity.FocusHandler = function(featureTypes) {
  gviz.fw.interactivity.BaseHandler.call(this, featureTypes, [gviz.fw.interactionEvents.OperationType.HOVER_IN, gviz.fw.interactionEvents.OperationType.HOVER_OUT]);
};
goog.inherits(gviz.fw.interactivity.FocusHandler, gviz.fw.interactivity.BaseHandler);
gviz.fw.interactivity.FocusHandler.prototype.changeState = function(featureId, operationType, state) {
  if (operationType == gviz.fw.interactionEvents.OperationType.HOVER_IN) {
    if (!featureId.equals(state.focusedFeature)) {
      return state.focusedFeature = featureId, !0;
    }
  } else {
    if (null != state.focusedFeature) {
      return state.focusedFeature = null, !0;
    }
  }
  return!1;
};
gviz.fw.interactivity.FocusHandler.prototype.calcEffects = function(state) {
  return goog.isDefAndNotNull(state.focusedFeature) ? [new gviz.fw.TargetedEffect(gviz.fw.EffectType.FOCUS, state.focusedFeature)] : [];
};
// INPUT (javascript/gviz/devel/jsapi/fw/render/rabl-helper.js)
gviz.fw.render.RaBlHelper = function() {
};
gviz.fw.render.RaBlHelper.prototype.appendShape = function() {
};
gviz.fw.render.RaBlHelper.prototype.drawLayers = function() {
};
// INPUT (javascript/gviz/devel/jsapi/fw/render/chart-renderer.js)
gviz.fw.render.ChartRenderer = function() {
};
gviz.fw.render.ChartRenderer.prototype.draw = function() {
};
gviz.fw.render.ChartRenderer.prototype.getSize = function() {
};
gviz.fw.render.ChartRenderer.prototype.setEffect = function() {
};
// INPUT (javascript/gviz/devel/jsapi/fw/abstract-builder.js)
gviz.fw.AbstractBuilder = function() {
};
// INPUT (javascript/gviz/devel/jsapi/fw/builder.js)
gviz.fw.Builder = function(factory, renderer, overlayArea, eventHandler, asyncWrapper) {
  this.factory = factory;
  this.renderer = renderer;
  this.wrapper_ = gviz.fw.RaBlWrapper.wrapAbstractRenderer(renderer);
  this.overlayArea = overlayArea;
  this.layerGroups = null;
  this.layerPrecedence = gviz.fw.Builder.DEFAULT_LAYER_PRECEDENCE;
  this.eventHandler = eventHandler;
  this.asyncWrapper = asyncWrapper;
  this.chartRenderer = null;
};
goog.inherits(gviz.fw.Builder, gviz.fw.AbstractBuilder);
gviz.fw.Builder.prototype.draw = function(definition) {
  this.layerGroups = {};
  var renderer = this.renderer;
  renderer.clear();
  this.chartRenderer = this.factory.createChartRenderer(definition, this.overlayArea);
  for (var size = this.chartRenderer.getSize(), canvas = renderer.createCanvas(size.width, size.height), i = 0;i < this.layerPrecedence.length;i++) {
    var layerName = this.layerPrecedence[i], layerGroup = renderer.createGroup();
    renderer.appendChild(canvas, layerGroup);
    this.layerGroups[layerName] = layerGroup;
  }
  this.chartRenderer.draw(this);
  this.setEventHandlers(canvas);
};
gviz.fw.Builder.prototype.setLayerPrecedence = function(layerPrecedence) {
  this.layerPrecedence = layerPrecedence;
};
gviz.fw.Builder.prototype.refresh = function(effectsDiff) {
  this.setEffects(effectsDiff.effectsToRemove, !1);
  this.setEffects(effectsDiff.effectsToAdd, !0);
  this.chartRenderer.draw(this);
};
gviz.fw.Builder.prototype.setEffects = function(visualEffects, enable) {
  for (var i = 0;i < visualEffects.length;i++) {
    for (var visualEffect = visualEffects[i], targets = visualEffect.targets, j = 0;j < targets.length;j++) {
      var targetId = targets[j];
      this.chartRenderer.setEffect(targetId, visualEffect.effect, enable);
    }
  }
};
gviz.fw.Builder.prototype.setEventHandlers = function(canvas) {
  var renderer = this.renderer;
  renderer.setEventHandler(canvas, goog.events.EventType.CONTEXTMENU, goog.events.Event.preventDefault);
  renderer.setEventHandler(canvas, goog.events.EventType.MOUSEOVER, this.asyncWrapper(goog.bind(this.handleEvent, this, gviz.fw.interactionEvents.OperationType.HOVER_IN)));
  renderer.setEventHandler(canvas, goog.events.EventType.MOUSEOUT, this.asyncWrapper(goog.bind(this.handleEvent, this, gviz.fw.interactionEvents.OperationType.HOVER_OUT)));
  renderer.setEventHandler(canvas, goog.events.EventType.CLICK, this.asyncWrapper(goog.bind(this.handleEvent, this, gviz.fw.interactionEvents.OperationType.CLICK)));
};
gviz.fw.Builder.prototype.handleEvent = function(operationType, event) {
  event.stopPropagation && event.stopPropagation();
  var eventTarget = event.target, targetFeatureIdStr = this.renderer.getLogicalName(eventTarget);
  if (targetFeatureIdStr != gviz.graphics.logicalname.DEFAULT_NAME) {
    var targetFeatureId = gviz.fw.FeatureId.parse(targetFeatureIdStr);
    goog.asserts.assert(targetFeatureId);
    this.eventHandler(targetFeatureId, operationType);
  }
};
gviz.fw.Builder.prototype.getRenderer = function() {
  return this.wrapper_;
};
gviz.fw.Builder.prototype.drawElement = function(newElement, oldElement, featureId, layerName) {
  goog.isDefAndNotNull(oldElement) ? (goog.asserts.assert(this.renderer.getLogicalName(oldElement) == featureId.serialize()), goog.asserts.assert(goog.dom.getParentElement(oldElement) == this.layerGroups[layerName].getElement()), this.replaceElement(newElement, oldElement)) : this.appendElement(newElement, featureId, layerName);
};
gviz.fw.Builder.prototype.appendElement = function(element, featureId, layerName) {
  var layerGroup = this.layerGroups[layerName];
  goog.asserts.assert(layerGroup);
  this.renderer.appendChild(layerGroup, element);
  this.renderer.setLogicalName(element, featureId.serialize());
};
gviz.fw.Builder.prototype.replaceElement = function(newElement, oldElement) {
  var parentElement = goog.dom.getParentElement(oldElement);
  parentElement.replaceChild(newElement, oldElement);
  var elementId = this.renderer.getLogicalName(oldElement);
  this.renderer.setLogicalName(newElement, elementId);
};
gviz.fw.Builder.prototype.removeElement = function(element) {
  this.renderer.removeElement(element);
};
gviz.fw.Builder.DEFAULT_LAYER_PRECEDENCE = [gviz.fw.render.LayerName.BACKGROUND, gviz.fw.render.LayerName.ROWS, gviz.fw.render.LayerName.ROW_LABELS, gviz.fw.render.LayerName.SELECTED_LABELS, gviz.fw.render.LayerName.FOCUSED_LABELS];
// INPUT (javascript/gviz/devel/jsapi/fw/event-dispatcher.js)
gviz.fw.EventDispatcher = function(eventSource) {
  this.eventSource_ = eventSource;
  this.state_ = null;
};
gviz.fw.EventDispatcher.prototype.setState = function(state) {
  this.state_ = state.clone();
};
gviz.fw.EventDispatcher.prototype.dispatchByStateChange = function(state) {
  goog.asserts.assert(this.state_);
  var drawnState = this.state_;
  state.selected.equals(drawnState.selected) || this.dispatchEvent(gviz.ChartEventType.SELECT, null);
  null === state.selectFeature || state.selectFeature.equals(drawnState.selectFeature) || this.dispatchEvent(gviz.ChartEventType.SELECT, null);
  var newFeature = state.focusedFeature, oldFeature = drawnState.focusedFeature, feature = newFeature;
  if (!newFeature && oldFeature || newFeature && !newFeature.equals(oldFeature)) {
    var eventType = gviz.ChartEventType.FOCUS_IN, data = {};
    if (!oldFeature) {
      data.row = newFeature.getAspect(gviz.fw.Aspects.ROW_INDEX), data.column = newFeature.getAspect(gviz.fw.Aspects.COLUMN_INDEX);
    } else {
      if (!newFeature) {
        eventType = gviz.ChartEventType.FOCUS_OUT, data.row = oldFeature.getAspect(gviz.fw.Aspects.ROW_INDEX), data.column = oldFeature.getAspect(gviz.fw.Aspects.COLUMN_INDEX), feature = oldFeature;
      } else {
        if (oldFeature.type() !== newFeature.type() || oldFeature.getAspect(gviz.fw.Aspects.ROW_INDEX) !== newFeature.getAspect(gviz.fw.Aspects.ROW_INDEX) || oldFeature.getAspect(gviz.fw.Aspects.COLUMN_INDEX) !== newFeature.getAspect(gviz.fw.Aspects.COLUMN_INDEX)) {
          data.row = newFeature.getAspect(gviz.fw.Aspects.ROW_INDEX), data.column = newFeature.getAspect(gviz.fw.Aspects.COLUMN_INDEX);
        }
      }
    }
    if (feature) {
      var date = feature.getAspect(gviz.fw.Aspects.DATE);
      goog.isDefAndNotNull(date) && (data.date = date);
    }
    this.dispatchEvent(eventType, data);
  }
  this.state_ = state.clone();
};
gviz.fw.EventDispatcher.prototype.dispatchEvent = function(eventType, eventData) {
  google.visualization.events.trigger(this.eventSource_, eventType, eventData);
};
// INPUT (javascript/gviz/devel/jsapi/fw/event-handler.js)
gviz.fw.EventHandler = function(callback, handlers) {
  goog.Disposable.call(this);
  this.state_ = null;
  this.handlers_ = handlers;
  this.scheduler_ = new gviz.canviz.Scheduler(callback);
  this.registerDisposable(this.scheduler_);
};
goog.inherits(gviz.fw.EventHandler, goog.Disposable);
gviz.fw.EventHandler.prototype.setState = function(state) {
  this.state_ = state;
};
gviz.fw.EventHandler.prototype.getHandlerFunc = function() {
  return goog.bind(this.handleEvent, this);
};
gviz.fw.EventHandler.prototype.handleEvent = function(featureId, operationType) {
  if (goog.isDefAndNotNull(this.handlers_)) {
    goog.asserts.assert(this.state_);
    var changed = !1;
    goog.array.forEach(this.handlers_, function(handler) {
      if (handler.eventApplies(featureId, operationType)) {
        var localChanged = handler.changeState(featureId, operationType, this.state_);
        changed = changed || localChanged;
      }
    }, this);
    changed && this.tickleScheduler();
  }
};
gviz.fw.EventHandler.prototype.tickleScheduler = function() {
  this.scheduler_.updateCountdown(50);
};
// INPUT (javascript/gviz/devel/jsapi/fw/runner.js)
gviz.fw.Runner = function(factory, wrapper, overlayArea, eventSource, options, asyncWrapper) {
  goog.Disposable.call(this);
  this.factory = factory;
  this.drawnState = this.state = null;
  var handlers = this.factory.createInteractivityHandlers(options);
  this.interactivityDefiner = this.factory.createInteractivityDefiner(handlers);
  var refreshAndDispatchEvents = asyncWrapper(goog.bind(this.refresh_, this, !0));
  this.eventHandler = this.factory.createEventHandler(refreshAndDispatchEvents, handlers);
  this.registerDisposable(this.eventHandler);
  this.builder = this.factory.createBuilder(wrapper, overlayArea, this.eventHandler.getHandlerFunc(), asyncWrapper);
  this.eventDispatcher = this.factory.createEventDispatcher(eventSource);
};
goog.inherits(gviz.fw.Runner, goog.Disposable);
gviz.fw.Runner.prototype.draw = function(definition, initialState) {
  this.state = initialState.clone();
  this.eventHandler.setState(this.state);
  this.eventDispatcher.setState(this.state);
  var effects = this.interactivityDefiner.calcEffects(this.state);
  this.builder.draw(definition, effects);
  this.drawnState = this.state.clone();
  this.eventDispatcher.dispatchEvent(gviz.ChartEventType.READY, null);
};
gviz.fw.Runner.prototype.refresh_ = function(dispatchEvents) {
  goog.asserts.assert(this.state);
  var effectsDiff = this.interactivityDefiner.calcEffectsDiff(this.state);
  this.builder.refresh(effectsDiff);
  this.drawnState = this.state.clone();
  dispatchEvents && this.eventDispatcher.dispatchByStateChange(this.state);
};
gviz.fw.Runner.prototype.setSelection = function(selected) {
  this.refresh_(!0);
  this.state.selected.setSelection(selected);
  this.refresh_(!1);
};
gviz.fw.Runner.prototype.getSelection = function() {
  if (null == this.drawnState.selectFeature) {
    return this.drawnState.selected.getSelection();
  }
  var featureId = this.drawnState.selectFeature, result = {};
  goog.isDefAndNotNull(featureId.getAspect(gviz.fw.Aspects.DATE)) && (result.date = featureId.getAspect(gviz.fw.Aspects.DATE));
  goog.isDefAndNotNull(featureId.getAspect(gviz.fw.Aspects.ROW_INDEX)) && (result.row = featureId.getAspect(gviz.fw.Aspects.ROW_INDEX));
  return[result];
};
// INPUT (javascript/gviz/devel/jsapi/fw/base-visualization.js)
gviz.fw.BaseVisualization = function(container) {
  google.visualization.AbstractVisualization.call(this, container);
};
goog.inherits(gviz.fw.BaseVisualization, google.visualization.AbstractVisualization);
gviz.fw.BaseVisualization.prototype.getFactory = function() {
  return this;
};
gviz.fw.BaseVisualization.prototype.createEventHandler = function(callback, handlers) {
  return new gviz.fw.EventHandler(callback, handlers);
};
gviz.fw.BaseVisualization.prototype.createEventDispatcher = function(eventSource) {
  return new gviz.fw.EventDispatcher(eventSource);
};
gviz.fw.BaseVisualization.prototype.createInteractivityHandlers = function() {
  return null;
};
gviz.fw.BaseVisualization.prototype.createInteractivityDefiner = function(handlers) {
  return new gviz.fw.InteractivityDefiner(handlers);
};
gviz.fw.BaseVisualization.prototype.createRunner = function(wrapper, overlayArea, eventSource, options, asyncWrapper) {
  return new gviz.fw.Runner(this, wrapper, overlayArea, eventSource, options, asyncWrapper);
};
gviz.fw.BaseVisualization.prototype.clearInternal = function() {
  goog.dispose(this.runner_);
  this.runner_ = null;
};
gviz.fw.BaseVisualization.prototype.setSelection = function(selection) {
  this.runner_ && this.runner_.setSelection(selection);
};
gviz.fw.BaseVisualization.prototype.getSelection = function() {
  return this.runner_ ? this.runner_.getSelection() : [];
};
// INPUT (research/infovis/nightingale/categorypalette.js)
var nightingale = {CategoryPalette:function(totalColors, opt_highContrast) {
  var baseColors = opt_highContrast ? nightingale.CategoryPalette.HIGH_CONTRAST_COLORS_ : nightingale.CategoryPalette.BASE_COLORS_, max = baseColors.length;
  this.palette_ = [];
  for (var numBrightnessVariations = 1 + Math.floor((totalColors - 1) / max), baseSize = Math.ceil(totalColors / numBrightnessVariations), baseRGB = [], i = 0;i < max;i++) {
    baseColors[i][1] < baseSize && baseRGB.push(baseColors[i][0]);
  }
  for (i = 0;i < totalColors;i++) {
    var baseIndex = opt_highContrast ? i % baseSize : Math.floor(i / numBrightnessVariations), base = baseRGB[baseIndex], amountToFade = opt_highContrast ? Math.floor(i / baseSize) : i % numBrightnessVariations, blendType = opt_highContrast ? nightingale.CategoryPalette.HIGH_CONTRAST_BLEND_ : nightingale.CategoryPalette.NORMAL_BLEND_, colorIntensity = Math.pow(blendType, amountToFade);
    this.palette_[i] = goog.array.map(base, function(x) {
      return~~(colorIntensity * x + 255 * (1 - colorIntensity));
    });
  }
}};
nightingale.CategoryPalette.BASE_COLORS_ = [[[66, 133, 244], 0], [[209, 68, 55], 0], [[244, 180, 0], 0], [[15, 157, 88], 0], [[171, 71, 188], 0], [[0, 172, 193], 0], [[255, 112, 67], 0], [[158, 157, 36], 0], [[92, 107, 192], 0], [[240, 98, 146], 0], [[0, 121, 107], 0], [[194, 24, 91], 0]];
nightingale.CategoryPalette.HIGH_CONTRAST_COLORS_ = [[[67, 69, 157], 6], [[83, 168, 251], 8], [[95, 150, 84], 10], [[241, 202, 58], 2], [[231, 113, 27], 5], [[135, 27, 71], 4], [[67, 116, 224], 0], [[26, 135, 99], 1], [[185, 194, 70], 9], [[228, 147, 7], 7], [[211, 54, 45], 3]];
nightingale.CategoryPalette.NORMAL_BLEND_ = .85;
nightingale.CategoryPalette.HIGH_CONTRAST_BLEND_ = .7;
nightingale.CategoryPalette.prototype.getSize = function() {
  return this.palette_.length;
};
nightingale.CategoryPalette.prototype.getColor = function(n) {
  return "rgb(" + this.palette_[n] + ")";
};
nightingale.CategoryPalette.prototype.getHex = function(n) {
  function hex(a) {
    var s = a.toString(16);
    1 == s.length && (s = "0" + s);
    return s;
  }
  var t = this.palette_[n];
  return "#" + (hex(t[0]) + hex(t[1]) + hex(t[2])).toUpperCase();
};
// INPUT (javascript/gviz/devel/jsapi/packages/core/a11y.js)
gviz.a11y = {};
gviz.a11y.createHtmlTableRep = function(dataTable) {
  var strings = [];
  strings.push("<table>");
  gviz.a11y.makeTableRow_(strings, dataTable, gviz.a11y.addColumnHeader_);
  for (var numRows = dataTable.getNumberOfRows(), rowNum = 0;rowNum < numRows;++rowNum) {
    gviz.a11y.makeTableRow_(strings, dataTable, function(s, d, c) {
      gviz.a11y.addDataCell_(s, d, c, rowNum);
    });
  }
  strings.push("</table>");
  return strings.join("");
};
gviz.a11y.makeTableRow_ = function(strings, dataTable, cb) {
  strings.push("<tr>");
  for (var cols = dataTable.getNumberOfColumns(), i = 0;i < cols;++i) {
    "" === dataTable.getColumnRole(i) && cb(strings, dataTable, i);
  }
  strings.push("</tr>\n");
};
gviz.a11y.addColumnHeader_ = function(strings, dataTable, colIndex) {
  strings.push("<th>");
  strings.push("" + goog.string.htmlEscape(dataTable.getColumnLabel(colIndex) || dataTable.getColumnId(colIndex)));
  strings.push("</th>");
};
gviz.a11y.addDataCell_ = function(strings, dataTable, colIndex, rowIndex) {
  strings.push("<td>");
  var val = goog.string.htmlEscape(dataTable.getValue(rowIndex, colIndex) + "");
  strings.push("" + val);
  strings.push("</td>");
};
// INPUT (javascript/gviz/devel/jsapi/fw/framework-visualizations.js)
gviz.fw.FrameworkVisualization = function(container) {
  gviz.fw.BaseVisualization.call(this, container);
  this.drawingFrame = null;
};
goog.inherits(gviz.fw.FrameworkVisualization, gviz.fw.BaseVisualization);
gviz.fw.FrameworkVisualization.prototype.createBuilder = function(wrapper, overlayArea, eventHandler, asyncWrapper) {
  if (null == overlayArea) {
    throw Error("Internal error: missing overlayArea");
  }
  var renderer = wrapper.abstractRenderer();
  return new gviz.fw.Builder(this, renderer, overlayArea, eventHandler, asyncWrapper);
};
gviz.fw.FrameworkVisualization.prototype.drawInternal = function(asyncWrapper, dataTable, opt_options) {
  google.visualization.errors.removeAll(this.container);
  var userOptions = opt_options || {}, defaultOptions = this.getDefaultOptions() || {}, options = new gviz.Options([userOptions, defaultOptions]), width = gviz.util.VisCommon.getWidth(this.container, options), height = gviz.util.VisCommon.getHeight(this.container, options), chartSize = new goog.math.Size(width, height), forceIFrame = options.inferBooleanValue("forceIFrame");
  this.createOrUpdateDrawingFrame(chartSize, asyncWrapper, forceIFrame);
  this.drawingFrame.waitUntilReady(goog.bind(this.completeTheDraw_, this, dataTable, options, chartSize, asyncWrapper), asyncWrapper);
};
gviz.fw.FrameworkVisualization.prototype.createOrUpdateDrawingFrame = function(chartSize, asyncWrapper, forceIFrame) {
  goog.isDefAndNotNull(this.drawingFrame) ? this.drawingFrame.update(chartSize, asyncWrapper) : this.drawingFrame = new gviz.graphics.DrawingFrame(this.container, chartSize, asyncWrapper, forceIFrame);
};
gviz.fw.FrameworkVisualization.prototype.completeTheDraw_ = function(dataTable, options, chartSize, asyncWrapper) {
  var renderer = this.drawingFrame.getRenderer();
  goog.asserts.assert(renderer);
  var overlayArea = this.drawingFrame.getOverlayArea();
  goog.asserts.assert(overlayArea);
  var chartDefiner = this.getFactory().createDefiner(dataTable, options, goog.bind(renderer.getTextSize, renderer), chartSize), definition = chartDefiner.getDefinition();
  goog.dispose(this.runner_);
  var wrapper = renderer instanceof gviz.graphics.AbstractRenderer ? gviz.fw.RaBlWrapper.wrapAbstractRenderer(renderer) : gviz.fw.RaBlWrapper.wrapRaBl(renderer);
  this.runner_ = this.getFactory().createRunner(wrapper, overlayArea, this, options, asyncWrapper);
  var initialState = new gviz.fw.State;
  this.runner_.draw(definition, initialState);
  if (renderer.createAccessibilityContainer) {
    var aContainer = renderer.createAccessibilityContainer();
    aContainer && dataTable && (aContainer.innerHTML = gviz.a11y.createHtmlTableRep(dataTable));
  }
};
gviz.fw.FrameworkVisualization.prototype.clearInternal = function() {
  gviz.fw.FrameworkVisualization.superClass_.clearInternal.call(this);
  goog.dispose(this.drawingFrame);
  this.drawingFrame = null;
};
// INPUT (javascript/gviz/devel/jsapi/fw/util/ngcategorypalette.js)
gviz.fw.util = {};
gviz.fw.util.NGCategoryPaletteWrapper = function() {
  this.palette_ = null;
  this.categoryMap_ = new goog.structs.Map;
  this.subcategoryMap_ = new goog.structs.Map;
};
gviz.fw.util.NGCategoryPaletteWrapper.prototype.addCategory = function(category, opt_subcategory) {
  goog.asserts.assert(null === this.palette_, "You must add all categories before getting any colors.");
  this.categoryMap_.containsKey(category) || this.categoryMap_.set(category, this.categoryMap_.getCount());
  goog.isDefAndNotNull(opt_subcategory) && !this.subcategoryMap_.containsKey(opt_subcategory) && this.subcategoryMap_.set(opt_subcategory, this.subcategoryMap_.getCount());
};
gviz.fw.util.NGCategoryPaletteWrapper.prototype.hexColor = function(category, opt_subcategory) {
  null == this.palette_ && (this.palette_ = new nightingale.CategoryPalette(this.categoryMap_.getCount()));
  goog.asserts.assert(this.categoryMap_.containsKey(category), "Color requested for unknown category");
  var baseColor = this.palette_.getHex(this.categoryMap_.get(category));
  if (2 > this.subcategoryMap_.getCount() || !goog.isDefAndNotNull(opt_subcategory)) {
    return baseColor;
  }
  goog.asserts.assert(this.subcategoryMap_.containsKey(opt_subcategory));
  var baseColorRgb = goog.color.hexToRgb(baseColor), subcategoryIndex = this.subcategoryMap_.get(opt_subcategory);
  return goog.color.rgbArrayToHex(goog.color.blend(baseColorRgb, [255, 255, 255], 1 - subcategoryIndex / this.subcategoryMap_.getCount()));
};
// INPUT (javascript/gviz/devel/jsapi/fw/render/rendered-element.js)
gviz.fw.render.RenderedElement = function(el, featureId, layer) {
  this.el = el;
  this.featureId = featureId.clone();
  this.layer = layer;
};
// INPUT (javascript/gviz/devel/jsapi/fw/render/chart-assembler.js)
gviz.fw.render.ChartAssembler = function() {
  this.renderedElements_ = new goog.structs.Map;
  this.renderedStaticElements_ = null;
  this.autoRemoveElements = !0;
};
gviz.fw.render.ChartAssembler.prototype.assembleStaticElements = function() {
  return[];
};
gviz.fw.render.ChartAssembler.prototype.draw = function(helper) {
  var drawHelper = helper;
  if (!goog.isDefAndNotNull(this.renderedStaticElements_)) {
    this.renderedStaticElements_ = new goog.structs.Map;
    var staticElements = this.assembleStaticElements(drawHelper);
    goog.array.forEach(staticElements, goog.bind(this.renderElement, this, drawHelper, this.renderedStaticElements_));
  }
  var elements = this.assembleElements(drawHelper), existingElements = new goog.structs.Set(this.renderedElements_.getKeys());
  goog.array.forEach(elements, function(el) {
    var serializedId = el.featureId.serialize();
    existingElements.remove(serializedId);
    this.renderElement(drawHelper, this.renderedElements_, el);
  }, this);
  this.autoRemoveElements && goog.iter.forEach(existingElements, function(idToRemove) {
    var el = this.renderedElements_.get(idToRemove);
    drawHelper.removeElement(el.el);
    this.renderedElements_.remove(idToRemove);
  }, this);
};
gviz.fw.render.ChartAssembler.prototype.renderElement = function(drawHelper, elementMap, newEl) {
  var serializedId = newEl.featureId.serialize(), oldEl = elementMap.get(serializedId, null);
  oldEl && oldEl.specialEl && drawHelper.removeElement(oldEl.specialEl);
  gviz.fw.render.LayerName.isSpecialLayer(newEl.layer) ? (goog.style.setElementShown(oldEl.el, !1), oldEl.specialEl = newEl.el, oldEl.specialLayer = newEl.layer, drawHelper.appendElement(oldEl.specialEl, oldEl.featureId, oldEl.specialLayer)) : oldEl != newEl && (null === oldEl || oldEl.layer !== newEl.layer ? (null != oldEl && drawHelper.removeElement(oldEl.el), drawHelper.appendElement(newEl.el, newEl.featureId, newEl.layer)) : drawHelper.drawElement(newEl.el, oldEl.el, newEl.featureId, newEl.layer), 
  elementMap.set(serializedId, newEl));
};
// INPUT (javascript/gviz/devel/jsapi/common/tree/tree-aggregation.js)
gviz.tree = {};
gviz.tree.aggregation = {};
gviz.tree.aggregation.sumNoOverride = function(value, childValues) {
  gviz.tree.aggregation.assertNumberOrNullInput_(value, childValues);
  if (0 == childValues.length) {
    return goog.isNull(value) ? 0 : value;
  }
  var sum$$0 = goog.array.reduce(childValues, function(sum, childValue) {
    return sum + childValue;
  }, 0);
  return sum$$0;
};
gviz.tree.aggregation.averageNoOverride = function(value$$0, childValues) {
  gviz.tree.aggregation.assertNumberOrNullInput_(value$$0, childValues);
  if (0 == childValues.length) {
    return value$$0;
  }
  var nonNullChilds = goog.array.filter(childValues, function(value) {
    return null != value;
  });
  return 0 == nonNullChilds.length ? null : gviz.tree.aggregation.sumNoOverride(value$$0, nonNullChilds) / nonNullChilds.length;
};
gviz.tree.aggregation.assertNumberOrNull_ = function(value) {
  goog.asserts.assert(goog.isNull(value) || goog.isNumber(value));
};
gviz.tree.aggregation.assertNumberOrNullInput_ = function(value, childValues) {
  gviz.tree.aggregation.assertNumberOrNull_(value);
  goog.array.forEach(childValues, function(childValue) {
    gviz.tree.aggregation.assertNumberOrNull_(childValue);
  });
};
// INPUT (javascript/gviz/devel/jsapi/common/tree/node.js)
gviz.tree.Node = function() {
};
gviz.tree.Node.prototype.getId = function() {
};
gviz.tree.Node.prototype.getName = function() {
};
gviz.tree.Node.prototype.getParent = function() {
};
gviz.tree.Node.prototype.isLeaf = function() {
};
gviz.tree.Node.prototype.getChildren = function() {
};
gviz.tree.Node.prototype.getChildAt = function() {
};
gviz.tree.Node.prototype.getChildCount = function() {
};
gviz.tree.Node.prototype.getDepth = function() {
};
gviz.tree.Node.prototype.getHeight = function() {
};
gviz.tree.Node.prototype.getAncestors = function() {
};
gviz.tree.Node.prototype.getRoot = function() {
};
gviz.tree.Node.prototype.contains = function() {
};
gviz.tree.Node.prototype.traverse = function() {
};
gviz.tree.Node.prototype.find = function() {
};
gviz.tree.Node.prototype.calcAggregatedValue = function() {
};
// INPUT (javascript/gviz/devel/jsapi/common/tree/data-node.js)
gviz.tree.DataNode = function() {
};
gviz.tree.DataNode.prototype.getRow = function() {
};
gviz.tree.DataNode.prototype.getDataTable = function() {
};
gviz.tree.DataNode.prototype.getFormattedName = function() {
};
gviz.tree.DataNode.prototype.getRowProperty = function() {
};
gviz.tree.DataNode.prototype.getValue = function() {
};
gviz.tree.DataNode.prototype.getFormattedValue = function() {
};
// INPUT (javascript/gviz/devel/jsapi/common/layered-object.js)
gviz.util.LayeredObject = function(numberOfLayers) {
  goog.asserts.assert(0 < numberOfLayers, "Expecting one or more layers, got " + numberOfLayers);
  this.layers_ = goog.array.repeat({}, numberOfLayers);
  this.compact_ = goog.array.repeat({}, numberOfLayers);
};
gviz.util.LayeredObject.prototype.setLayer = function(index, layer) {
  var numberOfLayers = this.layers_.length;
  goog.asserts.assert(0 <= index && index < numberOfLayers, "Index %s is out of range [0,%s]", index, numberOfLayers - 1);
  this.layers_[index] = layer;
  for (var i = index;i < numberOfLayers;++i) {
    this.compact_[i] = this.recursivelyAddSubLayer_(0 == i ? {} : this.compact_[i - 1], this.layers_[i]);
  }
};
gviz.util.LayeredObject.prototype.isLeaf_ = function(v) {
  var typeOfValue = goog.typeOf(v);
  return "object" != typeOfValue && "array" != typeOfValue || "object" == typeOfValue && goog.isFunction(v.clone) || goog.isDateLike(v);
};
gviz.util.LayeredObject.prototype.recursivelyAddSubLayer_ = function(subCompact, subLayer) {
  if (this.isLeaf_(subLayer) || this.isLeaf_(subCompact) || "array" == goog.typeOf(subLayer)) {
    return subLayer;
  }
  var subLayerObject = subLayer;
  if ("object" == goog.typeOf(subCompact)) {
    var subCompactObject = subCompact, ret = goog.object.clone(subCompactObject);
    goog.object.forEach(subLayerObject, function(val, key) {
      goog.object.containsKey(subCompactObject, key) && null != subCompact[key] ? ret[key] = this.recursivelyAddSubLayer_(subCompact[key], val) : ret[key] = val;
    }, this);
  } else {
    ret = goog.array.clone(subCompact), goog.object.forEach(subLayerObject, function(val, key) {
      ret[key] = this.recursivelyAddSubLayer_(subCompact[key], val);
    }, this);
  }
  return ret;
};
gviz.util.LayeredObject.prototype.compact = function() {
  return goog.array.peek(this.compact_);
};
// INPUT (javascript/gviz/devel/jsapi/common/tree/node-base.js)
gviz.tree.NodeBase = function(id, name) {
  goog.Disposable.call(this);
  this.id_ = id;
  this.name_ = name;
};
goog.inherits(gviz.tree.NodeBase, goog.Disposable);
gviz.tree.NodeBase.EMPTY_ARRAY_ = [];
gviz.tree.NodeBase.prototype.parent_ = null;
gviz.tree.NodeBase.prototype.children_ = null;
gviz.tree.NodeBase.prototype.setId = function(id) {
  this.id_ = id;
};
gviz.tree.NodeBase.prototype.getId = function() {
  return this.id_;
};
gviz.tree.NodeBase.prototype.getName = function() {
  return this.name_;
};
gviz.tree.NodeBase.prototype.getParent = function() {
  return this.parent_;
};
gviz.tree.NodeBase.prototype.isLeaf = function() {
  return!this.getChildCount();
};
gviz.tree.NodeBase.prototype.getChildren = function() {
  return this.children_ || gviz.tree.NodeBase.EMPTY_ARRAY_;
};
gviz.tree.NodeBase.prototype.getChildAt = function(index) {
  return this.getChildren()[index] || null;
};
gviz.tree.NodeBase.prototype.getChildCount = function() {
  return this.getChildren().length;
};
gviz.tree.NodeBase.prototype.getDepth = function() {
  for (var depth = 0, node = this;node.getParent();) {
    depth++, node = node.getParent();
  }
  return depth;
};
gviz.tree.NodeBase.prototype.getHeight = function() {
  var childs = this.getChildren(), maxChildHeight = goog.array.reduce(childs, function(height, child) {
    return Math.max(height, child.getHeight());
  }, -1);
  return maxChildHeight + 1;
};
gviz.tree.NodeBase.prototype.getAncestors = function() {
  for (var ancestors = [], node = this.getParent();node;) {
    ancestors.push(node), node = node.getParent();
  }
  return ancestors;
};
gviz.tree.NodeBase.prototype.getRoot = function() {
  for (var root = this;root.getParent();) {
    root = root.getParent();
  }
  return root;
};
gviz.tree.NodeBase.prototype.contains = function(node) {
  var current = node;
  do {
    current = current.getParent();
  } while (current && current != this);
  return Boolean(current);
};
gviz.tree.NodeBase.findCommonAncestor = function(var_args) {
  if (0 == arguments.length) {
    return null;
  }
  for (var ret = arguments[0], retDepth = ret.getDepth(), i = 1;i < arguments.length;i++) {
    for (var node = arguments[i], depth = node.getDepth();node != ret;) {
      depth <= retDepth && (ret = ret.getParent(), retDepth--), depth > retDepth && (node = node.getParent(), depth--);
    }
  }
  return ret;
};
gviz.tree.NodeBase.prototype.traverse = function(f, opt_this) {
  var traverse = function(node, depth) {
    !1 !== f.call(opt_this, node, depth) && goog.array.forEach(node.getChildren(), function(child) {
      traverse(child, depth + 1);
    });
  };
  traverse(this, 0);
};
gviz.tree.NodeBase.prototype.find = function(f, opt_this) {
  var nodes = [];
  this.traverse(function(node) {
    f.call(opt_this, node) && nodes.push(node);
  });
  return nodes;
};
gviz.tree.NodeBase.prototype.calcAggregatedValue = function(getter, aggregator, opt_setter, opt_this) {
  for (var nodeValue = getter.call(opt_this, this), aggregatedChilds = [], childs = this.getChildren(), i = 0;i < childs.length;i++) {
    var child = childs[i], aggregatedChild = child.calcAggregatedValue(getter, aggregator, opt_setter, opt_this);
    aggregatedChilds.push(aggregatedChild);
  }
  var aggregatedValue = aggregator.call(opt_this, nodeValue, aggregatedChilds);
  opt_setter && opt_setter.call(opt_this, this, aggregatedValue);
  return aggregatedValue;
};
gviz.tree.NodeBase.prototype.setParent_ = function(parent) {
  this.parent_ = parent;
};
gviz.tree.NodeBase.prototype.addChild = function(child) {
  goog.asserts.assert(!child.getParent());
  child.setParent_(this);
  this.children_ = this.children_ || [];
  this.children_.push(child);
  this.registerDisposable(child);
};
// INPUT (javascript/gviz/devel/jsapi/common/tree/data-node-impl.js)
gviz.tree.DataNodeImpl = function(name, dataTable, rowIndex) {
  gviz.tree.NodeBase.call(this, rowIndex, name);
  this.dataTable_ = dataTable;
};
goog.inherits(gviz.tree.DataNodeImpl, gviz.tree.NodeBase);
gviz.tree.DataNodeImpl.NAME_COLUMN_ = 0;
gviz.tree.DataNodeImpl.prototype.setRow = function(rowIndex) {
  this.setId(rowIndex);
};
gviz.tree.DataNodeImpl.prototype.getRow = function() {
  return this.getId();
};
gviz.tree.DataNodeImpl.prototype.getDataTable = function() {
  return this.dataTable_;
};
gviz.tree.DataNodeImpl.prototype.getFormattedName = function() {
  var formattedName = this.getFormattedValue(gviz.tree.DataNodeImpl.NAME_COLUMN_);
  return formattedName || this.getName();
};
gviz.tree.DataNodeImpl.prototype.getRowProperty = function(property) {
  return this.getRowRelatedData_(this.dataTable_.getRowProperty, property);
};
gviz.tree.DataNodeImpl.prototype.getValue = function(columnIndex) {
  return this.getRowRelatedData_(this.dataTable_.getValue, columnIndex);
};
gviz.tree.DataNodeImpl.prototype.getFormattedValue = function(columnIndex) {
  return this.getRowRelatedData_(this.dataTable_.getFormattedValue, columnIndex);
};
gviz.tree.DataNodeImpl.prototype.getRowRelatedData_ = function(getter, var_args) {
  var row = this.getRow();
  if (goog.isDefAndNotNull(row)) {
    var fullArgs = [row];
    goog.array.extend(fullArgs, goog.array.slice(arguments, 1));
    return getter.apply(this.dataTable_, fullArgs);
  }
  return null;
};
// INPUT (javascript/gviz/devel/jsapi/common/tree/tree.js)
gviz.tree.Tree = function() {
};
gviz.tree.Tree.prototype.getRootNodes = function() {
};
gviz.tree.Tree.prototype.getTreeCount = function() {
};
gviz.tree.Tree.prototype.isForest = function() {
};
gviz.tree.Tree.prototype.getNodeById = function() {
};
gviz.tree.Tree.prototype.getHeight = function() {
};
gviz.tree.Tree.prototype.traverse = function() {
};
gviz.tree.Tree.prototype.find = function() {
};
gviz.tree.Tree.prototype.calcAggregatedValue = function() {
};
// INPUT (javascript/gviz/devel/jsapi/common/tree/tree-base.js)
gviz.tree.TreeBase = function() {
  goog.Disposable.call(this);
  this.rootNodes_ = [];
  this.nodeById_ = {};
};
goog.inherits(gviz.tree.TreeBase, goog.Disposable);
gviz.tree.TreeBase.prototype.addRootNode = function(rootNode) {
  this.rootNodes_.push(rootNode);
  this.registerDisposable(rootNode);
  this.addNode(rootNode);
};
gviz.tree.TreeBase.prototype.addNode = function(node) {
  var id = node.getId();
  goog.isDefAndNotNull(id) && (goog.asserts.assert(!goog.isDef(this.nodeById_[id])), this.nodeById_[id] = node);
};
gviz.tree.TreeBase.prototype.getRootNodes = function() {
  return this.rootNodes_;
};
gviz.tree.TreeBase.prototype.getTreeCount = function() {
  return this.rootNodes_.length;
};
gviz.tree.TreeBase.prototype.isForest = function() {
  return 1 < this.getTreeCount();
};
gviz.tree.TreeBase.prototype.getNodeById = function(id) {
  return this.nodeById_[id] || null;
};
gviz.tree.TreeBase.prototype.getHeight = function() {
  var rootNodes = this.getRootNodes(), height$$0 = goog.array.reduce(rootNodes, function(height, rootNode) {
    return Math.max(height, rootNode.getHeight());
  }, -1);
  return height$$0;
};
gviz.tree.TreeBase.prototype.traverse = function(f, opt_this) {
  for (var rootNodes = this.getRootNodes(), i = 0;i < rootNodes.length;i++) {
    var rootNode = rootNodes[i];
    rootNode.traverse(f, opt_this);
  }
};
gviz.tree.TreeBase.prototype.find = function(f, opt_this) {
  for (var nodes = [], rootNodes = this.getRootNodes(), i = 0;i < rootNodes.length;i++) {
    var rootNode = rootNodes[i];
    goog.array.extend(nodes, rootNode.find(f, opt_this));
  }
  return nodes;
};
gviz.tree.TreeBase.prototype.calcAggregatedValue = function(getter, aggregator, setter, opt_this) {
  for (var rootNodes = this.getRootNodes(), i = 0;i < rootNodes.length;i++) {
    var rootNode = rootNodes[i];
    rootNode.calcAggregatedValue(getter, aggregator, setter, opt_this);
  }
};
// INPUT (javascript/gviz/devel/jsapi/common/tree/data-tree.js)
gviz.tree.DataTree = function(dataTable, opt_options) {
  gviz.tree.TreeBase.call(this);
  if (2 > dataTable.getNumberOfColumns()) {
    throw Error("Data table should have at least 2 columns");
  }
  if ("string" != dataTable.getColumnType(0)) {
    throw Error("Column 0 must be of type string");
  }
  if ("string" != dataTable.getColumnType(1)) {
    throw Error("Column 1 must be of type string");
  }
  for (var options = this.parseOptions_(opt_options), errorOnCycle = options.errorOnCycle, errorOnDuplicateId = options.errorOnDuplicateId, forceParentExists = options.forceParentExists, nameToNode = {}, nodes = [], row = 0;row < dataTable.getNumberOfRows();row++) {
    var name = dataTable.getValue(row, gviz.tree.DataTree.NAME_COLUMN_);
    if (name) {
      var node = nameToNode[name];
      node ? goog.isDefAndNotNull(node.getRow()) || node.setRow(row) : (nameToNode[name] = node = new gviz.tree.DataNodeImpl(name, dataTable, row), nodes.push(node));
      var parentName = node.getValue(gviz.tree.DataTree.PARENT_COLUMN_);
      if (parentName) {
        var parentNode = nameToNode[parentName];
        parentNode || (nameToNode[parentName] = parentNode = new gviz.tree.DataNodeImpl(parentName, dataTable, null), nodes.push(parentNode));
        if (node.getParent()) {
          if (errorOnDuplicateId) {
            throw Error("More than one row with the same id (" + node.getName() + ").");
          }
        } else {
          if (node != parentNode && !node.contains(parentNode)) {
            parentNode.addChild(node);
          } else {
            if (errorOnCycle) {
              throw Error("Data contains a cycle: " + this.nodesToString_(goog.array.concat(parentNode, parentNode.getAncestors())) + ".");
            }
          }
        }
      }
    }
  }
  for (var i = 0;i < nodes.length;i++) {
    node = nodes[i];
    if (forceParentExists && goog.isNull(node.getRow())) {
      throw Error('Failed to find row with id "' + node.getName() + '".');
    }
    node.getParent() ? this.addNode(node) : this.addRootNode(node);
  }
};
goog.inherits(gviz.tree.DataTree, gviz.tree.TreeBase);
gviz.tree.DataTree.NAME_COLUMN_ = 0;
gviz.tree.DataTree.PARENT_COLUMN_ = 1;
gviz.tree.DataTree.prototype.nodesToString_ = function(nodes) {
  return goog.array.map(nodes, function(node) {
    return node.getName();
  }).toString();
};
gviz.tree.DataTree.prototype.parseOptions_ = function(opt_options) {
  var options = new gviz.util.LayeredObject(2);
  options.setLayer(0, {errorOnCycle:!0, errorOnDuplicateId:!0, forceParentExists:!0});
  goog.isDefAndNotNull(opt_options) && options.setLayer(1, opt_options);
  return options.compact();
};
// INPUT (javascript/gviz/devel/jsapi/common/tree/projected-tree.js)
gviz.tree.ProjectedTree = function(tree, nodeFactory, opt_this) {
  gviz.tree.TreeBase.call(this);
  for (var rootNodes = tree.getRootNodes(), i = 0;i < rootNodes.length;i++) {
    var rootNode = rootNodes[i], newRootNode = this.projectNode_(rootNode, nodeFactory, opt_this);
    this.addRootNode(newRootNode);
  }
};
goog.inherits(gviz.tree.ProjectedTree, gviz.tree.TreeBase);
gviz.tree.ProjectedTree.prototype.projectNode_ = function(node, nodeFactory, opt_this) {
  for (var newNode = nodeFactory.call(opt_this, node), childs = node.getChildren(), i = 0;i < childs.length;i++) {
    var child = childs[i], newChild = this.projectNode_(child, nodeFactory, opt_this);
    this.addNode(newChild);
    newNode.addChild(newChild);
  }
  return newNode;
};
// INPUT (javascript/closure/graphics/path.js)
goog.graphics = {};
goog.graphics.Path = function() {
  this.segments_ = [];
  this.count_ = [];
  this.arguments_ = [];
};
goog.graphics.Path.prototype.closePoint_ = null;
goog.graphics.Path.prototype.currentPoint_ = null;
goog.graphics.Path.prototype.simple_ = !0;
goog.graphics.Path.Segment = {MOVETO:0, LINETO:1, CURVETO:2, ARCTO:3, CLOSE:4};
goog.graphics.Path.segmentArgCounts_ = function() {
  var counts = [];
  counts[goog.graphics.Path.Segment.MOVETO] = 2;
  counts[goog.graphics.Path.Segment.LINETO] = 2;
  counts[goog.graphics.Path.Segment.CURVETO] = 6;
  counts[goog.graphics.Path.Segment.ARCTO] = 6;
  counts[goog.graphics.Path.Segment.CLOSE] = 0;
  return counts;
}();
goog.graphics.Path.getSegmentCount = function(segment) {
  return goog.graphics.Path.segmentArgCounts_[segment];
};
goog.graphics.Path.prototype.appendPath = function(path) {
  path.currentPoint_ && (Array.prototype.push.apply(this.segments_, path.segments_), Array.prototype.push.apply(this.count_, path.count_), Array.prototype.push.apply(this.arguments_, path.arguments_), this.currentPoint_ = path.currentPoint_.concat(), this.closePoint_ = path.closePoint_.concat(), this.simple_ = this.simple_ && path.simple_);
  return this;
};
goog.graphics.Path.prototype.clear = function() {
  this.segments_.length = 0;
  this.count_.length = 0;
  this.arguments_.length = 0;
  delete this.closePoint_;
  delete this.currentPoint_;
  delete this.simple_;
  return this;
};
goog.graphics.Path.prototype.moveTo = function(x, y) {
  goog.array.peek(this.segments_) == goog.graphics.Path.Segment.MOVETO ? this.arguments_.length -= 2 : (this.segments_.push(goog.graphics.Path.Segment.MOVETO), this.count_.push(1));
  this.arguments_.push(x, y);
  this.currentPoint_ = this.closePoint_ = [x, y];
  return this;
};
goog.graphics.Path.prototype.lineTo = function(var_args) {
  var lastSegment = goog.array.peek(this.segments_);
  if (null == lastSegment) {
    throw Error("Path cannot start with lineTo");
  }
  lastSegment != goog.graphics.Path.Segment.LINETO && (this.segments_.push(goog.graphics.Path.Segment.LINETO), this.count_.push(0));
  for (var i = 0;i < arguments.length;i += 2) {
    var x = arguments[i], y = arguments[i + 1];
    this.arguments_.push(x, y);
  }
  this.count_[this.count_.length - 1] += i / 2;
  this.currentPoint_ = [x, y];
  return this;
};
goog.graphics.Path.prototype.curveTo = function(var_args) {
  var lastSegment = goog.array.peek(this.segments_);
  if (null == lastSegment) {
    throw Error("Path cannot start with curve");
  }
  lastSegment != goog.graphics.Path.Segment.CURVETO && (this.segments_.push(goog.graphics.Path.Segment.CURVETO), this.count_.push(0));
  for (var i = 0;i < arguments.length;i += 6) {
    var x = arguments[i + 4], y = arguments[i + 5];
    this.arguments_.push(arguments[i], arguments[i + 1], arguments[i + 2], arguments[i + 3], x, y);
  }
  this.count_[this.count_.length - 1] += i / 6;
  this.currentPoint_ = [x, y];
  return this;
};
goog.graphics.Path.prototype.close = function() {
  var lastSegment = goog.array.peek(this.segments_);
  if (null == lastSegment) {
    throw Error("Path cannot start with close");
  }
  lastSegment != goog.graphics.Path.Segment.CLOSE && (this.segments_.push(goog.graphics.Path.Segment.CLOSE), this.count_.push(1), this.currentPoint_ = this.closePoint_);
  return this;
};
goog.graphics.Path.prototype.arc = function(cx, cy, rx, ry, fromAngle, extent, connect) {
  var startX = cx + goog.math.angleDx(fromAngle, rx), startY = cy + goog.math.angleDy(fromAngle, ry);
  connect ? this.currentPoint_ && startX == this.currentPoint_[0] && startY == this.currentPoint_[1] || this.lineTo(startX, startY) : this.moveTo(startX, startY);
  return this.arcTo(rx, ry, fromAngle, extent);
};
goog.graphics.Path.prototype.arcTo = function(rx, ry, fromAngle, extent) {
  var cx = this.currentPoint_[0] - goog.math.angleDx(fromAngle, rx), cy = this.currentPoint_[1] - goog.math.angleDy(fromAngle, ry), ex = cx + goog.math.angleDx(fromAngle + extent, rx), ey = cy + goog.math.angleDy(fromAngle + extent, ry);
  this.segments_.push(goog.graphics.Path.Segment.ARCTO);
  this.count_.push(1);
  this.arguments_.push(rx, ry, fromAngle, extent, ex, ey);
  this.simple_ = !1;
  this.currentPoint_ = [ex, ey];
  return this;
};
goog.graphics.Path.prototype.arcToAsCurves = function(rx, ry, fromAngle, extent) {
  for (var cx = this.currentPoint_[0] - goog.math.angleDx(fromAngle, rx), cy = this.currentPoint_[1] - goog.math.angleDy(fromAngle, ry), extentRad = goog.math.toRadians(extent), arcSegs = Math.ceil(Math.abs(extentRad) / Math.PI * 2), inc = extentRad / arcSegs, angle = goog.math.toRadians(fromAngle), j = 0;j < arcSegs;j++) {
    var relX = Math.cos(angle), relY = Math.sin(angle), z = 4 / 3 * Math.sin(inc / 2) / (1 + Math.cos(inc / 2)), c0 = cx + (relX - z * relY) * rx, c1 = cy + (relY + z * relX) * ry, angle = angle + inc, relX = Math.cos(angle), relY = Math.sin(angle);
    this.curveTo(c0, c1, cx + (relX + z * relY) * rx, cy + (relY - z * relX) * ry, cx + relX * rx, cy + relY * ry);
  }
  return this;
};
goog.graphics.Path.prototype.forEachSegment = function(callback) {
  for (var points = this.arguments_, index = 0, i = 0, length = this.segments_.length;i < length;i++) {
    var seg = this.segments_[i], n = goog.graphics.Path.segmentArgCounts_[seg] * this.count_[i];
    callback(seg, points.slice(index, index + n));
    index += n;
  }
};
goog.graphics.Path.prototype.clone = function() {
  var path = new this.constructor;
  path.segments_ = this.segments_.concat();
  path.count_ = this.count_.concat();
  path.arguments_ = this.arguments_.concat();
  path.closePoint_ = this.closePoint_ && this.closePoint_.concat();
  path.currentPoint_ = this.currentPoint_ && this.currentPoint_.concat();
  path.simple_ = this.simple_;
  return path;
};
goog.graphics.Path.prototype.isSimple = function() {
  return this.simple_;
};
goog.graphics.Path.simplifySegmentMap_ = function() {
  var map = {};
  map[goog.graphics.Path.Segment.MOVETO] = goog.graphics.Path.prototype.moveTo;
  map[goog.graphics.Path.Segment.LINETO] = goog.graphics.Path.prototype.lineTo;
  map[goog.graphics.Path.Segment.CLOSE] = goog.graphics.Path.prototype.close;
  map[goog.graphics.Path.Segment.CURVETO] = goog.graphics.Path.prototype.curveTo;
  map[goog.graphics.Path.Segment.ARCTO] = goog.graphics.Path.prototype.arcToAsCurves;
  return map;
}();
goog.graphics.Path.createSimplifiedPath = function(src) {
  if (src.isSimple()) {
    return src.clone();
  }
  var path = new goog.graphics.Path;
  src.forEachSegment(function(segment, args) {
    goog.graphics.Path.simplifySegmentMap_[segment].apply(path, args);
  });
  return path;
};
goog.graphics.Path.prototype.transform = function(tx) {
  if (!this.isSimple()) {
    throw Error("Non-simple path");
  }
  tx.transform(this.arguments_, 0, this.arguments_, 0, this.arguments_.length / 2);
  this.closePoint_ && tx.transform(this.closePoint_, 0, this.closePoint_, 0, 1);
  this.currentPoint_ && this.closePoint_ != this.currentPoint_ && tx.transform(this.currentPoint_, 0, this.currentPoint_, 0, 1);
  return this;
};
goog.graphics.Path.prototype.isEmpty = function() {
  return 0 == this.segments_.length;
};
// INPUT (javascript/closure/graphics/abstractgraphics.js)
goog.graphics.AbstractGraphics = function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper) {
  goog.ui.Component.call(this, opt_domHelper);
  this.width = width;
  this.height = height;
  this.coordWidth = opt_coordWidth || null;
  this.coordHeight = opt_coordHeight || null;
};
goog.inherits(goog.graphics.AbstractGraphics, goog.ui.Component);
goog.graphics.AbstractGraphics.prototype.canvasElement = null;
goog.graphics.AbstractGraphics.prototype.coordLeft = 0;
goog.graphics.AbstractGraphics.prototype.coordTop = 0;
goog.graphics.AbstractGraphics.prototype.getCanvasElement = function() {
  return this.canvasElement;
};
goog.graphics.AbstractGraphics.prototype.getCoordSize = function() {
  return this.coordWidth ? new goog.math.Size(this.coordWidth, this.coordHeight) : this.getPixelSize();
};
goog.graphics.AbstractGraphics.prototype.getSize = function() {
  return this.getPixelSize();
};
goog.graphics.AbstractGraphics.prototype.getPixelSize = function() {
  return this.isInDocument() ? goog.style.getSize(this.getElement()) : goog.isNumber(this.width) && goog.isNumber(this.height) ? new goog.math.Size(this.width, this.height) : null;
};
goog.graphics.AbstractGraphics.prototype.getPixelScaleX = function() {
  var pixelSize = this.getPixelSize();
  return pixelSize ? pixelSize.width / this.getCoordSize().width : 0;
};
goog.graphics.AbstractGraphics.prototype.getPixelScaleY = function() {
  var pixelSize = this.getPixelSize();
  return pixelSize ? pixelSize.height / this.getCoordSize().height : 0;
};
goog.graphics.AbstractGraphics.prototype.removeElement = function(element) {
  goog.dom.removeNode(element.getElement());
};
goog.graphics.AbstractGraphics.prototype.drawCircle = function(cx, cy, r, stroke, fill, opt_group) {
  return this.drawEllipse(cx, cy, r, r, stroke, fill, opt_group);
};
goog.graphics.AbstractGraphics.prototype.drawText = function(text, x, y, width, height, align, vAlign, font, stroke, fill, opt_group) {
  var baseline = font.size / 2, textY;
  textY = "bottom" == vAlign ? y + height - baseline : "center" == vAlign ? y + height / 2 : y + baseline;
  return this.drawTextOnLine(text, x, textY, x + width, textY, align, font, stroke, fill, opt_group);
};
goog.graphics.AbstractGraphics.prototype.createPath = function() {
  return new goog.graphics.Path;
};
goog.graphics.AbstractGraphics.prototype.resume = function() {
};
// INPUT (javascript/closure/graphics/affinetransform.js)
goog.graphics.AffineTransform = function(opt_m00, opt_m10, opt_m01, opt_m11, opt_m02, opt_m12) {
  if (6 == arguments.length) {
    this.setTransform(opt_m00, opt_m10, opt_m01, opt_m11, opt_m02, opt_m12);
  } else {
    if (0 != arguments.length) {
      throw Error("Insufficient matrix parameters");
    }
    this.m00_ = this.m11_ = 1;
    this.m10_ = this.m01_ = this.m02_ = this.m12_ = 0;
  }
};
goog.graphics.AffineTransform.prototype.clone = function() {
  return new goog.graphics.AffineTransform(this.m00_, this.m10_, this.m01_, this.m11_, this.m02_, this.m12_);
};
goog.graphics.AffineTransform.prototype.setTransform = function(m00, m10, m01, m11, m02, m12) {
  if (!(goog.isNumber(m00) && goog.isNumber(m10) && goog.isNumber(m01) && goog.isNumber(m11) && goog.isNumber(m02) && goog.isNumber(m12))) {
    throw Error("Invalid transform parameters");
  }
  this.m00_ = m00;
  this.m10_ = m10;
  this.m01_ = m01;
  this.m11_ = m11;
  this.m02_ = m02;
  this.m12_ = m12;
  return this;
};
goog.graphics.AffineTransform.prototype.copyFrom = function(tx) {
  this.m00_ = tx.m00_;
  this.m10_ = tx.m10_;
  this.m01_ = tx.m01_;
  this.m11_ = tx.m11_;
  this.m02_ = tx.m02_;
  this.m12_ = tx.m12_;
  return this;
};
goog.graphics.AffineTransform.prototype.scale = function(sx, sy) {
  this.m00_ *= sx;
  this.m10_ *= sx;
  this.m01_ *= sy;
  this.m11_ *= sy;
  return this;
};
goog.graphics.AffineTransform.prototype.translate = function(dx, dy) {
  this.m02_ += dx * this.m00_ + dy * this.m01_;
  this.m12_ += dx * this.m10_ + dy * this.m11_;
  return this;
};
goog.graphics.AffineTransform.prototype.rotate = function(theta, x, y) {
  return this.concatenate(goog.graphics.AffineTransform.getRotateInstance(theta, x, y));
};
goog.graphics.AffineTransform.prototype.toString = function() {
  return "matrix(" + [this.m00_, this.m10_, this.m01_, this.m11_, this.m02_, this.m12_].join() + ")";
};
goog.graphics.AffineTransform.prototype.getScaleX = function() {
  return this.m00_;
};
goog.graphics.AffineTransform.prototype.getScaleY = function() {
  return this.m11_;
};
goog.graphics.AffineTransform.prototype.getTranslateX = function() {
  return this.m02_;
};
goog.graphics.AffineTransform.prototype.getTranslateY = function() {
  return this.m12_;
};
goog.graphics.AffineTransform.prototype.getShearX = function() {
  return this.m01_;
};
goog.graphics.AffineTransform.prototype.getShearY = function() {
  return this.m10_;
};
goog.graphics.AffineTransform.prototype.concatenate = function(tx) {
  var m0 = this.m00_, m1 = this.m01_;
  this.m00_ = tx.m00_ * m0 + tx.m10_ * m1;
  this.m01_ = tx.m01_ * m0 + tx.m11_ * m1;
  this.m02_ += tx.m02_ * m0 + tx.m12_ * m1;
  m0 = this.m10_;
  m1 = this.m11_;
  this.m10_ = tx.m00_ * m0 + tx.m10_ * m1;
  this.m11_ = tx.m01_ * m0 + tx.m11_ * m1;
  this.m12_ += tx.m02_ * m0 + tx.m12_ * m1;
  return this;
};
goog.graphics.AffineTransform.prototype.transform = function(src, srcOff, dst, dstOff, numPts) {
  for (var i = srcOff, j = dstOff, srcEnd = srcOff + 2 * numPts;i < srcEnd;) {
    var x = src[i++], y = src[i++];
    dst[j++] = x * this.m00_ + y * this.m01_ + this.m02_;
    dst[j++] = x * this.m10_ + y * this.m11_ + this.m12_;
  }
};
goog.graphics.AffineTransform.getScaleInstance = function(sx, sy) {
  return(new goog.graphics.AffineTransform).setToScale(sx, sy);
};
goog.graphics.AffineTransform.getTranslateInstance = function(dx, dy) {
  return(new goog.graphics.AffineTransform).setToTranslation(dx, dy);
};
goog.graphics.AffineTransform.getShearInstance = function(shx, shy) {
  return(new goog.graphics.AffineTransform).setToShear(shx, shy);
};
goog.graphics.AffineTransform.getRotateInstance = function(theta, x, y) {
  return(new goog.graphics.AffineTransform).setToRotation(theta, x, y);
};
goog.graphics.AffineTransform.prototype.setToScale = function(sx, sy) {
  return this.setTransform(sx, 0, 0, sy, 0, 0);
};
goog.graphics.AffineTransform.prototype.setToTranslation = function(dx, dy) {
  return this.setTransform(1, 0, 0, 1, dx, dy);
};
goog.graphics.AffineTransform.prototype.setToShear = function(shx, shy) {
  return this.setTransform(1, shy, shx, 1, 0, 0);
};
goog.graphics.AffineTransform.prototype.setToRotation = function(theta, x, y) {
  var cos = Math.cos(theta), sin = Math.sin(theta);
  return this.setTransform(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);
};
goog.graphics.AffineTransform.prototype.equals = function(tx) {
  return this == tx ? !0 : tx ? this.m00_ == tx.m00_ && this.m01_ == tx.m01_ && this.m02_ == tx.m02_ && this.m10_ == tx.m10_ && this.m11_ == tx.m11_ && this.m12_ == tx.m12_ : !1;
};
// INPUT (javascript/closure/graphics/element.js)
goog.graphics.Element = function(element, graphics) {
  goog.events.EventTarget.call(this);
  this.element_ = element;
  this.graphics_ = graphics;
  this[goog.events.Listenable.IMPLEMENTED_BY_PROP] = !1;
};
goog.inherits(goog.graphics.Element, goog.events.EventTarget);
goog.graphics.Element.prototype.graphics_ = null;
goog.graphics.Element.prototype.element_ = null;
goog.graphics.Element.prototype.transform_ = null;
goog.graphics.Element.prototype.getElement = function() {
  return this.element_;
};
goog.graphics.Element.prototype.getGraphics = function() {
  return this.graphics_;
};
goog.graphics.Element.prototype.getTransform = function() {
  return this.transform_ ? this.transform_.clone() : new goog.graphics.AffineTransform;
};
goog.graphics.Element.prototype.setTransform = function(affineTransform) {
  this.transform_ = affineTransform.clone();
  this.getGraphics().setElementAffineTransform(this, affineTransform);
};
goog.graphics.Element.prototype.addEventListener = function(type, handler, opt_capture, opt_handlerScope) {
  goog.events.listen(this.element_, type, handler, opt_capture, opt_handlerScope);
};
goog.graphics.Element.prototype.removeEventListener = function(type, handler, opt_capture, opt_handlerScope) {
  goog.events.unlisten(this.element_, type, handler, opt_capture, opt_handlerScope);
};
goog.graphics.Element.prototype.disposeInternal = function() {
  goog.graphics.Element.superClass_.disposeInternal.call(this);
  goog.asserts.assert(this.element_);
  goog.events.removeAll(this.element_);
};
// INPUT (javascript/closure/graphics/strokeandfillelement.js)
goog.graphics.StrokeAndFillElement = function(element, graphics, stroke, fill) {
  goog.graphics.Element.call(this, element, graphics);
  this.setStroke(stroke);
  this.setFill(fill);
};
goog.inherits(goog.graphics.StrokeAndFillElement, goog.graphics.Element);
goog.graphics.StrokeAndFillElement.prototype.fill = null;
goog.graphics.StrokeAndFillElement.prototype.stroke_ = null;
goog.graphics.StrokeAndFillElement.prototype.setFill = function(fill) {
  this.fill = fill;
  this.getGraphics().setElementFill(this, fill);
};
goog.graphics.StrokeAndFillElement.prototype.getFill = function() {
  return this.fill;
};
goog.graphics.StrokeAndFillElement.prototype.setStroke = function(stroke) {
  this.stroke_ = stroke;
  this.getGraphics().setElementStroke(this, stroke);
};
goog.graphics.StrokeAndFillElement.prototype.getStroke = function() {
  return this.stroke_;
};
// INPUT (javascript/closure/graphics/ellipseelement.js)
goog.graphics.EllipseElement = function(element, graphics, stroke, fill) {
  goog.graphics.StrokeAndFillElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.EllipseElement, goog.graphics.StrokeAndFillElement);
// INPUT (javascript/closure/graphics/groupelement.js)
goog.graphics.GroupElement = function(element, graphics) {
  goog.graphics.Element.call(this, element, graphics);
};
goog.inherits(goog.graphics.GroupElement, goog.graphics.Element);
// INPUT (javascript/closure/graphics/imageelement.js)
goog.graphics.ImageElement = function(element, graphics) {
  goog.graphics.Element.call(this, element, graphics);
};
goog.inherits(goog.graphics.ImageElement, goog.graphics.Element);
// INPUT (javascript/closure/graphics/pathelement.js)
goog.graphics.PathElement = function(element, graphics, stroke, fill) {
  goog.graphics.StrokeAndFillElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.PathElement, goog.graphics.StrokeAndFillElement);
// INPUT (javascript/closure/graphics/rectelement.js)
goog.graphics.RectElement = function(element, graphics, stroke, fill) {
  goog.graphics.StrokeAndFillElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.RectElement, goog.graphics.StrokeAndFillElement);
// INPUT (javascript/closure/graphics/textelement.js)
goog.graphics.TextElement = function(element, graphics, stroke, fill) {
  goog.graphics.StrokeAndFillElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.TextElement, goog.graphics.StrokeAndFillElement);
// INPUT (javascript/closure/graphics/canvaselement.js)
goog.graphics.CanvasGroupElement = function(graphics) {
  goog.graphics.GroupElement.call(this, null, graphics);
  this.children_ = [];
};
goog.inherits(goog.graphics.CanvasGroupElement, goog.graphics.GroupElement);
goog.graphics.CanvasGroupElement.prototype.clear = function() {
  this.children_.length && (this.children_.length = 0, this.getGraphics().redraw());
};
goog.graphics.CanvasGroupElement.prototype.setSize = function() {
};
goog.graphics.CanvasGroupElement.prototype.appendChild = function(element) {
  this.children_.push(element);
};
goog.graphics.CanvasGroupElement.prototype.draw = function() {
  for (var i = 0, len = this.children_.length;i < len;i++) {
    this.getGraphics().drawElement(this.children_[i]);
  }
};
goog.graphics.CanvasEllipseElement = function(element, graphics, cx, cy, rx, ry, stroke, fill) {
  goog.graphics.EllipseElement.call(this, element, graphics, stroke, fill);
  this.cx_ = cx;
  this.cy_ = cy;
  this.rx_ = rx;
  this.ry_ = ry;
  this.path_ = new goog.graphics.Path;
  this.setUpPath_();
  this.pathElement_ = new goog.graphics.CanvasPathElement(null, graphics, this.path_, stroke, fill);
};
goog.inherits(goog.graphics.CanvasEllipseElement, goog.graphics.EllipseElement);
goog.graphics.CanvasEllipseElement.prototype.setUpPath_ = function() {
  this.path_.clear();
  this.path_.moveTo(this.cx_ + goog.math.angleDx(0, this.rx_), this.cy_ + goog.math.angleDy(0, this.ry_));
  this.path_.arcTo(this.rx_, this.ry_, 0, 360);
  this.path_.close();
};
goog.graphics.CanvasEllipseElement.prototype.setCenter = function(cx, cy) {
  this.cx_ = cx;
  this.cy_ = cy;
  this.setUpPath_();
  this.pathElement_.setPath(this.path_);
};
goog.graphics.CanvasEllipseElement.prototype.setRadius = function(rx, ry) {
  this.rx_ = rx;
  this.ry_ = ry;
  this.setUpPath_();
  this.pathElement_.setPath(this.path_);
};
goog.graphics.CanvasEllipseElement.prototype.draw = function(ctx) {
  this.pathElement_.draw(ctx);
};
goog.graphics.CanvasRectElement = function(element, graphics, x, y, w, h, stroke, fill) {
  goog.graphics.RectElement.call(this, element, graphics, stroke, fill);
  this.x_ = x;
  this.y_ = y;
  this.w_ = w;
  this.h_ = h;
};
goog.inherits(goog.graphics.CanvasRectElement, goog.graphics.RectElement);
goog.graphics.CanvasRectElement.prototype.setPosition = function(x, y) {
  this.x_ = x;
  this.y_ = y;
  this.drawn_ && this.getGraphics().redraw();
};
goog.graphics.CanvasRectElement.prototype.drawn_ = !1;
goog.graphics.CanvasRectElement.prototype.setSize = function(width, height) {
  this.w_ = width;
  this.h_ = height;
  this.drawn_ && this.getGraphics().redraw();
};
goog.graphics.CanvasRectElement.prototype.draw = function(ctx) {
  this.drawn_ = !0;
  ctx.beginPath();
  ctx.moveTo(this.x_, this.y_);
  ctx.lineTo(this.x_, this.y_ + this.h_);
  ctx.lineTo(this.x_ + this.w_, this.y_ + this.h_);
  ctx.lineTo(this.x_ + this.w_, this.y_);
  ctx.closePath();
};
goog.graphics.CanvasPathElement = function(element, graphics, path, stroke, fill) {
  goog.graphics.PathElement.call(this, element, graphics, stroke, fill);
  this.setPath(path);
};
goog.inherits(goog.graphics.CanvasPathElement, goog.graphics.PathElement);
goog.graphics.CanvasPathElement.prototype.drawn_ = !1;
goog.graphics.CanvasPathElement.prototype.setPath = function(path) {
  this.path_ = path.isSimple() ? path : goog.graphics.Path.createSimplifiedPath(path);
  this.drawn_ && this.getGraphics().redraw();
};
goog.graphics.CanvasPathElement.prototype.draw = function(ctx) {
  this.drawn_ = !0;
  ctx.beginPath();
  this.path_.forEachSegment(function(segment, args) {
    switch(segment) {
      case goog.graphics.Path.Segment.MOVETO:
        ctx.moveTo(args[0], args[1]);
        break;
      case goog.graphics.Path.Segment.LINETO:
        for (var i = 0;i < args.length;i += 2) {
          ctx.lineTo(args[i], args[i + 1]);
        }
        break;
      case goog.graphics.Path.Segment.CURVETO:
        for (i = 0;i < args.length;i += 6) {
          ctx.bezierCurveTo(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]);
        }
        break;
      case goog.graphics.Path.Segment.ARCTO:
        throw Error("Canvas paths cannot contain arcs");;
      case goog.graphics.Path.Segment.CLOSE:
        ctx.closePath();
    }
  });
};
goog.graphics.CanvasTextElement = function(graphics, text, x1, y1, x2, y2, align, font, stroke, fill) {
  var element = goog.dom.createDom(goog.dom.TagName.DIV, {style:"display:table;position:absolute;padding:0;margin:0;border:0"});
  goog.graphics.TextElement.call(this, element, graphics, stroke, fill);
  this.text_ = text;
  this.x1_ = x1;
  this.y1_ = y1;
  this.x2_ = x2;
  this.y2_ = y2;
  this.align_ = align || "left";
  this.font_ = font;
  this.innerElement_ = goog.dom.createDom("DIV", {style:"display:table-cell;padding: 0;margin: 0;border: 0"});
  this.updateStyle_();
  this.updateText_();
  graphics.getElement().appendChild(element);
  element.appendChild(this.innerElement_);
};
goog.inherits(goog.graphics.CanvasTextElement, goog.graphics.TextElement);
goog.graphics.CanvasTextElement.prototype.setText = function(text) {
  this.text_ = text;
  this.updateText_();
};
goog.graphics.CanvasTextElement.prototype.setFill = function(fill) {
  this.fill = fill;
  var element = this.getElement();
  element && (element.style.color = fill.getColor() || fill.getColor1());
};
goog.graphics.CanvasTextElement.prototype.setStroke = function() {
};
goog.graphics.CanvasTextElement.prototype.draw = function() {
};
goog.graphics.CanvasTextElement.prototype.updateStyle_ = function() {
  var x1 = this.x1_, x2 = this.x2_, y1 = this.y1_, y2 = this.y2_, align = this.align_, font = this.font_, style = this.getElement().style, scaleX = this.getGraphics().getPixelScaleX(), scaleY = this.getGraphics().getPixelScaleY();
  if (x1 == x2) {
    style.lineHeight = "90%";
    this.innerElement_.style.verticalAlign = "center" == align ? "middle" : "left" == align ? y1 < y2 ? "top" : "bottom" : y1 < y2 ? "bottom" : "top";
    style.textAlign = "center";
    var w = font.size * scaleX;
    style.top = Math.round(Math.min(y1, y2) * scaleY) + "px";
    style.left = Math.round((x1 - w / 2) * scaleX) + "px";
    style.width = Math.round(w) + "px";
    style.height = Math.abs(y1 - y2) * scaleY + "px";
    style.fontSize = .6 * font.size * scaleY + "pt";
  } else {
    style.lineHeight = "100%", this.innerElement_.style.verticalAlign = "top", style.textAlign = align, style.top = Math.round(((y1 + y2) / 2 - 2 * font.size / 3) * scaleY) + "px", style.left = Math.round(x1 * scaleX) + "px", style.width = Math.round(Math.abs(x2 - x1) * scaleX) + "px", style.height = "auto", style.fontSize = font.size * scaleY + "pt";
  }
  style.fontWeight = font.bold ? "bold" : "normal";
  style.fontStyle = font.italic ? "italic" : "normal";
  style.fontFamily = font.family;
  var fill = this.getFill();
  style.color = fill.getColor() || fill.getColor1();
};
goog.graphics.CanvasTextElement.prototype.updateText_ = function() {
  this.innerElement_.innerHTML = this.x1_ == this.x2_ ? goog.array.map(this.text_.split(""), function(entry) {
    return goog.string.htmlEscape(entry);
  }).join("<br>") : goog.string.htmlEscape(this.text_);
};
goog.graphics.CanvasImageElement = function(element, graphics, x, y, w, h, src) {
  goog.graphics.ImageElement.call(this, element, graphics);
  this.x_ = x;
  this.y_ = y;
  this.w_ = w;
  this.h_ = h;
  this.src_ = src;
};
goog.inherits(goog.graphics.CanvasImageElement, goog.graphics.ImageElement);
goog.graphics.CanvasImageElement.prototype.drawn_ = !1;
goog.graphics.CanvasImageElement.prototype.setPosition = function(x, y) {
  this.x_ = x;
  this.y_ = y;
  this.drawn_ && this.getGraphics().redraw();
};
goog.graphics.CanvasImageElement.prototype.setSize = function(width, height) {
  this.w_ = width;
  this.h_ = height;
  this.drawn_ && this.getGraphics().redraw();
};
goog.graphics.CanvasImageElement.prototype.draw = function(ctx) {
  if (this.img_) {
    this.w_ && this.h_ && ctx.drawImage(this.img_, this.x_, this.y_, this.w_, this.h_), this.drawn_ = !0;
  } else {
    var img = new Image;
    img.onload = goog.bind(this.handleImageLoad_, this, img);
    img.src = this.src_;
  }
};
goog.graphics.CanvasImageElement.prototype.handleImageLoad_ = function(img) {
  this.img_ = img;
  this.getGraphics().redraw();
};
// INPUT (javascript/closure/graphics/fill.js)
goog.graphics.Fill = function() {
};
// INPUT (javascript/closure/graphics/solidfill.js)
goog.graphics.SolidFill = function(color, opt_opacity) {
  this.color_ = color;
  this.opacity_ = null == opt_opacity ? 1 : opt_opacity;
};
goog.inherits(goog.graphics.SolidFill, goog.graphics.Fill);
goog.graphics.SolidFill.prototype.getColor = function() {
  return this.color_;
};
goog.graphics.SolidFill.prototype.getOpacity = function() {
  return this.opacity_;
};
// INPUT (javascript/closure/graphics/canvasgraphics.js)
goog.graphics.CanvasGraphics = function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper) {
  goog.graphics.AbstractGraphics.call(this, width, height, opt_coordWidth, opt_coordHeight, opt_domHelper);
};
goog.inherits(goog.graphics.CanvasGraphics, goog.graphics.AbstractGraphics);
goog.graphics.CanvasGraphics.prototype.setElementFill = function() {
  this.redraw();
};
goog.graphics.CanvasGraphics.prototype.setElementStroke = function() {
  this.redraw();
};
goog.graphics.CanvasGraphics.prototype.setElementAffineTransform = function() {
  this.redraw();
};
goog.graphics.CanvasGraphics.prototype.pushElementTransform = function(element) {
  var ctx = this.getContext();
  ctx.save();
  var transform = element.getTransform(), tx = transform.getTranslateX(), ty = transform.getTranslateY();
  (tx || ty) && ctx.translate(tx, ty);
  var sinTheta = transform.getShearY();
  sinTheta && ctx.rotate(Math.asin(sinTheta));
};
goog.graphics.CanvasGraphics.prototype.popElementTransform = function() {
  this.getContext().restore();
};
goog.graphics.CanvasGraphics.prototype.createDom = function() {
  var element = this.dom_.createDom("div", {style:"position:relative;overflow:hidden"});
  this.setElementInternal(element);
  this.canvas_ = this.dom_.createDom("canvas");
  element.appendChild(this.canvas_);
  this.lastGroup_ = this.canvasElement = new goog.graphics.CanvasGroupElement(this);
  this.redrawTimeout_ = 0;
  this.updateSize();
};
goog.graphics.CanvasGraphics.prototype.clearContext_ = function() {
  this.context_ = null;
};
goog.graphics.CanvasGraphics.prototype.getContext = function() {
  this.getElement() || this.createDom();
  this.context_ || (this.context_ = this.canvas_.getContext("2d"), this.context_.save());
  return this.context_;
};
goog.graphics.CanvasGraphics.prototype.setSize = function(pixelWidth, pixelHeight) {
  this.width = pixelWidth;
  this.height = pixelHeight;
  this.updateSize();
  this.redraw();
};
goog.graphics.CanvasGraphics.prototype.getPixelSize = function() {
  var width = this.width, height = this.height, computeWidth = goog.isString(width) && -1 != width.indexOf("%"), computeHeight = goog.isString(height) && -1 != height.indexOf("%");
  if (!this.isInDocument() && (computeWidth || computeHeight)) {
    return null;
  }
  var parent, parentSize;
  computeWidth && (parent = this.getElement().parentNode, parentSize = goog.style.getSize(parent), width = parseFloat(width) * parentSize.width / 100);
  computeHeight && (parent = parent || this.getElement().parentNode, parentSize = parentSize || goog.style.getSize(parent), height = parseFloat(height) * parentSize.height / 100);
  return new goog.math.Size(width, height);
};
goog.graphics.CanvasGraphics.prototype.updateSize = function() {
  goog.style.setSize(this.getElement(), this.width, this.height);
  var pixels = this.getPixelSize();
  pixels && (goog.style.setSize(this.canvas_, pixels.width, pixels.height), this.canvas_.width = pixels.width, this.canvas_.height = pixels.height, this.clearContext_());
};
goog.graphics.CanvasGraphics.prototype.reset = function() {
  var ctx = this.getContext();
  ctx.restore();
  var size = this.getPixelSize();
  size.width && size.height && ctx.clearRect(0, 0, size.width, size.height);
  ctx.save();
};
goog.graphics.CanvasGraphics.prototype.clear = function() {
  this.reset();
  this.canvasElement.clear();
  for (var el = this.getElement();1 < el.childNodes.length;) {
    el.removeChild(el.lastChild);
  }
};
goog.graphics.CanvasGraphics.prototype.redraw = function() {
  if (this.preventRedraw_) {
    this.needsRedraw_ = !0;
  } else {
    if (this.isInDocument()) {
      this.reset();
      if (this.coordWidth) {
        var pixels = this.getPixelSize();
        this.getContext().scale(pixels.width / this.coordWidth, pixels.height / this.coordHeight);
      }
      (this.coordLeft || this.coordTop) && this.getContext().translate(-this.coordLeft, -this.coordTop);
      this.pushElementTransform(this.canvasElement);
      this.canvasElement.draw(this.context_);
      this.popElementTransform();
    }
  }
};
goog.graphics.CanvasGraphics.prototype.drawElement = function(element) {
  if (!(element instanceof goog.graphics.CanvasTextElement)) {
    var ctx = this.getContext();
    this.pushElementTransform(element);
    if (element.getFill && element.getStroke) {
      var fill = element.getFill();
      if (fill) {
        if (fill instanceof goog.graphics.SolidFill) {
          0 != fill.getOpacity() && (ctx.globalAlpha = fill.getOpacity(), ctx.fillStyle = fill.getColor(), element.draw(ctx), ctx.fill(), ctx.globalAlpha = 1);
        } else {
          var linearGradient = ctx.createLinearGradient(fill.getX1(), fill.getY1(), fill.getX2(), fill.getY2());
          linearGradient.addColorStop(0, fill.getColor1());
          linearGradient.addColorStop(1, fill.getColor2());
          ctx.fillStyle = linearGradient;
          element.draw(ctx);
          ctx.fill();
        }
      }
      var stroke = element.getStroke();
      if (stroke) {
        element.draw(ctx);
        ctx.strokeStyle = stroke.getColor();
        var width = stroke.getWidth();
        goog.isString(width) && -1 != width.indexOf("px") && (width = parseFloat(width) / this.getPixelScaleX());
        ctx.lineWidth = width;
        ctx.stroke();
      }
    } else {
      element.draw(ctx);
    }
    this.popElementTransform();
  }
};
goog.graphics.CanvasGraphics.prototype.append_ = function(element, group) {
  this.append(element, group);
};
goog.graphics.CanvasGraphics.prototype.append = function(element, group) {
  group = group || this.canvasElement;
  group.appendChild(element);
  this.isDrawable(group) && this.drawElement(element);
};
goog.graphics.CanvasGraphics.prototype.drawEllipse = function(cx, cy, rx, ry, stroke, fill, opt_group) {
  var element = new goog.graphics.CanvasEllipseElement(null, this, cx, cy, rx, ry, stroke, fill);
  this.append(element, opt_group);
  return element;
};
goog.graphics.CanvasGraphics.prototype.drawRect = function(x, y, width, height, stroke, fill, opt_group) {
  var element = new goog.graphics.CanvasRectElement(null, this, x, y, width, height, stroke, fill);
  this.append(element, opt_group);
  return element;
};
goog.graphics.CanvasGraphics.prototype.drawImage = function(x, y, width, height, src, opt_group) {
  var element = new goog.graphics.CanvasImageElement(null, this, x, y, width, height, src);
  this.append(element, opt_group);
  return element;
};
goog.graphics.CanvasGraphics.prototype.drawTextOnLine = function(text, x1, y1, x2, y2, align, font, stroke, fill, opt_group) {
  var element = new goog.graphics.CanvasTextElement(this, text, x1, y1, x2, y2, align, font, stroke, fill);
  this.append(element, opt_group);
  return element;
};
goog.graphics.CanvasGraphics.prototype.drawPath = function(path, stroke, fill, opt_group) {
  var element = new goog.graphics.CanvasPathElement(null, this, path, stroke, fill);
  this.append(element, opt_group);
  return element;
};
goog.graphics.CanvasGraphics.prototype.isDrawable = function(group) {
  return this.isInDocument() && !this.redrawTimeout_ && !this.isRedrawRequired(group);
};
goog.graphics.CanvasGraphics.prototype.isRedrawRequired = function(group) {
  return group != this.canvasElement && group != this.lastGroup_;
};
goog.graphics.CanvasGraphics.prototype.createGroup = function(opt_group) {
  var group = new goog.graphics.CanvasGroupElement(this);
  opt_group = opt_group || this.canvasElement;
  if (opt_group == this.canvasElement || opt_group == this.lastGroup_) {
    this.lastGroup_ = group;
  }
  this.append(group, opt_group);
  return group;
};
goog.graphics.CanvasGraphics.prototype.disposeInternal = function() {
  this.context_ = null;
  goog.graphics.CanvasGraphics.superClass_.disposeInternal.call(this);
};
goog.graphics.CanvasGraphics.prototype.enterDocument = function() {
  var oldPixelSize = this.getPixelSize();
  goog.graphics.CanvasGraphics.superClass_.enterDocument.call(this);
  oldPixelSize || (this.updateSize(), this.dispatchEvent(goog.events.EventType.RESIZE));
  this.redraw();
};
goog.graphics.CanvasGraphics.prototype.resume = function() {
  this.preventRedraw_ = !1;
  this.needsRedraw_ && (this.redraw(), this.needsRedraw_ = !1);
};
// INPUT (javascript/closure/graphics/lineargradient.js)
goog.graphics.LinearGradient = function(x1, y1, x2, y2, color1, color2, opt_opacity1, opt_opacity2) {
  this.x1_ = x1;
  this.y1_ = y1;
  this.x2_ = x2;
  this.y2_ = y2;
  this.color1_ = color1;
  this.color2_ = color2;
  goog.asserts.assert(goog.isNumber(opt_opacity1) == goog.isNumber(opt_opacity2), "Both or neither of opt_opacity1 and opt_opacity2 have to be set.");
  this.opacity1_ = goog.isDef(opt_opacity1) ? opt_opacity1 : null;
  this.opacity2_ = goog.isDef(opt_opacity2) ? opt_opacity2 : null;
};
goog.inherits(goog.graphics.LinearGradient, goog.graphics.Fill);
goog.graphics.LinearGradient.prototype.getX1 = function() {
  return this.x1_;
};
goog.graphics.LinearGradient.prototype.getY1 = function() {
  return this.y1_;
};
goog.graphics.LinearGradient.prototype.getX2 = function() {
  return this.x2_;
};
goog.graphics.LinearGradient.prototype.getY2 = function() {
  return this.y2_;
};
goog.graphics.LinearGradient.prototype.getColor1 = function() {
  return this.color1_;
};
goog.graphics.LinearGradient.prototype.getColor2 = function() {
  return this.color2_;
};
goog.graphics.LinearGradient.prototype.getOpacity1 = function() {
  return this.opacity1_;
};
goog.graphics.LinearGradient.prototype.getOpacity2 = function() {
  return this.opacity2_;
};
// INPUT (javascript/closure/graphics/stroke.js)
goog.graphics.Stroke = function(width, color, opt_opacity) {
  this.width_ = width;
  this.color_ = color;
  this.opacity_ = null == opt_opacity ? 1 : opt_opacity;
};
goog.graphics.Stroke.prototype.getWidth = function() {
  return this.width_;
};
goog.graphics.Stroke.prototype.getColor = function() {
  return this.color_;
};
goog.graphics.Stroke.prototype.getOpacity = function() {
  return this.opacity_;
};
// INPUT (javascript/closure/graphics/svgelement.js)
goog.graphics.SvgGroupElement = function(element, graphics) {
  goog.graphics.GroupElement.call(this, element, graphics);
};
goog.inherits(goog.graphics.SvgGroupElement, goog.graphics.GroupElement);
goog.graphics.SvgGroupElement.prototype.clear = function() {
  goog.dom.removeChildren(this.getElement());
};
goog.graphics.SvgGroupElement.prototype.setSize = function(width, height) {
  this.getGraphics().setElementAttributes(this.getElement(), {width:width, height:height});
};
goog.graphics.SvgEllipseElement = function(element, graphics, stroke, fill) {
  goog.graphics.EllipseElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.SvgEllipseElement, goog.graphics.EllipseElement);
goog.graphics.SvgEllipseElement.prototype.setCenter = function(cx, cy) {
  this.getGraphics().setElementAttributes(this.getElement(), {cx:cx, cy:cy});
};
goog.graphics.SvgEllipseElement.prototype.setRadius = function(rx, ry) {
  this.getGraphics().setElementAttributes(this.getElement(), {rx:rx, ry:ry});
};
goog.graphics.SvgRectElement = function(element, graphics, stroke, fill) {
  goog.graphics.RectElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.SvgRectElement, goog.graphics.RectElement);
goog.graphics.SvgRectElement.prototype.setPosition = function(x, y) {
  this.getGraphics().setElementAttributes(this.getElement(), {x:x, y:y});
};
goog.graphics.SvgRectElement.prototype.setSize = function(width, height) {
  this.getGraphics().setElementAttributes(this.getElement(), {width:width, height:height});
};
goog.graphics.SvgPathElement = function(element, graphics, stroke, fill) {
  goog.graphics.PathElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.SvgPathElement, goog.graphics.PathElement);
goog.graphics.SvgPathElement.prototype.setPath = function(path) {
  this.getGraphics().setElementAttributes(this.getElement(), {d:goog.graphics.SvgGraphics.getSvgPath(path)});
};
goog.graphics.SvgTextElement = function(element, graphics, stroke, fill) {
  goog.graphics.TextElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.SvgTextElement, goog.graphics.TextElement);
goog.graphics.SvgTextElement.prototype.setText = function(text) {
  this.getElement().firstChild.data = text;
};
goog.graphics.SvgImageElement = function(element, graphics) {
  goog.graphics.ImageElement.call(this, element, graphics);
};
goog.inherits(goog.graphics.SvgImageElement, goog.graphics.ImageElement);
goog.graphics.SvgImageElement.prototype.setPosition = function(x, y) {
  this.getGraphics().setElementAttributes(this.getElement(), {x:x, y:y});
};
goog.graphics.SvgImageElement.prototype.setSize = function(width, height) {
  this.getGraphics().setElementAttributes(this.getElement(), {width:width, height:height});
};
// INPUT (javascript/closure/graphics/svggraphics.js)
goog.graphics.SvgGraphics = function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper) {
  goog.graphics.AbstractGraphics.call(this, width, height, opt_coordWidth, opt_coordHeight, opt_domHelper);
  this.defs_ = {};
  this.useManualViewbox_ = goog.userAgent.WEBKIT && !goog.userAgent.isVersionOrHigher(526);
  this.handler_ = new goog.events.EventHandler(this);
};
goog.inherits(goog.graphics.SvgGraphics, goog.graphics.AbstractGraphics);
goog.graphics.SvgGraphics.SVG_NS_ = "http://www.w3.org/2000/svg";
goog.graphics.SvgGraphics.DEF_ID_PREFIX_ = "_svgdef_";
goog.graphics.SvgGraphics.nextDefId_ = 0;
goog.graphics.SvgGraphics.prototype.createSvgElement_ = function(tagName, opt_attributes) {
  var element = this.dom_.getDocument().createElementNS(goog.graphics.SvgGraphics.SVG_NS_, tagName);
  opt_attributes && this.setElementAttributes(element, opt_attributes);
  return element;
};
goog.graphics.SvgGraphics.prototype.setElementAttributes = function(element, attributes) {
  for (var key in attributes) {
    element.setAttribute(key, attributes[key]);
  }
};
goog.graphics.SvgGraphics.prototype.append_ = function(element, opt_group) {
  var parent = opt_group || this.canvasElement;
  parent.getElement().appendChild(element.getElement());
};
goog.graphics.SvgGraphics.prototype.setElementFill = function(element, fill) {
  var svgElement = element.getElement();
  if (fill instanceof goog.graphics.SolidFill) {
    svgElement.setAttribute("fill", fill.getColor()), svgElement.setAttribute("fill-opacity", fill.getOpacity());
  } else {
    if (fill instanceof goog.graphics.LinearGradient) {
      var defKey = "lg-" + fill.getX1() + "-" + fill.getY1() + "-" + fill.getX2() + "-" + fill.getY2() + "-" + fill.getColor1() + "-" + fill.getColor2(), id = this.getDef(defKey);
      if (!id) {
        var gradient = this.createSvgElement_("linearGradient", {x1:fill.getX1(), y1:fill.getY1(), x2:fill.getX2(), y2:fill.getY2(), gradientUnits:"userSpaceOnUse"}), gstyle = "stop-color:" + fill.getColor1();
        goog.isNumber(fill.getOpacity1()) && (gstyle += ";stop-opacity:" + fill.getOpacity1());
        var stop1 = this.createSvgElement_("stop", {offset:"0%", style:gstyle});
        gradient.appendChild(stop1);
        gstyle = "stop-color:" + fill.getColor2();
        goog.isNumber(fill.getOpacity2()) && (gstyle += ";stop-opacity:" + fill.getOpacity2());
        var stop2 = this.createSvgElement_("stop", {offset:"100%", style:gstyle});
        gradient.appendChild(stop2);
        id = this.addDef(defKey, gradient);
      }
      svgElement.setAttribute("fill", "url(#" + id + ")");
    } else {
      svgElement.setAttribute("fill", "none");
    }
  }
};
goog.graphics.SvgGraphics.prototype.setElementStroke = function(element, stroke) {
  var svgElement = element.getElement();
  if (stroke) {
    svgElement.setAttribute("stroke", stroke.getColor());
    svgElement.setAttribute("stroke-opacity", stroke.getOpacity());
    var width = stroke.getWidth();
    goog.isString(width) && -1 != width.indexOf("px") ? svgElement.setAttribute("stroke-width", parseFloat(width) / this.getPixelScaleX()) : svgElement.setAttribute("stroke-width", width);
  } else {
    svgElement.setAttribute("stroke", "none");
  }
};
goog.graphics.SvgGraphics.prototype.setElementAffineTransform = function(element, affineTransform) {
  var t = affineTransform, substr = [t.getScaleX(), t.getShearY(), t.getShearX(), t.getScaleY(), t.getTranslateX(), t.getTranslateY()].join();
  element.getElement().setAttribute("transform", "matrix(" + substr + ")");
};
goog.graphics.SvgGraphics.prototype.createDom = function() {
  var attributes = {width:this.width, height:this.height, overflow:"hidden"}, svgElement = this.createSvgElement_("svg", attributes), groupElement = this.createSvgElement_("g");
  this.defsElement_ = this.createSvgElement_("defs");
  this.canvasElement = new goog.graphics.SvgGroupElement(groupElement, this);
  svgElement.appendChild(this.defsElement_);
  svgElement.appendChild(groupElement);
  this.setElementInternal(svgElement);
  this.setViewBox_();
};
goog.graphics.SvgGraphics.prototype.getViewBox_ = function() {
  return this.coordLeft + " " + this.coordTop + " " + (this.coordWidth ? this.coordWidth + " " + this.coordHeight : "");
};
goog.graphics.SvgGraphics.prototype.setViewBox_ = function() {
  if (this.coordWidth || this.coordLeft || this.coordTop) {
    this.getElement().setAttribute("preserveAspectRatio", "none"), this.useManualViewbox_ ? this.updateManualViewBox_() : this.getElement().setAttribute("viewBox", this.getViewBox_());
  }
};
goog.graphics.SvgGraphics.prototype.updateManualViewBox_ = function() {
  if (this.isInDocument() && (this.coordWidth || this.coordLeft || !this.coordTop)) {
    var size = this.getPixelSize();
    if (0 == size.width) {
      this.getElement().style.visibility = "hidden";
    } else {
      this.getElement().style.visibility = "";
      var offsetX = -this.coordLeft, offsetY = -this.coordTop, scaleX = size.width / this.coordWidth, scaleY = size.height / this.coordHeight;
      this.canvasElement.getElement().setAttribute("transform", "scale(" + scaleX + " " + scaleY + ") translate(" + offsetX + " " + offsetY + ")");
    }
  }
};
goog.graphics.SvgGraphics.prototype.setSize = function(pixelWidth, pixelHeight) {
  goog.style.setSize(this.getElement(), pixelWidth, pixelHeight);
};
goog.graphics.SvgGraphics.prototype.getPixelSize = function() {
  if (!goog.userAgent.GECKO) {
    return this.isInDocument() ? goog.style.getSize(this.getElement()) : goog.graphics.SvgGraphics.superClass_.getPixelSize.call(this);
  }
  var width = this.width, height = this.height, computeWidth = goog.isString(width) && -1 != width.indexOf("%"), computeHeight = goog.isString(height) && -1 != height.indexOf("%");
  if (!this.isInDocument() && (computeWidth || computeHeight)) {
    return null;
  }
  var parent, parentSize;
  computeWidth && (parent = this.getElement().parentNode, parentSize = goog.style.getSize(parent), width = parseFloat(width) * parentSize.width / 100);
  computeHeight && (parent = parent || this.getElement().parentNode, parentSize = parentSize || goog.style.getSize(parent), height = parseFloat(height) * parentSize.height / 100);
  return new goog.math.Size(width, height);
};
goog.graphics.SvgGraphics.prototype.clear = function() {
  this.canvasElement.clear();
  goog.dom.removeChildren(this.defsElement_);
  this.defs_ = {};
};
goog.graphics.SvgGraphics.prototype.drawEllipse = function(cx, cy, rx, ry, stroke, fill, opt_group) {
  var element = this.createSvgElement_("ellipse", {cx:cx, cy:cy, rx:rx, ry:ry}), wrapper = new goog.graphics.SvgEllipseElement(element, this, stroke, fill);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.SvgGraphics.prototype.drawRect = function(x, y, width, height, stroke, fill, opt_group) {
  var element = this.createSvgElement_("rect", {x:x, y:y, width:width, height:height}), wrapper = new goog.graphics.SvgRectElement(element, this, stroke, fill);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.SvgGraphics.prototype.drawImage = function(x, y, width, height, src, opt_group) {
  var element = this.createSvgElement_("image", {x:x, y:y, width:width, height:height, "image-rendering":"optimizeQuality", preserveAspectRatio:"none"});
  element.setAttributeNS("http://www.w3.org/1999/xlink", "href", src);
  var wrapper = new goog.graphics.SvgImageElement(element, this);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.SvgGraphics.prototype.drawTextOnLine = function(text, x1, y1, x2, y2, align, font, stroke, fill, opt_group) {
  var angle = Math.round(goog.math.angle(x1, y1, x2, y2)), dx = x2 - x1, dy = y2 - y1, lineLength = Math.round(Math.sqrt(dx * dx + dy * dy)), fontSize = font.size, attributes = {"font-family":font.family, "font-size":fontSize}, baseline = Math.round(.85 * fontSize), textY = Math.round(y1 - fontSize / 2 + baseline), textX = x1;
  "center" == align ? (textX += Math.round(lineLength / 2), attributes["text-anchor"] = "middle") : "right" == align && (textX += lineLength, attributes["text-anchor"] = "end");
  attributes.x = textX;
  attributes.y = textY;
  font.bold && (attributes["font-weight"] = "bold");
  font.italic && (attributes["font-style"] = "italic");
  0 != angle && (attributes.transform = "rotate(" + angle + " " + x1 + " " + y1 + ")");
  var element = this.createSvgElement_("text", attributes);
  element.appendChild(this.dom_.getDocument().createTextNode(text));
  if (null == stroke && goog.userAgent.GECKO && goog.userAgent.MAC) {
    var color = "black";
    fill instanceof goog.graphics.SolidFill && (color = fill.getColor());
    stroke = new goog.graphics.Stroke(1, color);
  }
  var wrapper = new goog.graphics.SvgTextElement(element, this, stroke, fill);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.SvgGraphics.prototype.drawPath = function(path, stroke, fill, opt_group) {
  var element = this.createSvgElement_("path", {d:goog.graphics.SvgGraphics.getSvgPath(path)}), wrapper = new goog.graphics.SvgPathElement(element, this, stroke, fill);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.SvgGraphics.getSvgPath = function(path) {
  var list = [];
  path.forEachSegment(function(segment, args) {
    switch(segment) {
      case goog.graphics.Path.Segment.MOVETO:
        list.push("M");
        Array.prototype.push.apply(list, args);
        break;
      case goog.graphics.Path.Segment.LINETO:
        list.push("L");
        Array.prototype.push.apply(list, args);
        break;
      case goog.graphics.Path.Segment.CURVETO:
        list.push("C");
        Array.prototype.push.apply(list, args);
        break;
      case goog.graphics.Path.Segment.ARCTO:
        var extent = args[3];
        list.push("A", args[0], args[1], 0, 180 < Math.abs(extent) ? 1 : 0, 0 < extent ? 1 : 0, args[4], args[5]);
        break;
      case goog.graphics.Path.Segment.CLOSE:
        list.push("Z");
    }
  });
  return list.join(" ");
};
goog.graphics.SvgGraphics.prototype.createGroup = function(opt_group) {
  var element = this.createSvgElement_("g"), parent = opt_group || this.canvasElement;
  parent.getElement().appendChild(element);
  return new goog.graphics.SvgGroupElement(element, this);
};
goog.graphics.SvgGraphics.prototype.getTextWidth = function() {
};
goog.graphics.SvgGraphics.prototype.addDef = function(defKey, defElement) {
  if (defKey in this.defs_) {
    return this.defs_[defKey];
  }
  var id = goog.graphics.SvgGraphics.DEF_ID_PREFIX_ + goog.graphics.SvgGraphics.nextDefId_++;
  defElement.setAttribute("id", id);
  this.defs_[defKey] = id;
  var defs = this.defsElement_;
  defs.appendChild(defElement);
  return id;
};
goog.graphics.SvgGraphics.prototype.getDef = function(defKey) {
  return defKey in this.defs_ ? this.defs_[defKey] : null;
};
goog.graphics.SvgGraphics.prototype.enterDocument = function() {
  var oldPixelSize = this.getPixelSize();
  goog.graphics.SvgGraphics.superClass_.enterDocument.call(this);
  oldPixelSize || this.dispatchEvent(goog.events.EventType.RESIZE);
  if (this.useManualViewbox_) {
    var width = this.width, height = this.height;
    "string" == typeof width && -1 != width.indexOf("%") && "string" == typeof height && -1 != height.indexOf("%") && this.handler_.listen(goog.graphics.SvgGraphics.getResizeCheckTimer_(), goog.Timer.TICK, this.updateManualViewBox_);
    this.updateManualViewBox_();
  }
};
goog.graphics.SvgGraphics.prototype.exitDocument = function() {
  goog.graphics.SvgGraphics.superClass_.exitDocument.call(this);
  this.useManualViewbox_ && this.handler_.unlisten(goog.graphics.SvgGraphics.getResizeCheckTimer_(), goog.Timer.TICK, this.updateManualViewBox_);
};
goog.graphics.SvgGraphics.prototype.disposeInternal = function() {
  delete this.defs_;
  delete this.defsElement_;
  delete this.canvasElement;
  goog.graphics.SvgGraphics.superClass_.disposeInternal.call(this);
};
goog.graphics.SvgGraphics.getResizeCheckTimer_ = function() {
  goog.graphics.SvgGraphics.resizeCheckTimer_ || (goog.graphics.SvgGraphics.resizeCheckTimer_ = new goog.Timer(400), goog.graphics.SvgGraphics.resizeCheckTimer_.start());
  return goog.graphics.SvgGraphics.resizeCheckTimer_;
};
// INPUT (javascript/closure/graphics/vmlelement.js)
goog.graphics.vmlGetElement_ = function() {
  return this.element_ = this.getGraphics().getVmlElement(this.id_) || this.element_;
};
goog.graphics.VmlGroupElement = function(element, graphics) {
  this.id_ = element.id;
  goog.graphics.GroupElement.call(this, element, graphics);
};
goog.inherits(goog.graphics.VmlGroupElement, goog.graphics.GroupElement);
goog.graphics.VmlGroupElement.prototype.getElement = goog.graphics.vmlGetElement_;
goog.graphics.VmlGroupElement.prototype.clear = function() {
  goog.dom.removeChildren(this.getElement());
};
goog.graphics.VmlGroupElement.prototype.isRootElement_ = function() {
  return this.getGraphics().getCanvasElement() == this;
};
goog.graphics.VmlGroupElement.prototype.setSize = function(width, height) {
  var element = this.getElement(), style = element.style;
  style.width = goog.graphics.VmlGraphics.toSizePx(width);
  style.height = goog.graphics.VmlGraphics.toSizePx(height);
  element.coordsize = goog.graphics.VmlGraphics.toSizeCoord(width) + " " + goog.graphics.VmlGraphics.toSizeCoord(height);
  this.isRootElement_() || (element.coordorigin = "0 0");
};
goog.graphics.VmlEllipseElement = function(element, graphics, cx, cy, rx, ry, stroke, fill) {
  this.id_ = element.id;
  goog.graphics.EllipseElement.call(this, element, graphics, stroke, fill);
  this.cx = cx;
  this.cy = cy;
  this.rx = rx;
  this.ry = ry;
};
goog.inherits(goog.graphics.VmlEllipseElement, goog.graphics.EllipseElement);
goog.graphics.VmlEllipseElement.prototype.getElement = goog.graphics.vmlGetElement_;
goog.graphics.VmlEllipseElement.prototype.setCenter = function(cx, cy) {
  this.cx = cx;
  this.cy = cy;
  goog.graphics.VmlGraphics.setPositionAndSize(this.getElement(), cx - this.rx, cy - this.ry, 2 * this.rx, 2 * this.ry);
};
goog.graphics.VmlEllipseElement.prototype.setRadius = function(rx, ry) {
  this.rx = rx;
  this.ry = ry;
  goog.graphics.VmlGraphics.setPositionAndSize(this.getElement(), this.cx - rx, this.cy - ry, 2 * rx, 2 * ry);
};
goog.graphics.VmlRectElement = function(element, graphics, stroke, fill) {
  this.id_ = element.id;
  goog.graphics.RectElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.VmlRectElement, goog.graphics.RectElement);
goog.graphics.VmlRectElement.prototype.getElement = goog.graphics.vmlGetElement_;
goog.graphics.VmlRectElement.prototype.setPosition = function(x, y) {
  var style = this.getElement().style;
  style.left = goog.graphics.VmlGraphics.toPosPx(x);
  style.top = goog.graphics.VmlGraphics.toPosPx(y);
};
goog.graphics.VmlRectElement.prototype.setSize = function(width, height) {
  var style = this.getElement().style;
  style.width = goog.graphics.VmlGraphics.toSizePx(width);
  style.height = goog.graphics.VmlGraphics.toSizePx(height);
};
goog.graphics.VmlPathElement = function(element, graphics, stroke, fill) {
  this.id_ = element.id;
  goog.graphics.PathElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.VmlPathElement, goog.graphics.PathElement);
goog.graphics.VmlPathElement.prototype.getElement = goog.graphics.vmlGetElement_;
goog.graphics.VmlPathElement.prototype.setPath = function(path) {
  goog.graphics.VmlGraphics.setAttribute(this.getElement(), "path", goog.graphics.VmlGraphics.getVmlPath(path));
};
goog.graphics.VmlTextElement = function(element, graphics, stroke, fill) {
  this.id_ = element.id;
  goog.graphics.TextElement.call(this, element, graphics, stroke, fill);
};
goog.inherits(goog.graphics.VmlTextElement, goog.graphics.TextElement);
goog.graphics.VmlTextElement.prototype.getElement = goog.graphics.vmlGetElement_;
goog.graphics.VmlTextElement.prototype.setText = function(text) {
  goog.graphics.VmlGraphics.setAttribute(this.getElement().childNodes[1], "string", text);
};
goog.graphics.VmlImageElement = function(element, graphics) {
  this.id_ = element.id;
  goog.graphics.ImageElement.call(this, element, graphics);
};
goog.inherits(goog.graphics.VmlImageElement, goog.graphics.ImageElement);
goog.graphics.VmlImageElement.prototype.getElement = goog.graphics.vmlGetElement_;
goog.graphics.VmlImageElement.prototype.setPosition = function(x, y) {
  var style = this.getElement().style;
  style.left = goog.graphics.VmlGraphics.toPosPx(x);
  style.top = goog.graphics.VmlGraphics.toPosPx(y);
};
goog.graphics.VmlImageElement.prototype.setSize = function(width, height) {
  var style = this.getElement().style;
  style.width = goog.graphics.VmlGraphics.toPosPx(width);
  style.height = goog.graphics.VmlGraphics.toPosPx(height);
};
// INPUT (javascript/closure/graphics/vmlgraphics.js)
goog.graphics.VmlGraphics = function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper) {
  goog.graphics.AbstractGraphics.call(this, width, height, opt_coordWidth, opt_coordHeight, opt_domHelper);
  this.handler_ = new goog.events.EventHandler(this);
};
goog.inherits(goog.graphics.VmlGraphics, goog.graphics.AbstractGraphics);
goog.graphics.VmlGraphics.VML_PREFIX_ = "g_vml_";
goog.graphics.VmlGraphics.VML_NS_ = "urn:schemas-microsoft-com:vml";
goog.graphics.VmlGraphics.VML_IMPORT_ = "#default#VML";
goog.graphics.VmlGraphics.IE8_MODE_ = document.documentMode && 8 <= document.documentMode;
goog.graphics.VmlGraphics.COORD_MULTIPLIER = 100;
goog.graphics.VmlGraphics.toCssSize = function(size) {
  return goog.isString(size) && goog.string.endsWith(size, "%") ? size : parseFloat(size.toString()) + "px";
};
goog.graphics.VmlGraphics.toPosCoord = function(number) {
  return Math.round((parseFloat(number.toString()) - .5) * goog.graphics.VmlGraphics.COORD_MULTIPLIER);
};
goog.graphics.VmlGraphics.toPosPx = function(number) {
  return goog.graphics.VmlGraphics.toPosCoord(number) + "px";
};
goog.graphics.VmlGraphics.toSizeCoord = function(number) {
  return Math.round(parseFloat(number.toString()) * goog.graphics.VmlGraphics.COORD_MULTIPLIER);
};
goog.graphics.VmlGraphics.toSizePx = function(number) {
  return goog.graphics.VmlGraphics.toSizeCoord(number) + "px";
};
goog.graphics.VmlGraphics.setAttribute = function(element, name, value) {
  goog.graphics.VmlGraphics.IE8_MODE_ ? element[name] = value : element.setAttribute(name, value);
};
goog.graphics.VmlGraphics.prototype.createVmlElement = function(tagName) {
  var element = this.dom_.createElement(goog.graphics.VmlGraphics.VML_PREFIX_ + ":" + tagName);
  element.id = goog.string.createUniqueString();
  return element;
};
goog.graphics.VmlGraphics.prototype.getVmlElement = function(id) {
  return this.dom_.getElement(id);
};
goog.graphics.VmlGraphics.prototype.updateGraphics_ = function() {
  goog.graphics.VmlGraphics.IE8_MODE_ && this.isInDocument() && (this.getElement().innerHTML = this.getElement().innerHTML);
};
goog.graphics.VmlGraphics.prototype.append_ = function(element, opt_group) {
  var parent = opt_group || this.canvasElement;
  parent.getElement().appendChild(element.getElement());
  this.updateGraphics_();
};
goog.graphics.VmlGraphics.prototype.setElementFill = function(element, fill) {
  var vmlElement = element.getElement();
  goog.graphics.VmlGraphics.removeFill_(vmlElement);
  if (fill instanceof goog.graphics.SolidFill) {
    if ("transparent" == fill.getColor()) {
      vmlElement.filled = !1;
    } else {
      if (1 != fill.getOpacity()) {
        vmlElement.filled = !0;
        var fillNode = this.createVmlElement("fill");
        fillNode.opacity = Math.round(100 * fill.getOpacity()) + "%";
        fillNode.color = fill.getColor();
        vmlElement.appendChild(fillNode);
      } else {
        vmlElement.filled = !0, vmlElement.fillcolor = fill.getColor();
      }
    }
  } else {
    if (fill instanceof goog.graphics.LinearGradient) {
      vmlElement.filled = !0;
      var gradient = this.createVmlElement("fill");
      gradient.color = fill.getColor1();
      gradient.color2 = fill.getColor2();
      goog.isNumber(fill.getOpacity1()) && (gradient.opacity = fill.getOpacity1());
      goog.isNumber(fill.getOpacity2()) && (gradient.opacity2 = fill.getOpacity2());
      var angle = goog.math.angle(fill.getX1(), fill.getY1(), fill.getX2(), fill.getY2()), angle = Math.round(goog.math.standardAngle(270 - angle));
      gradient.angle = angle;
      gradient.type = "gradient";
      vmlElement.appendChild(gradient);
    } else {
      vmlElement.filled = !1;
    }
  }
  this.updateGraphics_();
};
goog.graphics.VmlGraphics.prototype.setElementStroke = function(element, stroke) {
  var vmlElement = element.getElement();
  if (stroke) {
    vmlElement.stroked = !0;
    var width = stroke.getWidth(), width = goog.isString(width) && -1 == width.indexOf("px") ? parseFloat(width) : width * this.getPixelScaleX(), strokeElement = vmlElement.getElementsByTagName("stroke")[0];
    strokeElement || (strokeElement = strokeElement || this.createVmlElement("stroke"), vmlElement.appendChild(strokeElement));
    strokeElement.opacity = stroke.getOpacity();
    strokeElement.weight = width + "px";
    strokeElement.color = stroke.getColor();
  } else {
    vmlElement.stroked = !1;
  }
  this.updateGraphics_();
};
goog.graphics.VmlGraphics.prototype.setElementAffineTransform = function(element, affineTransform) {
  var t = affineTransform, vmlElement = element.getElement();
  goog.graphics.VmlGraphics.removeSkew_(vmlElement);
  var skewNode = this.createVmlElement("skew");
  skewNode.on = "true";
  skewNode.origin = -vmlElement.style.pixelLeft / vmlElement.style.pixelWidth - .5 + "," + (-vmlElement.style.pixelTop / vmlElement.style.pixelHeight - .5);
  skewNode.offset = t.getTranslateX().toFixed(1) + "px," + t.getTranslateY().toFixed(1) + "px";
  skewNode.matrix = [t.getScaleX().toFixed(6), t.getShearX().toFixed(6), t.getShearY().toFixed(6), t.getScaleY().toFixed(6), 0, 0].join();
  vmlElement.appendChild(skewNode);
  this.updateGraphics_();
};
goog.graphics.VmlGraphics.removeSkew_ = function(element) {
  goog.array.forEach(element.childNodes, function(child) {
    "skew" == child.tagName && element.removeChild(child);
  });
};
goog.graphics.VmlGraphics.removeFill_ = function(element) {
  element.fillcolor = "";
  goog.array.forEach(element.childNodes, function(child) {
    "fill" == child.tagName && element.removeChild(child);
  });
};
goog.graphics.VmlGraphics.setPositionAndSize = function(element, left, top, width, height) {
  var style = element.style;
  style.position = "absolute";
  style.left = goog.graphics.VmlGraphics.toPosPx(left);
  style.top = goog.graphics.VmlGraphics.toPosPx(top);
  style.width = goog.graphics.VmlGraphics.toSizePx(width);
  style.height = goog.graphics.VmlGraphics.toSizePx(height);
  "shape" == element.tagName && (element.coordsize = goog.graphics.VmlGraphics.toSizeCoord(width) + " " + goog.graphics.VmlGraphics.toSizeCoord(height));
};
goog.graphics.VmlGraphics.prototype.createFullSizeElement_ = function(type) {
  var element = this.createVmlElement(type), size = this.getCoordSize();
  goog.graphics.VmlGraphics.setPositionAndSize(element, 0, 0, size.width, size.height);
  return element;
};
try {
  //eval("document.namespaces");
} catch (ex$$15) {
}
goog.graphics.VmlGraphics.prototype.createDom = function() {
  var doc = this.dom_.getDocument();
  if (!doc.namespaces[goog.graphics.VmlGraphics.VML_PREFIX_]) {
    goog.graphics.VmlGraphics.IE8_MODE_ ? doc.namespaces.add(goog.graphics.VmlGraphics.VML_PREFIX_, goog.graphics.VmlGraphics.VML_NS_, goog.graphics.VmlGraphics.VML_IMPORT_) : doc.namespaces.add(goog.graphics.VmlGraphics.VML_PREFIX_, goog.graphics.VmlGraphics.VML_NS_);
    var ss = doc.createStyleSheet();
    ss.cssText = goog.graphics.VmlGraphics.VML_PREFIX_ + "\\:*{behavior:url(#default#VML)}";
  }
  var pixelWidth = this.width, pixelHeight = this.height, divElement = this.dom_.createDom("div", {style:"overflow:hidden;position:relative;width:" + goog.graphics.VmlGraphics.toCssSize(pixelWidth) + ";height:" + goog.graphics.VmlGraphics.toCssSize(pixelHeight)});
  this.setElementInternal(divElement);
  var group = this.createVmlElement("group"), style = group.style;
  style.position = "absolute";
  style.left = style.top = 0;
  style.width = this.width;
  style.height = this.height;
  group.coordsize = this.coordWidth ? goog.graphics.VmlGraphics.toSizeCoord(this.coordWidth) + " " + goog.graphics.VmlGraphics.toSizeCoord(this.coordHeight) : goog.graphics.VmlGraphics.toSizeCoord(pixelWidth) + " " + goog.graphics.VmlGraphics.toSizeCoord(pixelHeight);
  group.coordorigin = goog.isDef(this.coordLeft) ? goog.graphics.VmlGraphics.toSizeCoord(this.coordLeft) + " " + goog.graphics.VmlGraphics.toSizeCoord(this.coordTop) : "0 0";
  divElement.appendChild(group);
  this.canvasElement = new goog.graphics.VmlGroupElement(group, this);
  goog.events.listen(divElement, goog.events.EventType.RESIZE, goog.bind(this.handleContainerResize_, this));
};
goog.graphics.VmlGraphics.prototype.handleContainerResize_ = function() {
  var size = goog.style.getSize(this.getElement()), style = this.canvasElement.getElement().style;
  if (size.width) {
    style.width = size.width + "px", style.height = size.height + "px";
  } else {
    for (var current = this.getElement();current && current.currentStyle && "none" != current.currentStyle.display;) {
      current = current.parentNode;
    }
    current && current.currentStyle && this.handler_.listen(current, "propertychange", this.handleContainerResize_);
  }
  this.dispatchEvent(goog.events.EventType.RESIZE);
};
goog.graphics.VmlGraphics.prototype.setSize = function(pixelWidth, pixelHeight) {
  goog.style.setSize(this.getElement(), pixelWidth, pixelHeight);
};
goog.graphics.VmlGraphics.prototype.getPixelSize = function() {
  var el = this.getElement();
  return new goog.math.Size(el.style.pixelWidth || el.offsetWidth || 1, el.style.pixelHeight || el.offsetHeight || 1);
};
goog.graphics.VmlGraphics.prototype.clear = function() {
  this.canvasElement.clear();
};
goog.graphics.VmlGraphics.prototype.drawEllipse = function(cx, cy, rx, ry, stroke, fill, opt_group) {
  var element = this.createVmlElement("oval");
  goog.graphics.VmlGraphics.setPositionAndSize(element, cx - rx, cy - ry, 2 * rx, 2 * ry);
  var wrapper = new goog.graphics.VmlEllipseElement(element, this, cx, cy, rx, ry, stroke, fill);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.VmlGraphics.prototype.drawRect = function(x, y, width, height, stroke, fill, opt_group) {
  var element = this.createVmlElement("rect");
  goog.graphics.VmlGraphics.setPositionAndSize(element, x, y, width, height);
  var wrapper = new goog.graphics.VmlRectElement(element, this, stroke, fill);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.VmlGraphics.prototype.drawImage = function(x, y, width, height, src, opt_group) {
  var element = this.createVmlElement("image");
  goog.graphics.VmlGraphics.setPositionAndSize(element, x, y, width, height);
  goog.graphics.VmlGraphics.setAttribute(element, "src", src);
  var wrapper = new goog.graphics.VmlImageElement(element, this);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.VmlGraphics.prototype.drawTextOnLine = function(text, x1, y1, x2, y2, align, font, stroke, fill, opt_group) {
  var shape = this.createFullSizeElement_("shape"), pathElement = this.createVmlElement("path"), path = "M" + goog.graphics.VmlGraphics.toPosCoord(x1) + "," + goog.graphics.VmlGraphics.toPosCoord(y1) + "L" + goog.graphics.VmlGraphics.toPosCoord(x2) + "," + goog.graphics.VmlGraphics.toPosCoord(y2) + "E";
  goog.graphics.VmlGraphics.setAttribute(pathElement, "v", path);
  goog.graphics.VmlGraphics.setAttribute(pathElement, "textpathok", "true");
  var textPathElement = this.createVmlElement("textpath");
  textPathElement.setAttribute("on", "true");
  var style = textPathElement.style;
  style.fontSize = font.size * this.getPixelScaleX();
  style.fontFamily = font.family;
  null != align && (style["v-text-align"] = align);
  font.bold && (style.fontWeight = "bold");
  font.italic && (style.fontStyle = "italic");
  goog.graphics.VmlGraphics.setAttribute(textPathElement, "string", text);
  shape.appendChild(pathElement);
  shape.appendChild(textPathElement);
  var wrapper = new goog.graphics.VmlTextElement(shape, this, stroke, fill);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.VmlGraphics.prototype.drawPath = function(path, stroke, fill, opt_group) {
  var element = this.createFullSizeElement_("shape");
  goog.graphics.VmlGraphics.setAttribute(element, "path", goog.graphics.VmlGraphics.getVmlPath(path));
  var wrapper = new goog.graphics.VmlPathElement(element, this, stroke, fill);
  this.append_(wrapper, opt_group);
  return wrapper;
};
goog.graphics.VmlGraphics.getVmlPath = function(path) {
  var list = [];
  path.forEachSegment(function(segment, args) {
    switch(segment) {
      case goog.graphics.Path.Segment.MOVETO:
        list.push("m");
        Array.prototype.push.apply(list, goog.array.map(args, goog.graphics.VmlGraphics.toSizeCoord));
        break;
      case goog.graphics.Path.Segment.LINETO:
        list.push("l");
        Array.prototype.push.apply(list, goog.array.map(args, goog.graphics.VmlGraphics.toSizeCoord));
        break;
      case goog.graphics.Path.Segment.CURVETO:
        list.push("c");
        Array.prototype.push.apply(list, goog.array.map(args, goog.graphics.VmlGraphics.toSizeCoord));
        break;
      case goog.graphics.Path.Segment.CLOSE:
        list.push("x");
        break;
      case goog.graphics.Path.Segment.ARCTO:
        var toAngle = args[2] + args[3], cx = goog.graphics.VmlGraphics.toSizeCoord(args[4] - goog.math.angleDx(toAngle, args[0])), cy = goog.graphics.VmlGraphics.toSizeCoord(args[5] - goog.math.angleDy(toAngle, args[1])), rx = goog.graphics.VmlGraphics.toSizeCoord(args[0]), ry = goog.graphics.VmlGraphics.toSizeCoord(args[1]), fromAngle = Math.round(-65536 * args[2]), extent = Math.round(-65536 * args[3]);
        list.push("ae", cx, cy, rx, ry, fromAngle, extent);
    }
  });
  return list.join(" ");
};
goog.graphics.VmlGraphics.prototype.createGroup = function(opt_group) {
  var element = this.createFullSizeElement_("group"), parent = opt_group || this.canvasElement;
  parent.getElement().appendChild(element);
  return new goog.graphics.VmlGroupElement(element, this);
};
goog.graphics.VmlGraphics.prototype.getTextWidth = function() {
  return 0;
};
goog.graphics.VmlGraphics.prototype.enterDocument = function() {
  goog.graphics.VmlGraphics.superClass_.enterDocument.call(this);
  this.handleContainerResize_();
  this.updateGraphics_();
};
goog.graphics.VmlGraphics.prototype.disposeInternal = function() {
  this.canvasElement = null;
  goog.graphics.VmlGraphics.superClass_.disposeInternal.call(this);
};
// INPUT (javascript/closure/graphics/graphics.js)
goog.graphics.createGraphics = function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper) {
  var graphics;
  graphics = !goog.userAgent.IE || goog.userAgent.isVersionOrHigher("9") && (opt_domHelper || goog.dom.getDomHelper()).getDocument().createElementNS ? !goog.userAgent.WEBKIT || goog.userAgent.isVersionOrHigher("420") && !goog.userAgent.MOBILE ? new goog.graphics.SvgGraphics(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper) : new goog.graphics.CanvasGraphics(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper) : new goog.graphics.VmlGraphics(width, height, opt_coordWidth, opt_coordHeight, 
  opt_domHelper);
  graphics.createDom();
  return graphics;
};
goog.graphics.createSimpleGraphics = function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper) {
  if (goog.userAgent.MAC && goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher("1.9a")) {
    var graphics = new goog.graphics.CanvasGraphics(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper);
    graphics.createDom();
    return graphics;
  }
  return goog.graphics.createGraphics(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper);
};
goog.graphics.isBrowserSupported = function() {
  return goog.userAgent.IE ? goog.userAgent.isVersionOrHigher("5.5") : goog.userAgent.GECKO ? goog.userAgent.isVersionOrHigher("1.8") : goog.userAgent.OPERA ? goog.userAgent.isVersionOrHigher("9.0") : goog.userAgent.WEBKIT ? goog.userAgent.isVersionOrHigher("412") : !1;
};
// INPUT (javascript/closure/ui/serverchart.js)
goog.ui.ServerChart = function(type, opt_width, opt_height, opt_domHelper, opt_uri) {
  goog.ui.Component.call(this, opt_domHelper);
  this.uri_ = new goog.Uri(opt_uri || goog.ui.ServerChart.CHART_SERVER_SCHEME_INDEPENDENT_URI);
  this.encodingType_ = goog.ui.ServerChart.EncodingType.AUTOMATIC;
  this.dataSets_ = [];
  this.setColors_ = [];
  this.setLegendTexts_ = [];
  this.xLabels_ = [];
  this.leftLabels_ = [];
  this.rightLabels_ = [];
  this.multiAxisType_ = [];
  this.multiAxisLabelText_ = {};
  this.multiAxisLabelPosition_ = {};
  this.multiAxisRange_ = {};
  this.multiAxisLabelStyle_ = {};
  this.setType(type);
  this.setSize(opt_width, opt_height);
  this.minValue_ = this.isPieChart() ? 0 : Infinity;
};
goog.inherits(goog.ui.ServerChart, goog.ui.Component);
goog.ui.ServerChart.CHART_SERVER_SCHEME_INDEPENDENT_URI = "//chart.googleapis.com/chart";
goog.ui.ServerChart.CHART_SERVER_HTTP_URI = "http://chart.googleapis.com/chart";
goog.ui.ServerChart.CHART_SERVER_HTTPS_URI = "https://chart.googleapis.com/chart";
goog.ui.ServerChart.CHART_SERVER_URI = goog.ui.ServerChart.CHART_SERVER_HTTP_URI;
goog.ui.ServerChart.DEFAULT_NORMALIZATION = .5;
goog.ui.ServerChart.prototype.uriLengthLimit_ = 2048;
goog.ui.ServerChart.prototype.gridX_ = 0;
goog.ui.ServerChart.prototype.gridY_ = 0;
goog.ui.ServerChart.prototype.maxValue_ = -Infinity;
goog.ui.ServerChart.prototype.title_ = null;
goog.ui.ServerChart.prototype.numVisibleDataSets_ = null;
goog.ui.ServerChart.prototype.createDom = function() {
  var size = this.getSize();
  this.setElementInternal(this.getDomHelper().createDom("img", {src:this.getUri(), "class":"aAAaGVIZSENTINELaAAa-serverchart-image", width:size[0], height:size[1]}));
};
goog.ui.ServerChart.prototype.decorateInternal = function(img) {
  img.src = this.getUri();
  this.setElementInternal(img);
};
goog.ui.ServerChart.prototype.getUri = function() {
  this.computeDataString_();
  return this.uri_;
};
goog.ui.ServerChart.prototype.getUriLengthLimit = function() {
  return this.uriLengthLimit_;
};
goog.ui.ServerChart.prototype.setMarkerParameter = function(value) {
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.MARKERS, value);
};
goog.ui.ServerChart.prototype.getMarkerParameter = function() {
  return this.uri_.getParameterValue(goog.ui.ServerChart.UriParam.MARKERS);
};
goog.ui.ServerChart.EncodingType = {AUTOMATIC:"", EXTENDED:"e", SIMPLE:"s", TEXT:"t"};
goog.ui.ServerChart.ChartType = {BAR:"br", CLOCK:"cf", CONCENTRIC_PIE:"pc", FILLEDLINE:"lr", FINANCE:"lfi", GOOGLEOMETER:"gom", HORIZONTAL_GROUPED_BAR:"bhg", HORIZONTAL_STACKED_BAR:"bhs", LINE:"lc", MAP:"t", MAPUSA:"tuss", MAPWORLD:"twoc", PIE:"p", PIE3D:"p3", RADAR:"rs", SCATTER:"s", SPARKLINE:"ls", VENN:"v", VERTICAL_GROUPED_BAR:"bvg", VERTICAL_STACKED_BAR:"bvs", XYLINE:"lxy"};
goog.ui.ServerChart.MultiAxisType = {X_AXIS:"x", LEFT_Y_AXIS:"y", RIGHT_Y_AXIS:"r", TOP_AXIS:"t"};
goog.ui.ServerChart.MultiAxisAlignment = {ALIGN_LEFT:-1, ALIGN_CENTER:0, ALIGN_RIGHT:1};
goog.ui.ServerChart.LegendPosition = {TOP:"t", BOTTOM:"b", LEFT:"l", RIGHT:"r"};
goog.ui.ServerChart.AxisDisplayType = {LINE_AND_TICKS:"lt", LINE:"l", TICKS:"t"};
goog.ui.ServerChart.MaximumValue = {WIDTH:1E3, HEIGHT:1E3, MAP_WIDTH:440, MAP_HEIGHT:220, TOTAL_AREA:3E5};
goog.ui.ServerChart.UriParam = {BACKGROUND_FILL:"chf", BAR_HEIGHT:"chbh", DATA:"chd", DATA_COLORS:"chco", DATA_LABELS:"chld", DATA_SCALING:"chds", DIGITAL_SIGNATURE:"sig", GEOGRAPHICAL_REGION:"chtm", GRID:"chg", LABEL_COLORS:"chlc", LEFT_Y_LABELS:"chly", LEGEND:"chdl", LEGEND_POSITION:"chdlp", LEGEND_TEXTS:"chdl", LINE_STYLES:"chls", MARGINS:"chma", MARKERS:"chm", MISC_PARAMS:"chp", MULTI_AXIS_LABEL_POSITION:"chxp", MULTI_AXIS_LABEL_TEXT:"chxl", MULTI_AXIS_RANGE:"chxr", MULTI_AXIS_STYLE:"chxs", MULTI_AXIS_TYPES:"chxt", 
RIGHT_LABELS:"chlr", RIGHT_LABEL_POSITIONS:"chlrp", SIZE:"chs", TITLE:"chtt", TITLE_FORMAT:"chts", TYPE:"cht", X_AXIS_STYLE:"chx", X_LABELS:"chl"};
goog.ui.ServerChart.prototype.setBackgroundFill = function(fill) {
  var value = [];
  goog.array.forEach(fill, function(spec) {
    spec.area = spec.area || "bg";
    spec.effect = spec.effect || "s";
    value.push([spec.area, spec.effect, spec.color].join());
  });
  value = value.join("|");
  this.setParameterValue(goog.ui.ServerChart.UriParam.BACKGROUND_FILL, value);
};
goog.ui.ServerChart.prototype.setEncodingType = function(type) {
  this.encodingType_ = type;
};
goog.ui.ServerChart.prototype.setType = function(type) {
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.TYPE, type);
};
goog.ui.ServerChart.prototype.getType = function() {
  return this.uri_.getParameterValue(goog.ui.ServerChart.UriParam.TYPE);
};
goog.ui.ServerChart.prototype.setSize = function(opt_width, opt_height) {
  var sizeString = [opt_width || 300, opt_height || 150].join("x");
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.SIZE, sizeString);
};
goog.ui.ServerChart.prototype.getSize = function() {
  var sizeStr = this.uri_.getParameterValue(goog.ui.ServerChart.UriParam.SIZE);
  return sizeStr.split("x");
};
goog.ui.ServerChart.prototype.setMinValue = function(minValue) {
  this.minValue_ = minValue;
};
goog.ui.ServerChart.prototype.getMinValue = function() {
  return this.minValue_;
};
goog.ui.ServerChart.prototype.setMaxValue = function(maxValue) {
  this.maxValue_ = maxValue;
};
goog.ui.ServerChart.prototype.getMaxValue = function() {
  return this.maxValue_;
};
goog.ui.ServerChart.prototype.setMargins = function(leftMargin, rightMargin, topMargin, bottomMargin) {
  var margins = [leftMargin, rightMargin, topMargin, bottomMargin].join(), UriParam = goog.ui.ServerChart.UriParam;
  this.uri_.setParameterValue(UriParam.MARGINS, margins);
};
goog.ui.ServerChart.prototype.setXLabels = function(labels) {
  this.xLabels_ = labels;
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.X_LABELS, this.xLabels_.join("|"));
};
goog.ui.ServerChart.prototype.isBarChart = function() {
  var type = this.getType();
  return type == goog.ui.ServerChart.ChartType.BAR || type == goog.ui.ServerChart.ChartType.HORIZONTAL_GROUPED_BAR || type == goog.ui.ServerChart.ChartType.HORIZONTAL_STACKED_BAR || type == goog.ui.ServerChart.ChartType.VERTICAL_GROUPED_BAR || type == goog.ui.ServerChart.ChartType.VERTICAL_STACKED_BAR;
};
goog.ui.ServerChart.prototype.isPieChart = function() {
  var type = this.getType();
  return type == goog.ui.ServerChart.ChartType.PIE || type == goog.ui.ServerChart.ChartType.PIE3D || type == goog.ui.ServerChart.ChartType.CONCENTRIC_PIE;
};
goog.ui.ServerChart.prototype.isHorizontalBarChart = function() {
  var type = this.getType();
  return type == goog.ui.ServerChart.ChartType.BAR || type == goog.ui.ServerChart.ChartType.HORIZONTAL_GROUPED_BAR || type == goog.ui.ServerChart.ChartType.HORIZONTAL_STACKED_BAR;
};
goog.ui.ServerChart.prototype.isLineChart = function() {
  var type = this.getType();
  return type == goog.ui.ServerChart.ChartType.FILLEDLINE || type == goog.ui.ServerChart.ChartType.LINE || type == goog.ui.ServerChart.ChartType.SPARKLINE || type == goog.ui.ServerChart.ChartType.XYLINE;
};
goog.ui.ServerChart.prototype.isMap = function() {
  var type = this.getType();
  return type == goog.ui.ServerChart.ChartType.MAP || type == goog.ui.ServerChart.ChartType.MAPUSA || type == goog.ui.ServerChart.ChartType.MAPWORLD;
};
goog.ui.ServerChart.prototype.isStackedBarChart = function() {
  var type = this.getType();
  return type == goog.ui.ServerChart.ChartType.BAR || type == goog.ui.ServerChart.ChartType.HORIZONTAL_STACKED_BAR || type == goog.ui.ServerChart.ChartType.VERTICAL_STACKED_BAR;
};
goog.ui.ServerChart.prototype.setParameterValue = function(key, value) {
  this.uri_.setParameterValue(key, value);
};
goog.ui.ServerChart.prototype.removeParameter = function(key) {
  this.uri_.removeParameter(key);
};
goog.ui.ServerChart.prototype.setLegendPosition = function(value) {
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.LEGEND_POSITION, value);
};
goog.ui.ServerChart.prototype.setNumVisibleDataSets = function(n) {
  this.numVisibleDataSets_ = n;
};
goog.ui.ServerChart.prototype.setTitle = function(title) {
  this.title_ = title;
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.TITLE, this.title_.replace(/\n/g, "|"));
};
goog.ui.ServerChart.prototype.setAutomaticBarWidth = function(opt_spaceBars, opt_spaceGroups) {
  var widths = ["a"];
  goog.isDef(opt_spaceBars) && widths.push(opt_spaceBars);
  goog.isDef(opt_spaceGroups) && widths.push(opt_spaceGroups);
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.BAR_HEIGHT, widths.join(","));
};
goog.ui.ServerChart.prototype.addMultiAxis = function(axisType) {
  this.multiAxisType_.push(axisType);
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.MULTI_AXIS_TYPES, this.multiAxisType_.join(","));
  return this.multiAxisType_.length - 1;
};
goog.ui.ServerChart.prototype.setMultiAxisLabelText = function(axisNumber, labelText) {
  this.multiAxisLabelText_[axisNumber] = labelText;
  var axisString = this.computeMultiAxisDataString_(this.multiAxisLabelText_, ":|", "|", "|");
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.MULTI_AXIS_LABEL_TEXT, axisString);
};
goog.ui.ServerChart.prototype.setMultiAxisRange = function(axisNumber, rangeStart, rangeEnd, opt_interval) {
  goog.asserts.assert(rangeStart != rangeEnd, "Range start and end cannot be the same value.");
  goog.asserts.assert(isFinite(rangeStart) && isFinite(rangeEnd), "Range start and end must be finite numbers.");
  this.multiAxisRange_[axisNumber] = [rangeStart, rangeEnd];
  goog.isDef(opt_interval) && this.multiAxisRange_[axisNumber].push(opt_interval);
  var rangeString = this.computeMultiAxisDataString_(this.multiAxisRange_, ",", ",", "|");
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.MULTI_AXIS_RANGE, rangeString);
};
goog.ui.ServerChart.prototype.addDataSet = function(data, color, opt_legendText) {
  var dataMin = this.arrayMin_(data);
  dataMin < this.minValue_ && (this.minValue_ = dataMin);
  var dataMax = this.arrayMax_(data);
  dataMax > this.maxValue_ && (this.maxValue_ = dataMax);
  if (goog.isDef(opt_legendText)) {
    if (this.setLegendTexts_.length < this.dataSets_.length) {
      throw Error("Cannot start adding legends text after first element.");
    }
    this.setLegendTexts_.push(opt_legendText);
    this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.LEGEND_TEXTS, this.setLegendTexts_.join("|"));
  }
  this.dataSets_.push(data);
  this.setColors_.push(color);
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.DATA_COLORS, this.setColors_.join(","));
};
goog.ui.ServerChart.prototype.getData = function(opt_setNumber) {
  return goog.isDef(opt_setNumber) ? this.dataSets_[opt_setNumber] : this.dataSets_;
};
goog.ui.ServerChart.prototype.computeDataString_ = function() {
  var ok;
  this.encodingType_ != goog.ui.ServerChart.EncodingType.AUTOMATIC ? ok = this.computeDataStringForEncoding_(this.encodingType_) : (ok = this.computeDataStringForEncoding_(goog.ui.ServerChart.EncodingType.EXTENDED)) || (ok = this.computeDataStringForEncoding_(goog.ui.ServerChart.EncodingType.SIMPLE));
  ok || this.dispatchEvent(new goog.ui.ServerChart.UriTooLongEvent(this.uri_.toString()));
};
goog.ui.ServerChart.prototype.computeDataStringForEncoding_ = function(encoding) {
  for (var dataStrings = [], i = 0, setLen = this.dataSets_.length;i < setLen;++i) {
    dataStrings[i] = this.getChartServerValues_(this.dataSets_[i], this.minValue_, this.maxValue_, encoding);
  }
  var delimiter = encoding == goog.ui.ServerChart.EncodingType.TEXT ? "|" : ",", dataStrings = dataStrings.join(delimiter), data;
  data = null == this.numVisibleDataSets_ ? goog.string.buildString(encoding, ":", dataStrings) : goog.string.buildString(encoding, this.numVisibleDataSets_, ":", dataStrings);
  this.uri_.setParameterValue(goog.ui.ServerChart.UriParam.DATA, data);
  return this.uri_.toString().length < this.uriLengthLimit_;
};
goog.ui.ServerChart.prototype.computeMultiAxisDataString_ = function(data, indexSeparator, elementSeparator, axisSeparator) {
  for (var elementStrings = [], i = 0, setLen = this.multiAxisType_.length;i < setLen;++i) {
    data[i] && elementStrings.push(i + indexSeparator + data[i].join(elementSeparator));
  }
  return elementStrings.join(axisSeparator);
};
goog.ui.ServerChart.CHART_VALUES = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
goog.ui.ServerChart.CHART_VALUES_EXTENDED = goog.ui.ServerChart.CHART_VALUES + "-.";
goog.ui.ServerChart.EXTENDED_UPPER_BOUND = Math.pow(goog.ui.ServerChart.CHART_VALUES_EXTENDED.length, 2) - 1;
goog.ui.ServerChart.prototype.getConvertedValue_ = function(value, minValue, maxValue, encoding) {
  goog.asserts.assert(minValue <= maxValue, "minValue should be less than or equal to maxValue");
  var isExtended = encoding == goog.ui.ServerChart.EncodingType.EXTENDED;
  if (goog.isNull(value) || !goog.isDef(value) || isNaN(value) || value < minValue || value > maxValue) {
    return isExtended ? "__" : "_";
  }
  if (encoding == goog.ui.ServerChart.EncodingType.TEXT) {
    return String(value);
  }
  var frac = goog.ui.ServerChart.DEFAULT_NORMALIZATION;
  maxValue > minValue && (frac = (value - minValue) / (maxValue - minValue));
  if (isExtended) {
    var maxIndex = goog.ui.ServerChart.CHART_VALUES_EXTENDED.length, upperBound = goog.ui.ServerChart.EXTENDED_UPPER_BOUND, index1 = Math.floor(frac * upperBound / maxIndex), index2 = Math.floor(frac * upperBound % maxIndex), extendedVals = goog.ui.ServerChart.CHART_VALUES_EXTENDED;
    return extendedVals.charAt(index1) + extendedVals.charAt(index2);
  }
  var index = Math.round(frac * (goog.ui.ServerChart.CHART_VALUES.length - 1));
  return goog.ui.ServerChart.CHART_VALUES.charAt(index);
};
goog.ui.ServerChart.prototype.getChartServerValues_ = function(values, minValue, maxValue, encoding) {
  for (var s = [], i = 0, valuesLen = values.length;i < valuesLen;++i) {
    s.push(this.getConvertedValue_(values[i], minValue, maxValue, encoding));
  }
  return s.join(this.encodingType_ == goog.ui.ServerChart.EncodingType.TEXT ? "," : "");
};
goog.ui.ServerChart.prototype.arrayMin_ = function(ary) {
  for (var min = Infinity, i = 0, aryLen = ary.length;i < aryLen;++i) {
    var value = ary[i];
    null != value && value < min && (min = value);
  }
  return min;
};
goog.ui.ServerChart.prototype.arrayMax_ = function(ary) {
  for (var max = -Infinity, i = 0, aryLen = ary.length;i < aryLen;++i) {
    var value = ary[i];
    null != value && value > max && (max = value);
  }
  return max;
};
goog.ui.ServerChart.prototype.disposeInternal = function() {
  goog.ui.ServerChart.superClass_.disposeInternal.call(this);
  delete this.xLabels_;
  delete this.leftLabels_;
  delete this.rightLabels_;
  delete this.gridX_;
  delete this.gridY_;
  delete this.setColors_;
  delete this.setLegendTexts_;
  delete this.dataSets_;
  this.uri_ = null;
  delete this.minValue_;
  delete this.maxValue_;
  this.title_ = null;
  delete this.multiAxisType_;
  delete this.multiAxisLabelText_;
  delete this.multiAxisLabelPosition_;
  delete this.multiAxisRange_;
  delete this.multiAxisLabelStyle_;
};
goog.ui.ServerChart.Event = {URI_TOO_LONG:"uritoolong"};
goog.ui.ServerChart.UriTooLongEvent = function(uri) {
  goog.events.Event.call(this, goog.ui.ServerChart.Event.URI_TOO_LONG);
  this.uri = uri;
};
goog.inherits(goog.ui.ServerChart.UriTooLongEvent, goog.events.Event);
// INPUT (javascript/gviz/devel/jsapi/jet/shape.js)
gviz.jet = {};
gviz.jet.Shape = function(type, featureId, layerName) {
  this.type_ = type;
  this.featureId_ = featureId;
  this.props_ = {};
  this.checkpointed_ = !1;
  this.rablShape_ = null;
  this.layerName_ = layerName;
  "path" === type && (this.props_.fill = "none", this.props_.stroke = "#000", this.rablShape_ = new RaBl.RaBl.Shapes.Path(this.props_));
};
gviz.jet.Shape.prototype.reset = function() {
  this.checkpointed_ && (this.props_ = Object.getPrototypeOf(this.props_));
};
gviz.jet.Shape.prototype.el = function() {
  if (null == this.rablShape_) {
    var func = $jscomp.scope.funcMap[this.type_];
    if (!func) {
      throw Error("No draw routine for " + this.type_ + ".");
    }
    this.rablShape_ = func.call(null, this.props_);
  }
  return this.rablShape_;
};
gviz.jet.Shape.prototype.props = function() {
  return this.props_;
};
gviz.jet.Shape.prototype.getFeatureId = function() {
  return this.featureId_;
};
gviz.jet.Shape.prototype.getLayerName = function() {
  return this.layerName_;
};
gviz.jet.Shape.prototype.setX = function(x) {
  this.props_.x = x;
  return this;
};
gviz.jet.Shape.prototype.setY = function(y) {
  this.props_.y = y;
  return this;
};
gviz.jet.Shape.prototype.setX2 = function(x) {
  this.props_.x2 = x;
  return this;
};
gviz.jet.Shape.prototype.setY2 = function(y) {
  this.props_.y2 = y;
  return this;
};
gviz.jet.Shape.prototype.setWidth = function(width) {
  this.props_.width = width;
  return this;
};
gviz.jet.Shape.prototype.setHeight = function(height) {
  this.props_.height = height;
  return this;
};
gviz.jet.Shape.prototype.setText = function(text) {
  this.props_.text = text;
  return this;
};
gviz.jet.Shape.prototype.setRadius = function(radius) {
  this.props_.radius = radius;
  return this;
};
gviz.jet.Shape.prototype.inferStyleValues = function(options, path, opt_overrides) {
  var overrides = opt_overrides || {}, self = this;
  options.inferObjectValue(path, null, function(obj) {
    var fill = gviz.Options.convertToColor(obj.fill || overrides.fill) || "none";
    self.setFill(fill);
    var fillOpacity = gviz.Options.convertToRatioNumber(obj.fillOpacity);
    goog.isDefAndNotNull(fillOpacity) && self.setFillOpacity(fillOpacity);
    var stroke = gviz.Options.convertToColor(obj.stroke || overrides.stroke);
    goog.isDefAndNotNull(stroke) && self.setStroke(stroke);
    var strokeWidth = gviz.Options.convertToNonNegativeNumber(obj.strokeWidth);
    goog.isDefAndNotNull(strokeWidth) && self.setStrokeWidth(strokeWidth);
    return null;
  });
  return this;
};
gviz.jet.Shape.prototype.setStroke = function(stroke) {
  this.props_.stroke = stroke;
  this.rablShape_ && this.rablShape_.style("stroke", stroke);
  return this;
};
gviz.jet.Shape.prototype.setStrokeWidth = function(width) {
  this.props_.strokeWidth = width;
  this.rablShape_ && this.rablShape_.style("strokeWidth", width);
  return this;
};
gviz.jet.Shape.prototype.setFill = function(fill) {
  this.props_.fill = fill;
  return this;
};
gviz.jet.Shape.prototype.setFillOpacity = function(fillOpacity) {
  this.props_.fillOpacity = fillOpacity;
  return this;
};
gviz.jet.Shape.prototype.move = function(x, y) {
  this.rablShape_.move(x, y);
  return this;
};
gviz.jet.Shape.prototype.addLine = function(x, y) {
  this.rablShape_.line(x, y);
  return this;
};
gviz.jet.Shape.prototype.addArc = function(cx, cy, rx, ry, from, to, clockwise) {
  this.rablShape_.arc(cx, cy, rx, ry, from, to, clockwise);
  return this;
};
gviz.jet.Shape.prototype.setFontFamily = function(fontFamily) {
  this.props_.fontFamily = fontFamily;
  return this;
};
gviz.jet.Shape.prototype.setFontSize = function(fontSize) {
  this.props_.fontSize = fontSize;
  return this;
};
gviz.jet.Shape.prototype.setFontWeight = function(fontWeight) {
  this.props_.fontWeight = fontWeight;
  return this;
};
gviz.jet.Shape.prototype.setAngle = function(angle) {
  this.props_.rotate = angle;
  return this;
};
gviz.jet.Shape.prototype.setCornerRadius = function(radius) {
  var corners = this.props_.corners = {};
  corners.rx = radius;
  corners.ry = radius;
  return this;
};
gviz.jet.Shape.prototype.setHAlign = function(percent) {
  this.props_.halign = percent;
  return this;
};
gviz.jet.Shape.prototype.setVAlign = function(percent) {
  this.props_.valign = percent;
  return this;
};
gviz.jet.Shape.makeCircle_ = function(props) {
  var style = {fill:props.fill};
  return new RaBl.RaBl.Shapes.Circle(props.radius, props.x, props.y, style);
};
gviz.jet.Shape.makeLine_ = function(props) {
  return new RaBl.RaBl.Shapes.Line(props.x, props.y, props.x2, props.y2, props);
};
gviz.jet.Shape.makeRect_ = function(props) {
  return new RaBl.RaBl.Shapes.Rect(props.x, props.y, props.width, props.height, props);
};
gviz.jet.Shape.makeText_ = function(props) {
  return new RaBl.RaBl.Shapes.Text(props.x, props.y, props.text, props);
};
$jscomp.scope.funcMap = {circle:gviz.jet.Shape.makeCircle_, line:gviz.jet.Shape.makeLine_, rect:gviz.jet.Shape.makeRect_, text:gviz.jet.Shape.makeText_};
// INPUT (javascript/gviz/devel/jsapi/jet/definition.js)
gviz.jet.Definition = function(size) {
  this.shapes_ = [];
  this.size_ = size;
  this.internalId_ = 0;
};
gviz.jet.Definition.prototype.getSize = function() {
  return this.size_;
};
gviz.jet.Definition.prototype.getShapes = function() {
  return this.shapes_;
};
gviz.jet.Definition.prototype.addCircle = function(featureId, layerName, x, y, radius) {
  var shape = (new gviz.jet.Shape("circle", featureId || this.createDefaultFeatureId_(), layerName || "background")).setX(x).setY(y).setRadius(radius);
  this.shapes_.push(shape);
  return shape;
};
gviz.jet.Definition.prototype.addLine = function(featureId, layerName, x1, y1, x2, y2) {
  var shape = (new gviz.jet.Shape("line", featureId || this.createDefaultFeatureId_(), layerName || "background")).setX(x1).setY(y1).setX2(x2).setY2(y2);
  this.shapes_.push(shape);
  return shape;
};
gviz.jet.Definition.prototype.addPath = function(featureId, layerName) {
  var shape = new gviz.jet.Shape("path", featureId || this.createDefaultFeatureId_(), layerName || "background");
  this.shapes_.push(shape);
  return shape;
};
gviz.jet.Definition.prototype.addRect = function(featureId, layerName, x, y, width, height) {
  var shape = (new gviz.jet.Shape("rect", featureId || this.createDefaultFeatureId_(), layerName || "background")).setX(x).setY(y).setWidth(width).setHeight(height);
  this.shapes_.push(shape);
  return shape;
};
gviz.jet.Definition.prototype.addText = function(featureId, layerName, text, x, y, width) {
  var shape = (new gviz.jet.Shape("text", featureId || this.createDefaultFeatureId_(), layerName || "background")).setText(text).setX(x).setY(y).setWidth(width);
  this.shapes_.push(shape);
  return shape;
};
gviz.jet.Definition.prototype.createDefaultFeatureId_ = function() {
  var featureId = new gviz.fw.FeatureId(gviz.fw.FeatureType.BACKGROUND);
  featureId.setAspect(gviz.fw.Aspects.SUBTYPE, "__internal_" + this.internalId_);
  this.internalId_ += 1;
  return featureId;
};
// INPUT (javascript/gviz/devel/jsapi/common/staticrepository.js)
gviz.staticrepository = {};
gviz.staticrepository.ROOT_URI_FORMAT_ = "%s://www.gstatic.com/charts/%s/%s/";
gviz.staticrepository.getScheme_ = function() {
  var location = gviz.util.VisCommon.getLocation();
  return goog.string.isEmptySafe(location) || "http" != goog.uri.utils.getScheme(location) ? "https" : "http";
};
gviz.staticrepository.getRootUri = function(packageName, version) {
  var scheme = gviz.staticrepository.getScheme_();
  return goog.string.format(gviz.staticrepository.ROOT_URI_FORMAT_, scheme, packageName, version);
};
// INPUT (javascript/gviz/devel/jsapi/common/colorbar/scale.js)
gviz.colorbar = {};
gviz.colorbar.Scale = function(valuesScale, colorsScale) {
  if (valuesScale) {
    if (colorsScale.length != valuesScale.length) {
      throw Error("colorsScale and valuesScale must be of the same length");
    }
  } else {
    if (1 != colorsScale.length) {
      throw Error("colorsScale must contain exactly one element when no valueScale is provided");
    }
  }
  this.valuesScale_ = valuesScale;
  this.colorsScale_ = goog.array.map(colorsScale, function(color) {
    return goog.color.parse(color).hex;
  });
};
gviz.colorbar.Scale.ONE_SIDED_DEFAULT_COLORS_ = ["#EFE6DC", "#109618"];
gviz.colorbar.Scale.OPTIONS_PATH = "colorAxis";
gviz.colorbar.Scale.TWO_SIDED_DEFAULT_COLORS_ = ["#DC3912", "#EFE6DC", "#109618"];
gviz.colorbar.Scale.prototype.getValuesScale = function() {
  return this.valuesScale_;
};
gviz.colorbar.Scale.prototype.getColorsScale = function() {
  return this.colorsScale_;
};
gviz.colorbar.Scale.prototype.getColorFor = function(value) {
  if (!this.valuesScale_) {
    return this.colorsScale_[0];
  }
  if (value >= this.valuesScale_[this.valuesScale_.length - 1]) {
    return this.colorsScale_[this.colorsScale_.length - 1];
  }
  if (value <= this.valuesScale_[0]) {
    return this.colorsScale_[0];
  }
  var valuePos = goog.array.binarySearch(this.valuesScale_, value);
  if (0 <= valuePos) {
    return this.colorsScale_[valuePos];
  }
  var lowColorIndex = -valuePos - 2, highColorIndex = -valuePos - 1, gradientRange = this.valuesScale_[highColorIndex] - this.valuesScale_[lowColorIndex], gradientSpread = (value - this.valuesScale_[lowColorIndex]) / gradientRange, blendedColor = gviz.util.blendHexColors(this.colorsScale_[highColorIndex], this.colorsScale_[lowColorIndex], gradientSpread);
  return blendedColor;
};
gviz.colorbar.Scale.getCtorArgs_ = function(values, colors) {
  colors && 0 != colors.length ? 1 == colors.length && (colors = [gviz.colorbar.Scale.ONE_SIDED_DEFAULT_COLORS_[0], colors[0]]) : colors = values && 3 == values.length ? gviz.colorbar.Scale.TWO_SIDED_DEFAULT_COLORS_ : gviz.colorbar.Scale.ONE_SIDED_DEFAULT_COLORS_;
  if (!values || 2 > values.length) {
    return{values:null, colors:[goog.array.peek(colors)]};
  }
  var minValue = values[0], maxValue = values[values.length - 1], rangeWidth = maxValue - minValue;
  if (0 == rangeWidth) {
    return{values:[maxValue], colors:[goog.array.peek(colors)]};
  }
  if (2 == values.length) {
    values = [];
    for (var step = rangeWidth / (colors.length - 1), i = 0;i < colors.length;i++) {
      values.push(minValue + step * i);
    }
  }
  return{values:values, colors:colors};
};
gviz.colorbar.Scale.create = function(options, valueRange) {
  var optionsPath = gviz.colorbar.Scale.OPTIONS_PATH + ".", values = null, valuesOptionPath = optionsPath + "values", userValues = options.inferValue(valuesOptionPath);
  if (userValues && 0 < userValues.length) {
    1 == userValues.length && (userValues = [userValues[0], userValues[0]]);
    valueRange && (goog.isDefAndNotNull(userValues[0]) || (userValues[0] = valueRange.start), goog.isDefAndNotNull(userValues[userValues.length - 1]) || (userValues[userValues.length - 1] = valueRange.end));
    if (!goog.isDefAndNotNull(userValues[0])) {
      throw Error(valuesOptionPath + " must not contain nulls");
    }
    for (var i = 1;i < userValues.length;i++) {
      if (!goog.isDefAndNotNull(userValues[i])) {
        throw Error(valuesOptionPath + " must not contain nulls");
      }
      if (userValues[i] < userValues[i - 1]) {
        throw Error(valuesOptionPath + " must be a monotonically increasing series");
      }
    }
    values = userValues;
  } else {
    var minValueOptionPath = optionsPath + "minValue", maxValueOptionPath = optionsPath + "maxValue", userMinValue = options.inferOptionalNumberValue(minValueOptionPath), userMaxValue = options.inferOptionalNumberValue(maxValueOptionPath);
    if (goog.isDefAndNotNull(userMinValue) && goog.isDefAndNotNull(userMaxValue) && userMinValue > userMaxValue) {
      throw Error(minValueOptionPath + " (" + userMinValue + ") must be at most " + maxValueOptionPath + " (" + userMaxValue + ")");
    }
    var newValueRange = gviz.util.getOverridenRange(valueRange, userMinValue, userMaxValue);
    newValueRange && (values = [newValueRange.start, newValueRange.end]);
  }
  var colors = options.inferValue("colors"), colors = options.inferValue(optionsPath + "colors", colors), colorScaleArgs = gviz.colorbar.Scale.getCtorArgs_(values, colors);
  return new gviz.colorbar.Scale(colorScaleArgs.values, colorScaleArgs.colors);
};
// INPUT (javascript/gviz/devel/jsapi/common/tooltip/htmlbuilder.js)
gviz.util.tooltip.htmlbuilder = {};
gviz.util.tooltip.htmlbuilder.draw = function(tooltipDef, container) {
  var tooltip = gviz.util.tooltip.htmlbuilder.createOverlayHtml(container, tooltipDef.html);
  tooltipDef.customHtml && (tooltip.innerHTML = tooltipDef.html.content);
  var size = new goog.math.Size(tooltip.clientWidth, tooltip.clientHeight), topLeft = gviz.util.tooltip.htmlbuilder.positionTooltip(tooltipDef.anchor, tooltipDef.pivot, tooltipDef.boundaries, tooltipDef.spacing, tooltipDef.margin, size);
  tooltip.style.width = tooltip.clientWidth + 1 + "px";
  tooltip.style.height = tooltip.clientHeight + "px";
  tooltip.style.left = topLeft.x + "px";
  tooltip.style.top = topLeft.y + "px";
  return tooltip;
};
gviz.util.tooltip.htmlbuilder.positionTooltip = function(point, pivot, boundaries, spacing, margin, size) {
  var dx = goog.math.sign(point.x - pivot.x), dy = goog.math.sign(point.y - pivot.y), cx = point.x + (spacing + size.width / 2) * dx, cy = point.y + (spacing + size.height / 2) * dy, left = goog.math.clamp(cx - size.width / 2, boundaries.left + margin, boundaries.right - margin - size.width), top = goog.math.clamp(cy - size.height / 2, boundaries.top + margin, boundaries.bottom - margin - size.height);
  return new goog.math.Coordinate(left, top);
};
gviz.util.tooltip.htmlbuilder.createOverlayHtml = function(container, htmlStructure) {
  var element = gviz.graphics.util.createDom(goog.dom.getDomHelper(container), htmlStructure);
  container.appendChild(element);
  return element;
};
// INPUT (javascript/gviz/devel/jsapi/common/tooltip/tooltipbuilder.js)
gviz.util.tooltip.builder = {};
gviz.util.tooltip.builder.draw = function(tooltipDef, renderer, drawingGroup) {
  var group = gviz.util.tooltip.builder.create(tooltipDef, renderer);
  renderer.appendChild(drawingGroup, group);
  return group;
};
gviz.util.tooltip.builder.create = function(tooltipDef, renderer) {
  var group = renderer.createGroup();
  gviz.util.tooltip.builder.drawTooltipOutline_(tooltipDef, renderer, group);
  gviz.util.tooltip.builder.drawTooltipBody_(tooltipDef, renderer, group);
  return group;
};
gviz.util.tooltip.builder.createNightingale = function(tooltipDef, renderer) {
  var group = renderer.createGroup();
  gviz.util.tooltip.builder.drawNightingaleTooltipOutline_(tooltipDef, renderer, group);
  gviz.util.tooltip.builder.drawTooltipBody_(tooltipDef, renderer, group);
  return group;
};
gviz.util.tooltip.builder.drawNightingaleTooltipOutline_ = function(tooltipDef, renderer, drawingGroup) {
  var path = gviz.util.tooltip.builder.createOutlinePath_(tooltipDef.outline, gviz.util.tooltip.builder.NIGHTINGALE_CORNER_RADIUS_), brush = new gviz.graphics.Brush({fill:"white", stroke:"#b2b2b2", strokeWidth:1.5});
  brush.setShadow({radius:1, opacity:.2, xOffset:0, yOffset:2});
  renderer.drawPath(path, brush, drawingGroup);
};
gviz.util.tooltip.builder.drawTooltipOutline_ = function(tooltipDef, renderer, drawingGroup) {
  for (var path = gviz.util.tooltip.builder.createOutlinePath_(tooltipDef.outline, gviz.util.tooltip.builder.CORNER_RADIUS_), brushes = [new gviz.graphics.Brush({fill:"white", stroke:"#ccc", strokeWidth:1}), new gviz.graphics.Brush({fill:"#ccc", strokeWidth:0, fillOpacity:.6}), new gviz.graphics.Brush({fill:"#ccc", strokeWidth:0, fillOpacity:.4})], i = brushes.length - 1;0 <= i;--i) {
    var pathElement = renderer.drawPath(path, brushes[i], drawingGroup);
    renderer.setOffset(pathElement, i, i);
  }
};
gviz.util.tooltip.builder.drawTooltipBody_ = function(tooltipDef, renderer, drawingGroup) {
  for (var bodyLayout = tooltipDef.bodyLayout, i = 0;i < bodyLayout.entries.length;i++) {
    var entryLayout = bodyLayout.entries[i], entry = entryLayout.entry, entryDrawingGroup = renderer.createGroup();
    renderer.appendChild(drawingGroup, entryDrawingGroup);
    switch(entry.type) {
      case gviz.util.tooltip.BodyEntryType.LINE:
        var line = entry.data, lineLayout = entryLayout.data;
        lineLayout.background && renderer.drawRect(lineLayout.background.box.left, lineLayout.background.box.top, lineLayout.background.box.right - lineLayout.background.box.left, lineLayout.background.box.bottom - lineLayout.background.box.top, line.background.brush, entryDrawingGroup);
        for (var j = 0;j < lineLayout.items.length;j++) {
          var item = line.items[j], itemLayout = lineLayout.items[j];
          switch(item.type) {
            case gviz.util.tooltip.BodyItemType.TEXT:
              renderer.drawText(item.data.text, bodyLayout.rtl ? itemLayout.box.right : itemLayout.box.left, itemLayout.box.top, 1, gviz.graphics.TextAlign.START, gviz.graphics.TextAlign.START, item.data.style, entryDrawingGroup, bodyLayout.rtl);
              break;
            case gviz.util.tooltip.BodyItemType.SQUARE:
              renderer.drawRect(itemLayout.box.left, itemLayout.box.top, itemLayout.box.right - itemLayout.box.left, itemLayout.box.bottom - itemLayout.box.top, item.data.brush, entryDrawingGroup);
              break;
            default:
              goog.asserts.fail('Invalid tooltip item type "' + item.type + '"');
          }
        }
        if (goog.isDefAndNotNull(line.id)) {
          var lineID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.ACTIONS_MENU_ENTRY, line.id]);
          renderer.setLogicalName(entryDrawingGroup, lineID);
        }
        break;
      case gviz.util.tooltip.BodyEntryType.SEPARATOR:
        var separator = entry.data, separatorLayout = entryLayout.data, separatorPath = new gviz.graphics.PathSegments;
        separatorPath.move(separatorLayout.line.x0, separatorLayout.line.y0);
        separatorPath.addLine(separatorLayout.line.x1, separatorLayout.line.y1);
        renderer.drawPath(separatorPath, separator.brush, entryDrawingGroup);
        break;
      default:
        goog.asserts.fail('Invalid tooltip entry type "' + entry.type + '"');
    }
  }
};
gviz.util.tooltip.builder.createOutlinePath_ = function(outline, cornerRadius) {
  var path = new gviz.graphics.PathSegments, box = new goog.math.Box(outline.box.top + .5, outline.box.right + .5, outline.box.bottom + .5, outline.box.left + .5), handlePoints = outline.handlePoints;
  path.move(box.left + cornerRadius, box.bottom);
  path.addArc(box.left + cornerRadius, box.bottom - cornerRadius, cornerRadius, cornerRadius, 180, 270, !0);
  path.addLine(box.left, box.top + cornerRadius);
  path.addArc(box.left + cornerRadius, box.top + cornerRadius, cornerRadius, cornerRadius, 270, 0, !0);
  if (goog.isDefAndNotNull(handlePoints) && handlePoints[0].y == outline.box.top) {
    for (var i = 0;3 > i;++i) {
      path.addLine(handlePoints[i].x + .5, handlePoints[i].y + .5);
    }
  }
  path.addLine(box.right - cornerRadius, box.top);
  path.addArc(box.right - cornerRadius, box.top + cornerRadius, cornerRadius, cornerRadius, 0, 90, !0);
  path.addLine(box.right, box.bottom - cornerRadius);
  path.addArc(box.right - cornerRadius, box.bottom - cornerRadius, cornerRadius, cornerRadius, 90, 180, !0);
  if (goog.isDefAndNotNull(handlePoints) && handlePoints[0].y == outline.box.bottom) {
    for (i = 0;3 > i;++i) {
      path.addLine(handlePoints[i].x + .5, handlePoints[i].y + .5);
    }
  }
  path.close();
  return path;
};
gviz.util.tooltip.builder.EDGE_MINIMUM_DISTANCE_ = 5;
gviz.util.tooltip.builder.CORNER_RADIUS_ = 1;
gviz.util.tooltip.builder.NIGHTINGALE_CORNER_RADIUS_ = 2;
// INPUT (javascript/gviz/devel/jsapi/common/math/coordinate.js)
gviz.math = {};
gviz.math.Coordinate = function(opt_x, opt_y) {
  this.x = opt_x || 0;
  this.y = opt_y || 0;
};
gviz.math.Coordinate.clone = function(c) {
  return new gviz.math.Coordinate(c.x, c.y);
};
gviz.math.Coordinate.prototype.clone = function() {
  return gviz.math.Coordinate.clone(this);
};
// INPUT (javascript/gviz/devel/canviz/text-block.js)
gviz.canviz.TextBlockUtil = {};
gviz.canviz.TextBlock = {};
gviz.canviz.TextBlockUtil.calcLineBoundingBox = function(textLine, textBlock) {
  goog.asserts.assert(!goog.isDefAndNotNull(textBlock.angle) || 0 == textBlock.angle, "Can only calculate the bounding box of axis aligned texts (angle is 0)");
  var anchor = textBlock.anchor ? textBlock.anchor : {x:0, y:0}, xStartEnd = gviz.graphics.TextAlign.getAbsoluteCoordinates(textLine.x + anchor.x, textLine.length, textBlock.paralAlign), yStartEnd = gviz.graphics.TextAlign.getAbsoluteCoordinates(textLine.y + anchor.y, textBlock.textStyle.fontSize, textBlock.perpenAlign);
  return xStartEnd.start == xStartEnd.end || yStartEnd.start == yStartEnd.end ? null : new goog.math.Box(yStartEnd.start, xStartEnd.end, yStartEnd.end, xStartEnd.start);
};
gviz.canviz.TextBlockUtil.calcBoundingBox = function(textBlock) {
  var linesBoundingBoxes = goog.array.map(textBlock.lines, function(line) {
    return gviz.canviz.TextBlockUtil.calcLineBoundingBox(line, textBlock);
  }), linesBoundingBoxes = goog.array.filter(linesBoundingBoxes, goog.isDefAndNotNull);
  return gviz.util.calcBoundingBox(linesBoundingBoxes);
};
// INPUT (javascript/gviz/devel/canviz/util.js)
gviz.canviz.util = {};
gviz.canviz.util.STRING_ZEROES = "0000000000000000";
gviz.canviz.util.PRECISION_THRESHOLD = 1E-7;
gviz.canviz.util.ICU_PATTERN_DECIMAL_SEPARATOR = ".";
gviz.canviz.util.removeFirstElement = function(array) {
  return goog.array.slice(array, 1);
};
gviz.canviz.util.removeLastElement = function(array) {
  return goog.array.slice(array, 0, array.length - 1);
};
gviz.canviz.util.absNumericDiff = function(value1, value2) {
  return Math.abs(value1 - value2);
};
gviz.canviz.util.arraysAlmostEqual = function(a1, a2, tolerance, opt_diffFunc) {
  if (!a1 && !a2) {
    return!0;
  }
  if (!a1 || !a2 || a1.length != a2.length) {
    return!1;
  }
  var diffFunc = opt_diffFunc || gviz.canviz.util.absNumericDiff;
  return goog.array.every(a1, function(obj, i) {
    return diffFunc(a1[i], a2[i]) <= tolerance;
  });
};
gviz.canviz.util.objectsAlmostEqual = function(obj1, obj2, tolerance, opt_diffFunc) {
  if (!obj1 || !obj2) {
    return!0;
  }
  var diffFunc = opt_diffFunc || gviz.canviz.util.absNumericDiff;
  return goog.object.every(obj1, function(value1, key) {
    var value2 = obj2[key];
    return!goog.isDef(obj2[key]) || diffFunc(value1, value2) <= tolerance;
  });
};
gviz.canviz.util.getKeyEnsureDefault = function(object, key, defaultValue) {
  goog.isDefAndNotNull(object[key]) || (object[key] = defaultValue);
  return object[key];
};
gviz.canviz.util.createLogger = function(className, opt_divName) {
  return gviz.util.VisCommon.createLogger(className, opt_divName);
};
gviz.canviz.util.functionTangentCalculator_ = function(vectorFromPrevious, vectorToNext, smoothingFactor) {
  if (0 == vectorFromPrevious.x || 0 == vectorToNext.x) {
    var dy;
    dy = 0 == vectorFromPrevious.x && 0 == vectorToNext.x ? 0 : 0 == vectorFromPrevious.x ? vectorFromPrevious.y : vectorToNext.y;
    return{x:0, y:dy * smoothingFactor / 6};
  }
  var dx = smoothingFactor / 3 * Math.min(Math.abs(vectorFromPrevious.x), Math.abs(vectorToNext.x)), slope = (vectorFromPrevious.y / vectorFromPrevious.x + vectorToNext.y / vectorToNext.x) / 2;
  return 0 < vectorFromPrevious.x ? {x:dx, y:dx * slope} : {x:-dx, y:-dx * slope};
};
gviz.canviz.util.phaseTangentCalculator_ = function(vectorFromPrevious, vectorToNext, smoothingFactor) {
  var magnitudeFromPrevious = vectorFromPrevious.magnitude(), magnitudeToNext = vectorToNext.magnitude();
  if (0 == magnitudeFromPrevious || 0 == magnitudeToNext) {
    return new goog.math.Vec2(0, 0);
  }
  var srqtRatio = Math.sqrt(magnitudeFromPrevious / magnitudeToNext), vectorSum = goog.math.Vec2.sum(vectorFromPrevious.clone().scale(1 / srqtRatio), vectorToNext.clone().scale(srqtRatio));
  vectorSum.scale(smoothingFactor / 6);
  return vectorSum;
};
gviz.canviz.util.calculateControlPoints = function(points, smoothingFactor, isFunction, isClosed, interpolateNulls) {
  for (var tangentCalculator = isFunction ? gviz.canviz.util.functionTangentCalculator_ : gviz.canviz.util.phaseTangentCalculator_, result = [], i = 0;i < points.length;++i) {
    var nextIndex, previousIndex;
    interpolateNulls ? (nextIndex = gviz.canviz.util.nextNonNull(points, i, 1, isClosed), previousIndex = gviz.canviz.util.nextNonNull(points, i, -1, isClosed)) : (nextIndex = isClosed ? (i + 1) % points.length : i + 1, previousIndex = isClosed ? (points.length + i - 1) % points.length : i - 1);
    if (goog.isDefAndNotNull(nextIndex) && goog.isDefAndNotNull(previousIndex) && goog.isDefAndNotNull(points[i]) && goog.isDefAndNotNull(points[previousIndex]) && goog.isDefAndNotNull(points[nextIndex])) {
      var tangent = tangentCalculator(goog.math.Vec2.difference(points[i], points[previousIndex]), goog.math.Vec2.difference(points[nextIndex], points[i]), smoothingFactor);
      result.push([goog.math.Vec2.difference(points[i], tangent), goog.math.Vec2.sum(points[i], tangent)]);
    } else {
      goog.isDefAndNotNull(points[i]) ? result.push([points[i].clone(), points[i].clone()]) : result.push(null);
    }
  }
  return result;
};
gviz.canviz.util.nextNonNull = function(array, index, direction, isCircular) {
  var result = index + direction;
  for (isCircular && (result = (result + array.length) % array.length);result != index && 0 <= result && result < array.length;) {
    if (goog.isDefAndNotNull(array[result])) {
      return result;
    }
    result += direction;
    isCircular && (result = (result + array.length) % array.length);
  }
  return null;
};
gviz.canviz.util.closestValueTo = function(number, table, opt_index) {
  opt_index = opt_index || 0;
  var i = goog.array.findIndex(table, function(record) {
    return record[opt_index] > number;
  });
  return-1 == i ? table.length - 1 : 0 == i ? 0 : table[i][opt_index] - number < number - table[i - 1][opt_index] ? i : i - 1;
};
gviz.canviz.util.extrapolatedClosestValueTo = function(target, table, opt_numOfRepeatingSubIntervals, opt_index) {
  opt_index = opt_index || 0;
  var subIntervalsPerInterval = opt_numOfRepeatingSubIntervals || 0;
  if (0 < table.length && target <= goog.array.peek(table)) {
    var closest = gviz.canviz.util.closestValueTo(target, table, opt_index);
    return[closest, table[closest][opt_index]];
  }
  var firstPariticipatingIndex = table.length - 1 - subIntervalsPerInterval, highestValueInTable = goog.array.peek(table)[opt_index], lowestValueInRepeatingInterval = table[firstPariticipatingIndex][opt_index], totalRepeatingInterval = highestValueInTable - lowestValueInRepeatingInterval, numberOfIntervalsToExtend = Math.floor((target - highestValueInTable) / totalRepeatingInterval), actualResidue = target - highestValueInTable - numberOfIntervalsToExtend * totalRepeatingInterval, possibleResidueTable = 
  goog.array.map(goog.array.slice(table, firstPariticipatingIndex), function(value) {
    return[value[opt_index] - lowestValueInRepeatingInterval];
  }), closestResidueIndex = gviz.canviz.util.closestValueTo(actualResidue, possibleResidueTable, 0), indexInExtrapoledTableOfRoundedTarget = table.length - 1 + numberOfIntervalsToExtend * subIntervalsPerInterval + closestResidueIndex, roundedTarget = highestValueInTable + numberOfIntervalsToExtend * totalRepeatingInterval + possibleResidueTable[closestResidueIndex][0];
  return[indexInExtrapoledTableOfRoundedTarget, roundedTarget];
};
gviz.canviz.util.rangeMap = function(length, f, opt_obj) {
  for (var res = [], i = 0;i < length;i++) {
    res[i] = f.call(opt_obj, i);
  }
  return res;
};
gviz.canviz.util.getPieChartColorMapping = function(numberOfColors, numberOfSlices) {
  if (numberOfColors >= numberOfSlices) {
    return function(sliceIndex) {
      return sliceIndex;
    };
  }
  if (2 >= numberOfColors) {
    return function(sliceIndex) {
      return sliceIndex % numberOfColors;
    };
  }
  var residue = numberOfSlices % numberOfColors, residueSequenceOffset = Math.floor((numberOfColors - residue) / 2), firstSliceOfResidue = numberOfSlices - residue;
  return function(sliceIndex) {
    return sliceIndex < firstSliceOfResidue ? sliceIndex % numberOfColors : (sliceIndex + residueSequenceOffset) % numberOfColors;
  };
};
gviz.canviz.util.getMaxOrMin_ = function(object) {
  return goog.isDefAndNotNull(object.max) ? object.max : object.min;
};
gviz.canviz.util.fillFirstNBuckets = function(buckets, total, opt_dropPenalty, opt_penaltyIndex) {
  goog.isDef(opt_dropPenalty) || (opt_dropPenalty = 0);
  goog.isDef(opt_penaltyIndex) || (opt_penaltyIndex = buckets.length);
  for (var penaltyTotal = total - opt_dropPenalty, idx = 0, resWithPenalty = 0 <= penaltyTotal ? 0 : null, sum = 0, sumWithPenalty = 0, last = null, lastWithPenalty = null;idx < buckets.length;) {
    var bucketMin = buckets[idx].min;
    goog.asserts.assert(0 <= bucketMin, "bucket.min size must be a non-negative number");
    var bucketMax = gviz.canviz.util.getMaxOrMin_(buckets[idx]);
    goog.asserts.assert(bucketMax >= bucketMin, "bucket.max size must be larger than or equal to bucket.min");
    var diff = bucketMax - bucketMin, sum = sum + bucketMin;
    if (sum <= penaltyTotal) {
      var resWithPenalty = idx + 1, cappedDiff = Math.min(penaltyTotal - sum, diff), sumWithPenalty = sum + cappedDiff, lastWithPenalty = bucketMin + cappedDiff
    }
    if (sum > total) {
      return idx >= opt_penaltyIndex ? {n:idx, last:last, remainder:total - (sum - bucketMin)} : goog.isNull(resWithPenalty) ? null : {n:resWithPenalty, last:lastWithPenalty, remainder:penaltyTotal - sumWithPenalty};
    }
    cappedDiff = Math.min(total - sum, diff);
    sum += cappedDiff;
    last = bucketMin + cappedDiff;
    idx++;
  }
  return{n:idx, last:last, remainder:total - sum};
};
gviz.canviz.util.fillCommunicatingVessels = function(buckets, total, opt_getSize) {
  var getSize = opt_getSize || goog.functions.identity, sizes = goog.array.map(buckets, getSize);
  goog.array.sort(sizes);
  for (var waterLevel = 0, i = 0;i < sizes.length;i++) {
    var step = sizes[i] - waterLevel, numOfItemsForThisStep = sizes.length - i, totalSizeForStep = step * numOfItemsForThisStep;
    if (totalSizeForStep <= total) {
      waterLevel = sizes[i], total -= totalSizeForStep;
    } else {
      waterLevel += total / numOfItemsForThisStep;
      total = 0;
      break;
    }
  }
  return{waterLevel:waterLevel, remainder:total};
};
gviz.canviz.util.distributeRealEstate = function(items, total, opt_dropPenalty, opt_penaltyIndex) {
  var fillFirstNBucketsResult = gviz.canviz.util.fillFirstNBuckets(items, total, opt_dropPenalty, opt_penaltyIndex);
  if (!fillFirstNBucketsResult) {
    return null;
  }
  var fitItemsCount = fillFirstNBucketsResult.n, totalMargin = fillFirstNBucketsResult.remainder, fitItems = goog.array.slice(items, 0, fitItemsCount), largestLengthOfExtraArray = goog.array.reduce(fitItems, function(res, item) {
    return Math.max(res, item.extra.length);
  }, 0), result = goog.array.map(fitItems, gviz.canviz.util.getMaxOrMin_);
  0 < result.length && (result[result.length - 1] = fillFirstNBucketsResult.last);
  for (var i = 0;i < largestLengthOfExtraArray;i++) {
    for (var getIthExtra = function(item) {
      return item.extra[i] || 0;
    }, fillCommunicatingVesselsResult = gviz.canviz.util.fillCommunicatingVessels(fitItems, totalMargin, getIthExtra), totalMargin = fillCommunicatingVesselsResult.remainder, j = 0;j < result.length;j++) {
      result[j] += Math.min(fillCommunicatingVesselsResult.waterLevel, items[j].extra[i] || 0);
    }
    if (0 == totalMargin) {
      break;
    }
  }
  return result;
};
gviz.canviz.util.distributeRealEstateWithKeys = function(items, total, opt_dropPenalty, opt_penaltyIndex) {
  var tempResult = gviz.canviz.util.distributeRealEstate(items, total, opt_dropPenalty, opt_penaltyIndex), result = {};
  goog.array.forEach(items, function(item, i) {
    var key = item.key;
    goog.isDefAndNotNull(result[key]) || (result[key] = []);
    i < tempResult.length && result[key].push(tempResult[i]);
  });
  return result;
};
gviz.canviz.util.arrayMultiSlice = function(arr, var_args) {
  var sliceArgs = goog.array.slice(arguments, 1);
  goog.asserts.assert(0 == sliceArgs.length % 2);
  for (var result = [], i = 0;i < sliceArgs.length;i += 2) {
    var beginIdx = Math.min(sliceArgs[i], arr.length), endIdx = Math.min(sliceArgs[i + 1], arr.length), slice = goog.array.slice(arr, beginIdx, endIdx);
    goog.array.extend(result, slice);
  }
  return result;
};
gviz.canviz.util.countRequiredDecimalPrecision = function(number) {
  if (0 == number) {
    return 0;
  }
  for (var x = Math.abs(number), i = 0;16 > i;++i) {
    if (Math.abs(x - Math.round(x)) < x * gviz.canviz.util.PRECISION_THRESHOLD) {
      return i;
    }
    x *= 10;
  }
  return 16;
};
gviz.canviz.util.getExponent_ = function(value) {
  return Math.floor(Math.log(value) / gviz.canviz.Constants.LOG_10);
};
gviz.canviz.util.roundToNumSignificantDigits = function(numSignificantDigits, value) {
  if (0 == value) {
    return value;
  }
  goog.asserts.assert(0 < numSignificantDigits, "numSignificantDigits must be > 0");
  goog.asserts.assert(isFinite(numSignificantDigits), "numSignificantDigits must be > 0");
  var valueExponent = gviz.canviz.util.getExponent_(Math.abs(value)) + 1;
  if (valueExponent > numSignificantDigits) {
    var normalizer = Math.pow(10, valueExponent - numSignificantDigits);
    return Math.round(value / normalizer) * normalizer;
  }
  normalizer = Math.pow(10, numSignificantDigits - valueExponent);
  return Math.round(value * normalizer) / normalizer;
};
gviz.canviz.util.getNumDecimalsPattern = function(numDecimals) {
  var decimalPattern = google.visualization.NumberFormat.DECIMAL_PATTERN;
  if (0 >= numDecimals) {
    return decimalPattern.substr(0, decimalPattern.lastIndexOf(gviz.canviz.util.ICU_PATTERN_DECIMAL_SEPARATOR));
  }
  for (var decimalPattern = decimalPattern.substr(0, decimalPattern.lastIndexOf(gviz.canviz.util.ICU_PATTERN_DECIMAL_SEPARATOR) + 1), i = 0;i < numDecimals;i++) {
    decimalPattern += "#";
  }
  return decimalPattern;
};
gviz.canviz.util.getNumDecimalsFormatter = function(numDecimals) {
  return new google.visualization.NumberFormat({pattern:gviz.canviz.util.getNumDecimalsPattern(numDecimals)});
};
gviz.canviz.util.concatSuffix = function(rootPath, property) {
  return goog.isString(rootPath) ? [rootPath + "." + property] : goog.array.map(rootPath, function(singleRootPath) {
    return singleRootPath + "." + property;
  });
};
gviz.canviz.util.getArray2dValue_ = function(array2d, i1, i2) {
  return 0 > i1 || 0 > i2 ? null : array2d[i1][i2];
};
gviz.canviz.util.calcEditDistanceStep_ = function(array1, array2, array2d, i1, i2, equals) {
  var results = [], lower1 = gviz.canviz.util.getArray2dValue_(array2d, i1 - 1, i2);
  lower1 && results.push({pathLink:lower1, score:lower1.score + 1, key1:i1 - 1, value1:null, key2:null, value2:null});
  var lower2 = gviz.canviz.util.getArray2dValue_(array2d, i1, i2 - 1);
  lower2 && results.push({pathLink:lower2, score:lower2.score + 1, key1:null, value1:null, key2:i2 - 1, value2:null});
  var lower12 = gviz.canviz.util.getArray2dValue_(array2d, i1 - 1, i2 - 1);
  lower12 && equals(array1[i1 - 1], array2[i2 - 1]) && results.push({pathLink:lower12, score:lower12.score, key1:i1 - 1, value1:i2 - 1, key2:i2 - 1, value2:i1 - 1});
  goog.array.sort(results, function(r1, r2) {
    return r1.score - r2.score;
  });
  return 0 < results.length ? results[0] : {pathLink:null, score:0, key1:null, value1:null, key2:null, value2:null};
};
gviz.canviz.util.calcEditDistance = function(array1, array2, opt_equals) {
  for (var equals = opt_equals || function(v1, v2) {
    return v1 == v2;
  }, array2d = [], i1 = 0, leni1 = array1.length;i1 <= leni1;i1++) {
    array2d[i1] = array2d[i1] || [];
    for (var i2 = 0, leni2 = array2.length;i2 <= leni2;i2++) {
      array2d[i1][i2] = gviz.canviz.util.calcEditDistanceStep_(array1, array2, array2d, i1, i2, equals);
    }
  }
  var map1 = {}, map2 = {}, pathElement = array2d[leni1][leni2];
  goog.asserts.assert(pathElement);
  for (var score = pathElement.score;pathElement;) {
    goog.isDefAndNotNull(pathElement.key1) && (map1[pathElement.key1] = pathElement.value1), goog.isDefAndNotNull(pathElement.key2) && (map2[pathElement.key2] = pathElement.value2), pathElement = pathElement.pathLink;
  }
  return{score:score, map1:map1, map2:map2};
};
gviz.canviz.util.mergeArrays = function(ar1Array, ar2Array, opt_getValue) {
  if (!ar1Array || !ar2Array || 0 === ar1Array.length || 0 === ar2Array.length) {
    return null;
  }
  for (var merged = [], getValue = opt_getValue || goog.functions.identity, ar1 = 0, ar2 = 0, ar1Value, ar2Value;ar1 < ar1Array.length || ar2 < ar2Array.length;) {
    ar1 < ar1Array.length && (ar1Value = getValue(ar1Array[ar1])), ar2 < ar2Array.length && (ar2Value = getValue(ar2Array[ar2])), ar1 < ar1Array.length && ar2 < ar2Array.length && ar1Value == ar2Value ? (merged.push({value:ar1Value, ar1:ar1, ar2:ar2}), ar1++, ar2++) : ar1 < ar1Array.length && (null == ar1Value || ar2 == ar2Array.length || ar1Value < ar2Value) ? (merged.push({value:ar1Value, ar1:ar1, ar2:null}), ar1++) : ar2 < ar2Array.length && (null == ar2Value || ar1 == ar1Array.length || ar2Value < 
    ar1Value) && (merged.push({value:ar2Value, ar1:null, ar2:ar2}), ar2++);
  }
  var nearest = function(value, array, idx) {
    if (null == idx) {
      return 0;
    }
    if (idx === array.length - 1 || null == value) {
      return idx;
    }
    var v0 = getValue(array[idx]);
    if (null == v0) {
      return idx + 1;
    }
    var v1 = getValue(array[idx + 1]);
    return null == v1 ? idx : Math.abs(value - v0) <= Math.abs(value - v1) ? idx : idx + 1;
  }, previousAr1 = null, previousAr2 = null;
  goog.array.forEach(merged, function(item) {
    null == item.ar1 ? item.ar1 = nearest(item.value, ar1Array, previousAr1) : previousAr1 = item.ar1;
    null == item.ar2 ? item.ar2 = nearest(item.value, ar2Array, previousAr2) : previousAr2 = item.ar2;
  });
  return merged;
};
gviz.canviz.util.containsNoOtherProperties = function(obj, permittedProperties) {
  for (var property in obj) {
    if (!goog.array.contains(permittedProperties, property)) {
      return!1;
    }
  }
  return!0;
};
gviz.canviz.util.calcCompensatedPointRadius = function(brush, desiredRadius) {
  var radius = desiredRadius - brush.getVisibleStrokeWidth() / 2;
  return Math.max(radius, 0);
};
gviz.canviz.util.simulateForceSystem = function(initialState, getForceFuncs, applyForceFunc, diffFunc, diffLimit, relaxationCoefDecreaseFactor, maxIterationCount) {
  for (var state = initialState, relaxationCoef = 1, i = 0;i < maxIterationCount;i++) {
    var newState = gviz.canviz.util.calcForceSystemNewState_(state, getForceFuncs, applyForceFunc, relaxationCoef), newStateWithZeroRelaxation = gviz.canviz.util.calcForceSystemNewState_(state, getForceFuncs, applyForceFunc, 0), newStateAlmostEqual = gviz.canviz.util.objectsAlmostEqual(state, newState, diffLimit, diffFunc), zeroRelaxStateAlmostEqual = gviz.canviz.util.objectsAlmostEqual(state, newStateWithZeroRelaxation, diffLimit, diffFunc);
    if (newStateAlmostEqual && zeroRelaxStateAlmostEqual) {
      break;
    }
    state = newState;
    relaxationCoef *= relaxationCoefDecreaseFactor;
  }
  return state;
};
gviz.canviz.util.calcForceSystemNewState_ = function(state, getForceFuncs, applyForceFunc, relaxationCoef) {
  var newState = {};
  goog.object.forEach(state, function(value, key) {
    for (var newValue = value, i = 0;i < getForceFuncs.length;i++) {
      var getForceFunc = getForceFuncs[i], force = getForceFunc(state, key, relaxationCoef), newValue = applyForceFunc(newValue, force)
    }
    newState[key] = newValue;
  });
  return newState;
};
gviz.canviz.util.piecewiseLinearInterpolation = function(coordinates, x, interpolateNulls) {
  if (interpolateNulls) {
    return gviz.canviz.util.piecewiseLinearInterpolation_(goog.array.filter(coordinates, goog.isDefAndNotNull), x);
  }
  for (var prevNull = -1, i = 0;i < coordinates.length;i++) {
    var coordinate = coordinates[i];
    if (goog.isNull(coordinate)) {
      var component = goog.array.slice(coordinates, prevNull + 1, i), y = gviz.canviz.util.piecewiseLinearInterpolation_(component, x);
      if (!goog.isNull(y)) {
        return y;
      }
      prevNull = i;
    }
  }
  var lastComponent = goog.array.slice(coordinates, prevNull + 1);
  return gviz.canviz.util.piecewiseLinearInterpolation_(lastComponent, x);
};
gviz.canviz.util.piecewiseLinearInterpolation_ = function(coordinates, x$$0) {
  var compareFn = function(x, coordinate) {
    return goog.array.defaultCompare(x, coordinate.x);
  }, i = goog.array.binarySearch(coordinates, x$$0, compareFn);
  if (0 <= i) {
    return coordinates[i].y;
  }
  var insertionIndex = -(i + 1);
  if (0 == insertionIndex || insertionIndex == coordinates.length) {
    return null;
  }
  var prev = coordinates[insertionIndex - 1], next = coordinates[insertionIndex], line = new goog.math.Line(prev.x, prev.y, next.x, next.y), t = (x$$0 - prev.x) / (next.x - prev.x);
  return line.getInterpolatedPoint(t).y;
};
// INPUT (javascript/gviz/devel/jsapi/common/number-scale.js)
gviz.NumberScaleUtil = {};
gviz.NumberScaleUtil.getIdentityScale = function() {
  return{transform:function(v) {
    return v;
  }, inverse:function(n) {
    return n;
  }};
};
gviz.NumberScaleUtil.getPiecewiseLinearScale_ = function(gaps) {
  var wires = gviz.NumberScaleUtil.gapsToWires_(gaps);
  return{transform:function(v) {
    var wire = gviz.NumberScaleUtil.findWire_(wires, v, function(wire) {
      return wire.source;
    });
    if (goog.isNull(wire)) {
      return v;
    }
    var wireDiff = v - wire.source;
    return wire.target + wireDiff * wire.gapRatio;
  }, inverse:function(n) {
    var wire$$0 = gviz.NumberScaleUtil.findWire_(wires, n, function(wire) {
      return wire.target;
    });
    if (goog.isNull(wire$$0)) {
      return n;
    }
    if (0 == wire$$0.gapRatio) {
      return wire$$0.source;
    }
    var wireDiff = n - wire$$0.target;
    return wire$$0.source + wireDiff / wire$$0.gapRatio;
  }};
};
gviz.NumberScaleUtil.gapsToWires_ = function(gaps) {
  for (var wires = [], offset = 0, prevEnd = null, i = 0;i < gaps.length;i++) {
    var gap = gaps[i], gapSize = gap.gapSize, start = gap.start, end = gap.end;
    goog.asserts.assert(0 <= gapSize);
    goog.asserts.assert(start < end);
    goog.asserts.assert(goog.isNull(prevEnd) || prevEnd <= start);
    var gapRatio = gapSize / (end - start);
    if (goog.isNull(prevEnd) || prevEnd != start) {
      var startWire = {source:start, target:start + offset, gapRatio:gapRatio};
      wires.push(startWire);
    } else {
      startWire = wires[wires.length - 1], startWire.gapRatio = gapRatio;
    }
    var endWire = {source:end, target:start + offset + gapSize, gapRatio:1};
    wires.push(endWire);
    offset += gapSize - (end - start);
    prevEnd = end;
  }
  return wires;
};
gviz.NumberScaleUtil.findWire_ = function(wires, number, wireNumberGetter) {
  var pseudoWire = {source:number, target:number, gapRatio:0}, index = goog.array.binarySearch(wires, pseudoWire, function(aw, bw) {
    var a = wireNumberGetter(aw), b = wireNumberGetter(bw);
    return a < b ? -1 : a > b ? 1 : 0;
  });
  0 > index && (index = -index - 2);
  return 0 > index ? null : wires[index];
};
gviz.NumberScaleUtil.getLogScale = function() {
  return{transform:function(v) {
    return Math.log(v) / Math.LN10;
  }, inverse:function(n) {
    return Math.pow(10, n);
  }};
};
gviz.NumberScaleUtil.getMirroredLogScale = function(zeroThreshold) {
  goog.asserts.assert(0 < zeroThreshold);
  return{transform:function(v) {
    return v > zeroThreshold ? Math.log(v / zeroThreshold) / Math.LN10 : v < -zeroThreshold ? -Math.log(-v / zeroThreshold) / Math.LN10 : 0;
  }, inverse:function(n) {
    return 0 < n ? Math.pow(10, n) * zeroThreshold : 0 > n ? -Math.pow(10, -n) * zeroThreshold : 0;
  }};
};
gviz.NumberScaleUtil.SCALE_TYPE = {PIECEWISE_LINEAR:"piecewiseLinear", LOG:"log", MIRROR_LOG:"mirrorLog"};
gviz.NumberScaleUtil.getScaleType = function(options, logOptionsPath, scaleOptionsPath) {
  var scaleType = options.inferOptionalEnumValue(scaleOptionsPath, gviz.NumberScaleUtil.SCALE_TYPE);
  return scaleType ? scaleType : options.inferBooleanValue(logOptionsPath) ? gviz.NumberScaleUtil.SCALE_TYPE.LOG : gviz.NumberScaleUtil.SCALE_TYPE.PIECEWISE_LINEAR;
};
gviz.NumberScaleUtil.getScale = function(scaleType, valueToZeroDistance, gaps) {
  switch(scaleType) {
    case gviz.NumberScaleUtil.SCALE_TYPE.PIECEWISE_LINEAR:
      return goog.array.isEmpty(gaps) ? gviz.NumberScaleUtil.getIdentityScale() : gviz.NumberScaleUtil.getPiecewiseLinearScale_(gaps);
    case gviz.NumberScaleUtil.SCALE_TYPE.LOG:
      return gviz.NumberScaleUtil.getLogScale();
    case gviz.NumberScaleUtil.SCALE_TYPE.MIRROR_LOG:
      return gviz.NumberScaleUtil.getMirroredLogScale(valueToZeroDistance);
    default:
      return gviz.NumberScaleUtil.getIdentityScale();
  }
};
gviz.NumberScaleUtil.LOG_SCALE_OPTIONS_KEY = "logScale";
gviz.NumberScaleUtil.SCALE_TYPE_OPTIONS_KEY = "scaleType";
// INPUT (third_party/javascript/closure/mochikit/async/deferred.js)
/*
 Portions of this code are from MochiKit, received by
 The Closure Authors under the MIT license. All other code is Copyright
 2005-2009 The Closure Authors. All Rights Reserved.
*/
goog.async.Deferred = function(opt_onCancelFunction, opt_defaultScope) {
  this.sequence_ = [];
  this.onCancelFunction_ = opt_onCancelFunction;
  this.defaultScope_ = opt_defaultScope || null;
  this.hadError_ = this.fired_ = !1;
  this.result_ = void 0;
  this.silentlyCanceled_ = this.blocking_ = this.blocked_ = !1;
  this.unhandledErrorId_ = 0;
  this.parent_ = null;
  this.branches_ = 0;
  if (goog.async.Deferred.LONG_STACK_TRACES && (this.constructorStack_ = null, Error.captureStackTrace)) {
    var target = {stack:""};
    Error.captureStackTrace(target, goog.async.Deferred);
    "string" == typeof target.stack && (this.constructorStack_ = target.stack.replace(/^[^\n]*\n/, ""));
  }
};
goog.async.Deferred.STRICT_ERRORS = !1;
goog.async.Deferred.LONG_STACK_TRACES = !1;
goog.async.Deferred.prototype.cancel = function(opt_deepCancel) {
  if (this.hasFired()) {
    this.result_ instanceof goog.async.Deferred && this.result_.cancel();
  } else {
    if (this.parent_) {
      var parent = this.parent_;
      delete this.parent_;
      opt_deepCancel ? parent.cancel(opt_deepCancel) : parent.branchCancel_();
    }
    this.onCancelFunction_ ? this.onCancelFunction_.call(this.defaultScope_, this) : this.silentlyCanceled_ = !0;
    this.hasFired() || this.errback(new goog.async.Deferred.CanceledError(this));
  }
};
goog.async.Deferred.prototype.branchCancel_ = function() {
  this.branches_--;
  0 >= this.branches_ && this.cancel();
};
goog.async.Deferred.prototype.continue_ = function(isSuccess, res) {
  this.blocked_ = !1;
  this.updateResult_(isSuccess, res);
};
goog.async.Deferred.prototype.updateResult_ = function(isSuccess, res) {
  this.fired_ = !0;
  this.result_ = res;
  this.hadError_ = !isSuccess;
  this.fire_();
};
goog.async.Deferred.prototype.check_ = function() {
  if (this.hasFired()) {
    if (!this.silentlyCanceled_) {
      throw new goog.async.Deferred.AlreadyCalledError(this);
    }
    this.silentlyCanceled_ = !1;
  }
};
goog.async.Deferred.prototype.callback = function(opt_result) {
  this.check_();
  this.assertNotDeferred_(opt_result);
  this.updateResult_(!0, opt_result);
};
goog.async.Deferred.prototype.errback = function(opt_result) {
  this.check_();
  this.assertNotDeferred_(opt_result);
  this.makeStackTraceLong_(opt_result);
  this.updateResult_(!1, opt_result);
};
goog.async.Deferred.prototype.makeStackTraceLong_ = function(error) {
  goog.async.Deferred.LONG_STACK_TRACES && this.constructorStack_ && goog.isObject(error) && error.stack && /^[^\n]+(\n   [^\n]+)+/.test(error.stack) && (error.stack = error.stack + "\nDEFERRED OPERATION:\n" + this.constructorStack_);
};
goog.async.Deferred.prototype.assertNotDeferred_ = function(obj) {
  goog.asserts.assert(!(obj instanceof goog.async.Deferred), "An execution sequence may not be initiated with a blocking Deferred.");
};
goog.async.Deferred.prototype.addCallback = function(cb, opt_scope) {
  return this.addCallbacks(cb, null, opt_scope);
};
goog.async.Deferred.prototype.addErrback = function(eb, opt_scope) {
  return this.addCallbacks(null, eb, opt_scope);
};
goog.async.Deferred.prototype.addBoth = function(f, opt_scope) {
  return this.addCallbacks(f, f, opt_scope);
};
goog.async.Deferred.prototype.addCallbacks = function(cb, eb, opt_scope) {
  goog.asserts.assert(!this.blocking_, "Blocking Deferreds can not be re-used");
  this.sequence_.push([cb, eb, opt_scope]);
  this.hasFired() && this.fire_();
  return this;
};
goog.async.Deferred.prototype.then = function(opt_onFulfilled, opt_onRejected, opt_context) {
  var resolve, reject, promise = new goog.Promise(function(res, rej) {
    resolve = res;
    reject = rej;
  });
  this.addCallbacks(resolve, function(reason) {
    reason instanceof goog.async.Deferred.CanceledError ? promise.cancel() : reject(reason);
  });
  return promise.then(opt_onFulfilled, opt_onRejected, opt_context);
};
goog.Thenable.addImplementation(goog.async.Deferred);
goog.async.Deferred.prototype.chainDeferred = function(otherDeferred) {
  this.addCallbacks(otherDeferred.callback, otherDeferred.errback, otherDeferred);
  return this;
};
goog.async.Deferred.prototype.branch = function(opt_propagateCancel) {
  var d = new goog.async.Deferred;
  this.chainDeferred(d);
  opt_propagateCancel && (d.parent_ = this, this.branches_++);
  return d;
};
goog.async.Deferred.prototype.hasFired = function() {
  return this.fired_;
};
goog.async.Deferred.prototype.isError = function(res) {
  return res instanceof Error;
};
goog.async.Deferred.prototype.hasErrback_ = function() {
  return goog.array.some(this.sequence_, function(sequenceRow) {
    return goog.isFunction(sequenceRow[1]);
  });
};
goog.async.Deferred.prototype.fire_ = function() {
  this.unhandledErrorId_ && this.hasFired() && this.hasErrback_() && (goog.async.Deferred.unscheduleError_(this.unhandledErrorId_), this.unhandledErrorId_ = 0);
  this.parent_ && (this.parent_.branches_--, delete this.parent_);
  for (var res = this.result_, unhandledException = !1, isNewlyBlocked = !1;this.sequence_.length && !this.blocked_;) {
    var sequenceEntry = this.sequence_.shift(), callback = sequenceEntry[0], errback = sequenceEntry[1], scope = sequenceEntry[2], f = this.hadError_ ? errback : callback;
    if (f) {
      try {
        var ret = f.call(scope || this.defaultScope_, res);
        goog.isDef(ret) && (this.hadError_ = this.hadError_ && (ret == res || this.isError(ret)), this.result_ = res = ret);
        goog.Thenable.isImplementedBy(res) && (this.blocked_ = isNewlyBlocked = !0);
      } catch (ex) {
        res = ex, this.hadError_ = !0, this.makeStackTraceLong_(res), this.hasErrback_() || (unhandledException = !0);
      }
    }
  }
  this.result_ = res;
  if (isNewlyBlocked) {
    var onCallback = goog.bind(this.continue_, this, !0), onErrback = goog.bind(this.continue_, this, !1);
    res instanceof goog.async.Deferred ? (res.addCallbacks(onCallback, onErrback), res.blocking_ = !0) : res.then(onCallback, onErrback);
  } else {
    !goog.async.Deferred.STRICT_ERRORS || !this.isError(res) || res instanceof goog.async.Deferred.CanceledError || (unhandledException = this.hadError_ = !0);
  }
  unhandledException && (this.unhandledErrorId_ = goog.async.Deferred.scheduleError_(res));
};
goog.async.Deferred.succeed = function(opt_result) {
  var d = new goog.async.Deferred;
  d.callback(opt_result);
  return d;
};
goog.async.Deferred.fromPromise = function(promise) {
  var d = new goog.async.Deferred;
  d.callback();
  d.addCallback(function() {
    return promise;
  });
  return d;
};
goog.async.Deferred.fail = function(res) {
  var d = new goog.async.Deferred;
  d.errback(res);
  return d;
};
goog.async.Deferred.canceled = function() {
  var d = new goog.async.Deferred;
  d.cancel();
  return d;
};
goog.async.Deferred.when = function(value, callback, opt_scope) {
  return value instanceof goog.async.Deferred ? value.branch(!0).addCallback(callback, opt_scope) : goog.async.Deferred.succeed(value).addCallback(callback, opt_scope);
};
goog.async.Deferred.AlreadyCalledError = function() {
  goog.debug.Error.call(this);
};
goog.inherits(goog.async.Deferred.AlreadyCalledError, goog.debug.Error);
goog.async.Deferred.AlreadyCalledError.prototype.message = "Deferred has already fired";
goog.async.Deferred.AlreadyCalledError.prototype.name = "AlreadyCalledError";
goog.async.Deferred.CanceledError = function() {
  goog.debug.Error.call(this);
};
goog.inherits(goog.async.Deferred.CanceledError, goog.debug.Error);
goog.async.Deferred.CanceledError.prototype.message = "Deferred was canceled";
goog.async.Deferred.CanceledError.prototype.name = "CanceledError";
goog.async.Deferred.Error_ = function(error) {
  this.id_ = goog.global.setTimeout(goog.bind(this.throwError, this), 0);
  this.error_ = error;
};
goog.async.Deferred.Error_.prototype.throwError = function() {
  goog.asserts.assert(goog.async.Deferred.errorMap_[this.id_], "Cannot throw an error that is not scheduled.");
  delete goog.async.Deferred.errorMap_[this.id_];
  throw this.error_;
};
goog.async.Deferred.Error_.prototype.resetTimer = function() {
  goog.global.clearTimeout(this.id_);
};
goog.async.Deferred.errorMap_ = {};
goog.async.Deferred.scheduleError_ = function(error) {
  var deferredError = new goog.async.Deferred.Error_(error);
  goog.async.Deferred.errorMap_[deferredError.id_] = deferredError;
  return deferredError.id_;
};
goog.async.Deferred.unscheduleError_ = function(id) {
  var error = goog.async.Deferred.errorMap_[id];
  error && (error.resetTimer(), delete goog.async.Deferred.errorMap_[id]);
};
goog.async.Deferred.assertNoErrors = function() {
  var map = goog.async.Deferred.errorMap_, key;
  for (key in map) {
    var error = map[key];
    error.resetTimer();
    error.throwError();
  }
};
// INPUT (javascript/closure/net/jsloader.js)
goog.net.jsloader = {};
goog.net.jsloader.GLOBAL_VERIFY_OBJS_ = "closure_verification";
goog.net.jsloader.DEFAULT_TIMEOUT = 5E3;
goog.net.jsloader.scriptsToLoad_ = [];
goog.net.jsloader.loadMany = function(uris, opt_options) {
  if (uris.length) {
    var isAnotherModuleLoading = goog.net.jsloader.scriptsToLoad_.length;
    goog.array.extend(goog.net.jsloader.scriptsToLoad_, uris);
    if (!isAnotherModuleLoading) {
      uris = goog.net.jsloader.scriptsToLoad_;
      var popAndLoadNextScript = function() {
        var uri = uris.shift(), deferred = goog.net.jsloader.load(uri, opt_options);
        uris.length && deferred.addBoth(popAndLoadNextScript);
      };
      popAndLoadNextScript();
    }
  }
};
goog.net.jsloader.load = function(uri, opt_options) {
  var options = opt_options || {}, doc = options.document || document, script = goog.dom.createElement(goog.dom.TagName.SCRIPT), request = {script_:script, timeout_:void 0}, deferred = new goog.async.Deferred(goog.net.jsloader.cancel_, request), timeout = null, timeoutDuration = goog.isDefAndNotNull(options.timeout) ? options.timeout : goog.net.jsloader.DEFAULT_TIMEOUT;
  0 < timeoutDuration && (timeout = window.setTimeout(function() {
    goog.net.jsloader.cleanup_(script, !0);
    deferred.errback(new goog.net.jsloader.Error(goog.net.jsloader.ErrorCode.TIMEOUT, "Timeout reached for loading script " + uri));
  }, timeoutDuration), request.timeout_ = timeout);
  script.onload = script.onreadystatechange = function() {
    if (!script.readyState || "loaded" == script.readyState || "complete" == script.readyState) {
      var removeScriptNode = options.cleanupWhenDone || !1;
      goog.net.jsloader.cleanup_(script, removeScriptNode, timeout);
      deferred.callback(null);
    }
  };
  script.onerror = function() {
    goog.net.jsloader.cleanup_(script, !0, timeout);
    deferred.errback(new goog.net.jsloader.Error(goog.net.jsloader.ErrorCode.LOAD_ERROR, "Error while loading script " + uri));
  };
  goog.dom.setProperties(script, {type:"text/javascript", charset:"UTF-8", src:uri});
  var scriptParent = goog.net.jsloader.getScriptParentElement_(doc);
  scriptParent.appendChild(script);
  return deferred;
};
goog.net.jsloader.loadAndVerify = function(uri, verificationObjName, options) {
  goog.global[goog.net.jsloader.GLOBAL_VERIFY_OBJS_] || (goog.global[goog.net.jsloader.GLOBAL_VERIFY_OBJS_] = {});
  var verifyObjs = goog.global[goog.net.jsloader.GLOBAL_VERIFY_OBJS_];
  if (goog.isDef(verifyObjs[verificationObjName])) {
    return goog.async.Deferred.fail(new goog.net.jsloader.Error(goog.net.jsloader.ErrorCode.VERIFY_OBJECT_ALREADY_EXISTS, "Verification object " + verificationObjName + " already defined."));
  }
  var sendDeferred = goog.net.jsloader.load(uri, options), deferred = new goog.async.Deferred(goog.bind(sendDeferred.cancel, sendDeferred));
  sendDeferred.addCallback(function() {
    var result = verifyObjs[verificationObjName];
    goog.isDef(result) ? (deferred.callback(result), delete verifyObjs[verificationObjName]) : deferred.errback(new goog.net.jsloader.Error(goog.net.jsloader.ErrorCode.VERIFY_ERROR, "Script " + uri + " loaded, but verification object " + verificationObjName + " was not defined."));
  });
  sendDeferred.addErrback(function(error) {
    goog.isDef(verifyObjs[verificationObjName]) && delete verifyObjs[verificationObjName];
    deferred.errback(error);
  });
  return deferred;
};
goog.net.jsloader.getScriptParentElement_ = function(doc) {
  var headElements = doc.getElementsByTagName(goog.dom.TagName.HEAD);
  return!headElements || goog.array.isEmpty(headElements) ? doc.documentElement : headElements[0];
};
goog.net.jsloader.cancel_ = function() {
  var request = this;
  if (request && request.script_) {
    var scriptNode = request.script_;
    scriptNode && "SCRIPT" == scriptNode.tagName && goog.net.jsloader.cleanup_(scriptNode, !0, request.timeout_);
  }
};
goog.net.jsloader.cleanup_ = function(scriptNode, removeScriptNode, opt_timeout) {
  goog.isDefAndNotNull(opt_timeout) && goog.global.clearTimeout(opt_timeout);
  scriptNode.onload = goog.nullFunction;
  scriptNode.onerror = goog.nullFunction;
  scriptNode.onreadystatechange = goog.nullFunction;
  removeScriptNode && window.setTimeout(function() {
    goog.dom.removeNode(scriptNode);
  }, 0);
};
goog.net.jsloader.ErrorCode = {LOAD_ERROR:0, TIMEOUT:1, VERIFY_ERROR:2, VERIFY_OBJECT_ALREADY_EXISTS:3};
goog.net.jsloader.Error = function(code, opt_message) {
  var msg = "Jsloader error (code #" + code + ")";
  opt_message && (msg += ": " + opt_message);
  goog.debug.Error.call(this, msg);
  this.code = code;
};
goog.inherits(goog.net.jsloader.Error, goog.debug.Error);
// INPUT (third_party/javascript/swfobject/swfobject-1.5.compatibility.js)
var __flash_unloadHandler, __flash_savedUnloadHandler;
// INPUT (blaze-out/gcc-4.X.Y-crosstool-v17-hybrid-grtev3-k8-fastbuild/genfiles/third_party/javascript/swfobject/swfobject-1.5-closurized.js)
/*
 SWFObject v1.5: Flash Player detection and embed -
 http://blog.deconcept.com/swfobject/

 SWFObject is (c) 2007 Geoff Stearns and is released under the MIT License:
 http://www.opensource.org/licenses/mit-license.php

*/
var deconcept = {SWFObjectUtil:{}, SWFObject:function(swf, id, w, h, ver, c, quality, xiRedirectUrl, redirectUrl, detectKey) {
  if (document.getElementById) {
    this.DETECT_KEY = detectKey ? detectKey : "detectflash";
    this.skipDetect = deconcept.util.getRequestParameter(this.DETECT_KEY);
    this.params = {};
    this.variables = {};
    this.attributes = [];
    swf && this.setAttribute("swf", swf);
    id && this.setAttribute("id", id);
    w && this.setAttribute("width", w);
    h && this.setAttribute("height", h);
    ver && this.setAttribute("version", new deconcept.PlayerVersion(ver.toString().split(".")));
    this.installedVer = deconcept.SWFObjectUtil.getPlayerVersion();
    !window.opera && document.all && 7 < this.installedVer.major && (deconcept.SWFObject.doPrepUnload = !0);
    c && this.addParam("bgcolor", c);
    var q = quality ? quality : "high";
    this.addParam("quality", q);
    this.setAttribute("useExpressInstall", !1);
    this.setAttribute("doExpressInstall", !1);
    var xir = xiRedirectUrl ? xiRedirectUrl : window.location;
    this.setAttribute("xiRedirectUrl", xir);
    this.setAttribute("redirectUrl", "");
    redirectUrl && this.setAttribute("redirectUrl", redirectUrl);
  }
}};
deconcept.SWFObject.prototype = {setAttribute:function(name, value) {
  this.attributes[name] = value;
}, getAttribute:function(name) {
  return this.attributes[name];
}, addParam:function(name, value) {
  this.params[name] = value;
}, getParams:function() {
  return this.params;
}, addVariable:function(name, value) {
  this.variables[name] = value;
}, getVariables:function() {
  return this.variables;
}, getVariablePairs:function() {
  var variablePairs = [], key, variables = this.getVariables();
  for (key in variables) {
    variablePairs[variablePairs.length] = key + "=" + variables[key];
  }
  return variablePairs;
}, getSWFHTML:function() {
  var swfNode = "";
  if (navigator.plugins && navigator.mimeTypes && navigator.mimeTypes.length) {
    this.getAttribute("doExpressInstall") && (this.addVariable("MMplayerType", "PlugIn"), this.setAttribute("swf", this.xiSWFPath));
    var swfNode = '<embed type="application/x-shockwave-flash" src="' + this.getAttribute("swf") + '" width="' + this.getAttribute("width") + '" height="' + this.getAttribute("height") + '" style="' + this.getAttribute("style") + '"', swfNode = swfNode + (' id="' + this.getAttribute("id") + '" name="' + this.getAttribute("id") + '" '), params = this.getParams(), key;
    for (key in params) {
      swfNode += [key] + '="' + params[key] + '" ';
    }
    var pairs = this.getVariablePairs().join("&");
    0 < pairs.length && (swfNode += 'flashvars="' + pairs + '"');
    swfNode += "/>";
  } else {
    this.getAttribute("doExpressInstall") && (this.addVariable("MMplayerType", "ActiveX"), this.setAttribute("swf", this.xiSWFPath));
    swfNode = '<object id="' + this.getAttribute("id") + '" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="' + this.getAttribute("width") + '" height="' + this.getAttribute("height") + '" style="' + this.getAttribute("style") + '">';
    swfNode += '<param name="movie" value="' + this.getAttribute("swf") + '" />';
    params = this.getParams();
    for (key in params) {
      swfNode += '<param name="' + key + '" value="' + params[key] + '" />';
    }
    pairs = this.getVariablePairs().join("&");
    0 < pairs.length && (swfNode += '<param name="flashvars" value="' + pairs + '" />');
    swfNode += "</object>";
  }
  return swfNode;
}, write:function(elementId) {
  if (this.getAttribute("useExpressInstall")) {
    var expressInstallReqVer = new deconcept.PlayerVersion([6, 0, 65]);
    this.installedVer.versionIsValid(expressInstallReqVer) && !this.installedVer.versionIsValid(this.getAttribute("version")) && (this.setAttribute("doExpressInstall", !0), this.addVariable("MMredirectURL", escape(this.getAttribute("xiRedirectUrl"))), document.title = document.title.slice(0, 47) + " - Flash Player Installation", this.addVariable("MMdoctitle", document.title));
  }
  if (this.skipDetect || this.getAttribute("doExpressInstall") || this.installedVer.versionIsValid(this.getAttribute("version"))) {
    var n = "string" == typeof elementId ? document.getElementById(elementId) : elementId;
    n.innerHTML = this.getSWFHTML();
    return!0;
  }
  "" != this.getAttribute("redirectUrl") && document.location.replace(this.getAttribute("redirectUrl"));
  return!1;
}};
deconcept.SWFObjectUtil.getPlayerVersion = function() {
  var PlayerVersion = new deconcept.PlayerVersion([0, 0, 0]);
  if (navigator.plugins && navigator.mimeTypes.length) {
    var x = navigator.plugins["Shockwave Flash"];
    x && x.description && (PlayerVersion = new deconcept.PlayerVersion(x.description.replace(/([a-zA-Z]|\s)+/, "").replace(/(\s+r|\s+b[0-9]+)/, ".").split(".")));
  } else {
    if (navigator.userAgent && 0 <= navigator.userAgent.indexOf("Windows CE")) {
      for (var axo = 1, counter = 3;axo;) {
        try {
          counter++, axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash." + counter), PlayerVersion = new deconcept.PlayerVersion([counter, 0, 0]);
        } catch (e) {
          axo = null;
        }
      }
    } else {
      axo = null;
      try {
        axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
      } catch (e$$0) {
        try {
          axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6"), PlayerVersion = new deconcept.PlayerVersion([6, 0, 21]), axo.AllowScriptAccess = "always";
        } catch (e$$1) {
          if (6 == PlayerVersion.major) {
            return PlayerVersion;
          }
        }
        try {
          axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
        } catch (e$$2) {
        }
      }
      null != axo && (PlayerVersion = new deconcept.PlayerVersion(axo.GetVariable("$version").split(" ")[1].split(",")));
    }
  }
  return PlayerVersion;
};
deconcept.PlayerVersion = function(arrVersion) {
  this.major = null != arrVersion[0] ? parseInt(arrVersion[0], 10) : 0;
  this.minor = null != arrVersion[1] ? parseInt(arrVersion[1], 10) : 0;
  this.rev = null != arrVersion[2] ? parseInt(arrVersion[2], 10) : 0;
};
deconcept.PlayerVersion.prototype.versionIsValid = function(fv) {
  return this.major < fv.major ? !1 : this.major > fv.major ? !0 : this.minor < fv.minor ? !1 : this.minor > fv.minor ? !0 : this.rev < fv.rev ? !1 : !0;
};
deconcept.util = {getRequestParameter:function(param) {
  var q = document.location.search || document.location.hash;
  if (null == param) {
    return q;
  }
  if (q) {
    for (var pairs = q.substring(1).split("&"), i = 0;i < pairs.length;i++) {
      if (pairs[i].substring(0, pairs[i].indexOf("=")) == param) {
        return pairs[i].substring(pairs[i].indexOf("=") + 1);
      }
    }
  }
  return "";
}};
deconcept.SWFObjectUtil.cleanupSWFs = function() {
  for (var objects = document.getElementsByTagName("OBJECT"), i = objects.length - 1;0 <= i;i--) {
    objects[i].style.display = "none";
    for (var x in objects[i]) {
      "function" == typeof objects[i][x] && (objects[i][x] = function() {
      });
    }
  }
};
deconcept.SWFObject.doPrepUnload && !deconcept.unloadSet && (deconcept.SWFObjectUtil.prepUnload = function() {
  __flash_unloadHandler = function() {
  };
  __flash_savedUnloadHandler = function() {
  };
  window.attachEvent("onunload", deconcept.SWFObjectUtil.cleanupSWFs);
}, window.attachEvent("onbeforeunload", deconcept.SWFObjectUtil.prepUnload), deconcept.unloadSet = !0);
!document.getElementById && document.all && (document.getElementById = function(id) {
  return document.all[id];
});
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/interaction-events.js)
gviz.geochart = {};
gviz.geochart.interactionEvents = {};
gviz.geochart.interactionEvents.EventType = {FEATURE_CLICK:"featureClick", FEATURE_HOVER:"featureHover", FEATURE_MOVE:"featureMove", MARKER_HOVER:"markerHover", MARKER_CLICK:"markerClick", MARKER_MOVE:"markerMove"};
gviz.geochart.interactionEvents.ElementType = {FEATURE:"feature", MARKER:"marker", OCEAN:"ocean", MAGNIFYING_GLASS_BORDER:"magnifyingGlassBorder", MAGNIFYING_GLASS_TRIANGLE:"magnifyingGlassTriangle"};
gviz.geochart.interactionEvents.isFeatureEvent = function(event) {
  return event.elementType == gviz.geochart.interactionEvents.ElementType.FEATURE;
};
gviz.geochart.interactionEvents.isMarkerEvent = function(event) {
  return event.elementType == gviz.geochart.interactionEvents.ElementType.MARKER;
};
// INPUT (javascript/gviz/devel/jsapi/packages/util/regioncoder.js)
gviz.util.RegionCoder = function(dictionary) {
  this.dictionary_ = dictionary;
};
gviz.util.RegionCoder.logger_ = goog.log.getLogger("gviz.util.RegionCoder", goog.debug.Logger.Level.ALL);
gviz.util.RegionCoder.BASE_GEOCODES_URL_ = gviz.staticrepository.getRootUri("regioncoder", "0") + "geocodes";
gviz.util.RegionCoder.REQUEST_TIMEOUT_ = 5E3;
gviz.util.RegionCoder.coders_ = {};
gviz.util.RegionCoder.requestCoder = function(dictionaryName, callback) {
  dictionaryName = goog.string.trim(dictionaryName.toLowerCase());
  dictionaryName = goog.string.urlEncode(dictionaryName);
  var obj = gviz.util.RegionCoder.coders_[dictionaryName];
  if (null == obj) {
    gviz.util.RegionCoder.coders_[dictionaryName] = [callback];
    var url = gviz.util.RegionCoder.BASE_GEOCODES_URL_ + "/" + dictionaryName + ".js";
    goog.log.info(gviz.util.RegionCoder.logger_, "requesting dictionary " + url);
    gviz.util.VisCommon.appendScript(url);
    goog.Timer.callOnce(goog.partial(gviz.util.RegionCoder.dictionaryReady, dictionaryName, null), gviz.util.RegionCoder.REQUEST_TIMEOUT_);
    goog.log.info(gviz.util.RegionCoder.logger_, "sent request.");
  } else {
    "array" == goog.typeOf(obj) ? (goog.array.insert(obj, callback), goog.log.info(gviz.util.RegionCoder.logger_, "request already sent.")) : (goog.Timer.callOnce(goog.partial(callback, obj), 0), goog.log.info(gviz.util.RegionCoder.logger_, "dictionary downloaded."));
  }
};
gviz.util.RegionCoder.dictionaryReady = function(dictionaryName, dictionary) {
  if (dictionary) {
    goog.log.info(gviz.util.RegionCoder.logger_, "dictionary " + dictionaryName + " retrieved.");
    var regionCoder = new gviz.util.RegionCoder(dictionary), callbacks = gviz.util.RegionCoder.coders_[dictionaryName];
    if ("array" == goog.typeOf(callbacks)) {
      gviz.util.RegionCoder.coders_[dictionaryName] = regionCoder;
      for (var i = 0;i < callbacks.length;i++) {
        callbacks[i](regionCoder);
      }
    } else {
      goog.log.error(gviz.util.RegionCoder.logger_, "dictionary " + dictionaryName + " arrived too late.");
    }
  } else {
    if (callbacks = gviz.util.RegionCoder.coders_[dictionaryName], "array" == goog.typeOf(callbacks)) {
      for (goog.log.error(gviz.util.RegionCoder.logger_, "dictionary " + dictionaryName + " timeout."), gviz.util.RegionCoder.coders_[dictionaryName] = null, i = 0;i < callbacks.length;i++) {
        callbacks[i](null);
      }
    }
  }
};
gviz.util.RegionCoder.prototype.getCode = function(regionName) {
  regionName = goog.string.trim(regionName.toLowerCase());
  return this.dictionary_[regionName];
};
gviz.util.RegionCoder.hasProvincesRegionCodes = function(regionName) {
  return 0 <= goog.array.binarySearch(gviz.util.RegionCoder.REGIONS_WITH_PROVINCE_REGIONCODER_, regionName);
};
gviz.util.RegionCoder.REGIONS_WITH_PROVINCE_REGIONCODER_ = "AD AE AF AG AL AM AO AR AT AU AZ BA BB BD BE BF BG BH BI BJ BN BO BR BS BT BW BY BZ CA CD CF CG CH CI CL CM CN CO CR CS CU CV CY CZ DE DJ DK DM DO DZ EC EE EG ER ES ET FI FJ FM FR GA GB GD GE GH GM GN GQ GR GT GW GY HN HR HT HU ID IE IL IN IQ IR IS IT JM JO JP KE KG KH KI KM KN KP KR KW KZ LA LB LI LK LR LS LT LU LV LY MA MD ME MG MH MK ML MM MN MR MT MU MV MW MX MY MZ NA NE NG NI NL NO NP NR NZ OM PA PE PG PH PK PL PT PW PY QA RO RS RU RW SA SB SC SD SE SG SH SI SK SL SM SN SO SR ST SV SY SZ TD TG TH TJ TL TM TN TO TR TT TV TW TZ UA UG UM US UY UZ VC VE VN VU WS YE YU ZA ZM ZW".split(" ");
// INPUT (javascript/gviz/devel/jsapi/packages/util/regioncoder_export.js)
goog.exportSymbol("gviz.util.RegionCoder.dictionaryReady", gviz.util.RegionCoder.dictionaryReady);
// INPUT (javascript/gviz/devel/jsapi/common/colorbar/definition.js)
// INPUT (javascript/gviz/devel/jsapi/common/colorbar/definer.js)
gviz.colorbar.definer = {};
gviz.colorbar.Orientation = {HORIZONTAL:"horizontal", VERTICAL:"vertical"};
gviz.colorbar.definer.define = function(colorScale, drawingOptions, markers, textMeasureFunction) {
  var drawingRect = {}, extremeValuesTextSize = {}, numberFormat = drawingOptions.numberFormat || google.visualization.NumberFormat.DECIMAL_PATTERN;
  if (drawingOptions.orientation == gviz.colorbar.Orientation.HORIZONTAL) {
    var extremeValuesTextSize = gviz.colorbar.definer.calculateExtremeValuesTextProperties_(colorScale, drawingOptions.textStyle, numberFormat, textMeasureFunction), textDrawingRectBuffer = extremeValuesTextSize.minValue.height / 4, drawingRectStartOffset = extremeValuesTextSize.minValue.width + textDrawingRectBuffer, drawingRectWidth = drawingOptions.width - (extremeValuesTextSize.minValue.width + extremeValuesTextSize.maxValue.width + 2 * textDrawingRectBuffer), drawingRect = new goog.math.Rect(drawingRectStartOffset, 
    0, drawingRectWidth, drawingOptions.height)
  } else {
    drawingRect = new goog.math.Rect(0, 0, drawingOptions.width, drawingOptions.height);
  }
  var markerHeight = drawingRect.height * gviz.colorbar.definer.MARKER_HEIGHT_RATIO, markerEdge = 2 * (markerHeight / Math.sqrt(3)), colorsGradientDrawingRect = new goog.math.Rect(drawingRect.left + markerEdge / 2, drawingRect.top + markerHeight + 1, drawingRect.width - markerEdge, drawingRect.height - markerHeight - 1), colorGradientRectanglesDefinitions = gviz.colorbar.definer.defineColorsGradient_(colorScale, colorsGradientDrawingRect);
  if (goog.isDefAndNotNull(colorGradientRectanglesDefinitions) && 0 < colorGradientRectanglesDefinitions.length && (0 > colorGradientRectanglesDefinitions[0].rectangle.width || 0 > colorGradientRectanglesDefinitions[0].rectangle.height)) {
    return null;
  }
  var markersDefinitions = gviz.colorbar.definer.defineMarkers_(colorScale, drawingRect, markers, markerHeight, markerEdge, drawingOptions.markerColor), textItemsDefinitions = [];
  drawingOptions.orientation == gviz.colorbar.Orientation.HORIZONTAL && (textItemsDefinitions = gviz.colorbar.definer.defineTextItems_(drawingOptions, extremeValuesTextSize));
  var colorBarDefinition = {colorGradientRectanglesDefinitions:colorGradientRectanglesDefinitions, markersDefinitions:markersDefinitions, textItemsDefinitions:textItemsDefinitions};
  gviz.colorbar.definer.trasformOrientationAndPosition_(colorBarDefinition, drawingOptions);
  return colorBarDefinition;
};
gviz.colorbar.definer.MARKER_HEIGHT_RATIO = .33;
gviz.colorbar.definer.defineColorsGradient_ = function(colorScale, colorsGradientDrawingRect) {
  var colorsScale = colorScale.getColorsScale(), valuesScale = colorScale.getValuesScale(), valuesRange = valuesScale[valuesScale.length - 1] - valuesScale[0], colorGradientRectanglesDefinitions;
  if (0 == valuesRange) {
    colorGradientRectanglesDefinitions = [{rectangle:new goog.math.Rect(colorsGradientDrawingRect.left, colorsGradientDrawingRect.top, colorsGradientDrawingRect.width, colorsGradientDrawingRect.height), brush:new gviz.graphics.Brush({fill:colorsScale[0]})}];
  } else {
    colorGradientRectanglesDefinitions = [];
    for (var rectBarRatio = colorsGradientDrawingRect.width / valuesRange, leftBound = colorsGradientDrawingRect.left, rightBound = 0, i = 0;i < valuesScale.length - 1;++i) {
      rightBound = leftBound + (valuesScale[i + 1] - valuesScale[i]) * rectBarRatio, colorGradientRectanglesDefinitions[i] = {rectangle:new goog.math.Rect(leftBound, colorsGradientDrawingRect.top, rightBound - leftBound, colorsGradientDrawingRect.height), brush:new gviz.graphics.Brush({gradient:{x1:leftBound, y1:0, x2:rightBound, y2:0, color1:colorsScale[i], color2:colorsScale[i + 1]}})}, leftBound = rightBound;
    }
  }
  return colorGradientRectanglesDefinitions;
};
gviz.colorbar.definer.defineMarkers_ = function(colorScale, drawingRect, markers, markerHeight, markerEdge, markerColor) {
  for (var markersDefinitions = [], i = 0;i < markers.length;++i) {
    var markerAbsolutCenterPosition = drawingRect.left + gviz.colorbar.definer.getValuePosition_(markers[i].value, colorScale, drawingRect, markerEdge) + markerEdge / 2, markerPath = [markerAbsolutCenterPosition - markerEdge / 2, drawingRect.top, markerAbsolutCenterPosition + markerEdge / 2, drawingRect.top, markerAbsolutCenterPosition, drawingRect.top + markerHeight], markerBrush = new gviz.graphics.Brush({fill:markerColor, stroke:markerColor});
    markersDefinitions[i] = {path:markerPath, brush:markerBrush};
  }
  return markersDefinitions;
};
gviz.colorbar.definer.getValuePosition_ = function(value, colorScale, drawingRect, markerEdge) {
  var valuesScale = colorScale.getValuesScale();
  if (value < valuesScale[0]) {
    return 0;
  }
  var colorsGradientWidth = drawingRect.width - markerEdge;
  if (value > valuesScale[valuesScale.length - 1]) {
    return colorsGradientWidth;
  }
  var valuesRange = valuesScale[valuesScale.length - 1] - valuesScale[0];
  return 0 == valuesRange ? .5 * colorsGradientWidth : (value - valuesScale[0]) / valuesRange * colorsGradientWidth;
};
gviz.colorbar.definer.trasformOrientationAndPosition_ = function(colorBarDef, drawingOptions) {
  for (var colorGradientRectanglesDefinitions = colorBarDef.colorGradientRectanglesDefinitions, i = 0;i < colorGradientRectanglesDefinitions.length;++i) {
    var colorGradientRectangle = colorGradientRectanglesDefinitions[i];
    if (drawingOptions.orientation == gviz.colorbar.Orientation.VERTICAL) {
      var left = colorGradientRectangle.rectangle.left;
      colorGradientRectangle.rectangle.left = colorGradientRectangle.rectangle.top;
      colorGradientRectangle.rectangle.top = left;
      var width = colorGradientRectangle.rectangle.width;
      colorGradientRectangle.rectangle.width = colorGradientRectangle.rectangle.height;
      colorGradientRectangle.rectangle.height = width;
    }
    colorGradientRectangle.rectangle.left += drawingOptions.left;
    colorGradientRectangle.rectangle.top += drawingOptions.top;
    var brush = colorGradientRectangle.brush.clone();
    colorGradientRectangle.brush = brush;
    var brushGradient = brush.getGradient();
    drawingOptions.orientation == gviz.colorbar.Orientation.VERTICAL && (brushGradient.y1 = brushGradient.x1, brushGradient.x1 = 0, brushGradient.y2 = brushGradient.x2, brushGradient.x2 = 0);
    goog.isDefAndNotNull(brushGradient) && (brushGradient.x1 += drawingOptions.left, brushGradient.y1 += drawingOptions.top, brushGradient.x2 += drawingOptions.left, brushGradient.y2 += drawingOptions.top);
  }
  for (var markersDefinitions = colorBarDef.markersDefinitions, i = 0;i < markersDefinitions.length;++i) {
    for (var j = 0;3 > j;++j) {
      if (drawingOptions.orientation == gviz.colorbar.Orientation.VERTICAL) {
        var x = markersDefinitions[i].path[2 * j];
        markersDefinitions[i].path[2 * j] = markersDefinitions[i].path[2 * j + 1];
        markersDefinitions[i].path[2 * j + 1] = x;
      }
      markersDefinitions[i].path[2 * j] += drawingOptions.left;
      markersDefinitions[i].path[2 * j + 1] += drawingOptions.top;
    }
  }
  for (var textItemsDefinitions = colorBarDef.textItemsDefinitions, i = 0;i < textItemsDefinitions.length;++i) {
    textItemsDefinitions[i].x += drawingOptions.left, textItemsDefinitions[i].y += drawingOptions.top;
  }
};
gviz.colorbar.definer.calculateExtremeValuesTextProperties_ = function(colorScale, textStyle, numberPattern, textMeasureFunction) {
  var colorBarMinValue = colorScale.getValuesScale()[0], colorBarMaxValue = colorScale.getValuesScale()[colorScale.getValuesScale().length - 1], numberFormatter = new google.visualization.NumberFormat({pattern:numberPattern}), colorBarMinValueText = numberFormatter.formatValue(colorBarMinValue), colorBarMaxValueText = numberFormatter.formatValue(colorBarMaxValue);
  return{minValue:{text:colorBarMinValueText, width:textMeasureFunction ? textMeasureFunction(colorBarMinValueText, textStyle).width : 0, height:textStyle.fontSize}, maxValue:{text:colorBarMaxValueText, width:textMeasureFunction ? textMeasureFunction(colorBarMaxValueText, textStyle).width : 0, height:textStyle.fontSize}};
};
gviz.colorbar.definer.defineTextItems_ = function(drawingOptions, extremeValuesTextSize) {
  var textItemsDefinitions = [];
  textItemsDefinitions[0] = {x:0, y:drawingOptions.height - extremeValuesTextSize.minValue.height, text:extremeValuesTextSize.minValue.text, style:drawingOptions.textStyle};
  textItemsDefinitions[1] = {x:drawingOptions.width - extremeValuesTextSize.maxValue.width, y:drawingOptions.height - extremeValuesTextSize.maxValue.height, text:extremeValuesTextSize.maxValue.text, style:drawingOptions.textStyle};
  return textItemsDefinitions;
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/projection/projection-typedefs.js)
gviz.projection = {};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/static-map.js)
gviz.geochart.MapResolution = {CONTINENTS:"continents", SUBCONTINENTS:"subcontinents", COUNTRIES:"countries", PROVINCES:"provinces", METROS:"metros"};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/projection/base-projection.js)
gviz.projection.BaseProjection = function(options) {
  this.options_ = options || {};
};
gviz.projection.BaseProjection.prototype.getAspectRatio = function() {
  return gviz.canviz.Constants.GOLDEN_RATIO;
};
gviz.projection.BaseProjection.prototype.projectBoundingBox = function() {
  return null;
};
gviz.projection.BaseProjection.prototype.set = function(option, value) {
  this.options_[option] = value;
};
gviz.projection.BaseProjection.prototype.getOptions = function() {
  var options = this.options_, output = goog.object.unsafeClone(options);
  return output;
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/projection/albers-projection.js)
gviz.projection.AlbersProjection = function(options) {
  var originLat = 0, originLng = 0;
  if (options.boundingBox) {
    var lo = options.boundingBox.lo, hi = options.boundingBox.hi, originLat = (hi[0] - lo[0]) / 2 + lo[0], originLng = (hi[1] - lo[1]) / 2 + lo[1]
  }
  var default_parallels = [29.5, 45.5], defaults = {parallels:default_parallels, origin:{lat:originLat, lng:originLng}}, origin = defaults.origin;
  options.origin && goog.object.extend(origin, options.origin);
  goog.object.extend(defaults, options);
  defaults.origin = origin;
  defaults.parallels && 0 !== defaults.parallels.length ? 2 > defaults.parallels.length && (defaults.parallels[1] = Math.abs(defaults.parallels[0] - default_parallels[0]) > Math.abs(defaults.parallels[0] - default_parallels[1]) ? default_parallels[0] : default_parallels[1]) : defaults.parallels = default_parallels;
  gviz.projection.BaseProjection.call(this, options);
  this.originLat_ = defaults.origin.lat / (180 / Math.PI);
  this.originLng_ = defaults.origin.lng / (180 / Math.PI);
  this.parallels_ = goog.array.map(defaults.parallels, function(parallel) {
    return parallel / (180 / Math.PI);
  });
};
goog.inherits(gviz.projection.AlbersProjection, gviz.projection.BaseProjection);
gviz.projection.AlbersProjection.prototype.project = function(coordinates$$0) {
  return goog.array.map(arguments, goog.bind(function(coordinates) {
    goog.asserts.assert(2 === coordinates.length);
    var lat = coordinates[0] / (180 / Math.PI), lng = coordinates[1] / (180 / Math.PI), n = .5 * (Math.sin(this.parallels_[0]) + Math.sin(this.parallels_[1])), theta = n * (lng - this.originLng_), C = Math.cos(this.parallels_[0]), C = C * C, C = C + 2 * n * Math.sin(this.parallels_[0]), p = Math.sqrt(C - 2 * n * Math.sin(lat)) / n, p0 = Math.sqrt(C - 2 * n * Math.sin(this.originLat_)) / n;
    return{x:180 / Math.PI * Math.sin(theta) * p, y:180 / Math.PI * (p0 - p * Math.cos(theta))};
  }, this));
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/projection/kavrayskiy-vii-projection.js)
gviz.projection.KavrayskiyVIIProjection = function(options) {
  gviz.projection.BaseProjection.call(this, options);
};
goog.inherits(gviz.projection.KavrayskiyVIIProjection, gviz.projection.BaseProjection);
gviz.projection.KavrayskiyVIIProjection.prototype.getAspectRatio = function() {
  return 2.2;
};
gviz.projection.KavrayskiyVIIProjection.prototype.project = function(coordinates$$0) {
  return goog.array.map(arguments, function(coordinates) {
    goog.asserts.assert(2 === coordinates.length);
    var lat = coordinates[0] / (180 / Math.PI), lng = coordinates[1] / (180 / Math.PI), multiplier = 3 * lng / (2 * Math.PI) * (180 / Math.PI);
    return{x:Math.sqrt(Math.PI * Math.PI / 3 - lat * lat) * multiplier, y:lat};
  });
};
// INPUT (javascript/gviz/devel/jsapi/common/math/math.js)
gviz.math.sec = function(x) {
  return 1 / Math.cos(x);
};
gviz.math.cot = function(x) {
  return 1 / Math.tan(x);
};
gviz.math.solve3x3 = function(a, b, c, d) {
  var result = Array(3), theta = a[1] * b[0] / a[0] - b[1], omega = b[0] * a[2] / a[0] - b[2], zd = c[2], zd = zd - c[0] * a[2] / a[0], zd = zd + c[0] * a[1] / a[0] * (omega / theta), zd = zd - c[1] * omega / theta, zn = d[2], zn = zn - a[2] * d[0] / a[0], zn = zn + omega / theta * (a[1] * d[0] / a[0] - d[1]);
  result[2] = zn / zd;
  result[1] = a[1] / a[0] * (d[0] - c[0] * result[2]);
  result[1] += c[1] * result[2] - d[1];
  result[1] /= theta;
  result[0] = d[0] - b[0] * result[1] - c[0] * result[2];
  result[0] /= a[0];
  return result;
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/projection/lambert-projection.js)
gviz.projection.LambertProjection = function(options) {
  var originLat = 0, originLng = 0;
  if (options.boundingBox) {
    var lo = options.boundingBox.lo, hi = options.boundingBox.hi, originLat = (hi[0] - lo[0]) / 2 + lo[0], originLng = (hi[1] - lo[1]) / 2 + lo[1]
  }
  var default_parallels = [20, 50], defaults = {parallels:default_parallels, origin:{lat:originLat, lng:originLng}}, origin = defaults.origin;
  options.origin && goog.object.extend(origin, options.origin);
  goog.object.extend(defaults, options);
  defaults.origin = origin;
  defaults.parallels && 0 !== defaults.parallels.length ? 2 > defaults.parallels.length && (defaults.parallels[1] = Math.abs(defaults.parallels[0] - default_parallels[0]) > Math.abs(defaults.parallels[0] - default_parallels[1]) ? default_parallels[0] : default_parallels[1]) : defaults.parallels = default_parallels;
  gviz.projection.BaseProjection.call(this, options);
  this.originLat_ = defaults.origin.lat / (180 / Math.PI);
  this.originLng_ = defaults.origin.lng / (180 / Math.PI);
  this.parallels_ = goog.array.map(defaults.parallels, function(parallel) {
    return parallel / (180 / Math.PI);
  });
};
goog.inherits(gviz.projection.LambertProjection, gviz.projection.BaseProjection);
gviz.projection.LambertProjection.prototype.project = function(coordinates) {
  return goog.array.map(arguments, goog.bind(function(coordinate) {
    goog.asserts.assert(2 === coordinate.length);
    var lat = coordinate[0] / (180 / Math.PI), lng = coordinate[1] / (180 / Math.PI), n = Math.log(Math.cos(this.parallels_[0]) * gviz.math.sec(this.parallels_[1])) / Math.log(Math.tan(.25 * Math.PI + .5 * this.parallels_[1]) * gviz.math.cot(.25 * Math.PI + .5 * this.parallels_[0])), F = Math.cos(this.parallels_[0]) * Math.pow(Math.tan(.25 * Math.PI + .5 * this.parallels_[0]), n) / n, p = F * Math.pow(gviz.math.cot(.25 * Math.PI + .5 * lat), n), p0 = F * Math.pow(gviz.math.cot(.25 * Math.PI + .5 * 
    this.originLat_), n);
    return{x:180 / Math.PI * Math.sin(n * (lng - this.originLng_)) * p, y:p0 - 180 / Math.PI * Math.cos(n * (lng - this.originLng_)) * p};
  }, this));
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/util.js)
gviz.geochart.util = {};
gviz.geochart.util.projectLat = function(lat) {
  var radians = lat / 180 * Math.PI;
  return 180 / Math.PI * Math.log(Math.tan(.5 * radians + Math.PI / 4));
};
gviz.geochart.util.unprojectLat = function(mercatorLat) {
  var latRadians = mercatorLat / (180 / Math.PI);
  return 180 / Math.PI * (Math.atan(Math.exp(latRadians)) - Math.PI / 4) * 2;
};
gviz.geochart.util.BoundsTracker = function() {
  this.tracking_ = {};
};
gviz.geochart.util.BoundsTracker.prototype.track = function(variables$$0) {
  goog.array.forEach(arguments, goog.bind(function(variables) {
    for (var name in variables) {
      if (variables.hasOwnProperty(name)) {
        name in this.tracking_ || (this.tracking_[name] = {min:Infinity, max:-Infinity});
        if (!this.tracking_[name].min || variables[name] < this.tracking_[name].min) {
          this.tracking_[name].min = variables[name];
        }
        if (!this.tracking_[name].max || variables[name] > this.tracking_[name].max) {
          this.tracking_[name].max = variables[name];
        }
      }
    }
  }, this));
};
gviz.geochart.util.BoundsTracker.prototype.getBounds = function(variable) {
  return{min:this.tracking_[variable].min, max:this.tracking_[variable].max};
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/projection/mercator-projection.js)
gviz.projection.MercatorProjection = function(options) {
  gviz.projection.BaseProjection.call(this, options);
};
goog.inherits(gviz.projection.MercatorProjection, gviz.projection.BaseProjection);
gviz.projection.MercatorProjection.prototype.project = function(coordinates$$0) {
  return goog.array.map(arguments, function(coordinates) {
    goog.asserts.assert(2 === coordinates.length);
    var lat = coordinates[0], lng = coordinates[1];
    return{x:lng, y:gviz.geochart.util.projectLat(lat)};
  });
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/projection/projections.js)
gviz.projection.Projection = {ALBERS:"albers", KAVRAYSKIYVII:"kavrayskiy-vii", LAMBERT:"lambert", MERCATOR:"mercator"};
gviz.projection.Projections = {};
gviz.projection.Projections[gviz.projection.Projection.MERCATOR] = gviz.projection.MercatorProjection;
gviz.projection.Projections[gviz.projection.Projection.KAVRAYSKIYVII] = gviz.projection.KavrayskiyVIIProjection;
gviz.projection.Projections[gviz.projection.Projection.ALBERS] = gviz.projection.AlbersProjection;
gviz.projection.Projections[gviz.projection.Projection.LAMBERT] = gviz.projection.LambertProjection;
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/options.js)
gviz.geochart.options = {};
gviz.geochart.options.DEFAULT_WIDTH = 556;
gviz.geochart.options.DEFAULT_HEIGHT = 347;
gviz.geochart.options.LegendPosition = {NONE:"none", TOP_LEFT:"top_left", TOP_RIGHT:"top_right", BOTTOM_LEFT:"bottom_left", BOTTOM_RIGHT:"bottom_right"};
gviz.geochart.options.GeocodingContext = {NONE:"none", REGION:"region", BOUNDS:"bounds", BOTH:"both"};
gviz.geochart.options.DEFAULT_LEGEND_POSITION = gviz.geochart.options.LegendPosition.BOTTOM_LEFT;
gviz.geochart.options.DEFAULT_LEGEND_ORIENTATION = gviz.colorbar.Orientation.HORIZONTAL;
gviz.geochart.options.DEFAULT_PROJECTION = gviz.projection.Projection.MERCATOR;
gviz.geochart.options.DEFAULT_GEOCODING_CONTEXT = gviz.geochart.options.GeocodingContext.REGION;
gviz.geochart.options.inferProjection = function(options, optionPath, opt_defaultValue) {
  var defaultProjection = opt_defaultValue ? {name:opt_defaultValue} : null, convertToProjection = function(obj) {
    goog.isObject(obj) || (obj = {name:obj});
    gviz.Options.convertToEnumOrThrow(gviz.projection.Projection, "The projection you specified is not valid.", obj.name);
    return obj;
  }, projection = options.inferObjectValue(optionPath, defaultProjection, convertToProjection);
  return projection;
};
gviz.geochart.options.DEFAULTS = {region:"world", resolution:gviz.geochart.MapResolution.COUNTRIES, domain:"COM", displayMode:gviz.GeoChartDataFormat.DisplayMode.AUTO, showGeocodeWarnings:!1, backgroundColor:{fill:"white", stroke:"#666", strokeWidth:0}, datalessRegionColor:"F5F5F5", defaultColor:"267114", markerOpacity:1, selectionMode:gviz.Options.SelectionMode.SINGLE, fontName:"Arial", geocodingContext:gviz.geochart.options.DEFAULT_GEOCODING_CONTEXT, tooltip:{isHtml:!1, textStyle:{fontName:"Arial", 
fontSize:13, color:"black"}, trigger:gviz.Options.TooltipTrigger.FOCUS, showDisputedText:!1, showTitle:!0}, colorAxis:{minValue:null, maxValue:null, values:null}, sizeAxis:{minValue:null, maxValue:null, minSize:3, maxSize:12}, legend:{position:gviz.geochart.options.DEFAULT_LEGEND_POSITION, orientation:gviz.geochart.options.DEFAULT_LEGEND_ORIENTATION, textStyle:{color:"black", auraColor:"white"}}, marker:{style:{stroke:{color:"#ccc", width:1}}}, projection:gviz.geochart.options.DEFAULT_PROJECTION, 
keepAspectRatio:!0, magnifyingGlass:{enable:!0, zoomFactor:5}};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/location-provider.js)
gviz.geochart.Location = {};
gviz.geochart.LocationProvider = function(errorHandler) {
  goog.Disposable.call(this);
  (this.logger_ = gviz.util.VisCommon.createLogger(gviz.geochart.LocationProvider.LOCATION_PROVIDER_NAME_)) && this.logger_.setLevel(goog.log.Level.INFO);
  this.errorHandler_ = errorHandler;
  this.staticMap_ = null;
  this.showWarnings_ = !0;
  this.geocodingContext_ = null;
  this.requestGroup_ = new gviz.util.BatchGeocoder.RequestGroup;
  this.isIsoCodeRegExp_ = /^([a-zA-Z][a-zA-Z]|[a-zA-Z][a-zA-Z]\-[a-zA-Z0-9](|[a-zA-Z0-9](|[a-zA-Z0-9]))|\d\d\d)$/;
  this.isSimplisticUsMetroPattern_ = /^\d\d\d$/;
};
goog.inherits(gviz.geochart.LocationProvider, goog.Disposable);
gviz.geochart.LocationProvider.prototype.clearStaticMap = function() {
  this.staticMap_ = null;
};
gviz.geochart.LocationProvider.prototype.setStaticMap = function(staticMap) {
  this.staticMap_ = staticMap;
  goog.isDefAndNotNull(this.mapCallback_) && this.mapCallback_(staticMap);
};
gviz.geochart.LocationProvider.prototype.setGeocodingContext = function(geocodingContext) {
  this.geocodingContext_ = geocodingContext;
};
gviz.geochart.LocationProvider.prototype.processTable = function(dataTable, dataTableFormat, mapId, showWarnings, callback) {
  this.showWarnings_ = showWarnings;
  if (0 == dataTable.getNumberOfRows()) {
    goog.Timer.callOnce(function() {
      callback([], [], !0);
    });
  } else {
    switch(dataTableFormat.addressType) {
      case gviz.GeoChartDataFormat.AddressType.LATLNG:
        this.createLocationsFromLatLngs_(dataTable, dataTableFormat, callback);
        break;
      case gviz.GeoChartDataFormat.AddressType.REGIONCODE:
        this.regionCodeRows_(dataTable, dataTableFormat, mapId, callback);
        break;
      case gviz.GeoChartDataFormat.AddressType.ADDRESS:
        this.createLocationsFromAddresses_(dataTable, dataTableFormat, mapId, callback);
    }
  }
};
gviz.geochart.LocationProvider.prototype.createLocationsFromLatLngs_ = function(dataTable, dataTableFormat, callback) {
  goog.log.info(this.logger_, "lat/lng provided by user");
  for (var locations = [], i = 0;i < dataTable.getNumberOfRows();i++) {
    var lat = dataTable.getValue(i, dataTableFormat.latColumn), lng = dataTable.getValue(i, dataTableFormat.lngColumn);
    locations[i] = null == lat || null == lng ? null : {lat:goog.string.makeSafe(lat), lng:goog.string.makeSafe(lng)};
  }
  goog.Timer.callOnce(function() {
    callback([], locations, !0);
  });
};
gviz.geochart.LocationProvider.prototype.regionCodeRows_ = function(dataTable, dataTableFormat, mapId, callback) {
  for (var rawRegionNames = [], i = 0;i < dataTable.getNumberOfRows();i++) {
    rawRegionNames.push(dataTable.getValue(i, dataTableFormat.regionColumn));
  }
  mapId.resolution == gviz.geochart.MapResolution.METROS || mapId.resolution == gviz.geochart.MapResolution.CONTINENTS || mapId.resolution == gviz.geochart.MapResolution.SUBCONTINENTS ? this.createLocationsDirectly_(mapId, rawRegionNames, callback) : this.createLocationsFromRegionNames_(mapId, rawRegionNames, callback);
};
gviz.geochart.LocationProvider.prototype.createLocationsDirectly_ = function(mapId, rawRegionNames, callback) {
  var isUsMetros = goog.string.startsWith(mapId.region, "US") && mapId.resolution == gviz.geochart.MapResolution.METROS;
  goog.log.info(this.logger_, "RegionCoding directly. (isUsMetros=" + isUsMetros + ")");
  for (var locations = [], i = 0;i < rawRegionNames.length;i++) {
    var address = goog.string.makeSafe(rawRegionNames[i]);
    isUsMetros && this.isSimplisticUsMetroPattern_.test(address) && (address = "US-" + address);
    locations.push(address.toUpperCase());
  }
  goog.Timer.callOnce(function() {
    callback(locations, [], !0);
  });
};
gviz.geochart.LocationProvider.prototype.createLocationsFromRegionNames_ = function(mapId, rawRegionNames, callback) {
  var region = mapId.region, dictName;
  dictName = mapId.resolution == gviz.geochart.MapResolution.PROVINCES && gviz.util.RegionCoder.hasProvincesRegionCodes(region) ? region : "countries_en";
  if (mapId.resolution == gviz.geochart.MapResolution.PROVINCES && "US" == region) {
    for (var i$$0 = 0;i$$0 < rawRegionNames.length;++i$$0) {
      var rawRegionName = rawRegionNames[i$$0];
      2 == rawRegionName.length && (rawRegionNames[i$$0] = "US-" + rawRegionName);
    }
  }
  goog.log.info(this.logger_, "using regioncoder " + dictName);
  gviz.util.RegionCoder.requestCoder(dictName, this.bind_(function(coder) {
    for (var regions = this.codeRegionsUsingCoder_(rawRegionNames, coder), requests = [], i = 0;i < rawRegionNames.length;i++) {
      var code = regions[i];
      if (null == code) {
        var address = rawRegionNames[i];
        requests.push({address:address, regionIndex:i, markerIndex:null});
        regions[i] = address;
      }
    }
    goog.array.isEmpty(requests) ? callback(regions, [], !0) : (callback(regions, [], !1), this.geocode_(requests, region, callback, regions, []));
  }));
};
gviz.geochart.LocationProvider.prototype.codeRegionsUsingCoder_ = function(rawRegionNames, coder) {
  for (var regions = [], i = 0;i < rawRegionNames.length;++i) {
    var rawRegionName = rawRegionNames[i], regionName = goog.string.trim(goog.string.makeSafe(rawRegionName)).toLowerCase(), coderResult = coder && coder.getCode(regionName), code;
    coderResult ? (code = coderResult, goog.log.fine(this.logger_, 'RegionCoder: found code for region "' + rawRegionName + '": ' + code)) : this.isProbablyAnIsoCode_(regionName) ? (code = regionName.toUpperCase(), goog.log.fine(this.logger_, 'Using region "' + rawRegionName + '" as code: ' + code)) : (code = null, goog.log.info(this.logger_, 'RegionCoder: failed to find code for "' + rawRegionName + '". Will try again using Geocode.'));
    regions.push(code);
  }
  return regions;
};
gviz.geochart.LocationProvider.prototype.isProbablyAnIsoCode_ = function(regionName) {
  return this.isIsoCodeRegExp_.test(regionName);
};
gviz.geochart.LocationProvider.prototype.addWarning_ = function(text) {
  this.showWarnings_ && this.errorHandler_ && this.errorHandler_.addWarning(text);
};
gviz.geochart.LocationProvider.prototype.createLocationsFromAddresses_ = function(dataTable, dataTableFormat, mapId, callback) {
  var requests = [], region = mapId.region;
  2 == region.length && (region = region.toUpperCase(), region = region.replace(/GB/, "UK"), region = region.replace(/RU/, "SU"), region = region.replace(/TP/, "TL"));
  for (var i = 0;i < dataTable.getNumberOfRows();i++) {
    var address = goog.string.makeSafe(dataTable.getValue(i, dataTableFormat.addressColumn));
    this.regionAddsContext_(region) && (address += " " + region);
    requests.push({address:address, markerIndex:i, regionIndex:null});
  }
  this.geocode_(requests, region, callback, [], []);
};
gviz.geochart.LocationProvider.prototype.regionAddsContext_ = function(region) {
  return "world" == region || goog.string.isNumeric(region) ? !1 : this.geocodingContext_ === gviz.geochart.options.GeocodingContext.REGION || this.geocodingContext_ === gviz.geochart.options.GeocodingContext.BOTH;
};
gviz.geochart.LocationProvider.prototype.boundsAddContext_ = function() {
  return this.geocodingContext_ === gviz.geochart.options.GeocodingContext.BOUNDS || this.geocodingContext_ === gviz.geochart.options.GeocodingContext.BOTH;
};
gviz.geochart.LocationProvider.prototype.getMapBoundsForContext_ = function() {
  var minLat = Infinity, minLng = Infinity, maxLat = -Infinity, maxLng = -Infinity;
  if (goog.isDefAndNotNull(this.staticMap_) && 0 !== this.staticMap_.views.length) {
    return goog.array.forEach(this.staticMap_.views, function(view) {
      var boundingBox = view.boundingBox;
      minLat = Math.min(minLat, boundingBox.lo[0]);
      minLng = Math.min(minLat, boundingBox.lo[1]);
      maxLat = Math.max(maxLat, boundingBox.hi[0]);
      maxLng = Math.max(maxLat, boundingBox.hi[1]);
    }), {lo:{lat:minLat, lng:minLng}, hi:{lat:maxLat, lng:maxLng}};
  }
};
gviz.geochart.LocationProvider.prototype.geocode_ = function(requests, region, callback, regions, markers) {
  goog.log.info(this.logger_, "Sending geocoding requests to maps api");
  this.sendGeocodingRequest_(requests, region, callback, regions, markers);
};
gviz.geochart.LocationProvider.prototype.sendGeocodingRequest_ = function(requests, region, callback, regions, markers) {
  for (var batchRequests = [], i = 0;i < requests.length;i++) {
    var address = requests[i].address, batchRequest = {address:address};
    this.regionAddsContext_(region) && (batchRequest.region = region);
    this.boundsAddContext_() && (batchRequest.bounds = this.getMapBoundsForContext_());
    batchRequests.push(batchRequest);
  }
  var remainingRequests = goog.array.clone(requests), handleGeocodingResponse = goog.bind(this.handleGeocodingResponse_, this, remainingRequests, callback, regions, markers);
  this.requestGroup_.create(batchRequests, handleGeocodingResponse, 1);
};
gviz.geochart.LocationProvider.prototype.handleGeocodingResponse_ = function(remainingRequests, callback, regions, markers, geocodingLocations) {
  for (var numLocations = geocodingLocations.length, i = 0;i < numLocations;i++) {
    var request = remainingRequests[i];
    goog.asserts.assert(request);
    var address = request.address, regionIndex = request.regionIndex, markerIndex = request.markerIndex;
    if (geocodingLocations[i] && geocodingLocations[i][0]) {
      var geocoderResponse = geocodingLocations[i][0];
      goog.asserts.assert(geocoderResponse);
      goog.isDefAndNotNull(regionIndex) && (regions[regionIndex] = this.extractRegionCode_(address, geocoderResponse), regions[regionIndex] || (goog.log.warning(this.logger_, 'Geocode: failed to extract region code from "' + address + '"'), this.addWarning_('Failed geocoding "' + address + '"'), regions[regionIndex] = address));
      goog.isDefAndNotNull(markerIndex) && (markers[markerIndex] = this.extractMarker_(address, geocoderResponse));
    } else {
      goog.isDefAndNotNull(regionIndex) && (regions[regionIndex] = null), goog.isDefAndNotNull(markerIndex) && (markers[markerIndex] = null), goog.log.warning(this.logger_, 'Geocode: failed to parse response for "' + address + '"'), this.addWarning_('Failed geocoding "' + address + '"');
    }
  }
  goog.array.splice(remainingRequests, 0, numLocations);
  var isDone = goog.array.isEmpty(remainingRequests);
  isDone && goog.array.every(regions, goog.isNull) && goog.array.every(markers, goog.isNull) && this.addWarning_("Geocoding failed for all data points");
  callback(regions, markers, isDone);
};
gviz.geochart.LocationProvider.prototype.extractRegionCode_ = function(address, geocoderResponse) {
  var addressComps = geocoderResponse.address_components, code = null;
  1 == addressComps.length && 0 <= goog.array.indexOf(addressComps[0].types, "country") ? (code = addressComps[0].short_name, goog.log.info(this.logger_, 'Geocode: found country code for "' + address + '": ' + code)) : 2 == addressComps.length && "US" == addressComps[1].short_name && (code = "US-" + addressComps[0].short_name, goog.log.info(this.logger_, 'Geocode: found US province code for "' + address + '": ' + code));
  return code;
};
gviz.geochart.LocationProvider.prototype.extractMarker_ = function(address, geocoderResponse) {
  var marker = {lat:geocoderResponse.geometry.location.lat(), lng:geocoderResponse.geometry.location.lng()};
  goog.log.info(this.logger_, "Found lat/lng for address " + address + ": " + marker.lat + "/" + marker.lng);
  return marker;
};
gviz.geochart.LocationProvider.prototype.bind_ = function(f) {
  return goog.bind(f, this);
};
gviz.geochart.LocationProvider.prototype.disposeInternal = function() {
  this.requestGroup_.cancel();
  gviz.geochart.LocationProvider.superClass_.disposeInternal.call(this);
};
gviz.geochart.LocationProvider.LOCATION_PROVIDER_NAME_ = "google.visualization.locationProvider";
// INPUT (javascript/gviz/devel/jsapi/common/colorbar/builder.js)
gviz.colorbar.builder = {};
gviz.colorbar.builder.draw = function(colorBarDef, renderer, drawingGroup) {
  gviz.colorbar.builder.drawColorGradient_(colorBarDef.colorGradientRectanglesDefinitions, renderer, drawingGroup);
  gviz.colorbar.builder.drawMarkers_(colorBarDef.markersDefinitions, renderer, drawingGroup);
  gviz.colorbar.builder.drawTextItems_(colorBarDef.textItemsDefinitions, renderer, drawingGroup);
};
gviz.colorbar.builder.drawColorGradient_ = function(colorGradientRectanglesDefinitions, renderer, drawingGroup) {
  for (var i = 0;i < colorGradientRectanglesDefinitions.length;++i) {
    renderer.drawRect(colorGradientRectanglesDefinitions[i].rectangle.left, colorGradientRectanglesDefinitions[i].rectangle.top, colorGradientRectanglesDefinitions[i].rectangle.width, colorGradientRectanglesDefinitions[i].rectangle.height, colorGradientRectanglesDefinitions[i].brush, drawingGroup);
  }
};
gviz.colorbar.builder.drawMarkers_ = function(markersDefinitions, renderer, drawingGroup) {
  for (var i = 0;i < markersDefinitions.length;++i) {
    var path = new gviz.graphics.PathSegments;
    path.move(markersDefinitions[i].path[0], markersDefinitions[i].path[1]);
    path.addLine(markersDefinitions[i].path[2], markersDefinitions[i].path[3]);
    path.addLine(markersDefinitions[i].path[4], markersDefinitions[i].path[5]);
    path.close();
    renderer.drawPath(path, markersDefinitions[i].brush, drawingGroup);
  }
};
gviz.colorbar.builder.drawTextItems_ = function(textItemsDefinitions, renderer, drawingGroup) {
  for (var i = 0;i < textItemsDefinitions.length;++i) {
    renderer.drawText(textItemsDefinitions[i].text, textItemsDefinitions[i].x, textItemsDefinitions[i].y, 1, gviz.graphics.TextAlign.START, gviz.graphics.TextAlign.START, textItemsDefinitions[i].style, drawingGroup);
  }
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/idutils.js)
gviz.geochart.idutils = {};
gviz.geochart.idutils.generateId = function(tokens) {
  return tokens.join(gviz.geochart.idutils.TOKEN_SEPARATOR);
};
gviz.geochart.idutils.Token = {FEATURE:"feature", DISPUTED_AREA:"disputed", MARKER:"marker", BORDER:"border"};
gviz.geochart.idutils.TOKEN_SEPARATOR = ".";
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/map-definition.js)
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/logical-canvas.js)
gviz.geochart.LogicalCanvas = function(overlayArea, renderer, dataTableFormat) {
  goog.Disposable.call(this);
  this.renderer_ = renderer;
  this.getTextSize = goog.bind(this.renderer_.getTextSize, this.renderer_);
  this.overlayArea_ = overlayArea;
  this.tooltipElements_ = [];
  this.dataTableFormat_ = dataTableFormat;
  this.logger_ = gviz.util.VisCommon.createLogger(gviz.geochart.LogicalCanvas.NAME_);
  goog.log.info(this.logger_, "Starting...");
  this.idToElementMapping_ = {};
  this.eventTarget_ = new goog.events.EventTarget;
  this.magnifiedMarkerId_ = this.magnifiedAreaDrawingGroup_ = this.colorBarDrawingGroup_ = this.interactionTooltipDrawingGroup_ = this.featureGlowDrawingGroup_ = this.markersDrawingGroup_ = this.lastDrawnMapDef_ = null;
};
goog.inherits(gviz.geochart.LogicalCanvas, goog.Disposable);
gviz.geochart.LogicalCanvas.prototype.listen = function(type, handler) {
  goog.events.listen(this.eventTarget_, type, handler);
};
gviz.geochart.LogicalCanvas.prototype.plotChart = function(mapDef) {
  goog.log.info(this.logger_, "Redrawing from scratch...");
  var renderer = this.renderer_;
  renderer.clear();
  var mainChartElement = renderer.createCanvas(mapDef.width, mapDef.height);
  this.idToElementMapping_ = {};
  var mainGroup = renderer.createGroup();
  this.plotBackground_(mainGroup, mapDef, new goog.math.Rect(0, 0, mapDef.width, mapDef.height), !1);
  var mapDrawingGroup = renderer.createGroup();
  this.plotMap_(mapDrawingGroup, mapDef);
  var mapRect = this.getMapRect_(mapDef), mapClipGroup = renderer.clipGroup(mapDrawingGroup, mapRect);
  this.colorBarDrawingGroup_ = renderer.createGroup();
  this.plotColorBar_(mapDef);
  this.magnifiedAreaDrawingGroup_ = renderer.createGroup();
  this.plotMagnifiedArea_(mapDef);
  this.interactionTooltipDrawingGroup_ = renderer.createGroup();
  this.plotTooltip_(mapDef);
  renderer.appendChild(mainChartElement, mainGroup);
  renderer.appendChild(mainGroup, mapClipGroup);
  renderer.appendChild(mainGroup, this.colorBarDrawingGroup_);
  renderer.appendChild(mainGroup, this.magnifiedAreaDrawingGroup_);
  renderer.appendChild(mainGroup, this.interactionTooltipDrawingGroup_);
  this.lastDrawnMapDef_ = mapDef;
  this.addEventHandlers_(mainChartElement);
};
gviz.geochart.LogicalCanvas.prototype.plotMap_ = function(mapDrawingGroup, mapDef) {
  var renderer = this.renderer_, dataDrawingGroup = renderer.createGroup();
  this.featureGlowDrawingGroup_ = renderer.createGroup();
  for (var i = 0;i < mapDef.views.length;++i) {
    this.plotView_(dataDrawingGroup, mapDef, mapDef.views[i], !1), this.plotViewGlows_(mapDef, mapDef.views[i]);
  }
  this.markersDrawingGroup_ = renderer.createGroup();
  this.plotMarkers_(this.markersDrawingGroup_, mapDef.markersData, !1, mapDef.defaultFontName);
  renderer.appendChild(mapDrawingGroup, dataDrawingGroup);
  renderer.appendChild(mapDrawingGroup, this.featureGlowDrawingGroup_);
  renderer.appendChild(mapDrawingGroup, this.markersDrawingGroup_);
};
gviz.geochart.LogicalCanvas.prototype.plotData = function(mapDef) {
  goog.log.info(this.logger_, "Redrawing data...");
  this.redrawColors_(mapDef);
  this.redrawMarkers_(mapDef);
  this.plotInteraction(mapDef, !0);
};
gviz.geochart.LogicalCanvas.prototype.plotInteraction = function(mapDef, opt_forceGlowRedraw) {
  var forceGlowRedraw = opt_forceGlowRedraw || !1;
  goog.log.info(this.logger_, "Redrawing interaction...");
  this.redrawTooltip_(mapDef);
  this.redrawFeatureGlows_(mapDef, forceGlowRedraw);
  this.redrawMarkerGlows_(mapDef);
  this.redrawColorBar_(mapDef);
  this.redrawMagnifiedArea_(mapDef);
  this.lastDrawnMapDef_ = mapDef;
};
gviz.geochart.LogicalCanvas.prototype.redrawFeatureGlows_ = function(mapDef, forceGlowRedraw) {
  if (forceGlowRedraw || !gviz.object.unsafeEquals(this.lastDrawnMapDef_.glowingFeatures, mapDef.glowingFeatures)) {
    this.renderer_.removeChildren(this.featureGlowDrawingGroup_);
    for (var i = 0;i < mapDef.views.length;++i) {
      this.plotViewGlows_(mapDef, mapDef.views[i]);
    }
  }
};
gviz.geochart.LogicalCanvas.prototype.plotViewGlows_ = function(mapDef, viewDef) {
  for (var viewDrawingGroup = this.renderer_.createGroup(), glowingFeatures = goog.array.filter(viewDef.features, function(feature) {
    return goog.array.contains(mapDef.glowingFeatures, feature.id);
  }), i = 0;i < glowingFeatures.length;++i) {
    this.plotFeatureGlow_(viewDrawingGroup, mapDef, viewDef, glowingFeatures[i]);
  }
  goog.asserts.assert(this.featureGlowDrawingGroup_);
  this.renderer_.appendChild(this.featureGlowDrawingGroup_, viewDrawingGroup);
};
gviz.geochart.LogicalCanvas.prototype.redrawMarkers_ = function(mapDef) {
  var renderer = this.renderer_;
  goog.array.forEach(goog.dom.getChildren(this.markersDrawingGroup_.getElement()), function(markerElement) {
    goog.array.forEach(goog.dom.getChildren(markerElement), function(childNode) {
      renderer.removeElement(childNode);
    }, this);
  }, this);
  this.plotMarkers_(this.markersDrawingGroup_, mapDef.markersData, !1, mapDef.defaultFontName);
};
gviz.geochart.LogicalCanvas.glowBrush_ = new gviz.graphics.Brush({strokeWidth:"3", stroke:"black", strokeOpacity:"0.2"});
gviz.geochart.LogicalCanvas.glowBrush2_ = new gviz.graphics.Brush({strokeWidth:"1", stroke:"black", strokeOpacity:"0.1"});
gviz.geochart.LogicalCanvas.prototype.plotFeatureGlow_ = function(viewDrawingGroup, mapDef, viewDef, featureDef) {
  if (!this.isSlowRenderer()) {
    var fid = featureDef.id, brushes = mapDef.featuresData[fid].brushes;
    this.plotFeaturePart_(viewDrawingGroup, featureDef, !1, !1, [gviz.geochart.LogicalCanvas.glowBrush_, gviz.geochart.LogicalCanvas.glowBrush2_, brushes.fill]);
    goog.array.isEmpty(featureDef.disputed) || (this.plotFeaturePart_(viewDrawingGroup, featureDef, !0, !1, [brushes.disputed]), this.plotFeaturePart_(viewDrawingGroup, featureDef, !1, !1, [brushes.border]));
  }
};
gviz.geochart.LogicalCanvas.prototype.redrawMagnifiedArea_ = function(mapDef) {
  var newId = mapDef.magnifiedArea ? mapDef.magnifiedArea.markerId : null;
  this.magnifiedMarkerId_ != newId && (this.renderer_.removeChildren(this.magnifiedAreaDrawingGroup_), this.plotMagnifiedArea_(mapDef));
};
gviz.geochart.LogicalCanvas.prototype.plotMagnifiedArea_ = function(mapDef) {
  var magnifiedArea = mapDef.magnifiedArea;
  if (magnifiedArea) {
    var drawingGroup = this.magnifiedAreaDrawingGroup_;
    goog.asserts.assert(goog.isDefAndNotNull(drawingGroup));
    var viewDrawingGroup = this.plotMagnifiedAreaBorders_(drawingGroup, magnifiedArea), viewDef = magnifiedArea.view;
    this.plotBackground_(viewDrawingGroup, mapDef, viewDef.onscreenPosition, !0);
    this.plotView_(viewDrawingGroup, mapDef, viewDef, !0);
    this.plotMarkers_(viewDrawingGroup, magnifiedArea.markersData, !0, mapDef.defaultFontName);
    this.magnifiedMarkerId_ = magnifiedArea.markerId;
  } else {
    this.magnifiedMarkerId_ = null;
  }
};
gviz.geochart.LogicalCanvas.prototype.plotMagnifiedAreaBorders_ = function(drawingGroup, magnifiedArea) {
  var renderer = this.renderer_, rect = magnifiedArea.view.onscreenPosition, cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2, rx = rect.width / 2, ry = rect.height / 2, mx = magnifiedArea.markerPosition.x, my = magnifiedArea.markerPosition.y, triangleBrush = new gviz.graphics.Brush({fill:"808080", fillOpacity:.25}), triangle = new gviz.graphics.PathSegments;
  triangle.move(mx, my);
  triangle.addLine(mx, my + (cy > my ? ry : -ry));
  triangle.addLine(mx + (cx > mx ? rx : -rx), my);
  triangle.close();
  var triangleElement = renderer.drawPath(triangle, triangleBrush, drawingGroup);
  this.setNoFeatureInfo_(triangleElement, gviz.geochart.interactionEvents.ElementType.MAGNIFYING_GLASS_TRIANGLE, !0);
  var fillBrush = new gviz.graphics.Brush({fill:"white"}), fillElement = renderer.drawEllipse(cx, cy, rx, ry, fillBrush, drawingGroup), borderType = gviz.geochart.interactionEvents.ElementType.MAGNIFYING_GLASS_BORDER;
  this.setNoFeatureInfo_(fillElement, borderType, !0);
  var outerBorderBrush = new gviz.graphics.Brush({stroke:"bfbfbf", strokeWidth:1.5}), outerBorderElement = renderer.drawEllipse(cx, cy, rx, ry, outerBorderBrush, drawingGroup);
  this.setNoFeatureInfo_(outerBorderElement, borderType, !0);
  var viewDrawingGroup = renderer.createGroup(), innerRect = new goog.math.Rect(rect.left + 3.5, rect.top + 3.5, rect.width - 7, rect.height - 7), clipGroup = renderer.clipGroup(viewDrawingGroup, innerRect, !0);
  renderer.appendChild(drawingGroup, clipGroup);
  var innerBorderBrush = new gviz.graphics.Brush({stroke:"cccccc", strokeWidth:1.5}), innerBorderElement = renderer.drawEllipse(cx, cy, rx - 3.5, ry - 3.5, innerBorderBrush, drawingGroup);
  this.setNoFeatureInfo_(innerBorderElement, borderType, !0);
  return viewDrawingGroup;
};
gviz.geochart.LogicalCanvas.prototype.redrawTooltip_ = function(mapDef) {
  this.renderer_.removeChildren(this.interactionTooltipDrawingGroup_);
  this.plotTooltip_(mapDef);
};
gviz.geochart.LogicalCanvas.prototype.plotTooltip_ = function(mapDef) {
  0 < this.tooltipElements_.length && (goog.array.map(this.tooltipElements_, function(element) {
    this.renderer_.removeElement(element);
  }, this), this.tooltipElements_ = []);
  0 < mapDef.tooltips.length ? (goog.asserts.assert(this.interactionTooltipDrawingGroup_), this.tooltipElements_ = goog.array.map(mapDef.tooltips, function(tooltip) {
    return tooltip.html ? gviz.util.tooltip.htmlbuilder.draw(tooltip, this.overlayArea_.getContainer()) : gviz.util.tooltip.builder.draw(tooltip, this.renderer_, this.interactionTooltipDrawingGroup_).getElement();
  }, this)) : this.tooltipElements_ = [];
};
gviz.geochart.LogicalCanvas.prototype.redrawColors_ = function(mapDef) {
  goog.object.forEach(mapDef.featuresData, function(featureData, fid) {
    var brushes = featureData.brushes;
    this.setFeatureBrush_(fid, gviz.geochart.idutils.Token.FEATURE, brushes.fill);
    this.setFeatureBrush_(fid, gviz.geochart.idutils.Token.DISPUTED_AREA, brushes.disputed);
    this.setFeatureBrush_(fid, gviz.geochart.idutils.Token.BORDER, brushes.border);
  }, this);
};
gviz.geochart.LogicalCanvas.prototype.setFeatureBrush_ = function(fid, featurePart, brush) {
  var elementId = gviz.geochart.idutils.generateId([featurePart, fid]), polygons = this.idToElementMapping_[elementId];
  if (goog.isDefAndNotNull(polygons)) {
    for (var i = 0;i < polygons.length;++i) {
      this.renderer_.setBrush(polygons[i], brush);
    }
  }
};
gviz.geochart.LogicalCanvas.prototype.addEventHandlers_ = function(mainChartElement) {
  var handler = this.bind_(function(domEvent) {
    var info = this.parseElementInfo_(domEvent.target);
    if (info && info.eventsEnabled) {
      var event = {type:this.getDispatchEventType_(domEvent.type, info.type), elementType:info.elementType, data:this.getDispatchEventData_(domEvent, info.data)};
      domEvent.type != goog.events.EventType.MOUSEMOVE && (goog.log.fine(this.logger_, 'DOM event "' + domEvent.type + '" triggered on element ' + goog.json.serialize(info)), goog.log.fine(this.logger_, 'Dispatching event "' + event.type + '" over "' + event.elementType + '": ' + goog.json.serialize(event.data)));
      this.eventTarget_.dispatchEvent(event);
    }
  }), renderer = this.renderer_;
  renderer.setEventHandler(mainChartElement, goog.events.EventType.MOUSEMOVE, handler);
  renderer.setEventHandler(mainChartElement, goog.events.EventType.MOUSEOUT, handler);
  renderer.setEventHandler(mainChartElement, goog.events.EventType.MOUSEOVER, handler);
  renderer.setEventHandler(mainChartElement, goog.events.EventType.CLICK, handler);
};
gviz.geochart.LogicalCanvas.InteractiveElementType_ = {FEATURE:"feature", MARKER:"marker"};
gviz.geochart.LogicalCanvas.prototype.getDispatchEventType_ = function(domEventType, elementType) {
  switch(elementType) {
    case gviz.geochart.LogicalCanvas.InteractiveElementType_.FEATURE:
      switch(domEventType) {
        case goog.events.EventType.CLICK:
          return gviz.geochart.interactionEvents.EventType.FEATURE_CLICK;
        case goog.events.EventType.MOUSEMOVE:
          return gviz.geochart.interactionEvents.EventType.FEATURE_MOVE;
        case goog.events.EventType.MOUSEOUT:
        ;
        case goog.events.EventType.MOUSEOVER:
          return gviz.geochart.interactionEvents.EventType.FEATURE_HOVER;
      }
    ;
    case gviz.geochart.LogicalCanvas.InteractiveElementType_.MARKER:
      switch(domEventType) {
        case goog.events.EventType.CLICK:
          return gviz.geochart.interactionEvents.EventType.MARKER_CLICK;
        case goog.events.EventType.MOUSEMOVE:
          return gviz.geochart.interactionEvents.EventType.MARKER_MOVE;
        case goog.events.EventType.MOUSEOUT:
        ;
        case goog.events.EventType.MOUSEOVER:
          return gviz.geochart.interactionEvents.EventType.MARKER_HOVER;
      }
    ;
  }
  goog.asserts.fail("Unrecognized event type " + domEventType + " for element type " + elementType);
  return null;
};
gviz.geochart.LogicalCanvas.prototype.getDispatchEventData_ = function(domEvent, elementData) {
  var eventData = goog.object.clone(elementData);
  domEvent.type == goog.events.EventType.MOUSEOUT ? eventData.isOver = !1 : domEvent.type == goog.events.EventType.MOUSEOVER && (eventData.isOver = !0);
  eventData.cursorPosition = this.renderer_.getCursorPosition(domEvent);
  return eventData;
};
gviz.geochart.LogicalCanvas.prototype.setMarkerInfo_ = function(elementOrGroup, marker, isMagnified) {
  var elementType = gviz.geochart.interactionEvents.ElementType.MARKER;
  this.setElementOrGroupInfo_(elementOrGroup, ["M", elementType, "1", isMagnified ? "1" : "0", marker.markerId, marker.rowId, marker.isCluttered ? "1" : "0"]);
};
gviz.geochart.LogicalCanvas.prototype.setNoFeatureInfo_ = function(elementOrGroup, elementType, isMagnified) {
  this.setElementOrGroupInfo_(elementOrGroup, ["F", elementType, "1", isMagnified ? "1" : "0", "", "0"]);
};
gviz.geochart.LogicalCanvas.prototype.setFeatureInfo_ = function(elementOrGroup, featureDef, isDisputed, isMagnified) {
  var eventsEnabled = featureDef.eventsEnabled, fid = featureDef.id, elementType = gviz.geochart.interactionEvents.ElementType.FEATURE;
  this.setElementOrGroupInfo_(elementOrGroup, ["F", elementType, eventsEnabled ? "1" : "0", isMagnified ? "1" : "0", fid, isDisputed ? "1" : "0"]);
};
gviz.geochart.LogicalCanvas.prototype.setElementOrGroupInfo_ = function(elementOrGroup, info) {
  var infoString = info.join("#");
  this.renderer_.setLogicalName(elementOrGroup, infoString);
};
gviz.geochart.LogicalCanvas.prototype.parseElementInfo_ = function(element) {
  var infoString = this.renderer_.getLogicalName(element);
  if (!infoString || infoString == gviz.graphics.logicalname.DEFAULT_NAME) {
    return null;
  }
  var info = infoString.split("#");
  goog.asserts.assert(4 <= info.length);
  var elementType = info[1], eventsEnabled = "1" == info[2] ? !0 : !1, isMagnified = "1" == info[3] ? !0 : !1;
  switch(info[0]) {
    case "F":
      return goog.asserts.assert(6 == info.length), {type:gviz.geochart.LogicalCanvas.InteractiveElementType_.FEATURE, elementType:elementType, eventsEnabled:eventsEnabled, data:{isMagnified:isMagnified, featureId:info[4] ? info[4] : null, isDisputed:"1" == info[5] ? !0 : !1}};
    case "M":
      return goog.asserts.assert(7 == info.length), {type:gviz.geochart.LogicalCanvas.InteractiveElementType_.MARKER, elementType:elementType, eventsEnabled:eventsEnabled, data:{isMagnified:isMagnified, markerId:info[4], rowId:goog.string.toNumber(info[5]), isCluttered:"1" == info[6] ? !0 : !1}};
    default:
      return null;
  }
};
gviz.geochart.LogicalCanvas.prototype.plotBackground_ = function(drawingGroup, mapDef, rect, isMagnified) {
  var backgroundElement = this.renderer_.drawRect(rect.left, rect.top, rect.width, rect.height, mapDef.backgroundBrush, drawingGroup);
  this.setNoFeatureInfo_(backgroundElement, gviz.geochart.interactionEvents.ElementType.OCEAN, isMagnified);
};
gviz.geochart.LogicalCanvas.prototype.plotView_ = function(drawingGroup, mapDef, viewDef, isMagnified) {
  for (var viewDrawingGroup = this.renderer_.createGroup(), i = 0;i < viewDef.features.length;++i) {
    this.plotFeature_(viewDrawingGroup, mapDef, viewDef, viewDef.features[i], isMagnified);
  }
  this.renderer_.appendChild(drawingGroup, viewDrawingGroup);
};
gviz.geochart.LogicalCanvas.prototype.plotFeature_ = function(viewDrawingGroup, mapDef, viewDef, featureDef, isMagnified) {
  var fid = featureDef.id, brushes = mapDef.featuresData[fid].brushes;
  this.plotFeaturePart_(viewDrawingGroup, featureDef, !1, isMagnified, [brushes.fill], gviz.geochart.idutils.Token.FEATURE);
  goog.array.isEmpty(featureDef.disputed) || (this.plotFeaturePart_(viewDrawingGroup, featureDef, !0, isMagnified, [brushes.disputed], gviz.geochart.idutils.Token.DISPUTED_AREA), this.plotFeaturePart_(viewDrawingGroup, featureDef, !1, isMagnified, [brushes.border], gviz.geochart.idutils.Token.BORDER));
};
gviz.geochart.LogicalCanvas.prototype.plotFeaturePart_ = function(viewDrawingGroup, featureDef, isDisputed, isMagnified, brushes, opt_partToken) {
  var polygons = isDisputed ? featureDef.disputed : featureDef.polygons, fid = featureDef.id, elementId = goog.isDefAndNotNull(opt_partToken) ? gviz.geochart.idutils.generateId([opt_partToken, fid]) : null;
  elementId && (this.idToElementMapping_[elementId] = this.idToElementMapping_[elementId] || []);
  for (var i = 0;i < polygons.length;++i) {
    var polygon = polygons[i], path = this.plotPolygon_(polygon);
    if (0 < path.segments.length) {
      for (var j = 0;j < brushes.length;++j) {
        var brush = brushes[j], element = this.renderer_.drawPath(path, brush, viewDrawingGroup);
        element && (this.setFeatureInfo_(element, featureDef, isDisputed, isMagnified), elementId && this.idToElementMapping_[elementId].push(element));
      }
    }
  }
};
gviz.geochart.LogicalCanvas.prototype.plotPolygon_ = function(polygon) {
  var Direction = gviz.geochart.LogicalCanvas.PolylineDirection_, path = new gviz.graphics.PathSegments;
  this.plotPolyline_(path, polygon.shell, Direction.NATURAL);
  for (var i = 0;i < polygon.holes.length;i++) {
    var hole = polygon.holes[i];
    this.plotPolyline_(path, hole, Direction.REVERSE);
  }
  return path;
};
gviz.geochart.LogicalCanvas.PolylineDirection_ = {NATURAL:"natural", REVERSE:"reverse"};
gviz.geochart.LogicalCanvas.prototype.plotPolyline_ = function(path, polyline, direction) {
  var points = polyline.points, len = points.length;
  if (!(1 >= len)) {
    for (var Direction = gviz.geochart.LogicalCanvas.PolylineDirection_, firstIndex = direction == Direction.NATURAL ? 0 : len - 1, endIndex = direction == Direction.NATURAL ? len : -1, step = direction == Direction.NATURAL ? 1 : -1, i = firstIndex;i != endIndex;i += step) {
      var x = points[i][0], y = points[i][1];
      i == firstIndex ? path.move(x, y) : path.addLine(x, y);
    }
    path.close();
  }
};
gviz.geochart.LogicalCanvas.prototype.plotMarkers_ = function(drawingGroup, markers, isMagnified, fontName) {
  var renderer = this.renderer_, sortedMarkers = goog.array.clone(markers);
  goog.array.sort(sortedMarkers, function(marker1, marker2) {
    return marker2.size - marker1.size;
  });
  for (var i = 0;i < sortedMarkers.length;++i) {
    var marker = sortedMarkers[i], markerDrawingGroup = renderer.createGroup();
    this.setMarkerInfo_(markerDrawingGroup, marker, isMagnified);
    renderer.appendChild(drawingGroup, markerDrawingGroup);
    if (this.dataTableFormat_.displayMode === gviz.GeoChartDataFormat.DisplayMode.TEXT) {
      var textStyle = {fontName:fontName, fontSize:marker.size, color:marker.brush.getFill(), opacity:marker.brush.getFillOpacity(), auraColor:"", bold:!1, underline:!1, italic:!1};
      renderer.drawText(marker.label, marker.x, marker.y, 20, gviz.graphics.TextAlign.CENTER, gviz.graphics.TextAlign.CENTER, textStyle, markerDrawingGroup);
    } else {
      renderer.drawCircle(marker.x, marker.y, marker.size, marker.brush, markerDrawingGroup);
    }
    var elementId = gviz.geochart.idutils.generateId([gviz.geochart.idutils.Token.MARKER, marker.markerId]);
    this.idToElementMapping_[elementId] = markerDrawingGroup.getElement();
  }
};
gviz.geochart.LogicalCanvas.prototype.redrawMarkerGlows_ = function(mapDef) {
  var renderer = this.renderer_, lastGlowingMarkers = this.lastDrawnMapDef_.glowingMarkers;
  goog.array.forEach(lastGlowingMarkers, function(markerId) {
    if (!goog.array.contains(mapDef.glowingMarkers, markerId)) {
      for (var elementId = gviz.geochart.idutils.generateId([gviz.geochart.idutils.Token.MARKER, markerId]), markerElement = this.idToElementMapping_[elementId], children = goog.dom.getChildren(markerElement), i = 1;i < children.length;++i) {
        renderer.removeElement(children[i]);
      }
    }
  }, this);
  goog.array.forEach(mapDef.glowingMarkers, function(markerId) {
    if (!goog.array.contains(lastGlowingMarkers, markerId)) {
      var elementId = gviz.geochart.idutils.generateId([gviz.geochart.idutils.Token.MARKER, markerId]), markerElement = this.idToElementMapping_[elementId], circleElement = goog.dom.getFirstElementChild(markerElement), firstGlow = circleElement.cloneNode(!0);
      renderer.setBrush(firstGlow, gviz.geochart.LogicalCanvas.glowBrush_);
      markerElement.appendChild(firstGlow);
    }
  }, this);
};
gviz.geochart.LogicalCanvas.prototype.redrawColorBar_ = function(mapDef) {
  this.renderer_.removeChildren(this.colorBarDrawingGroup_);
  this.plotColorBar_(mapDef);
};
gviz.geochart.LogicalCanvas.prototype.plotColorBar_ = function(mapDef) {
  mapDef.colorBar && (goog.asserts.assert(this.colorBarDrawingGroup_), gviz.colorbar.builder.draw(mapDef.colorBar, this.renderer_, this.colorBarDrawingGroup_));
};
gviz.geochart.LogicalCanvas.prototype.disposeInternal = function() {
  goog.events.removeAll(this.eventTarget_);
  goog.isDefAndNotNull(this.tooltipElement_) && this.renderer_.removeElement(this.tooltipElement_);
  this.renderer_.clear();
  goog.dispose(this.lastDrawnMapDef_);
  this.lastDrawnMapDef_ = null;
  this.markersDrawingGroup_ && this.renderer_.removeElement(this.markersDrawingGroup_.getElement());
  this.markersDrawingGroup_ = null;
  this.featureGlowDrawingGroup_ && this.renderer_.removeElement(this.featureGlowDrawingGroup_.getElement());
  this.featureGlowDrawingGroup_ = null;
  this.interactionTooltipDrawingGroup_ && this.renderer_.removeElement(this.interactionTooltipDrawingGroup_.getElement());
  this.interactionTooltipDrawingGroup_ = null;
  this.colorBarDrawingGroup_ && this.renderer_.removeElement(this.colorBarDrawingGroup_.getElement());
  this.colorBarDrawingGroup_ = null;
  this.magnifiedAreaDrawingGroup_ && this.renderer_.removeElement(this.magnifiedAreaDrawingGroup_.getElement());
  this.magnifiedAreaDrawingGroup_ = null;
  gviz.geochart.LogicalCanvas.superClass_.disposeInternal.call(this);
};
gviz.geochart.LogicalCanvas.prototype.bind_ = function(f) {
  return goog.bind(f, this);
};
gviz.geochart.LogicalCanvas.prototype.getMapRect_ = function(mapDef) {
  var mapRect = mapDef.mapRect;
  return this.isSlowRenderer() ? new goog.math.Rect(mapRect.left, mapRect.top, mapRect.width - 1, mapRect.height - 1) : mapRect;
};
gviz.geochart.LogicalCanvas.prototype.isSlowRenderer = function() {
  return this.renderer_.isSlowRenderer();
};
gviz.geochart.LogicalCanvas.prototype.getDataTableFormat = function() {
  return this.dataTableFormat_;
};
gviz.geochart.LogicalCanvas.NAME_ = "gviz.geochart.LogicalCanvas";
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/interaction-state.js)
gviz.geochart.InteractionState = function(opt_state) {
  this.selection = new gviz.util.Selection;
  this.magnified = this.elaborated = this.focusedMarker = this.focusedFeature = null;
  if (goog.isDefAndNotNull(opt_state)) {
    this.selection.setSelection(opt_state.selection);
    var userState = new gviz.Options([opt_state]);
    this.focusedFeature = userState.inferOptionalStringValue("focusedFeature");
    this.focusedMarker = userState.inferOptionalStringValue("focusedMarker");
    var elaborated = userState.inferObjectValue("elaborated");
    if (goog.isDefAndNotNull(elaborated)) {
      var rowId = userState.inferOptionalNumberValue("elaborated.rowId"), isDisputed = userState.inferOptionalBooleanValue("elaborated.isDisputed"), xOrigin = userState.inferOptionalNumberValue("elaborated.origin.x"), yOrigin = userState.inferOptionalNumberValue("elaborated.origin.y");
      goog.isDefAndNotNull(rowId) && goog.isDefAndNotNull(xOrigin) && goog.isDefAndNotNull(yOrigin) && goog.isDefAndNotNull(isDisputed) && (this.elaborated = {rowId:rowId, isDisputed:isDisputed, origin:{x:xOrigin, y:yOrigin}});
    }
  }
};
gviz.geochart.InteractionState.prototype.clone = function() {
  var cloned = new gviz.geochart.InteractionState;
  cloned.selection = this.selection.clone();
  cloned.focusedFeature = goog.object.unsafeClone(this.focusedFeature);
  cloned.elaborated = goog.object.unsafeClone(this.elaborated);
  cloned.magnified = goog.object.unsafeClone(this.magnified);
  return cloned;
};
gviz.geochart.InteractionState.prototype.equals = function(other) {
  return goog.json.serialize(this) == goog.json.serialize(other);
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/magnified-area-definer.js)
gviz.geochart.MagnifiedAreaDefiner = function(mapSize, boundaries) {
  this.boundaries_ = this.removeMarginsFromBoundaries_(boundaries);
  this.glassSize_ = this.calcGlassSize_(mapSize);
};
gviz.geochart.MagnifiedAreaDefiner.prototype.removeMarginsFromBoundaries_ = function(boundaries) {
  var marginsBox = new goog.math.Box(-5, -5, -5, -5);
  return boundaries.clone().expand(marginsBox);
};
gviz.geochart.MagnifiedAreaDefiner.prototype.calcGlassSize_ = function(mapSize) {
  var glassSide = 2 * mapSize.getShortest() / 5;
  return new goog.math.Size(glassSide, glassSide);
};
gviz.geochart.MagnifiedAreaDefiner.prototype.calcPosition = function(markerPosition) {
  var box = this.boundaries_, glassSize = this.glassSize_, x = markerPosition.x, rightEnd = x + glassSize.width;
  rightEnd > box.right && (x = markerPosition.x - glassSize.width, goog.asserts.assert(x > box.left));
  var y = markerPosition.y - glassSize.height;
  y < box.top && (y = markerPosition.y, goog.asserts.assert(y + glassSize.height < box.bottom));
  return new goog.math.Rect(x, y, glassSize.width, glassSize.height);
};
gviz.geochart.MagnifiedAreaDefiner.prototype.calcBoundingBox = function(markerLocation, viewDef, zoomFactor) {
  var viewBoundingBox = viewDef.mapBoundingBox, viewSize = viewDef.onscreenPosition.getSize(), lat = parseFloat(markerLocation.lat), lng = parseFloat(markerLocation.lng);
  lng < viewBoundingBox.lo[1] ? lng += 360 : lng > viewBoundingBox.hi[1] && (lng -= 360);
  var radiusToMagnify = this.glassSize_.getShortest() / 2 / zoomFactor, viewZoom = viewSize.height / (viewBoundingBox.hi[0] - viewBoundingBox.lo[0]), radius = radiusToMagnify / viewZoom;
  return{hi:[lat + radius, lng + radius], lo:[lat - radius, lng - radius]};
};
gviz.geochart.MagnifiedAreaDefiner.isMarkerIn = function(magnifiedAreaDef, rowId) {
  var magnifiedMarkers = magnifiedAreaDef.markersData, marker$$0 = goog.array.find(magnifiedMarkers, function(marker) {
    return marker.rowId == rowId;
  });
  if (!marker$$0) {
    return!1;
  }
  var rect = magnifiedAreaDef.view.onscreenPosition, cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2, c = new goog.math.Coordinate(cx, cy), m = new goog.math.Coordinate(marker$$0.x, marker$$0.y), d = goog.math.Coordinate.distance(m, c), r = rect.getSize().getShortest() / 2;
  return d < .9 * r;
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/magnified-area-event-handler.js)
gviz.geochart.MagnifiedAreaEventHandler = function(logicalCanvas, options, initialState, scheduler) {
  this.logger_ = gviz.util.VisCommon.createLogger(gviz.geochart.MagnifiedAreaEventHandler.NAME_);
  goog.log.info(this.logger_, "Starting...");
  this.enabled_ = !logicalCanvas.isSlowRenderer() && options.inferBooleanValue("magnifyingGlass.enable");
  this.state_ = initialState;
  this.scheduler_ = scheduler;
  this.closeTimeout_ = this.openTimeout_ = null;
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.refreshState = function(state) {
  this.state_ = state;
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.handleEvent = function(event, magnifiedAreaDef) {
  if (!this.enabled_) {
    return!1;
  }
  if (this.handleClose_(event) || this.handleOpen_(event, magnifiedAreaDef)) {
    return!0;
  }
  var isFeatureEvent = gviz.geochart.interactionEvents.isFeatureEvent(event);
  return event.data.isMagnified && isFeatureEvent ? !0 : !1;
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.handleOpen_ = function(event, magnifiedAreaDef) {
  if (event.type != gviz.geochart.interactionEvents.EventType.MARKER_HOVER) {
    return!1;
  }
  if (event.data.isOver) {
    if (!event.data.isCluttered) {
      return!1;
    }
    if (magnifiedAreaDef && gviz.geochart.MagnifiedAreaDefiner.isMarkerIn(magnifiedAreaDef, event.data.rowId)) {
      return goog.log.info(this.logger_, "Inside marker which is already magnified."), !0;
    }
    this.cancelOpen_();
    goog.log.info(this.logger_, "Inside cluttered marker, wait & open.");
    this.openTimeout_ = window.setTimeout(this.bind_(function() {
      goog.log.info(this.logger_, "Timeout complete, open magnifying glass.");
      this.openTimeout_ = null;
      this.state_.magnified = {markerId:event.data.markerId, rowId:event.data.rowId};
      this.scheduler_.updateCountdown(0);
    }), gviz.geochart.MagnifiedAreaEventHandler.OPEN_WAIT_TIME_);
    return!0;
  }
  goog.log.info(this.logger_, "Exited a marker, cancel open if planned.");
  this.cancelOpen_();
  return!1;
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.handleClose_ = function(event) {
  if (!this.state_.magnified) {
    return!1;
  }
  switch(event.type) {
    case gviz.geochart.interactionEvents.EventType.MARKER_CLICK:
    ;
    case gviz.geochart.interactionEvents.EventType.FEATURE_CLICK:
      return this.handleClickClose_(event);
    case gviz.geochart.interactionEvents.EventType.MARKER_HOVER:
    ;
    case gviz.geochart.interactionEvents.EventType.FEATURE_HOVER:
      return event.data.isOver ? this.handleHoverInClose_(event) : this.handleHoverOutClose_(event), !1;
    case gviz.geochart.interactionEvents.EventType.FEATURE_MOVE:
      return this.handleMoveClose_(event);
    default:
      return!1;
  }
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.handleClickClose_ = function(event) {
  if (event.data.isMagnified) {
    return!1;
  }
  goog.log.info(this.logger_, "Clicked outside of the magnifying glass - close it.");
  this.close_();
  return!0;
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.handleHoverInClose_ = function(event) {
  var isMarker = gviz.geochart.interactionEvents.isMarkerEvent(event), inTriangle = event.elementType == gviz.geochart.interactionEvents.ElementType.MAGNIFYING_GLASS_TRIANGLE;
  event.data.isMagnified && !inTriangle ? (goog.log.info(this.logger_, "Inside magnifying glass, cancel close if planned."), this.cancelClose_()) : isMarker && (event.data.isCluttered ? (goog.log.info(this.logger_, "Inside cluttered marker, cancel close if planned."), this.cancelClose_()) : (goog.log.info(this.logger_, "Inside non-cluttered marker, close magnifying glass."), this.close_()));
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.handleHoverOutClose_ = function(event) {
  if (goog.isNull(this.closeTimeout_)) {
    var isMarker = gviz.geochart.interactionEvents.isMarkerEvent(event);
    if (event.data.isMagnified || isMarker) {
      goog.log.info(this.logger_, "Exited magnifying glass or marker, wait & close."), this.waitAndClose_();
    }
  }
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.handleMoveClose_ = function(event) {
  var inTriangle = event.elementType == gviz.geochart.interactionEvents.ElementType.MAGNIFYING_GLASS_TRIANGLE;
  return inTriangle ? (goog.log.info(this.logger_, "Moved inside triangle, restart close timeout."), this.waitAndClose_(), !0) : !1;
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.waitAndClose_ = function() {
  this.cancelClose_();
  this.closeTimeout_ = window.setTimeout(this.bind_(function() {
    goog.log.info(this.logger_, "Timeout complete, close magnifying glass.");
    this.closeTimeout_ = null;
    this.close_();
  }), gviz.geochart.MagnifiedAreaEventHandler.CLOSE_WAIT_TIME_);
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.close_ = function() {
  this.state_.magnified = null;
  this.scheduler_.updateCountdown(0);
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.cancelOpen_ = function() {
  goog.isNull(this.openTimeout_) || (goog.log.info(this.logger_, "Cancelling magnifying glass open."), goog.global.clearTimeout(this.openTimeout_), this.openTimeout_ = null);
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.cancelClose_ = function() {
  goog.isNull(this.closeTimeout_) || (goog.log.info(this.logger_, "Cancelling magnifying glass close."), goog.global.clearTimeout(this.closeTimeout_), this.closeTimeout_ = null);
};
gviz.geochart.MagnifiedAreaEventHandler.prototype.bind_ = function(f) {
  return goog.bind(f, this);
};
gviz.geochart.MagnifiedAreaEventHandler.OPEN_WAIT_TIME_ = 300;
gviz.geochart.MagnifiedAreaEventHandler.CLOSE_WAIT_TIME_ = 500;
gviz.geochart.MagnifiedAreaEventHandler.NAME_ = "gviz.geochart.MagnifiedAreaEventHandler";
// INPUT (javascript/gviz/devel/jsapi/common/size-scale.js)
gviz.SizeScale = function(minRadius, maxRadius, valueRange, numberScale) {
  this.minArea_ = Math.pow(minRadius, 2);
  this.maxArea_ = Math.pow(maxRadius, 2);
  this.defaultRadius_ = maxRadius;
  this.rangeWidth_ = (this.valueRange_ = valueRange ? new goog.math.Range(numberScale.transform(valueRange.start), numberScale.transform(valueRange.end)) : null) ? this.valueRange_.end - this.valueRange_.start : null;
  this.numberScale_ = numberScale;
};
gviz.SizeScale.prototype.getRadiusFor = function(value) {
  var area = null;
  goog.isDefAndNotNull(value) && goog.isDefAndNotNull(this.numberScale_) && (value = this.numberScale_.transform(value));
  if (goog.isDefAndNotNull(value) && goog.isDefAndNotNull(this.valueRange_)) {
    0 === this.rangeWidth_ && value === this.valueRange_.start ? area = (this.maxArea_ + this.minArea_) / 2 : value <= this.valueRange_.start ? area = this.minArea_ : value >= this.valueRange_.end && (area = this.maxArea_);
  } else {
    if (!this.rangeWidth_ || !goog.isDefAndNotNull(value)) {
      return this.defaultRadius_;
    }
  }
  if (!goog.isDefAndNotNull(area)) {
    goog.asserts.assert(this.numberScale_);
    value = goog.math.clamp(value, this.valueRange_.start, this.valueRange_.end);
    var relativeValue = (value - this.valueRange_.start) / this.rangeWidth_, area = goog.math.lerp(this.minArea_, this.maxArea_, relativeValue);
  }
  return Math.round(Math.sqrt(area));
};
gviz.SizeScale.create = function(options, valueRange) {
  var minRadius = options.inferNonNegativeNumberValue("sizeAxis.minSize"), maxRadius = options.inferNonNegativeNumberValue("sizeAxis.maxSize");
  if (minRadius > maxRadius) {
    throw Error("sizeAxis.minSize (" + minRadius + ") must be at most sizeAxis.maxSize (" + maxRadius + ")");
  }
  var userMinValue = options.inferOptionalNumberValue("sizeAxis.minValue"), userMaxValue = options.inferOptionalNumberValue("sizeAxis.maxValue");
  if (goog.isDefAndNotNull(userMinValue) && goog.isDefAndNotNull(userMaxValue) && userMinValue > userMaxValue) {
    throw Error("sizeAxis.minValue (" + userMinValue + ") must be at most sizeAxis.maxValue (" + userMaxValue + ")");
  }
  var newValueRange = gviz.util.getOverridenRange(valueRange, userMinValue, userMaxValue), scaleType = gviz.NumberScaleUtil.getScaleType(options, "sizeAxis." + gviz.NumberScaleUtil.LOG_SCALE_OPTIONS_KEY, "sizeAxis." + gviz.NumberScaleUtil.SCALE_TYPE_OPTIONS_KEY), numberScale = gviz.NumberScaleUtil.getScale(scaleType, 1, []);
  return new gviz.SizeScale(minRadius, maxRadius, newValueRange, numberScale);
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/projection/identity-projection.js)
gviz.projection.IdentityProjection = function(options) {
  gviz.projection.BaseProjection.call(this, options);
};
goog.inherits(gviz.projection.IdentityProjection, gviz.projection.BaseProjection);
gviz.projection.IdentityProjection.prototype.getAspectRatio = function() {
  return 1;
};
gviz.projection.IdentityProjection.prototype.project = function(coordinates$$0) {
  return goog.array.map(arguments, function(coordinates) {
    goog.asserts.assert(2 === coordinates.length);
    return{x:coordinates[1], y:coordinates[0]};
  });
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/map-definer.js)
gviz.geochart.MapDefiner = function(options, width, height, textMeasureFunction, dataTable, dataTableFormat) {
  this.options_ = options;
  var projection = gviz.geochart.options.inferProjection(options, "projection", gviz.geochart.options.DEFAULT_PROJECTION), projectionClass = gviz.projection.Projections[projection.name];
  this.projection_ = new projectionClass(projection);
  this.width_ = width;
  this.height_ = height;
  this.chartRect_ = gviz.geochart.MapDefiner.calcChartRect_(options, width, height);
  this.mapRect_ = this.calcMapRect_(options, this.chartRect_);
  this.textMeasureFunction_ = textMeasureFunction;
  this.dataTable_ = dataTable;
  this.dataTableFormat_ = dataTableFormat;
  this.defaultFontSize_ = options.inferNonNegativeNumberValue("fontSize", Math.round(Math.pow(2 * (this.chartRect_.width + this.chartRect_.height), 1 / 3)));
  this.markerStrokeColor_ = options.inferColorValue(["marker.style.stroke.color", "marker.style.stroke"], "#ccc");
  this.markerStrokeWidth_ = options.inferNonNegativeNumberValue("marker.style.stroke.width", 1);
  this.defaultFontName_ = options.inferStringValue("fontName");
  this.colorScale_ = this.constructColorScale_();
  this.sizeScale_ = this.constructSizeScale_();
  var legendOptions = options.inferValue("legend");
  this.hasLegend_ = "object" == goog.typeOf(legendOptions);
  this.legendPosition_ = options.inferEnumValue("legend.position", gviz.geochart.options.LegendPosition, gviz.geochart.options.DEFAULT_LEGEND_POSITION);
  this.legendBarLength_ = options.inferRatioNumberValue("legend.bar.length", 1 / 3);
  this.legendOrientation_ = options.inferEnumValue("legend.orientation", gviz.colorbar.Orientation, gviz.geochart.options.DEFAULT_LEGEND_ORIENTATION);
  var defaultLegendTextStyle = {fontName:this.defaultFontName_, fontSize:this.defaultFontSize_};
  this.legendTextStyle_ = options.inferTextStyleValue("legend.textStyle", defaultLegendTextStyle);
  this.numberFormat_ = options.inferOptionalStringValue("legend.numberFormat");
  this.datalessFeatureColor_ = options.inferColorValue("datalessRegionColor", "");
  this.defaultColor_ = options.inferColorValue("defaultColor", "");
  this.coloringFunction_ = this.computeColoringFunction_();
  this.sizingFunction_ = this.computeSizingFunction_();
  var tooltipTextStyle = options.inferTextStyleValue("tooltip.textStyle"), boldTextStyle = gviz.graphics.util.createBoldTextStyle(tooltipTextStyle, !0);
  this.tooltipTrigger_ = options.inferEnumValue("tooltip.trigger", gviz.Options.TooltipTrigger, gviz.Options.TooltipTrigger.FOCUS);
  this.isTooltipEnabled_ = this.tooltipTrigger_ != gviz.Options.TooltipTrigger.NONE;
  this.tooltipTextStyles_ = {normal:tooltipTextStyle, bold:boldTextStyle};
  var tooltipShowDisputedText = options.inferBooleanValue("tooltip.showDisputedText");
  this.tooltipShowTitle_ = options.inferBooleanValue("tooltip.showTitle");
  this.tooltipDisputedFormat_ = tooltipShowDisputedText ? "%s's administration (under dispute)" : "%s";
  this.isHtmlTooltip_ = options.inferBooleanValue("tooltip.isHtml");
  this.defaultMarkerSize_ = 10;
  this.regions_ = this.markers_ = this.views_ = null;
  this.borderColor_ = "#ccc";
  this.projections_ = null;
  this.markerOpacity_ = options.inferRatioNumberValue("markerOpacity");
  this.magnifiedAreaDefiner_ = new gviz.geochart.MagnifiedAreaDefiner(this.mapRect_.getSize(), new goog.math.Box(0, width, height, 0));
};
gviz.geochart.MapDefiner.prototype.showTooltipOnFocus_ = function() {
  return this.isTooltipEnabled_ && (this.tooltipTrigger_ === gviz.Options.TooltipTrigger.BOTH || this.tooltipTrigger_ === gviz.Options.TooltipTrigger.FOCUS);
};
gviz.geochart.MapDefiner.prototype.showTooltipOnSelection_ = function() {
  return this.isTooltipEnabled_ && (this.tooltipTrigger_ === gviz.Options.TooltipTrigger.BOTH || this.tooltipTrigger_ === gviz.Options.TooltipTrigger.SELECTION);
};
gviz.geochart.MapDefiner.prototype.refreshDataTable = function(dataTable) {
  this.dataTable_ = dataTable;
  this.colorScale_ = this.constructColorScale_();
  this.sizeScale_ = this.constructSizeScale_();
};
gviz.geochart.MapDefiner.prototype.defineMapStaticLayer = function(staticMapDefinition) {
  var options = this.options_;
  this.views_ = [];
  this.projections_ = [];
  for (var viewDefs = [], i = 0, len = staticMapDefinition.views.length;i < len;i++) {
    var view = staticMapDefinition.views[i], projectionOptions = this.projection_.getOptions();
    projectionOptions.boundingBox = {lo:view.boundingBox.lo, hi:view.boundingBox.hi};
    var projection = new this.projection_.constructor(projectionOptions);
    this.projections_.push(projection);
    var viewDef = this.positionView_(view, i);
    viewDefs.push(viewDef);
    this.views_.push({features:view.features, def:viewDef});
  }
  return{width:this.width_, height:this.height_, mapRect:this.mapRect_, selectionMode:options.inferEnumValue("selectionMode", gviz.Options.SelectionMode, gviz.Options.SelectionMode.SINGLE), tooltipTrigger:this.tooltipTrigger_, backgroundBrush:options.inferBrushValue("backgroundColor"), gridlineColor:options.inferOptionalColorValue("gridlineColor"), title:{text:options.inferStringValue("title"), textStyle:options.inferTextStyleValue("titleTextStyle", {fontName:this.defaultFontName_, fontSize:this.defaultFontSize_}), 
  lines:[], align:gviz.graphics.TextAlign.START, tooltip:""}, views:viewDefs, featuresData:this.getDatalessFeaturesData_(staticMapDefinition), glowingFeatures:[], glowingMarkers:[], markersData:[], colorBar:null, magnifiedArea:null, defaultFontName:this.defaultFontName_};
};
gviz.geochart.MapDefiner.prototype.getFeature_ = function(featureId) {
  for (var i = 0, leni = this.views_.length;i < leni;i++) {
    for (var features = this.views_[i].def.features, j = 0, lenj = features.length;j < lenj;j++) {
      var feature = features[j];
      if (feature.id == featureId) {
        return feature;
      }
    }
  }
  return null;
};
gviz.geochart.MapDefiner.prototype.getDatalessFeaturesData_ = function(staticMapDefinition) {
  var datalessFeatureBrushes = this.createFeatureBrushes_(this.datalessFeatureColor_), ret = {};
  goog.array.forEach(staticMapDefinition.views, function(view) {
    goog.array.forEach(view.features, function(feature) {
      ret[feature.id] = {brushes:datalessFeatureBrushes};
    }, this);
  }, this);
  return ret;
};
gviz.geochart.MapDefiner.prototype.projectBoundingBox_ = function(boundingBox, projection) {
  var projectedBoundingBox = projection.projectBoundingBox(boundingBox);
  if (null != projectedBoundingBox) {
    return projectedBoundingBox;
  }
  for (var boundsTracker = new gviz.geochart.util.BoundsTracker, i = 1;10 > i;i++) {
    var x = (boundingBox.hi[1] - boundingBox.lo[1]) / 10 * i + boundingBox.lo[1], y = (boundingBox.hi[0] - boundingBox.lo[0]) / 10 * i + boundingBox.lo[0], projectedBounds = projection.project([y, boundingBox.lo[1]], [y, boundingBox.hi[1]], [boundingBox.lo[0], x], [boundingBox.hi[0], x]);
    boundsTracker.track.apply(boundsTracker, projectedBounds);
  }
  var xBounds = boundsTracker.getBounds("x"), yBounds = boundsTracker.getBounds("y");
  return{hi:[yBounds.max, xBounds.max], lo:[yBounds.min, xBounds.min]};
};
gviz.geochart.MapDefiner.prototype.positionView_ = function(view, index) {
  var onscreenPosition = new goog.math.Rect(view.xoffset * this.mapRect_.width + this.mapRect_.left, view.yoffset * this.mapRect_.height + this.mapRect_.top, view.scale * this.mapRect_.width, view.scale * this.mapRect_.height), projection = this.projections_[index], boundingBox = this.projectBoundingBox_(view.boundingBox, projection);
  return{id:String(index), boundingBox:boundingBox, mapBoundingBox:view.boundingBox, onscreenPosition:onscreenPosition, features:goog.array.map(view.features, goog.bind(this.positionFeature_, this, boundingBox, onscreenPosition, projection))};
};
gviz.geochart.MapDefiner.prototype.positionFeature_ = function(boundingBox, onscreenPosition, projection, feature) {
  for (var featureCenter = this.calculateCenter_(goog.iter.chain(goog.iter.toIterator(feature.polygons), goog.iter.toIterator(feature.disputed)));featureCenter[1] > boundingBox.hi[1];) {
    featureCenter[1] -= 360;
  }
  for (;featureCenter[1] < boundingBox.lo[1];) {
    featureCenter[1] += 360;
  }
  return{id:feature.id, center:this.positionPointInBox_(boundingBox, onscreenPosition, projection, featureCenter), polygons:goog.array.map(feature.polygons, goog.bind(this.positionPolygon_, this, boundingBox, onscreenPosition, projection)), disputed:goog.array.map(feature.disputed, goog.bind(this.positionPolygon_, this, boundingBox, onscreenPosition, projection)), eventsEnabled:"__DISPUTED__All" != feature.id};
};
gviz.geochart.MapDefiner.prototype.calculateCenter_ = function(polygons) {
  var xSum = 0, ySum = 0, pointCount = 0;
  goog.iter.forEach(polygons, function(polygon) {
    goog.array.forEach(polygon.shell, function(point) {
      xSum += point[0];
      ySum += goog.math.modulo(point[1], 360);
      pointCount++;
    }, this);
  }, this);
  return[xSum / pointCount, ySum / pointCount];
};
gviz.geochart.MapDefiner.prototype.positionPolygon_ = function(boundingBox, onscreenPosition, projection, polygon) {
  return{shell:this.positionPolyline_(boundingBox, onscreenPosition, projection, polygon.shell), holes:goog.array.map(polygon.holes, goog.bind(this.positionPolyline_, this, boundingBox, onscreenPosition, projection))};
};
gviz.geochart.MapDefiner.prototype.positionPolyline_ = function(boundingBox, onscreenPosition, projection, polyline) {
  return{points:goog.array.map(polyline, goog.bind(this.positionPointInBox_, this, boundingBox, onscreenPosition, projection))};
};
gviz.geochart.MapDefiner.prototype.positionPointInBox_ = function(boundingBox, onscreenPosition, projection, point) {
  var lo = boundingBox.lo, hi = boundingBox.hi, width = onscreenPosition.width, height = onscreenPosition.height, left = onscreenPosition.left, top = onscreenPosition.top, projectedPoint = projection.project(point)[0];
  return[left + width * (projectedPoint.x - lo[1]) / (hi[1] - lo[1]), top + height * (1 - (projectedPoint.y - lo[0]) / (hi[0] - lo[0]))];
};
gviz.geochart.MapDefiner.prototype.defineMapDataLayer = function(regions, markers) {
  return{featuresData:this.defineAllFeatures_(regions), markersData:this.defineAllMarkers_(markers), colorBar:this.defineColorBar_([])};
};
gviz.geochart.MapDefiner.prototype.defineAllFeatures_ = function(regions) {
  this.regions_ = [];
  for (var features = {}, i = 0;i < this.dataTable_.getNumberOfRows();++i) {
    var region = regions[i];
    this.regions_.push(region);
    if (goog.isDefAndNotNull(region)) {
      var fillColor = this.coloringFunction_(i);
      goog.isDefAndNotNull(fillColor) && (features[region] = {rowId:i, brushes:this.createFeatureBrushes_(fillColor)});
    }
  }
  return features;
};
gviz.geochart.MapDefiner.prototype.defineAllMarkers_ = function(markerLocations) {
  var markerDefinitions = [];
  this.markers_ = [];
  for (var viewDefs = goog.array.map(this.views_, function(view) {
    return view.def;
  }), i = 0;i < markerLocations.length;++i) {
    var markerLocation = markerLocations[i], marker = {location:markerLocation, defs:{}};
    if (goog.isDefAndNotNull(markerLocation)) {
      var markerDefs = this.defineMarkersForRow_(i, markerLocation, viewDefs);
      goog.array.extend(markerDefinitions, markerDefs);
      for (var j = 0;j < markerDefs.length;j++) {
        var markerDef = markerDefs[j];
        marker.defs[markerDef.markerId] = markerDef;
      }
    }
    this.markers_.push(marker);
  }
  this.markClutteredMarkers_(markerDefinitions);
  return markerDefinitions;
};
gviz.geochart.MapDefiner.prototype.markClutteredMarkers_ = function(markers) {
  for (var i = 0;i < markers.length;i++) {
    for (var marker = markers[i], markerPos = new goog.math.Coordinate(marker.x, marker.y), clutterImpact = 0, j = 0;j < markers.length;j++) {
      if (i != j) {
        var marker2 = markers[j], marker2Pos = new goog.math.Coordinate(marker2.x, marker2.y), distance = goog.math.Coordinate.distance(markerPos, marker2Pos);
        distance < marker.size + marker2.size && (clutterImpact += marker.size + marker2.size - distance);
      }
    }
    marker.isCluttered = clutterImpact > marker.size;
  }
};
gviz.geochart.MapDefiner.prototype.defineMarkersForRow_ = function(rowId, markerLocation, viewDefs) {
  var size = this.sizingFunction_(rowId), fillColor = this.coloringFunction_(rowId);
  if (!goog.isDefAndNotNull(fillColor)) {
    return[];
  }
  for (var brush = new gviz.graphics.Brush({stroke:this.markerStrokeColor_, strokeWidth:this.markerStrokeWidth_, fill:fillColor, fillOpacity:this.markerOpacity_}), markerLat = parseFloat(markerLocation.lat), markerDefinitions = [], markerLng = parseFloat(markerLocation.lng), possibleLngs = [markerLng, markerLng + 360, markerLng - 360], i = 0;i < viewDefs.length;++i) {
    var viewDef = viewDefs[i], projection = this.projections_[i], boundingBox = viewDef.mapBoundingBox;
    if (!(markerLat < boundingBox.lo[0] || markerLat > boundingBox.hi[0])) {
      for (var j = 0;j < possibleLngs.length;++j) {
        var possibleLng = possibleLngs[j];
        if (!(possibleLng < boundingBox.lo[1] || possibleLng > boundingBox.hi[1])) {
          var absolutePos = this.positionPointInBox_(viewDef.boundingBox, viewDef.onscreenPosition, projection, [markerLat, possibleLng]), markerId = String(rowId + "-" + viewDef.id + "-" + j), markerLabel = "marker";
          goog.isDefAndNotNull(this.dataTableFormat_.locationNameColumn) && 0 <= this.dataTableFormat_.locationNameColumn ? markerLabel = this.dataTable_.getFormattedValue(rowId, this.dataTableFormat_.locationNameColumn) : goog.isDefAndNotNull(this.dataTableFormat_.addressColumn) && 0 <= this.dataTableFormat_.addressColumn ? markerLabel = this.dataTable_.getFormattedValue(rowId, this.dataTableFormat_.addressColumn) : goog.isDefAndNotNull(this.dataTableFormat_.regionColumn) && 0 <= this.dataTableFormat_.regionColumn ? 
          markerLabel = this.dataTable_.getFormattedValue(rowId, this.dataTableFormat_.regionColumn) : goog.isDefAndNotNull(this.dataTableFormat_.latColumn) && goog.isDefAndNotNull(this.dataTableFormat_.lngColumn) && 0 <= this.dataTableFormat_.latColumn && 0 <= this.dataTableFormat_.lngColumn && (markerLabel = this.formatLatLngAsString_(this.dataTable_.getValue(rowId, this.dataTableFormat_.latColumn), this.dataTable_.getValue(rowId, this.dataTableFormat_.lngColumn)));
          markerDefinitions.push({markerId:markerId, label:markerLabel, rowId:rowId, x:absolutePos[0], y:absolutePos[1], size:size, brush:brush, isCluttered:!1});
        }
      }
      if (0 < markerDefinitions.length) {
        break;
      }
    }
  }
  return markerDefinitions;
};
gviz.geochart.MapDefiner.prototype.defineMagnifiedArea_ = function(markerId, rowId) {
  var markers = this.markers_, marker = markers[rowId];
  goog.asserts.assert(marker);
  goog.asserts.assert(marker.location);
  var markerDef = marker.defs[markerId];
  goog.asserts.assert(markerDef);
  if (!markerDef.isCluttered) {
    return null;
  }
  for (var viewId = markerId.split("-")[1], view = this.views_[viewId], projection = this.projections_[viewId], zoomFactor = this.options_.inferNumberValue("magnifyingGlass.zoomFactor"), magnifiedAreaDefiner = this.magnifiedAreaDefiner_, boundingBox = magnifiedAreaDefiner.calcBoundingBox(marker.location, view.def, zoomFactor), markerPosition = new goog.math.Coordinate(markerDef.x, markerDef.y), onscreenPosition = magnifiedAreaDefiner.calcPosition(markerPosition), projectedBoundingBox = this.projectBoundingBox_(boundingBox, 
  projection), magnifiedView = {id:viewId + "-" + rowId + "-mag", boundingBox:projectedBoundingBox, mapBoundingBox:boundingBox, onscreenPosition:onscreenPosition, features:goog.array.map(view.features, goog.bind(this.positionFeature_, this, boundingBox, onscreenPosition, new gviz.projection.IdentityProjection))}, markerDefinitions = [], i = 0;i < markers.length;i++) {
    var markerLocation = markers[i].location;
    goog.isDefAndNotNull(markerLocation) && goog.array.extend(markerDefinitions, this.defineMarkersForRow_(i, markerLocation, [magnifiedView]));
  }
  return{markerId:markerId, markerPosition:markerPosition, view:magnifiedView, markersData:markerDefinitions};
};
gviz.geochart.MapDefiner.prototype.defineColorBar_ = function(markers) {
  if (!this.hasLegend_ || !goog.isDefAndNotNull(this.colorScale_) || !this.colorScale_.getValuesScale()) {
    return null;
  }
  var emSize = this.legendTextStyle_.fontSize, width = this.chartRect_.width, height = this.chartRect_.height, colorBarDrawingOptions = {top:0, left:0, width:this.legendOrientation_ == gviz.colorbar.Orientation.HORIZONTAL ? width * this.legendBarLength_ : height * this.legendBarLength_, height:1.5 * emSize, orientation:this.legendOrientation_, textStyle:this.legendTextStyle_, markerColor:"black", numberFormat:this.numberFormat_};
  colorBarDrawingOptions.top = this.legendPosition_ == gviz.geochart.options.LegendPosition.TOP_LEFT || this.legendPosition_ == gviz.geochart.options.LegendPosition.TOP_RIGHT ? 3 * emSize : this.legendOrientation_ == gviz.colorbar.Orientation.VERTICAL ? height - emSize - colorBarDrawingOptions.width : height - emSize - colorBarDrawingOptions.height;
  colorBarDrawingOptions.left = this.legendPosition_ == gviz.geochart.options.LegendPosition.TOP_LEFT || this.legendPosition_ == gviz.geochart.options.LegendPosition.BOTTOM_LEFT ? .5 * emSize : this.legendOrientation_ == gviz.colorbar.Orientation.VERTICAL ? width - emSize - colorBarDrawingOptions.height : width - emSize - colorBarDrawingOptions.width;
  colorBarDrawingOptions.left += this.chartRect_.left;
  colorBarDrawingOptions.top += this.chartRect_.top;
  var colorBarDefinitions = gviz.colorbar.definer.define(this.colorScale_, colorBarDrawingOptions, markers, this.textMeasureFunction_);
  return colorBarDefinitions;
};
gviz.geochart.MapDefiner.prototype.computeTableRange_ = function(columnIndex) {
  for (var range = null, i = 0;i < this.dataTable_.getNumberOfRows();++i) {
    var value = this.dataTable_.getValue(i, columnIndex), range = gviz.util.extendRangeToInclude(range, value)
  }
  return range;
};
gviz.geochart.MapDefiner.prototype.computeColoringFunction_ = function() {
  var columnIndex = this.dataTableFormat_.colorMetricsColumn;
  return goog.isDefAndNotNull(columnIndex) ? function(rowId) {
    var value = this.dataTable_.getValue(rowId, columnIndex);
    if (goog.isDefAndNotNull(value)) {
      var computedColor = this.colorScale_.getColorFor(value);
      return computedColor;
    }
    return this.defaultColor_;
  } : function() {
    return this.defaultColor_;
  };
};
gviz.geochart.MapDefiner.prototype.computeSizingFunction_ = function() {
  var columnIndex = this.dataTableFormat_.sizeMetricsColumn;
  return goog.isDefAndNotNull(columnIndex) ? function(rowId) {
    var value = this.dataTable_.getValue(rowId, columnIndex), computedSize = this.sizeScale_.getRadiusFor(value);
    return computedSize;
  } : function() {
    return this.defaultMarkerSize_;
  };
};
gviz.geochart.MapDefiner.prototype.constructColorScale_ = function() {
  var columnIndex = this.dataTableFormat_.colorMetricsColumn;
  if (!goog.isDefAndNotNull(columnIndex)) {
    return null;
  }
  var dataRange = this.computeTableRange_(columnIndex);
  return gviz.colorbar.Scale.create(this.options_, dataRange);
};
gviz.geochart.MapDefiner.prototype.constructSizeScale_ = function() {
  var columnIndex = this.dataTableFormat_.sizeMetricsColumn, dataRange = goog.isDefAndNotNull(columnIndex) ? this.computeTableRange_(columnIndex) : null;
  return gviz.SizeScale.create(this.options_, dataRange);
};
gviz.geochart.MapDefiner.prototype.defineMapInteractionLayer = function(state) {
  var ret = {glowingFeatures:[], glowingMarkers:[]};
  goog.isDefAndNotNull(state.focusedFeature) && (ret.glowingFeatures = [state.focusedFeature]);
  goog.isDefAndNotNull(state.focusedMarker) && (ret.glowingMarkers = [state.focusedMarker]);
  ret.tooltips = [];
  var showTooltipOnSelection = this.showTooltipOnSelection_();
  goog.array.forEach(state.selection.getRowIndexes(), function(row) {
    var tooltipBody = this.computeTooltipBody_(row, !1), textMeasureFunction = this.textMeasureFunction_, fontSize = this.tooltipTextStyles_.normal.fontSize, boundaries = new goog.math.Box(0, this.width_ - 1, this.height_ - 1, 0), marker = this.markers_[row], region = this.regions_[row], feature = region && this.getFeature_(region), pivot$$0 = null, anchor$$0 = null;
    goog.asserts.assert(goog.isDefAndNotNull(marker) || goog.isDefAndNotNull(region));
    feature ? (ret.glowingFeatures.push(feature.id), showTooltipOnSelection && (pivot$$0 = anchor$$0 = new goog.math.Coordinate(feature.center[0], feature.center[1]), ret.tooltips.push(gviz.util.tooltip.definer.createTooltipDefinition(tooltipBody, textMeasureFunction, !1, anchor$$0, boundaries, pivot$$0, void 0, this.isHtmlTooltip_)))) : marker && goog.object.forEach(marker.defs, function(def, id) {
      ret.glowingMarkers.push(id);
      if (showTooltipOnSelection) {
        var pivot = new goog.math.Coordinate(def.x, def.y), anchor = new goog.math.Coordinate(def.x - fontSize, def.y - fontSize);
        ret.tooltips.push(gviz.util.tooltip.definer.createTooltipDefinition(tooltipBody, textMeasureFunction, !1, anchor, boundaries, pivot, void 0, this.isHtmlTooltip_));
      }
    }, this);
  }, this);
  if (goog.isDefAndNotNull(state.elaborated)) {
    if (this.showTooltipOnFocus_()) {
      var tooltipBody = this.computeTooltipBody_(state.elaborated.rowId, state.elaborated.isDisputed), textMeasureFunction$$0 = this.textMeasureFunction_, fontSize$$0 = this.tooltipTextStyles_.normal.fontSize, boundaries$$0 = new goog.math.Box(0, this.width_ - 1, this.height_ - 1, 0), pivot$$1 = new goog.math.Coordinate(state.elaborated.origin.x, state.elaborated.origin.y), anchor$$1 = new goog.math.Coordinate(pivot$$1.x - fontSize$$0, pivot$$1.y - fontSize$$0);
      ret.tooltips.push(gviz.util.tooltip.definer.createTooltipDefinition(tooltipBody, textMeasureFunction$$0, !1, anchor$$1, boundaries$$0, pivot$$1, void 0, this.isHtmlTooltip_));
    }
    if (goog.isDefAndNotNull(this.dataTableFormat_.colorMetricsColumn)) {
      var markerValue = this.dataTable_.getValue(state.elaborated.rowId, this.dataTableFormat_.colorMetricsColumn), marker$$0 = {value:markerValue};
      ret.colorBar = this.defineColorBar_([marker$$0]);
    }
  }
  goog.isDefAndNotNull(state.magnified) && (ret.magnifiedArea = this.defineMagnifiedArea_(state.magnified.markerId, state.magnified.rowId));
  return ret;
};
gviz.geochart.MapDefiner.prototype.formatDegrees_ = function(degrees, negativeLabel, positiveLabel) {
  var directionLabel = 0 <= degrees ? positiveLabel : negativeLabel;
  degrees = Math.abs(degrees);
  var formattedDegrees = Math.floor(degrees), minutes = 60 * (degrees - formattedDegrees), formattedMinutes = Math.floor(minutes), seconds = 60 * (minutes - formattedMinutes), formattedSeconds = Math.round(seconds);
  return formattedDegrees + "\u00b0" + formattedMinutes + "'" + formattedSeconds + '"' + directionLabel;
};
gviz.geochart.MapDefiner.prototype.formatLatLngAsString_ = function(lat, lng) {
  return this.formatDegrees_(lat, "S", "N") + " " + this.formatDegrees_(lng, "W", "E");
};
gviz.geochart.MapDefiner.prototype.computeTooltipBody_ = function(rowId, isDisputed) {
  var tableFormat = this.dataTableFormat_, dataTable = this.dataTable_, body = {entries:[]}, title;
  if (goog.isDefAndNotNull(tableFormat.locationNameColumn)) {
    title = dataTable.getFormattedValue(rowId, tableFormat.locationNameColumn);
  } else {
    switch(tableFormat.addressType) {
      case gviz.GeoChartDataFormat.AddressType.LATLNG:
        var lat = dataTable.getValue(rowId, tableFormat.latColumn), lng = dataTable.getValue(rowId, tableFormat.lngColumn);
        title = this.formatLatLngAsString_(lat, lng);
        break;
      case gviz.GeoChartDataFormat.AddressType.REGIONCODE:
        title = dataTable.getFormattedValue(rowId, tableFormat.regionColumn);
        isDisputed && (title = goog.string.format(this.tooltipDisputedFormat_, title));
        break;
      case gviz.GeoChartDataFormat.AddressType.ADDRESS:
        title = dataTable.getFormattedValue(rowId, tableFormat.addressColumn);
        break;
      default:
        title = "";
    }
  }
  if (this.tooltipShowTitle_) {
    var titleLineEntry = gviz.util.tooltip.definer.createBodyTextLineEntry(title, this.tooltipTextStyles_.bold);
    body.entries.push(titleLineEntry);
  }
  if (goog.isDefAndNotNull(tableFormat.tooltipColumn)) {
    var content = dataTable.getFormattedValue(rowId, tableFormat.tooltipColumn);
    if (dataTable.getColumnProperty(tableFormat.tooltipColumn, "html")) {
      body.entries.push(gviz.util.tooltip.definer.createBodyTextLineEntry(content, this.tooltipTextStyles_.normal, void 0, void 0, void 0, void 0, void 0, !0));
    } else {
      for (var lines = content.split("\n"), i = 0;i < lines.length;i++) {
        var lineEntry = gviz.util.tooltip.definer.createBodyTextLineEntry(lines[i], this.tooltipTextStyles_.normal);
        body.entries.push(lineEntry);
      }
    }
  } else {
    if (goog.isDefAndNotNull(tableFormat.colorMetricsColumn)) {
      var subtitle = dataTable.getColumnLabel(tableFormat.colorMetricsColumn), content = dataTable.getFormattedValue(rowId, tableFormat.colorMetricsColumn), lineEntry = gviz.util.tooltip.definer.createBodyTextLineEntry(content, this.tooltipTextStyles_.bold, subtitle, this.tooltipTextStyles_.normal);
      body.entries.push(lineEntry);
    }
    goog.isDefAndNotNull(tableFormat.sizeMetricsColumn) && tableFormat.sizeMetricsColumn != tableFormat.colorMetricsColumn && (subtitle = dataTable.getColumnLabel(tableFormat.sizeMetricsColumn), content = dataTable.getFormattedValue(rowId, tableFormat.sizeMetricsColumn), lineEntry = gviz.util.tooltip.definer.createBodyTextLineEntry(content, this.tooltipTextStyles_.bold, subtitle, this.tooltipTextStyles_.normal), body.entries.push(lineEntry));
  }
  return body;
};
gviz.geochart.MapDefiner.prototype.bind_ = function(f) {
  return goog.bind(f, this);
};
gviz.geochart.MapDefiner.prototype.createFeatureBrushes_ = function(color) {
  var borderColor = color === gviz.graphics.util.NO_COLOR ? [255, 255, 255] : goog.color.hexToRgb(color), borderColor = goog.color.rgbArrayToHex(goog.color.darken(borderColor, .1));
  return{fill:this.createFillBrush_(color, borderColor), disputed:this.createDisputedBrush_(color), border:this.createBorderBrush_(borderColor)};
};
gviz.geochart.MapDefiner.prototype.createFillBrush_ = function(color, borderColor) {
  return new gviz.graphics.Brush({stroke:borderColor, fill:color});
};
gviz.geochart.MapDefiner.prototype.createDisputedBrush_ = function(color) {
  return new gviz.graphics.Brush({stroke:"none", pattern:new gviz.graphics.Pattern(gviz.graphics.Pattern.Style.PRIMARY_DIAGONAL_STRIPES, color, color == this.borderColor_ ? "#fff" : this.borderColor_)});
};
gviz.geochart.MapDefiner.prototype.createBorderBrush_ = function(borderColor) {
  return new gviz.graphics.Brush({stroke:borderColor});
};
gviz.geochart.MapDefiner.calcChartRect_ = function(options, width, height) {
  var backgroundBrush = options.inferBrushValue("backgroundColor"), doubleBorderSize = backgroundBrush.getVisibleStrokeWidth(), newWidth = width - doubleBorderSize, newHeight = height - doubleBorderSize, newLeft = Math.round((width - newWidth) / 2), newTop = Math.round((height - newHeight) / 2);
  return new goog.math.Rect(newLeft, newTop, newWidth, newHeight);
};
gviz.geochart.MapDefiner.prototype.calcMapRect_ = function(options, chartRect) {
  var keepAspectRatio = options.inferOptionalBooleanValue("keepAspectRatio");
  if (keepAspectRatio) {
    var width = chartRect.width, height = chartRect.height, aspectRatio = this.projection_.getAspectRatio(), newWidth = Math.min(width, Math.round(height * aspectRatio)), newLeft = Math.round((width - newWidth) / 2) + chartRect.left, newHeight = Math.min(height, Math.round(width / aspectRatio)), newTop = Math.round((height - newHeight) / 2) + chartRect.top;
    return new goog.math.Rect(newLeft, newTop, newWidth, newHeight);
  }
  return chartRect.clone();
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/active-map.js)
gviz.geochart.ActiveMap = function(logicalCanvas, options, width, height, dataTable, dataTableFormat, initialState, readyEventDispatcher, eventDispatcher) {
  goog.Disposable.call(this);
  this.logger_ = gviz.util.VisCommon.createLogger(gviz.geochart.ActiveMap.NAME_);
  goog.log.info(this.logger_, "Starting...");
  this.logicalCanvas_ = logicalCanvas;
  this.options_ = options;
  this.width_ = width;
  this.height_ = height;
  this.dataTableFormat_ = dataTableFormat;
  this.state_ = initialState;
  this.drawnState_ = null;
  this.readyWasTriggered_ = !1;
  this.readyEventDispatcher_ = readyEventDispatcher;
  this.eventDispatcher_ = eventDispatcher;
  this.staticMapDefLoaded_ = !1;
  this.delayedSetLocationsCall_ = null;
  this.allLocationsAreLoaded_ = !1;
  this.scheduler_ = new gviz.canviz.Scheduler(this.bind_(this.redraw_));
  this.mapDefinition_ = new gviz.util.LayeredObject(3);
  this.dirtyLayers_ = [!1, !1, !1];
  var textMeasureFunction = this.logicalCanvas_.getTextSize;
  this.mapDefiner_ = new gviz.geochart.MapDefiner(this.options_, this.width_, this.height_, textMeasureFunction, dataTable, this.dataTableFormat_);
  this.magnifiedAreaEventHandler_ = new gviz.geochart.MagnifiedAreaEventHandler(logicalCanvas, options, initialState, this.scheduler_);
  this.enableRegionInteractivity_ = options.inferBooleanValue("enableRegionInteractivity", dataTableFormat.displayMode == gviz.GeoChartDataFormat.DisplayMode.REGIONS);
  this.registerEventHandlers_();
};
goog.inherits(gviz.geochart.ActiveMap, goog.Disposable);
gviz.geochart.ActiveMap.prototype.setStaticMap = function(staticMapDef, mapId) {
  goog.log.info(this.logger_, "Setting static map data.");
  var staticMapLayer = this.mapDefiner_.defineMapStaticLayer(staticMapDef);
  this.setLayer_(gviz.geochart.ActiveMap.STATIC_MAP_LAYER, staticMapLayer);
  this.staticMapDefLoaded_ = !0;
  this.eventDispatcher_("mapLoaded", mapId);
  goog.isDefAndNotNull(this.delayedSetLocationsCall_) ? this.delayedSetLocationsCall_() : this.redraw_();
};
gviz.geochart.ActiveMap.prototype.setLocations = function(regions, markers, allLocationsAreLoaded, opt_dataTable, opt_state) {
  this.readyWasTriggered_ = !1;
  var setLocationCall = this.bind_(function() {
    this.allLocationsAreLoaded_ = allLocationsAreLoaded;
    goog.isDefAndNotNull(opt_dataTable) ? (goog.log.info(this.logger_, "Setting regions and data-table."), this.drawnState_ = null, this.mapDefiner_.refreshDataTable(opt_dataTable)) : goog.log.info(this.logger_, "Setting regions.");
    goog.isDefAndNotNull(opt_state) && (this.state_ = opt_state, this.magnifiedAreaEventHandler_.refreshState(opt_state));
    var dataLayer = this.mapDefiner_.defineMapDataLayer(regions, markers);
    this.setLayer_(gviz.geochart.ActiveMap.DATA_LAYER, dataLayer);
    this.redraw_();
  });
  this.staticMapDefLoaded_ ? setLocationCall() : this.delayedSetLocationsCall_ = setLocationCall;
};
gviz.geochart.ActiveMap.prototype.setSelection = function(selection) {
  this.state_.selection.setSelection(selection);
  this.scheduler_.updateCountdown(1);
};
gviz.geochart.ActiveMap.prototype.getSelection = function() {
  return this.state_.selection.getSelection();
};
gviz.geochart.ActiveMap.prototype.redraw_ = function() {
  if (this.staticMapDefLoaded_) {
    if (!goog.isDefAndNotNull(this.drawnState_) || !this.drawnState_.equals(this.state_)) {
      goog.log.info(this.logger_, "Refreshing interacion layer.");
      var interactionLayer = this.mapDefiner_.defineMapInteractionLayer(this.state_);
      this.setLayer_(gviz.geochart.ActiveMap.INTERACTION_LAYER, interactionLayer);
    }
    var compactedDefinition = this.mapDefinition_.compact();
    this.dirtyLayers_[gviz.geochart.ActiveMap.STATIC_MAP_LAYER] ? this.logicalCanvas_.plotChart(compactedDefinition) : this.dirtyLayers_[gviz.geochart.ActiveMap.DATA_LAYER] ? this.logicalCanvas_.plotData(compactedDefinition) : this.logicalCanvas_.plotInteraction(compactedDefinition);
    this.dirtyLayers_ = [!1, !1, !1];
    this.drawnState_ = this.state_.clone();
    !this.readyWasTriggered_ && this.allLocationsAreLoaded_ && (this.readyEventDispatcher_(), this.readyWasTriggered_ = !0);
  }
};
gviz.geochart.ActiveMap.prototype.drawWithTemporaryRenderer = function(renderer, overlayArea) {
  var logicalCanvas = new gviz.geochart.LogicalCanvas(overlayArea, renderer, this.logicalCanvas_.getDataTableFormat()), compactedDefinition = this.mapDefinition_.compact();
  logicalCanvas.plotChart(compactedDefinition);
  logicalCanvas.plotData(compactedDefinition);
  logicalCanvas.plotInteraction(compactedDefinition);
};
gviz.geochart.ActiveMap.prototype.featureHoverEventHandler_ = function(event) {
  if (!this.handleMagnifiedAreaEvent_(event) && this.enableRegionInteractivity_) {
    var fid = event.data.featureId;
    if (!goog.isNull(fid)) {
      if (event.data.isOver) {
        this.state_.focusedFeature = fid;
        var rowId = this.featureToRowNumber_(fid);
        this.state_.elaborated = goog.isDefAndNotNull(rowId) ? {rowId:rowId, isDisputed:event.data.isDisputed, origin:{x:event.data.cursorPosition.x, y:event.data.cursorPosition.y}} : null;
      } else {
        this.state_.focusedFeature = null, this.state_.elaborated = null;
      }
      this.scheduler_.updateCountdown(50);
    }
  }
};
gviz.geochart.ActiveMap.prototype.markerHoverEventHandler_ = function(event) {
  this.handleMagnifiedAreaEvent_(event) || (event.data.isOver ? (this.state_.focusedMarker = event.data.markerId, this.state_.elaborated = {rowId:event.data.rowId, isDisputed:!1, origin:{x:event.data.cursorPosition.x, y:event.data.cursorPosition.y}}) : (this.state_.focusedMarker = null, this.state_.elaborated = null), this.scheduler_.updateCountdown(50));
};
gviz.geochart.ActiveMap.prototype.featureMoveEventHandler_ = function(event) {
  this.handleMagnifiedAreaEvent_(event) || this.handleElaborationMove_(event);
};
gviz.geochart.ActiveMap.prototype.markerMoveEventHandler_ = function(event) {
  this.handleElaborationMove_(event);
};
gviz.geochart.ActiveMap.prototype.handleElaborationMove_ = function(event) {
  if (goog.isDefAndNotNull(this.state_.elaborated)) {
    var newOrigin = {x:event.data.cursorPosition.x, y:event.data.cursorPosition.y};
    goog.log.fine(this.logger_, "Moving tooltip to " + newOrigin.x + ", " + newOrigin.y);
    this.state_.elaborated.origin = newOrigin;
    this.scheduler_.updateCountdown(3);
  }
};
gviz.geochart.ActiveMap.prototype.featureClickEventHandler_ = function(event) {
  if (!this.handleMagnifiedAreaEvent_(event) && this.enableRegionInteractivity_) {
    var featureId = event.data.featureId;
    goog.isNull(featureId) || this.eventDispatcher_("regionClick", {region:featureId});
    var rowId = this.featureToRowNumber_(featureId);
    this.handleClick_(event, rowId);
  }
};
gviz.geochart.ActiveMap.prototype.markerClickEventHandler_ = function(event) {
  if (!this.handleMagnifiedAreaEvent_(event)) {
    var rowId = event.data.rowId;
    this.handleClick_(event, rowId);
  }
};
gviz.geochart.ActiveMap.prototype.handleClick_ = function(event, rowId) {
  var isSingle = this.mapDefinition_.compact().selectionMode == gviz.Options.SelectionMode.SINGLE;
  goog.isDefAndNotNull(rowId) ? (this.state_.selection.toggleRow(rowId, isSingle), this.eventDispatcher_("select", {})) : this.state_.selection.clear();
  this.scheduler_ && this.scheduler_.updateCountdown(50);
};
gviz.geochart.ActiveMap.prototype.handleMagnifiedAreaEvent_ = function(event) {
  var mapDef = this.mapDefinition_.compact(), magnifiedAreaDef = mapDef ? mapDef.magnifiedArea : null;
  return this.magnifiedAreaEventHandler_.handleEvent(event, magnifiedAreaDef);
};
gviz.geochart.ActiveMap.prototype.registerEventHandlers_ = function() {
  this.logicalCanvas_.listen(gviz.geochart.interactionEvents.EventType.FEATURE_CLICK, this.bind_(this.featureClickEventHandler_));
  this.logicalCanvas_.listen(gviz.geochart.interactionEvents.EventType.FEATURE_HOVER, this.bind_(this.featureHoverEventHandler_));
  this.logicalCanvas_.listen(gviz.geochart.interactionEvents.EventType.FEATURE_MOVE, this.bind_(this.featureMoveEventHandler_));
  this.logicalCanvas_.listen(gviz.geochart.interactionEvents.EventType.MARKER_CLICK, this.bind_(this.markerClickEventHandler_));
  this.logicalCanvas_.listen(gviz.geochart.interactionEvents.EventType.MARKER_HOVER, this.bind_(this.markerHoverEventHandler_));
  this.logicalCanvas_.listen(gviz.geochart.interactionEvents.EventType.MARKER_MOVE, this.bind_(this.markerMoveEventHandler_));
};
gviz.geochart.ActiveMap.prototype.featureToRowNumber_ = function(featureId) {
  if (goog.isNull(featureId)) {
    return null;
  }
  var mapDef = this.mapDefinition_.compact();
  return mapDef.featuresData[featureId] ? mapDef.featuresData[featureId].rowId : null;
};
gviz.geochart.ActiveMap.prototype.setLayer_ = function(layerId, layer) {
  this.mapDefinition_.setLayer(layerId, layer);
  this.dirtyLayers_[layerId] = !0;
};
gviz.geochart.ActiveMap.prototype.disposeInternal = function() {
  goog.log.info(this.logger_, "Disposing of the active map.");
  goog.dispose(this.scheduler_);
  this.scheduler_ = null;
  goog.dispose(this.logicalCanvas_);
  this.logicalCanvas_ = null;
  goog.dispose(this.mapDefiner_);
  this.mapDefiner_ = null;
  gviz.geochart.ActiveMap.superClass_.disposeInternal.call(this);
};
gviz.geochart.ActiveMap.prototype.bind_ = function(f) {
  return goog.bind(f, this);
};
gviz.geochart.ActiveMap.STATIC_MAP_LAYER = 0;
gviz.geochart.ActiveMap.DATA_LAYER = 1;
gviz.geochart.ActiveMap.INTERACTION_LAYER = 2;
gviz.geochart.ActiveMap.NAME_ = "gviz.geochart.ActiveMap";
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/map-list.js)
gviz.geochart.maplist = {};
gviz.geochart.maplist.MAPS = {COM:{COUNTRIES:"002 005 009 011 013 014 015 017 018 019 021 029 030 034 035 039 053 054 057 061 142 143 145 150 151 154 155 AD AE AF AG AI AL AM AO AR AS AT AU AW AX AZ BA BB BD BE BF BG BH BI BJ BL BM BN BO BQ BR BS BT BV BW BY BZ CA CC CD CF CG CH CI CK CL CM CN CO CR CU CV CW CX CY CZ DE DJ DK DM DO DZ EC EE EG EH ER ES ET FI FJ FK FM FO FR GA GB GD GE GF GG GH GI GL GM GN GP GQ GR GS GT GU GW GY HK HM HN HR HT HU ID IE IL IM IN IO IQ IR IS IT JE JM JO JP KE KG KH KI KM KN KP KR KW KY KZ LA LB LC LI LK LR LS LT LU LV LY MA MC MD ME MF MG MH MK ML MM MN MO MP MQ MR MS MT MU MV MW MX MY MZ NA NC NE NF NG NI NL NO NP NR NU NZ OM PA PE PF PG PH PK PL PM PN PR PS PT PW PY QA RE RO RS RU RW SA SB SC SD SE SG SH SI SJ SK SL SM SN SO SR SS ST SV SX SY SZ TC TD TF TG TH TJ TK TL TM TN TO TR TT TV TW TZ UA UG UM US UY UZ VA VC VE VG VI VN VU WF WS XK YE YT ZA ZM ZW world".split(" "), 
METROS:"US US-500 US-501 US-502 US-503 US-504 US-505 US-506 US-507 US-508 US-509 US-510 US-511 US-512 US-513 US-514 US-515 US-516 US-517 US-518 US-519 US-520 US-521 US-522 US-523 US-524 US-525 US-526 US-527 US-528 US-529 US-530 US-531 US-532 US-533 US-534 US-535 US-536 US-537 US-538 US-539 US-540 US-541 US-542 US-543 US-544 US-545 US-546 US-547 US-548 US-549 US-550 US-551 US-552 US-553 US-554 US-555 US-556 US-557 US-558 US-559 US-560 US-561 US-563 US-564 US-565 US-566 US-567 US-569 US-570 US-571 US-573 US-574 US-575 US-576 US-577 US-581 US-582 US-583 US-584 US-588 US-592 US-596 US-597 US-598 US-600 US-602 US-603 US-604 US-605 US-606 US-609 US-610 US-611 US-612 US-613 US-616 US-617 US-618 US-619 US-622 US-623 US-624 US-625 US-626 US-627 US-628 US-630 US-631 US-632 US-633 US-634 US-635 US-636 US-637 US-638 US-639 US-640 US-641 US-642 US-643 US-644 US-647 US-648 US-649 US-650 US-651 US-652 US-656 US-657 US-658 US-659 US-661 US-662 US-669 US-670 US-671 US-673 US-675 US-676 US-678 US-679 US-682 US-686 US-687 US-691 US-692 US-693 US-698 US-702 US-705 US-709 US-710 US-711 US-716 US-717 US-718 US-722 US-724 US-725 US-734 US-736 US-737 US-740 US-743 US-744 US-745 US-746 US-747 US-749 US-751 US-752 US-753 US-754 US-755 US-756 US-757 US-758 US-759 US-760 US-762 US-764 US-765 US-766 US-767 US-770 US-771 US-773 US-789 US-790 US-798 US-800 US-801 US-802 US-803 US-804 US-807 US-810 US-811 US-813 US-819 US-820 US-821 US-825 US-828 US-839 US-855 US-862 US-866 US-868 US-881 US-AK US-AL US-AR US-AZ US-CA US-CO US-CT US-DC US-DE US-FL US-GA US-HI US-IA US-ID US-IL US-IN US-KS US-KY US-LA US-MA US-MD US-ME US-MI US-MN US-MO US-MS US-MT US-NC US-ND US-NE US-NH US-NJ US-NM US-NV US-NY US-OH US-OK US-OR US-PA US-RI US-SC US-SD US-TN US-TX US-UT US-VA US-VT US-WA US-WI US-WV US-WY".split(" "), 
PROVINCES:"AD AE AF AG AL AM AO AR AT AU AZ BA BB BD BE BF BG BH BI BJ BN BO BQ BR BS BT BW BY BZ CA CD CF CG CH CI CL CM CN CO CR CU CV CY CZ DE DJ DK DM DO DZ EC EE EG EH ER ES ET FI FJ FM FR GA GB GD GE GH GL GM GN GQ GR GT GW GY HN HR HT HU ID IE IL IN IQ IR IS IT JM JO JP KE KG KH KI KM KN KP KR KW KZ LA LB LC LI LK LR LS LT LU LV LY MA MD ME MG MH MK ML MM MN MR MU MV MW MX MY MZ NA NE NG NI NL NO NP NR NZ OM PA PE PG PH PK PL PT PW PY QA RO RS RU RW SA SB SC SD SE SH SI SK SL SM SN SO SR SS ST SV SY SZ TD TG TH TJ TL TM TN TO TR TT TV TZ UA UG US US-AK US-AL US-AR US-AZ US-CA US-CO US-CT US-DC US-DE US-FL US-GA US-HI US-IA US-ID US-IL US-IN US-KS US-KY US-LA US-MA US-MD US-ME US-MI US-MN US-MO US-MS US-MT US-NC US-ND US-NE US-NH US-NJ US-NM US-NV US-NY US-OH US-OK US-OR US-PA US-RI US-SC US-SD US-TN US-TX US-UT US-VA US-VT US-WA US-WI US-WV US-WY UY UZ VC VE VN VU YE ZA ZM ZW".split(" "), 
REGIONS:"002 009 019 142 150 world".split(" "), SUBREGIONS:"002 005 009 011 013 014 015 017 018 019 021 029 030 034 035 039 053 054 057 061 142 143 145 150 151 154 155 world".split(" ")}, IN:{COUNTRIES:"002 009 019 030 034 035 142 143 145 151 AF BD BT CN IN MM NP PK RU TJ UZ world".split(" "), PROVINCES:"AF BD BT CN IN MM NP PK RU TJ UZ".split(" "), REGIONS:["002", "009", "019", "142", "world"], SUBREGIONS:"002 009 019 030 034 035 142 143 145 151 world".split(" ")}};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/maploader.js)
gviz.geochart.maploader = {};
gviz.geochart.maploader.logger_ = gviz.util.VisCommon.createLogger("gviz.geochart.maploader");
gviz.geochart.maploader.pending_ = {};
gviz.geochart.maploader.cache_ = {};
gviz.geochart.maploader.typeMapping_ = null;
gviz.geochart.maploader.DEFAULT_STATIC_REPOSITORY_URI_ = gviz.staticrepository.getRootUri("geochart", "10");
gviz.geochart.maploader.staticRepositoryUri_ = gviz.geochart.maploader.DEFAULT_STATIC_REPOSITORY_URI_;
gviz.geochart.maploader.BASE_URL_ = "mapfiles/%s.js";
gviz.geochart.maploader.setMapsSource = function(mapsSource, readyCallback, errorCallback) {
  goog.log.info(gviz.geochart.maploader.logger_, "Setting maps source to " + (mapsSource ? mapsSource : "default"));
  gviz.geochart.maploader.staticRepositoryUri_ = mapsSource ? mapsSource + "/" : gviz.geochart.maploader.DEFAULT_STATIC_REPOSITORY_URI_;
  gviz.geochart.maploader.cache_ = {};
  gviz.geochart.maploader.cachedBoundingBoxes_ = null;
  if (mapsSource) {
    var uri = gviz.geochart.maploader.staticRepositoryUri_ + "info/mapList.js", deferred = goog.net.jsloader.loadAndVerify(uri, "google_visualization_geochart_mapList", {cleanupWhenDone:!0});
    deferred.addCallbacks(function(response) {
      gviz.geochart.maploader.mapList_ = response;
      readyCallback();
    }, function() {
      goog.log.error(gviz.geochart.maploader.logger_, "Failed to load map list information from " + uri.toString());
      errorCallback();
    });
  } else {
    gviz.geochart.maploader.mapList_ = gviz.geochart.maplist.MAPS, readyCallback();
  }
};
gviz.geochart.maploader.loadMap = function(mapId, callback) {
  if (!goog.isDefAndNotNull(callback)) {
    throw Error("Callback is null or undefined");
  }
  var mapIdStr = gviz.geochart.maploader.mapIdToString_(mapId);
  if (goog.isDef(gviz.geochart.maploader.cache_[mapIdStr])) {
    var bindedCallback = goog.bind(callback, null, gviz.geochart.maploader.cache_[mapIdStr]);
    setTimeout(bindedCallback, 0);
  } else {
    if (goog.isDef(gviz.geochart.maploader.pending_[mapIdStr])) {
      gviz.geochart.maploader.pending_[mapIdStr].push(callback);
    } else {
      gviz.geochart.maploader.pending_[mapIdStr] = [callback];
      var uri = gviz.geochart.maploader.staticRepositoryUri_ + goog.string.format(gviz.geochart.maploader.BASE_URL_, mapIdStr), deferred = goog.net.jsloader.loadAndVerify(uri, "google_visualization_geochart_" + mapIdStr.replace("-", "$"), {cleanupWhenDone:!0});
      deferred.addCallbacks(function(response) {
        var digestedResponse = gviz.geochart.maploader.digest_(response);
        gviz.geochart.maploader.cache_[mapIdStr] = digestedResponse;
        goog.array.forEach(gviz.geochart.maploader.pending_[mapIdStr], function(aCallback) {
          aCallback(digestedResponse);
        });
        delete gviz.geochart.maploader.pending_[mapIdStr];
      }, function() {
        goog.array.forEach(gviz.geochart.maploader.pending_[mapIdStr], function(aCallback) {
          aCallback(null);
        });
        delete gviz.geochart.maploader.pending_[mapIdStr];
      });
    }
  }
};
gviz.geochart.maploader.mapIdToString_ = function(mapId) {
  var domainPrefix = "";
  "COM" != mapId.domain && (domainPrefix = mapId.domain + "_");
  return domainPrefix + mapId.region + "_" + gviz.geochart.maploader.mapResolutionToString_(mapId.resolution);
};
gviz.geochart.maploader.mapResolutionToString_ = function(resolution) {
  if (!goog.isDefAndNotNull(gviz.geochart.maploader.typeMapping_)) {
    var typeMapping = {};
    typeMapping[gviz.geochart.MapResolution.CONTINENTS] = "REGIONS";
    typeMapping[gviz.geochart.MapResolution.SUBCONTINENTS] = "SUBREGIONS";
    typeMapping[gviz.geochart.MapResolution.COUNTRIES] = "COUNTRIES";
    typeMapping[gviz.geochart.MapResolution.PROVINCES] = "PROVINCES";
    typeMapping[gviz.geochart.MapResolution.METROS] = "METROS";
    gviz.geochart.maploader.typeMapping_ = typeMapping;
  }
  return gviz.geochart.maploader.typeMapping_[resolution];
};
gviz.geochart.maploader.mapList_ = gviz.geochart.maplist.MAPS;
gviz.geochart.maploader.isMapIdExists = function(mapId) {
  var domain = mapId.domain, region = mapId.region, resolution = gviz.geochart.maploader.mapResolutionToString_(mapId.resolution), availableResolutions = gviz.geochart.maploader.mapList_[domain];
  if (availableResolutions) {
    var availableRegions = availableResolutions[resolution];
    if (availableRegions) {
      return 0 <= goog.array.binarySearch(availableRegions, region);
    }
  }
  return!1;
};
gviz.geochart.maploader.cachedBoundingBoxes_ = null;
gviz.geochart.maploader.getBoundingBoxInfo = function(callback) {
  if (goog.isDefAndNotNull(gviz.geochart.maploader.cachedBoundingBoxes_)) {
    callback(gviz.geochart.maploader.cachedBoundingBoxes_);
  } else {
    var uri = gviz.geochart.maploader.staticRepositoryUri_ + "info/boundingBoxes.js", deferred = goog.net.jsloader.loadAndVerify(uri, "google_visualization_geochart_boundingBoxes", {cleanupWhenDone:!0});
    deferred.addCallbacks(function(response) {
      var digestedResponse = gviz.geochart.maploader.digestBoundingBoxesInfo_(response);
      gviz.geochart.maploader.cachedBoundingBoxes_ = digestedResponse;
      callback(digestedResponse);
    }, function() {
      goog.log.error(gviz.geochart.maploader.logger_, "Failed to load boundingBoxes information.");
      callback(null);
    });
  }
};
gviz.geochart.maploader.digest_ = function(response) {
  return{views:goog.array.map(response.views, gviz.geochart.maploader.digestView_)};
};
gviz.geochart.maploader.digestView_ = function(view) {
  return{features:gviz.geochart.maploader.reduceFeatures_(goog.array.map(view.features, gviz.geochart.maploader.digestFeature_)), boundingBox:gviz.geochart.maploader.digestBoundingBox_(view.boundingBox), xoffset:view.xoffset, yoffset:view.yoffset, scale:view.scale};
};
gviz.geochart.maploader.reduceFeatures_ = function(features) {
  for (var disputedFeaturesMap = {}, normalFeatures = [], i = 0;i < features.length;i++) {
    var feature = features[i], fid = feature.id;
    goog.string.startsWith(fid, "__DISPUTED__") ? disputedFeaturesMap[fid] = feature : normalFeatures.push(feature);
  }
  for (i = 0;i < normalFeatures.length;i++) {
    var feature = normalFeatures[i], disputedFid = "__DISPUTED__" + feature.id, disputedFeature = disputedFeaturesMap[disputedFid];
    feature.disputed = disputedFeature ? disputedFeature.polygons : [];
  }
  var disputedAllFeature = disputedFeaturesMap.__DISPUTED__All;
  disputedAllFeature && (disputedAllFeature.disputed = disputedAllFeature.polygons, normalFeatures.push(disputedAllFeature));
  return normalFeatures;
};
gviz.geochart.maploader.digestFeature_ = function(feature) {
  return{id:feature.id, polygons:goog.array.map(feature.polygons, gviz.geochart.maploader.digestPolygon_), disputed:[]};
};
gviz.geochart.maploader.digestPolygon_ = function(polygon) {
  if (goog.isArrayLike(polygon)) {
    var shell = polygon;
    return{shell:gviz.geochart.maploader.digestPolyline_(shell), holes:[]};
  }
  return{shell:gviz.geochart.maploader.digestPolyline_(polygon.shell), holes:goog.array.map(polygon.holes, gviz.geochart.maploader.digestPolyline_)};
};
gviz.geochart.maploader.digestPolyline_ = function(polyline) {
  return goog.array.map(polyline, function(point) {
    return[gviz.geochart.util.unprojectLat(point[0]), parseFloat(point[1])];
  });
};
gviz.geochart.maploader.digestBoundingBox_ = function(boundingBox) {
  return{hi:[gviz.geochart.util.unprojectLat(boundingBox.hi[0]), parseFloat(boundingBox.hi[1])], lo:[gviz.geochart.util.unprojectLat(boundingBox.lo[0]), parseFloat(boundingBox.lo[1])]};
};
gviz.geochart.maploader.digestBoundingBoxesInfo_ = function(response) {
  return goog.array.map(response, gviz.geochart.maploader.digestBoundingBoxInfo_);
};
gviz.geochart.maploader.digestBoundingBoxInfo_ = function(boundingBoxInfo) {
  return{region:boundingBoxInfo.region, resolution:boundingBoxInfo.resolution, domain:boundingBoxInfo.domain, boundingBoxes:goog.array.map(boundingBoxInfo.boundingBoxes, gviz.geochart.maploader.digestBoundingBox_)};
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/map-resolver.js)
gviz.geochart.mapresolver = {};
gviz.geochart.mapresolver.getMapId = function(dataTable, dataTableFormat, options, callback) {
  var region = options.inferStringValue("region");
  if ("auto" != region) {
    callback(gviz.geochart.mapresolver.getVerifiedMapIdFromOptions_(region, options));
  } else {
    if (dataTableFormat.addressType != gviz.GeoChartDataFormat.AddressType.LATLNG) {
      callback(gviz.geochart.mapresolver.getVerifiedMapIdFromOptions_("world", options));
    } else {
      for (var resolution = options.inferOptionalEnumValue("resolution", gviz.geochart.MapResolution), domain = options.inferOptionalStringValue("domain"), latLngs = [], i = 0;i < dataTable.getNumberOfRows();++i) {
        latLngs.push({lat:dataTable.getValue(i, dataTableFormat.latColumn), lng:dataTable.getValue(i, dataTableFormat.lngColumn)});
      }
      gviz.geochart.maploader.getBoundingBoxInfo(function(boundingBoxesInfo) {
        if (boundingBoxesInfo) {
          var mapId = gviz.geochart.mapresolver.getMapId_(boundingBoxesInfo, latLngs, resolution, domain);
          goog.isDefAndNotNull(mapId) ? callback(mapId) : callback(gviz.geochart.mapresolver.getVerifiedMapIdFromOptions_("world", options));
        } else {
          callback(null);
        }
      });
    }
  }
};
gviz.geochart.mapresolver.getVerifiedMapIdFromOptions_ = function(region, options) {
  var resolution = options.inferEnumValue("resolution", gviz.geochart.MapResolution, gviz.geochart.MapResolution.COUNTRIES), domain = options.inferStringValue("domain"), mapId = {region:region, resolution:resolution, domain:domain};
  return gviz.geochart.maploader.isMapIdExists(mapId) || "COM" != mapId.domain && (mapId.domain = "COM", gviz.geochart.maploader.isMapIdExists(mapId)) ? mapId : null;
};
gviz.geochart.mapresolver.pointInBoundingBox_ = function(point, boundingBox) {
  return point.lat > boundingBox.lo[0] && point.lat < boundingBox.hi[0] && goog.array.some([-360, 0, 360], function(modifier) {
    return point.lng + modifier > boundingBox.lo[1] && point.lng + modifier < boundingBox.hi[1];
  });
};
gviz.geochart.mapresolver.getMapId_ = function(boundingBoxesInfo, latLngs, resolution, domain) {
  for (var i = 0;i < boundingBoxesInfo.length;++i) {
    var boundingBoxInfo = boundingBoxesInfo[i];
    if (!goog.isDefAndNotNull(resolution) || boundingBoxInfo.resolution == resolution) {
      if (!goog.isDefAndNotNull(domain) || boundingBoxInfo.domain == domain) {
        for (var allPointsInBBs = !0, j = 0;j < latLngs.length;++j) {
          for (var point = latLngs[j], pointInSomeBB = !1, boundingBoxes = boundingBoxInfo.boundingBoxes, k = 0;k < boundingBoxes.length;++k) {
            var bb = boundingBoxes[k];
            if (gviz.geochart.mapresolver.pointInBoundingBox_(point, bb)) {
              pointInSomeBB = !0;
              break;
            }
          }
          if (!pointInSomeBB) {
            allPointsInBBs = !1;
            break;
          }
        }
        if (allPointsInBBs) {
          return{region:boundingBoxInfo.region, resolution:boundingBoxInfo.resolution, domain:boundingBoxInfo.domain};
        }
      }
    }
  }
  return null;
};
gviz.geochart.mapresolver.mapExists = function(options) {
  var region = options.inferStringValue("region"), mapId = gviz.geochart.mapresolver.getVerifiedMapIdFromOptions_(region, options);
  return goog.isDefAndNotNull(mapId);
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/geo-chart.js)
google.visualization.GeoChart = function(container) {
  google.visualization.AbstractVisualization.call(this, container);
  this.logger_ = gviz.util.VisCommon.createLogger(google.visualization.GeoChart.NAME_);
  goog.log.info(this.logger_, "Starting...");
  this.activeMap_ = this.drawingFrame_ = null;
  this.locationProvider_ = new gviz.geochart.LocationProvider(this.errorHandler);
  this.lastDrawnOptionsSignature_ = "";
  this.chartSize_ = this.asyncWrapper_ = null;
};
goog.inherits(google.visualization.GeoChart, google.visualization.AbstractVisualization);
google.visualization.GeoChart.mapExists = function(userOptions) {
  goog.isDefAndNotNull(userOptions) || (userOptions = {});
  var options = new gviz.Options([userOptions, gviz.geochart.options.DEFAULTS]);
  return gviz.geochart.mapresolver.mapExists(options);
};
google.visualization.GeoChart.setMapsSource = function(mapsSource, readyCallback_opt, errorCallback_opt) {
  gviz.geochart.maploader.setMapsSource(mapsSource, function() {
    readyCallback_opt && readyCallback_opt();
  }, function() {
    errorCallback_opt && errorCallback_opt();
  });
};
google.visualization.GeoChart.prototype.drawInternal = function(asyncWrapper, dataTable, opt_options, opt_state) {
  //gviz.util.VisCommon.addCssToDom("/core/tooltip.css");
  google.visualization.errors.removeAll(this.container);
  this.asyncWrapper_ = asyncWrapper;
  goog.dispose(this.locationProvider_);
  this.locationProvider_ = new gviz.geochart.LocationProvider(this.errorHandler);
  var userOptions = opt_options || {}, userOptions = gviz.json.deserialize(gviz.json.serialize(userOptions)), options = new gviz.Options([userOptions, gviz.geochart.options.DEFAULTS]), state = new gviz.geochart.InteractionState(opt_state);
  this.chartSize_ = this.getSize_(this.container, options);
  var displayMode = options.inferEnumValue("displayMode", gviz.GeoChartDataFormat.DisplayMode, gviz.GeoChartDataFormat.DisplayMode.AUTO), geoChartDataFormat = new gviz.GeoChartDataFormat, analysisResults = geoChartDataFormat.analyzeTable(dataTable, displayMode, this.errorHandler);
  if (goog.isDefAndNotNull(analysisResults)) {
    var dataTableFormat = analysisResults, optionsSignature = goog.json.serialize({options:userOptions, format:dataTableFormat, size:this.chartSize_}), drawGivenMapId = this.asyncWrapper_(function(mapId) {
      if (!goog.isDefAndNotNull(mapId)) {
        throw Error("Requested map does not exist.");
      }
      goog.log.info(this.logger_, "MapId: " + mapId.region + ", " + mapId.resolution + ", " + mapId.domain);
      this.drawGivenMapId_(dataTable, dataTableFormat, options, optionsSignature, state, mapId);
    }, this);
    gviz.geochart.mapresolver.getMapId(dataTable, dataTableFormat, options, drawGivenMapId);
  }
};
google.visualization.GeoChart.prototype.getImageURI = function() {
  goog.asserts.assert(this.chartSize_);
  var div = goog.dom.getDomHelper(this.container).createElement("div"), textDiv = gviz.graphics.DrawingFrame.createTextMeasurementDiv(div, this.chartSize_), overlayArea = new gviz.graphics.OverlayArea(div), renderer = new gviz.graphics.CanvasRenderer(div, textDiv);
  this.activeMap_.drawWithTemporaryRenderer(renderer, overlayArea);
  var imageUrl = div.childNodes[0].toDataURL("image/png");
  return imageUrl;
};
google.visualization.GeoChart.prototype.getSize_ = function(container, options) {
  var defWidth = gviz.geochart.options.DEFAULT_WIDTH, defHeight = gviz.geochart.options.DEFAULT_HEIGHT, width = gviz.util.VisCommon.getWidth(container, options, -1), height = gviz.util.VisCommon.getHeight(container, options, -1);
  -1 == width && -1 == height ? (width = defWidth, height = defHeight) : -1 == width ? width = Math.round(height * defWidth / defHeight) : -1 == height && (height = Math.round(width * defHeight / defWidth));
  return new goog.math.Size(width, height);
};
google.visualization.GeoChart.prototype.drawGivenMapId_ = function(dataTable, dataTableFormat, options, optionsSignature, state, mapId) {
  goog.asserts.assert(this.chartSize_);
  var showGeocodeWarnings = options.inferBooleanValue("showGeocodeWarnings");
  if (this.lastDrawnOptionsSignature_ == optionsSignature) {
    goog.log.info(this.logger_, "Updating only the data table..."), this.processTable_(!1, options, dataTable, dataTableFormat, mapId, showGeocodeWarnings, state, optionsSignature);
  } else {
    goog.asserts.assert(this.asyncWrapper_);
    if (goog.isDefAndNotNull(this.drawingFrame_)) {
      this.drawingFrame_.update(this.chartSize_, this.asyncWrapper_);
    } else {
      var forceIFrame = options.inferBooleanValue("forceIFrame");
      this.drawingFrame_ = new gviz.graphics.DrawingFrame(this.container, this.chartSize_, this.asyncWrapper_, forceIFrame);
    }
    this.drawingFrame_.waitUntilReady(goog.bind(function() {
      var renderer = this.drawingFrame_.getRenderer(), overlayArea = this.drawingFrame_.getOverlayArea();
      this.drawGivenRenderer_(dataTable, dataTableFormat, options, optionsSignature, state, mapId, showGeocodeWarnings, overlayArea, renderer);
    }, this), this.asyncWrapper_);
  }
};
google.visualization.GeoChart.prototype.drawGivenRenderer_ = function(dataTable, dataTableFormat, options, optionsSignature, state, mapId, showGeocodeWarnings, overlayArea, renderer) {
  goog.asserts.assert(this.chartSize_);
  goog.asserts.assert(renderer);
  var logicalCanvas = new gviz.geochart.LogicalCanvas(overlayArea, renderer, dataTableFormat);
  goog.isDefAndNotNull(this.activeMap_) && goog.dispose(this.activeMap_);
  var chartSize = this.chartSize_;
  goog.dispose(this.activeMap_);
  this.activeMap_ = new gviz.geochart.ActiveMap(logicalCanvas, options, chartSize.width, chartSize.height, dataTable, dataTableFormat, state, goog.bind(this.dispatchReadyEvent_, this), goog.bind(this.dispatchEvent_, this));
  this.processTable_(!0, options, dataTable, dataTableFormat, mapId, showGeocodeWarnings, state, optionsSignature);
};
google.visualization.GeoChart.prototype.processTable_ = function(loadMap, options, dataTable, dataTableFormat, mapId, showGeocodeWarnings, state, optionsSignature) {
  var geocodingContext = options.inferEnumValue("geocodingContext", gviz.geochart.options.GeocodingContext, gviz.geochart.options.DEFAULT_GEOCODING_CONTEXT), waitForMap = geocodingContext === gviz.geochart.options.GeocodingContext.BOUNDS || geocodingContext === gviz.geochart.options.GeocodingContext.BOTH, callback = this.asyncWrapper_(function(regions, markers, isDone) {
    this.activeMap_.setLocations(regions, markers, isDone, dataTable, state);
  }, this), doProcessTable = goog.bind(function() {
    this.locationProvider_.processTable(dataTable, dataTableFormat, mapId, showGeocodeWarnings, callback);
  }, this);
  this.locationProvider_.setGeocodingContext(geocodingContext);
  loadMap && (this.locationProvider_.clearStaticMap(), gviz.geochart.maploader.loadMap(mapId, this.asyncWrapper_(function(staticMap) {
    goog.isDefAndNotNull(staticMap) ? (this.activeMap_.setStaticMap(staticMap, mapId), waitForMap && (this.locationProvider_.setStaticMap(staticMap), doProcessTable()), this.lastDrawnOptionsSignature_ = optionsSignature) : this.errorHandler.addError("Requested map does not exist.");
  }, this)));
  waitForMap || (this.locationProvider_.clearStaticMap(), doProcessTable());
};
google.visualization.GeoChart.prototype.setSelection = function(selection) {
  goog.isDefAndNotNull(this.activeMap_) ? this.activeMap_.setSelection(selection) : this.errorHandler.addError("The visualization is not ready yet.");
};
google.visualization.GeoChart.prototype.getSelection = function() {
  if (goog.isDefAndNotNull(this.activeMap_)) {
    return this.activeMap_.getSelection();
  }
  this.errorHandler.addError("The visualization is not ready yet.");
  return[];
};
google.visualization.GeoChart.prototype.dispatchReadyEvent_ = function() {
  this.dispatchEvent_(gviz.ChartEventType.READY, {});
};
google.visualization.GeoChart.prototype.dispatchEvent_ = function(eventType, eventData) {
  google.visualization.events.trigger(this, eventType, eventData);
};
google.visualization.GeoChart.prototype.clearInternal = function() {
  this.lastDrawnOptionsSignature_ = "";
  goog.dispose(this.activeMap_);
  this.activeMap_ = null;
  goog.dispose(this.drawingFrame_);
  this.drawingFrame_ = null;
};
google.visualization.GeoChart.NAME_ = "google.visualization.GeoChart";
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/geochart/googleapis_export.js)
goog.exportSymbol("google.visualization.GeoChart", google.visualization.GeoChart);
goog.exportProperty(google.visualization.GeoChart.prototype, "draw", google.visualization.GeoChart.prototype.draw);
goog.exportProperty(google.visualization.GeoChart.prototype, "getImageURI", google.visualization.GeoChart.prototype.getImageURI);
goog.exportProperty(google.visualization.GeoChart.prototype, "setSelection", google.visualization.GeoChart.prototype.setSelection);
goog.exportProperty(google.visualization.GeoChart.prototype, "getSelection", google.visualization.GeoChart.prototype.getSelection);
goog.exportProperty(google.visualization.GeoChart.prototype, "clearChart", google.visualization.GeoChart.prototype.clearChart);
goog.exportSymbol("google.visualization.GeoChart.mapExists", google.visualization.GeoChart.mapExists);
goog.exportSymbol("google.visualization.GeoChart.setMapsSource", google.visualization.GeoChart.setMapsSource);
// INPUT (javascript/closure/fx/easing.js)
goog.fx.easing = {};
goog.fx.easing.easeIn = function(t) {
  return goog.fx.easing.easeInInternal_(t, 3);
};
goog.fx.easing.easeInInternal_ = function(t, exp) {
  return Math.pow(t, exp);
};
goog.fx.easing.easeOut = function(t) {
  return goog.fx.easing.easeOutInternal_(t, 3);
};
goog.fx.easing.easeOutInternal_ = function(t, exp) {
  return 1 - goog.fx.easing.easeInInternal_(1 - t, exp);
};
goog.fx.easing.easeOutLong = function(t) {
  return goog.fx.easing.easeOutInternal_(t, 4);
};
goog.fx.easing.inAndOut = function(t) {
  return 3 * t * t - 2 * t * t * t;
};
// INPUT (javascript/gviz/devel/jsapi/fw/rabl-builder.js)
gviz.fw.RaBlBuilder = function(factory, wrapper, overlayArea, eventHandler, asyncWrapper) {
  this.factory = factory;
  this.renderer = wrapper.rabl();
  this.wrapper_ = wrapper;
  this.layerGroups = null;
  this.layerPrecedence = gviz.fw.RaBlBuilder.DEFAULT_LAYER_PRECEDENCE;
  this.eventHandler = eventHandler;
  this.asyncWrapper = asyncWrapper;
  this.chartRenderer = null;
};
goog.inherits(gviz.fw.RaBlBuilder, gviz.fw.AbstractBuilder);
gviz.fw.RaBlBuilder.prototype.draw = function(definition) {
  this.layerGroups = {};
  var renderer = this.renderer;
  renderer.clear();
  this.chartRenderer = this.factory.createChartRenderer(definition, null);
  this.chartRenderer.getSize();
  for (var i = 0;i < this.layerPrecedence.length;i++) {
    var layerName = this.layerPrecedence[i], group = this.layerGroups[layerName] = new RaBl.RaBl.Shapes.Group;
    this.setEventHandlers(group);
  }
  this.chartRenderer.draw(this);
  this.drawLayers();
  renderer.flushRenderingCommands();
};
gviz.fw.RaBlBuilder.prototype.drawLayers = function() {
  var rabl = this.wrapper_.rabl();
  goog.array.forEach(goog.object.getValues(this.layerGroups), function(group) {
    rabl.drawShape(group);
  }, this);
};
gviz.fw.RaBlBuilder.prototype.setLayerPrecedence = function(layerPrecedence) {
  this.layerPrecedence = layerPrecedence;
};
gviz.fw.RaBlBuilder.prototype.refresh = function(effectsDiff) {
  this.setEffects(effectsDiff.effectsToRemove, !1);
  this.setEffects(effectsDiff.effectsToAdd, !0);
  this.chartRenderer.draw(this);
};
gviz.fw.RaBlBuilder.prototype.setEffects = function(visualEffects, enable) {
  for (var i = 0;i < visualEffects.length;i++) {
    for (var visualEffect = visualEffects[i], targets = visualEffect.targets, j = 0;j < targets.length;j++) {
      var targetId = targets[j];
      this.chartRenderer.setEffect(targetId, visualEffect.effect, enable);
    }
  }
};
gviz.fw.RaBlBuilder.prototype.setEventHandlers = function(shape$$0) {
  var bind2 = function(func, self) {
    return function(arg) {
      func.apply(self, [this, arg]);
    };
  }, oshape = shape$$0;
  oshape.listen("click", bind2(function(shape, arg) {
    this.handleRablEvent_(gviz.fw.interactionEvents.OperationType.CLICK, shape, arg);
  }, this));
  oshape.listen("mousemove", bind2(function(shape, arg) {
    this.handleRablEvent_(gviz.fw.interactionEvents.OperationType.HOVER_IN, shape, arg);
  }, this));
  oshape.listen("mouseleave", bind2(function(shape, arg) {
    this.handleRablEvent_(gviz.fw.interactionEvents.OperationType.HOVER_OUT, shape, arg);
  }, this));
};
gviz.fw.RaBlBuilder.prototype.handleRablEvent_ = function(operationType, target, evt) {
  target = evt.target;
  var targetFeatureIdStr = target.data() && target.data().idStr;
  if (targetFeatureIdStr && targetFeatureIdStr != gviz.graphics.logicalname.DEFAULT_NAME) {
    var targetFeatureId = gviz.fw.FeatureId.parse(targetFeatureIdStr);
    goog.asserts.assert(targetFeatureId);
    this.eventHandler(targetFeatureId, operationType);
  }
};
gviz.fw.RaBlBuilder.prototype.getRenderer = function() {
  return this.wrapper_;
};
gviz.fw.RaBlBuilder.prototype.appendElement = function(element, featureId, layerName) {
  var data = element.data() || {};
  data.idStr = featureId.serialize();
  element.data(data);
  this.layerGroups[layerName].add(element);
};
gviz.fw.RaBlBuilder.prototype.drawElement = function(newElement, oldELement, featureId, layerName) {
  oldELement !== newElement && (oldELement && this.removeElement(oldELement), this.appendElement(newElement, featureId, layerName));
};
gviz.fw.RaBlBuilder.prototype.removeElement = function(element) {
  element && this.renderer.removeShape(element);
};
gviz.fw.RaBlBuilder.prototype.appendShape = function(shape) {
  this.layerGroups[shape.getLayerName()].add(shape.el());
};
gviz.fw.RaBlBuilder.DEFAULT_LAYER_PRECEDENCE = [gviz.fw.render.LayerName.BACKGROUND, gviz.fw.render.LayerName.ROWS, gviz.fw.render.LayerName.ROW_LABELS, gviz.fw.render.LayerName.SELECTED_LABELS, gviz.fw.render.LayerName.FOCUSED_LABELS];
// INPUT (javascript/gviz/devel/jsapi/fw/rabl-visualization.js)
gviz.fw.RaBlVisualization = function(container) {
  gviz.fw.BaseVisualization.call(this, container);
  this.rabl_ = null;
};
goog.inherits(gviz.fw.RaBlVisualization, gviz.fw.BaseVisualization);
gviz.fw.RaBlVisualization.prototype.drawInternal = function(asyncWrapper, dataTable, opt_options) {
  google.visualization.errors.removeAll(this.container);
  var userOptions = opt_options || {}, defaultOptions = this.getDefaultOptions() || {}, options = new gviz.Options([userOptions, defaultOptions]), width = gviz.util.VisCommon.getWidth(this.container, options), height = gviz.util.VisCommon.getHeight(this.container, options), chartSize = new goog.math.Size(width, height);
  this.rabl_ = new RaBl.RaBl(chartSize.width, chartSize.height, "svg", this.container);
  this.rabl_.then(goog.bind(this.completeTheDraw_, this, dataTable, options, chartSize, asyncWrapper));
};
gviz.fw.RaBlVisualization.prototype.completeTheDraw_ = function(dataTable, options, chartSize, asyncWrapper, rabl) {
  this.rabl_ = rabl;
  var chartDefiner = this.getFactory().createDefiner(dataTable, options, goog.memoize(RaBl.RaBl.generateTextMeasureFunction(this.rabl_), function(functionUid, args) {
    var signatureTokens = [functionUid, args[0]];
    signatureTokens.push(JSON.stringify(args[1]));
    var s = signatureTokens.join("_");
    return s;
  }), chartSize), definition = chartDefiner.getDefinition(), wrapper = gviz.fw.RaBlWrapper.wrapRaBl(this.rabl_);
  this.runner_ = this.getFactory().createRunner(wrapper, null, this, options, asyncWrapper);
  var initialState = new gviz.fw.State;
  this.runner_.draw(definition, initialState);
};
gviz.fw.RaBlVisualization.prototype.clearInternal = function() {
  gviz.fw.RaBlVisualization.superClass_.clearInternal.call(this);
};
gviz.fw.RaBlVisualization.prototype.createBuilder = function(wrapper, overlayArea, eventHandler, asyncWrapper) {
  var builder = new gviz.fw.RaBlBuilder(this, wrapper, overlayArea, eventHandler, asyncWrapper), layers = this.defineLayers();
  layers && builder.setLayerPrecedence(layers);
  return builder;
};
gviz.fw.RaBlVisualization.prototype.defineLayers = function() {
};
// INPUT (javascript/gviz/devel/jsapi/jet/jet-assembler.js)
gviz.jet.JetAssembler = function() {
  this.renderedElements_ = new goog.structs.Map;
  this.definition_ = this.size_ = this.renderedStaticElements_ = null;
};
gviz.jet.JetAssembler.prototype.setEffect = function() {
};
gviz.jet.JetAssembler.prototype.setDefinition = function(definition) {
  this.definition_ = definition;
  this.setSize(definition.getSize());
};
gviz.jet.JetAssembler.prototype.setSize = function(size) {
  this.size_ = size;
};
gviz.jet.JetAssembler.prototype.getSize = function() {
  return this.size_;
};
gviz.jet.JetAssembler.prototype.draw = function(helper) {
  var rablHelper = helper, newRenderedElements = new goog.structs.Map;
  goog.array.forEach(this.definition_.getShapes(), function(shape) {
    var serializedId = shape.getFeatureId().serialize();
    this.renderedElements_.containsKey(serializedId) ? shape.el = this.renderedElements_.get(serializedId).el : rablHelper.appendShape(shape);
    newRenderedElements.set(serializedId, shape);
  }, this);
  goog.iter.forEach(this.renderedElements_.getKeyIterator(), function(key) {
    newRenderedElements.containsKey(key);
  }, this);
  this.renderedElements_ = newRenderedElements;
  rablHelper.drawLayers();
};
// INPUT (javascript/gviz/devel/jsapi/jet/jet-viz.js)
gviz.jet.JetViz = function(container) {
  gviz.fw.RaBlVisualization.call(this, container);
};
goog.inherits(gviz.jet.JetViz, gviz.fw.RaBlVisualization);
gviz.jet.JetViz.prototype.createChartRenderer = function(definition) {
  var assembler = new gviz.jet.JetAssembler;
  assembler.setDefinition(definition);
  return assembler;
};
// INPUT (javascript/gviz/devel/jsapi/packages/format/dateformatter.js)
gviz.format.DateFormatter = function() {
  this.getDateFormatObjectMemoized_ = goog.memoize(goog.bind(this.getDateFormatObject_, this));
  this.format = goog.bind(this.getFormattedDate, this);
};
goog.addSingletonGetter(gviz.format.DateFormatter);
gviz.format.DateFormatter.prototype.getFormattedDate = function(formatString, date) {
  return this.getDateFormatObjectMemoized_(formatString).formatValue(date);
};
gviz.format.DateFormatter.prototype.getDateFormatObject_ = function(formatString) {
  return new google.visualization.DateFormat({pattern:formatString, valueType:"time"});
};
// INPUT (javascript/gviz/devel/jsapi/common/axis/tick-labels.js)
gviz.common = {};
gviz.common.axis = {};
gviz.common.axis.TickLabel = function(label, textStyle, opt_textAlign) {
  this.label = label;
  this.textStyle = textStyle;
  this.textAlign = opt_textAlign || null;
};
gviz.common.axis.TickLabel.prototype.getWidth = function(getTextWidth) {
  for (var lines = this.label.split("\n"), ret = 0, i = 0, leni = lines.length;i < leni;i++) {
    ret = Math.max(ret, getTextWidth(lines[i], this.textStyle));
  }
  return ret;
};
// INPUT (javascript/gviz/devel/jsapi/common/axis/horizontal-axis.js)
gviz.common.axis.HorizontalAxis = function(width, startValue, endValue, startX, leftMargin, rightMargin, opt_formatString) {
  this.width_ = width;
  this.startValue = startValue;
  this.endValue = endValue;
  this.leftMargin_ = leftMargin;
  this.rightMargin_ = rightMargin;
  this.dirty_ = !0;
  this.tickLabels_ = [];
  this.startX_ = startX;
  this.startY = null;
  this.granularity = 0;
  this.formatString_ = opt_formatString || null;
  this.tickLines = this.getTickLines_();
  var firstTick = this.tickLines[0].v.valueOf();
  firstTick > this.startValue && (this.tickLines.unshift({v:this.startValue, label:""}), this.tickLabels_.unshift(new gviz.common.axis.TickLabel("", {})));
  this.startValue = Math.min(this.tickLines[0].v.valueOf(), this.startValue);
  var newEnd = this.tickLines[this.tickLines.length - 1].v.valueOf(), oldEnd = this.endValue.valueOf();
  newEnd > oldEnd && (this.endValue = newEnd);
  this.valueToPixelFactor = this.width_ / (this.endValue - this.startValue);
  this.scaledTickLines = [];
  for (var i = 0, leni = this.tickLines.length;i < leni;i++) {
    this.scaledTickLines.push(this.scale(this.tickLines[i].v));
  }
};
gviz.common.axis.HorizontalAxis.prototype.computeBarLeftAndWidth = function(start, end, minWidth, additionalOffset) {
  var left = additionalOffset + (start - this.startValue) * this.valueToPixelFactor, width = (end - start) * this.valueToPixelFactor;
  if (width < minWidth) {
    var shift = (minWidth - width) / 2, width = minWidth, left = left - shift
  }
  return{left:left, width:width};
};
gviz.common.axis.HorizontalAxis.prototype.draw = function(measureFunc, createTextFunc, drawText) {
  if (this.dirty_) {
    if (!goog.isDefAndNotNull(this.startY)) {
      throw "startY must be set before calling draw().";
    }
    this.adjustLabels_(measureFunc);
    for (var axisData = {}, i = 0, leni = this.tickLines.length;i < leni;i++) {
      var tickLine = this.tickLines[i].v, label = this.tickLabels_[i];
      if (!(this.startValue > tickLine) && label.label) {
        for (var tickX = this.scaledTickLines[i], align = label.textAlign || gviz.graphics.TextAlign.CENTER, tickLabelEls = this.createMultilineText_(createTextFunc, label.label, tickX, this.startY + 10, 15, align, gviz.graphics.TextAlign.START, label.textStyle, 15), j = 0, lenj = tickLabelEls.length;j < lenj;j++) {
          drawText(tickLabelEls[j], null, axisData);
        }
      }
    }
    this.dirty_ = !1;
  }
};
gviz.common.axis.HorizontalAxis.prototype.createMultilineText_ = function(createText, text, x, y, width, halign, valign, textStyle, spacing) {
  for (var parts = text.split("\n"), elems = [], i = 0, leni = parts.length;i < leni;i++) {
    elems.push(createText(parts[i], x, y, width, halign, valign, textStyle)), y += spacing;
  }
  return elems;
};
gviz.common.axis.HorizontalAxis.prototype.scale = function(domainVal) {
  return(domainVal - this.startValue) * this.valueToPixelFactor + this.startX_;
};
gviz.common.axis.HorizontalAxis.prototype.adjustLabels_ = function(measure) {
  var lastIndex = this.tickLines.length - 1;
  if (0 !== lastIndex) {
    var first = this.tickLabels_[0], firstLen = first.getWidth(measure), fittedLabels = [new goog.math.Range(this.scaledTickLines[0] - firstLen / 2, this.scaledTickLines[0] + firstLen / 2)], trashed = [];
    this.scaledTickLines[0] - firstLen / 2 < this.startX_ - this.leftMargin_ && (first.textAlign = gviz.graphics.TextAlign.START, fittedLabels[0].start = this.scaledTickLines[0], fittedLabels[0].end = this.scaledTickLines[0] + firstLen);
    var last = this.tickLabels_[lastIndex], lastLen = last.getWidth(measure), endX = this.width_ + this.startX_, lastPlace = new goog.math.Range(this.scaledTickLines[lastIndex] - lastLen / 2, this.scaledTickLines[lastIndex] + lastLen / 2);
    lastLen / 2 + this.scaledTickLines[lastIndex] - this.rightMargin_ > endX && (last.textAlign = gviz.graphics.TextAlign.END, lastPlace.start = this.scaledTickLines[lastIndex] - lastLen, lastPlace.end = this.scaledTickLines[lastIndex]);
    goog.math.Range.hasIntersection(lastPlace, fittedLabels[0]) ? trashed.push(lastIndex) : fittedLabels.push(lastPlace);
    for (var i = 1;i < lastIndex;i++) {
      var label = this.tickLabels_[i], toPlace;
      switch(label.textAlign) {
        case gviz.graphics.TextAlign.START:
          toPlace = new goog.math.Range(this.scaledTickLines[i], this.scaledTickLines[i] + label.getWidth(measure));
          break;
        case gviz.graphics.TextAlign.CENTER:
        ;
        case null:
          toPlace = new goog.math.Range(this.scaledTickLines[i] - label.getWidth(measure) / 2, this.scaledTickLines[i] + label.getWidth(measure) / 2);
          break;
        case gviz.graphics.TextAlign.END:
          toPlace = new goog.math.Range(this.scaledTickLines[i] - label.getWidth(measure), this.scaledTickLines[i]);
          break;
        default:
          throw Error("unknown alignment in tick label.");;
      }
      for (var failed = !1, j = 0, lenj = fittedLabels.length;j < lenj;j++) {
        if (goog.math.Range.hasIntersection(fittedLabels[j], toPlace)) {
          failed = !0;
          break;
        }
      }
      failed ? trashed.push(i) : fittedLabels.push(toPlace);
    }
    j = 0;
    for (lenj = trashed.length;j < lenj;j++) {
      label = this.tickLabels_[trashed[j]], label.label = "";
    }
  }
};
gviz.common.axis.HorizontalAxis.prototype.getTickLines_ = function() {
  var opts = goog.bind(this.DygraphOpts, this), interval = Dygraph.pickDateTickGranularity(this.startValue, this.endValue, this.width_, opts), dygraphTicks = Dygraph.getDateAxis(this.startValue, this.endValue, interval, opts);
  return dygraphTicks;
};
gviz.common.axis.HorizontalAxis.prototype.DygraphOpts = function(opt_name) {
  var me = this, boldNext = !0, baseFormat = gviz.format.DateFormatter.getInstance().format, format = function(formatIn, date) {
    return baseFormat(me.formatString_ || formatIn, date);
  };
  switch(opt_name) {
    case "axisLabelFormatter":
      return function(date, granularity) {
        var bold, formatString, formattedDate;
        me.granularity = granularity;
        if (granularity <= Dygraph.THIRTY_SECONDLY) {
          return formatString = "s", formattedDate = format(formatString, date), me.tickLabels_.push(new gviz.common.axis.TickLabel(formattedDate, {auraColor:"", bold:!1, color:"black", fontName:"Arial", fontSize:13, italic:!1, underline:!1})), me.tickLabels_.length - 1 + "";
        }
        if (granularity <= Dygraph.THIRTY_MINUTELY) {
          formatString = ":mm";
          var minute = date.getMinutes();
          0 === minute || boldNext ? (bold = !0, formatString = "HH:mm") : bold = !1;
          boldNext = !1;
          formattedDate = format(formatString, date);
          me.tickLabels_.push(new gviz.common.axis.TickLabel(formattedDate, {auraColor:"", bold:bold, color:"black", fontName:"Arial", fontSize:13, italic:!1, underline:!1}));
          return me.tickLabels_.length - 1 + "";
        }
        if (granularity <= Dygraph.SIX_HOURLY) {
          formatString = "h";
          var hours = date.getHours();
          0 !== date.getMinutes() && (formatString += ":m");
          bold = 12 === hours || 0 === hours || boldNext;
          boldNext = me.startValue > date.valueOf() ? !0 : !1;
          bold && (formatString += "\n a");
          formattedDate = format(formatString, date);
          me.tickLabels_.push(new gviz.common.axis.TickLabel(formattedDate, {auraColor:"", bold:bold, color:"black", fontName:"Arial", fontSize:13, italic:!1, underline:!1}));
          return me.tickLabels_.length - 1 + "";
        }
        if (granularity <= Dygraph.DAILY) {
          formatString = "E";
          var dayOfWeek = date.getDay();
          0 === dayOfWeek || boldNext ? (formatString += "\n M/d", bold = !0) : bold = !1;
          boldNext = !1;
          formattedDate = format(formatString, date);
          me.tickLabels_.push(new gviz.common.axis.TickLabel(formattedDate, {auraColor:"", bold:bold, color:"black", fontName:"Arial", fontSize:13, italic:!1, underline:!1}));
          return me.tickLabels_.length - 1 + "";
        }
        if (granularity <= Dygraph.WEEKLY) {
          return formatString = "MMM d", bold = boldNext, boldNext = !1, formattedDate = format(formatString, date), me.tickLabels_.push(new gviz.common.axis.TickLabel(formattedDate, {auraColor:"", bold:bold, color:"black", fontName:"Arial", fontSize:13, italic:!1, underline:!1})), me.tickLabels_.length - 1 + "";
        }
        if (granularity <= Dygraph.BIANNUAL) {
          formatString = "MMM";
          var month = date.getMonth();
          bold = 0 === month || boldNext;
          boldNext = me.startValue > date.valueOf() ? !0 : !1;
          bold && (formatString += "\n yyyy");
          formattedDate = format(formatString, date);
          me.tickLabels_.push(new gviz.common.axis.TickLabel(formattedDate, {auraColor:"", bold:bold, color:"black", fontName:"Arial", fontSize:13, italic:!1, underline:!1}));
          return me.tickLabels_.length - 1 + "";
        }
        if (granularity <= Dygraph.CENTENNIAL) {
          return formatString = "yyyy", formattedDate = format(formatString, date), me.tickLabels_.push(new gviz.common.axis.TickLabel(formattedDate, {auraColor:"", bold:!1, color:"black", fontName:"Arial", fontSize:13, italic:!1, underline:!1})), me.tickLabels_.length - 1 + "";
        }
        throw "Unknown granularity.";
      };
    case "pixelsPerLabel":
      return 50;
  }
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/symbols.js)
gviz.math.expression = {};
gviz.math.expression.tokens = {};
gviz.math.expression.tokens.Symbol = {NUMBER:"number", IDENTIFIER:"identifier", EQUALS:"=", PLUS:"+", MINUS:"-", NEGATE:"--", TIMES:"*", OPEN_PAREN:"(", CLOSE_PAREN:")", SEPARATOR_COMMA:",", POWER:"^"};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/token.js)
gviz.math.expression.tokens.Token = function() {
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/expression.js)
gviz.math.expression.Expression = goog.nullFunction;
gviz.math.expression.Expression.prototype.simplify = function() {
  return this;
};
gviz.math.expression.Expression.prototype.isNegative = function() {
  return!1;
};
gviz.math.expression.Expression.prototype.isNumber = function() {
  return!1;
};
// INPUT (javascript/gviz/devel/canviz/axis/pow-10-math.js)
gviz.canviz.axis.Pow10Math = {};
gviz.canviz.axis.Pow10Math.exactScientific = function(significand, exponent) {
  return 0 > exponent ? significand / gviz.canviz.axis.Pow10Math.powerOf(-exponent) : significand * gviz.canviz.axis.Pow10Math.powerOf(exponent);
};
gviz.canviz.axis.Pow10Math.powerOf = function(value) {
  return Math.pow(10, value);
};
gviz.canviz.axis.Pow10Math.exponentOf = function(value) {
  return.4342944819032518 * Math.log(value);
};
gviz.canviz.axis.Pow10Math.isPowerOf10 = function(value) {
  var x = Math.abs(gviz.canviz.axis.Pow10Math.exponentOf(value));
  return 1E-7 > Math.abs(x - Math.round(x));
};
gviz.canviz.axis.Pow10Math.floor = function(value) {
  return gviz.canviz.axis.Pow10Math.exactScientific(1, gviz.canviz.axis.Pow10Math.floorExponent(value));
};
gviz.canviz.axis.Pow10Math.ceil = function(value) {
  return gviz.canviz.axis.Pow10Math.exactScientific(1, gviz.canviz.axis.Pow10Math.ceilExponent(value));
};
gviz.canviz.axis.Pow10Math.round = function(value) {
  var ceiled = gviz.canviz.axis.Pow10Math.exactScientific(1, gviz.canviz.axis.Pow10Math.ceilExponent(value)), floored = ceiled / 10;
  return value - floored < ceiled - value ? floored : ceiled;
};
gviz.canviz.axis.Pow10Math.floorExponent = function(value) {
  return Math.floor(gviz.canviz.axis.Pow10Math.exponentOf(value));
};
gviz.canviz.axis.Pow10Math.ceilExponent = function(value) {
  return Math.ceil(gviz.canviz.axis.Pow10Math.exponentOf(value));
};
gviz.canviz.axis.Pow10Math.roundExponent = function(value) {
  return Math.round(gviz.canviz.axis.Pow10Math.exponentOf(value));
};
// INPUT (javascript/gviz/devel/canviz/value-scale.js)
gviz.canviz.ValueScale = function() {
};
gviz.canviz.ValueScale.prototype.init = function(options, optionsPath, numberOfTicks) {
  this.calibrated = !1;
  this.options_ = options;
  this.optionsPath_ = optionsPath;
  this.numberOfSections = goog.isNull(numberOfTicks) || 0 > numberOfTicks ? this.getDefaultNumberOfSections() : 2 < numberOfTicks ? numberOfTicks - 1 : 1;
  this.ticks = [];
  this.numericMinValue = Infinity;
  this.numericMaxValue = -Infinity;
  this.format = options.inferOptionalStringValue(this.getAbsoluteOptionsPath("format"));
  options.inferValue(this.getAbsoluteOptionsPath("valueFormatter"), function(value, suggestion) {
    return suggestion;
  });
  this.numericPreCalculator_ = null;
};
gviz.canviz.ValueScale.prototype.initPreCalculator = function(distanceToZero, gaps) {
  var scaleType = gviz.NumberScaleUtil.getScaleType(this.options_, this.getAbsoluteOptionsPath(gviz.NumberScaleUtil.LOG_SCALE_OPTIONS_KEY), this.getAbsoluteOptionsPath(gviz.NumberScaleUtil.SCALE_TYPE_OPTIONS_KEY));
  if (!goog.array.isEmpty(gaps) && scaleType != gviz.NumberScaleUtil.SCALE_TYPE.PIECEWISE_LINEAR) {
    throw Error("Non-linear scale with gaps is not supported.");
  }
  for (var numericGaps = [], i = 0;i < gaps.length;i++) {
    var numericGap = this.gapToNumeric_(gaps[i]);
    numericGap && numericGaps.push(numericGap);
  }
  this.numericPreCalculator_ = gviz.NumberScaleUtil.getScale(scaleType, gviz.canviz.axis.Pow10Math.floor(distanceToZero), numericGaps);
};
gviz.canviz.ValueScale.prototype.gapToNumeric_ = function(gap) {
  var gapSize = this.gapValueToNumberInternal(gap.gapValue), start = this.valueToNumberInternal(gap.startValue), end = this.valueToNumberInternal(gap.endValue);
  if (0 < gapSize) {
    if (start + gapSize < end) {
      start += gapSize;
    } else {
      return null;
    }
  }
  return{gapSize:0, start:start, end:end};
};
gviz.canviz.ValueScale.prototype.getAbsoluteOptionsPath = function(property) {
  return gviz.canviz.util.concatSuffix(this.optionsPath_, property);
};
gviz.canviz.ValueScale.prototype.getDefaultNumberOfSections = function() {
  return-1;
};
gviz.canviz.ValueScale.prototype.calibrate = function(minValue, maxValue, shouldExpand) {
  this.calibrated || (shouldExpand && (this.extendRangeToIncludeValue(minValue), this.extendRangeToIncludeValue(maxValue)), this.calibrateMinMax(), this.calibrateInternal(this.numericMinValue, this.numericMaxValue, shouldExpand), this.generateTicks(this.numericMinValue, this.numericMaxValue, shouldExpand), this.createFormatter(), this.numberOfSections = Math.max(1, this.ticks.length - 1), this.calibrated = !0);
};
gviz.canviz.ValueScale.prototype.calibrateMinMax = function() {
  Infinity == this.numericMinValue && -Infinity == this.numericMaxValue && (this.numericMinValue = 0, this.numericMaxValue = 1);
  Infinity == this.numericMinValue && (this.numericMinValue = this.numericMaxValue);
  -Infinity == this.numericMaxValue && (this.numericMaxValue = this.numericMinValue);
  this.numericMinValue == this.numericMaxValue && (0 == this.numericMinValue ? (this.numericMinValue = -1, this.numericMaxValue = 1) : 0 < this.numericMinValue ? (this.numericMinValue /= 2, this.numericMaxValue *= 2) : (this.numericMinValue *= 2, this.numericMaxValue /= 2));
  goog.asserts.assert(Infinity > this.numericMinValue, "numericMinValue is Infinity");
  goog.asserts.assert(-Infinity < this.numericMaxValue, "numericMaxValue is -Infinity");
};
gviz.canviz.ValueScale.prototype.calibrateInternal = function() {
};
gviz.canviz.ValueScale.prototype.setTicks = function(ticks) {
  this.ticks = ticks;
};
gviz.canviz.ValueScale.prototype.getFormatter = function() {
  this.formatter_ || this.createFormatter();
  return this.formatter_;
};
gviz.canviz.ValueScale.prototype.valueToNumber = function(v) {
  var number = this.valueToUnscaledNumber(v);
  if (!goog.isDefAndNotNull(number)) {
    return null;
  }
  var result = this.scaleNumericValue(number);
  return isFinite(result) ? result : null;
};
gviz.canviz.ValueScale.prototype.valueToUnscaledNumber = function(value) {
  return goog.isDefAndNotNull(value) ? this.valueToNumberInternal(value) : null;
};
gviz.canviz.ValueScale.prototype.extendRangeToIncludeNumber = function(num) {
  goog.isDefAndNotNull(num) && (this.numericMinValue = Math.min(this.numericMinValue, num), this.numericMaxValue = Math.max(this.numericMaxValue, num));
};
gviz.canviz.ValueScale.prototype.extendRangeToIncludeValue = function(v) {
  this.extendRangeToIncludeNumber(this.valueToNumber(v));
};
gviz.canviz.ValueScale.prototype.numberToValue = function(value) {
  return this.numberToValueInternal(this.unscaleNumericValue(value));
};
gviz.canviz.ValueScale.prototype.unscaledNumberToValue = function(value) {
  return goog.isDefAndNotNull(value) ? this.numberToValueInternal(value) : null;
};
gviz.canviz.ValueScale.prototype.scaleNumericValue = function(value) {
  goog.asserts.assert(this.numericPreCalculator_);
  return this.numericPreCalculator_.transform(value);
};
gviz.canviz.ValueScale.prototype.unscaleNumericValue = function(value) {
  goog.asserts.assert(this.numericPreCalculator_);
  return this.numericPreCalculator_.inverse(value);
};
gviz.canviz.ValueScale.prototype.compareValues = function(value1, value2) {
  return value1 < value2 ? -1 : value1 > value2 ? 1 : 0;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/renderer/string-renderer.js)
gviz.math.expression.renderer = {};
gviz.math.expression.renderer.StringRenderer = function(opt_numberFormatter) {
  this.formatter = opt_numberFormatter || String;
};
gviz.math.expression.renderer.StringRenderer.renderers = {};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.NUMBER] = function(token, renderer) {
  return renderer.formatter(token.value);
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.IDENTIFIER] = function(token) {
  return token.name;
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.PLUS] = function() {
  return " + ";
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.MINUS] = function() {
  return " - ";
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.NEGATE] = function() {
  return "-";
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.EQUALS] = function() {
  return " = ";
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.TIMES] = function() {
  return " * ";
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.OPEN_PAREN] = function() {
  return "(";
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.CLOSE_PAREN] = function() {
  return ")";
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.SEPARATOR_COMMA] = function() {
  return ", ";
};
gviz.math.expression.renderer.StringRenderer.renderers[gviz.math.expression.tokens.Symbol.POWER] = function() {
  return "^";
};
gviz.math.expression.renderer.StringRenderer.prototype.render = function(tokens) {
  return goog.array.map(tokens, function(token) {
    var symbol = token.getSymbol();
    return gviz.math.expression.renderer.StringRenderer.renderers[symbol](token, this);
  }, this).join("");
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/minus.js)
gviz.math.expression.tokens.Minus = function() {
  gviz.math.expression.tokens.Token.call(this);
};
goog.inherits(gviz.math.expression.tokens.Minus, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.Minus.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.MINUS;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/plus.js)
gviz.math.expression.tokens.Plus = function() {
  gviz.math.expression.tokens.Token.call(this);
};
goog.inherits(gviz.math.expression.tokens.Plus, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.Plus.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.PLUS;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/nary-operator.js)
gviz.math.expression.NaryOperator = function(components) {
  gviz.math.expression.Expression.call(this);
  this.components = components;
};
goog.inherits(gviz.math.expression.NaryOperator, gviz.math.expression.Expression);
gviz.math.expression.NaryOperator.prototype.join = function(token) {
  var joined = [];
  goog.array.forEach(this.components, function(component, index) {
    0 < index && joined.push(token);
    var wrapWithParentheses = !1;
    component instanceof gviz.math.expression.NaryOperator && 1 < component.getComponentCount() && this.getPrecedence() > component.getPrecedence() && (wrapWithParentheses = !0);
    wrapWithParentheses && joined.push(new gviz.math.expression.tokens.OpenParen);
    goog.array.extend(joined, component.compose());
    wrapWithParentheses && joined.push(new gviz.math.expression.tokens.CloseParen);
  }, this);
  return joined;
};
gviz.math.expression.NaryOperator.prototype.simplify = function() {
  if (1 === this.components.length) {
    return this.components[0];
  }
  var components = [];
  goog.array.forEach(this.components, function(component) {
    components.push(component.simplify());
  });
  this.components = components;
  return this;
};
gviz.math.expression.NaryOperator.prototype.getComponent = function(opt_index) {
  var index = opt_index || 0;
  return this.components[index];
};
gviz.math.expression.NaryOperator.prototype.getComponentCount = function() {
  return this.components.length;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/add.js)
gviz.math.expression.Add = function(components) {
  gviz.math.expression.NaryOperator.call(this, components);
};
goog.inherits(gviz.math.expression.Add, gviz.math.expression.NaryOperator);
gviz.math.expression.Add.prototype.getPrecedence = function() {
  return 1;
};
gviz.math.expression.Add.prototype.compose = function() {
  var composed = [];
  goog.array.forEach(this.components, function(component) {
    var isNegative = component.isNegative();
    0 < composed.length && isNegative ? (composed.push(new gviz.math.expression.tokens.Minus), component = (new gviz.math.expression.Neg(component)).simplify()) : 0 < composed.length && composed.push(new gviz.math.expression.tokens.Plus);
    composed = goog.array.concat(composed, component.compose());
  });
  return composed;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/close-paren.js)
gviz.math.expression.tokens.CloseParen = function() {
  gviz.math.expression.tokens.Token.call(this);
};
goog.inherits(gviz.math.expression.tokens.CloseParen, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.CloseParen.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.CLOSE_PAREN;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/identifier.js)
gviz.math.expression.tokens.Identifier = function(name) {
  gviz.math.expression.tokens.Token.call(this);
  this.name = name;
};
goog.inherits(gviz.math.expression.tokens.Identifier, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.Identifier.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.IDENTIFIER;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/open-paren.js)
gviz.math.expression.tokens.OpenParen = function() {
  gviz.math.expression.tokens.Token.call(this);
};
goog.inherits(gviz.math.expression.tokens.OpenParen, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.OpenParen.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.OPEN_PAREN;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/separator-comma.js)
gviz.math.expression.tokens.SeparatorComma = function() {
  gviz.math.expression.tokens.Token.call(this);
};
goog.inherits(gviz.math.expression.tokens.SeparatorComma, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.SeparatorComma.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.SEPARATOR_COMMA;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/call.js)
gviz.math.expression.Call = function(name, args) {
  gviz.math.expression.NaryOperator.call(this, args);
  this.name = name;
};
goog.inherits(gviz.math.expression.Call, gviz.math.expression.NaryOperator);
gviz.math.expression.Call.prototype.simplify = function() {
  return this;
};
gviz.math.expression.Call.prototype.compose = function() {
  var composed = [new gviz.math.expression.tokens.Identifier(this.name), new gviz.math.expression.tokens.OpenParen];
  goog.array.extend(composed, this.join(new gviz.math.expression.tokens.SeparatorComma), [new gviz.math.expression.tokens.CloseParen]);
  return composed;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/equals.js)
gviz.math.expression.tokens.Equals = function() {
  gviz.math.expression.tokens.Token.call(this);
};
goog.inherits(gviz.math.expression.tokens.Equals, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.Equals.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.EQUALS;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/eq.js)
gviz.math.expression.Eq = function(components) {
  gviz.math.expression.NaryOperator.call(this, components);
};
goog.inherits(gviz.math.expression.Eq, gviz.math.expression.NaryOperator);
gviz.math.expression.Eq.prototype.getPrecedence = function() {
  return 0;
};
gviz.math.expression.Eq.prototype.compose = function() {
  return this.join(new gviz.math.expression.tokens.Equals);
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/times.js)
gviz.math.expression.tokens.Times = function() {
  gviz.math.expression.tokens.Token.call(this);
};
goog.inherits(gviz.math.expression.tokens.Times, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.Times.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.TIMES;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/negate.js)
gviz.math.expression.tokens.Negate = function() {
  gviz.math.expression.tokens.Token.call(this);
};
goog.inherits(gviz.math.expression.tokens.Negate, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.Negate.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.NEGATE;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/unary-operator.js)
gviz.math.expression.UnaryOperator = function(component) {
  gviz.math.expression.NaryOperator.call(this, [component]);
};
goog.inherits(gviz.math.expression.UnaryOperator, gviz.math.expression.NaryOperator);
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/neg.js)
gviz.math.expression.Neg = function(component) {
  gviz.math.expression.UnaryOperator.call(this, component);
};
goog.inherits(gviz.math.expression.Neg, gviz.math.expression.UnaryOperator);
gviz.math.expression.Neg.prototype.simplify = function() {
  var r = this.getComponent().simplify();
  if (r.isNegative()) {
    if (r instanceof gviz.math.expression.Neg) {
      return r.getComponent();
    }
    if (r instanceof gviz.math.expression.Number) {
      return new gviz.math.expression.Number(-r.getValue());
    }
    throw Error("Unknown type of negative.");
  }
  return new gviz.math.expression.Neg(r);
};
gviz.math.expression.Neg.prototype.compose = function() {
  return goog.array.concat([new gviz.math.expression.tokens.Negate], this.getComponent().compose());
};
gviz.math.expression.Neg.prototype.isNegative = function() {
  var simplified = this.simplify();
  return simplified instanceof gviz.math.expression.Neg;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/number.js)
gviz.math.expression.tokens.Number = function(number) {
  goog.asserts.assert(goog.isNumber(number));
  this.value = number;
};
goog.inherits(gviz.math.expression.tokens.Number, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.Number.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.NUMBER;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/number.js)
gviz.math.expression.Number = function(value) {
  gviz.math.expression.Expression.call(this);
  goog.asserts.assert(goog.isNumber(value));
  this.value = value;
};
goog.inherits(gviz.math.expression.Number, gviz.math.expression.Expression);
gviz.math.expression.Number.prototype.compose = function() {
  return[new gviz.math.expression.tokens.Number(this.value)];
};
gviz.math.expression.Number.prototype.isNegative = function() {
  return 0 > this.value;
};
gviz.math.expression.Number.prototype.getValue = function() {
  return this.value;
};
gviz.math.expression.Number.prototype.isNumber = function() {
  return!0;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/mul.js)
gviz.math.expression.Mul = function(components, opt_collapseTerms) {
  gviz.math.expression.NaryOperator.call(this, components);
  this.collapseTerms_ = goog.isDefAndNotNull(opt_collapseTerms) ? opt_collapseTerms : !1;
};
goog.inherits(gviz.math.expression.Mul, gviz.math.expression.NaryOperator);
gviz.math.expression.Mul.prototype.getPrecedence = function() {
  return 2;
};
gviz.math.expression.Mul.prototype.simplify = function() {
  gviz.math.expression.Mul.superClass_.simplify.call(this);
  var negCount = 0, newcomponents = [], constant = 1;
  goog.array.forEach(this.components, function(component) {
    component.isNegative() && (component = (new gviz.math.expression.Neg(component)).simplify(), negCount++);
    component.isNumber() && (constant *= component.getValue(), component = null);
    component && newcomponents.push(component);
  });
  1 !== constant && goog.array.splice(newcomponents, 0, 0, new gviz.math.expression.Number(constant));
  var r = new gviz.math.expression.Mul(newcomponents, this.collapseTerms_);
  negCount % 2 && (r = new gviz.math.expression.Neg(r));
  return r;
};
gviz.math.expression.Mul.prototype.compose = function() {
  return this.collapseTerms_ ? goog.array.concat.apply(null, goog.array.map(this.components, function(component) {
    return component.compose();
  })) : this.join(new gviz.math.expression.tokens.Times);
};
gviz.math.expression.Mul.prototype.isNegative = function() {
  var negCount = 0;
  goog.array.forEach(this.components, function(component) {
    component.isNegative() && negCount++;
  });
  return!!(negCount % 2);
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/tokens/power.js)
gviz.math.expression.tokens.Power = function() {
  gviz.math.expression.tokens.Token.call(this);
};
goog.inherits(gviz.math.expression.tokens.Power, gviz.math.expression.tokens.Token);
gviz.math.expression.tokens.Power.prototype.getSymbol = function() {
  return gviz.math.expression.tokens.Symbol.POWER;
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/power.js)
gviz.math.expression.Pow = function(components) {
  gviz.math.expression.NaryOperator.call(this, components);
};
goog.inherits(gviz.math.expression.Pow, gviz.math.expression.NaryOperator);
gviz.math.expression.Pow.prototype.getPrecedence = function() {
  return 3;
};
gviz.math.expression.Pow.prototype.compose = function() {
  return this.join(new gviz.math.expression.tokens.Power);
};
// INPUT (javascript/gviz/devel/canviz/trendlines/data-builder.js)
gviz.canviz.trendlines = {};
gviz.canviz.trendlines.DataBuilder = function(maxgap, yFunction) {
  this.data_ = [];
  this.maxgap_ = maxgap;
  this.yFunction_ = yFunction;
};
gviz.canviz.trendlines.DataBuilder.prototype.addData_ = function(x) {
  this.data_.push([x, this.yFunction_(x)]);
};
gviz.canviz.trendlines.DataBuilder.prototype.addData = function(x) {
  if (0 < this.data_.length) {
    var lastData = this.data_[this.data_.length - 1][0], gap = x - lastData;
    if (gap > this.maxgap_) {
      var insertCount = Math.round(gap / this.maxgap_);
      if (1 < insertCount) {
        for (var i = 1;i < insertCount;i++) {
          this.addData_(i / insertCount * (x - lastData) + lastData);
        }
      }
    }
  }
  this.addData_(x);
};
gviz.canviz.trendlines.DataBuilder.prototype.build = function() {
  return this.data_;
};
// INPUT (javascript/gviz/devel/canviz/trendlines/linear-data-builder.js)
gviz.canviz.trendlines.LinearDataBuilder = function(maxgap, slope, offset) {
  gviz.canviz.trendlines.DataBuilder.call(this, maxgap, function(x) {
    return offset + slope * x;
  });
};
goog.inherits(gviz.canviz.trendlines.LinearDataBuilder, gviz.canviz.trendlines.DataBuilder);
// INPUT (javascript/gviz/devel/canviz/trendlines/linear-regression.js)
gviz.canviz.trendlines.linearRegression = function(size, domainGetter, dataGetter, options) {
  var trendline = gviz.canviz.trendlines.polynomialTrendline(size, domainGetter, dataGetter, {range:options.range, maxGap:options.maxGap, degree:1});
  return goog.isNull(trendline) || isNaN(trendline.r2) ? null : {data:trendline.data, r2:trendline.r2, equation:{offset:trendline.coefficients[0], slope:trendline.coefficients[1]}};
};
// INPUT (javascript/gviz/devel/canviz/trendlines/exponential-trendline.js)
gviz.canviz.trendlines.exponentialTrendline = function(dataSize, domainGetter, dataGetter, options) {
  for (var minimum = Infinity, i$$0 = 0;i$$0 < dataSize;i$$0++) {
    var x = domainGetter(i$$0), y = dataGetter(i$$0);
    null != y && y < minimum && (minimum = y);
  }
  var minimum = 0 < minimum ? null : minimum - 1, trendline = gviz.canviz.trendlines.linearRegression(dataSize, domainGetter, function(i) {
    var value = dataGetter(i);
    if (null == value) {
      return null;
    }
    null != minimum && (value -= minimum);
    return Math.log(value);
  }, options);
  if (goog.isNull(trendline)) {
    return null;
  }
  for (var outdata = [], i$$0 = 0;i$$0 < trendline.data.length;i$$0++) {
    x = trendline.data[i$$0][0], y = Math.exp(trendline.data[i$$0][1]), null != minimum && (y += minimum), outdata.push([x, y]);
  }
  var equation = new gviz.math.expression.Mul([new gviz.math.expression.Number(Math.exp(trendline.equation.offset)), new gviz.math.expression.Pow([new gviz.math.expression.Variable("e"), new gviz.math.expression.Mul([new gviz.math.expression.Number(trendline.equation.slope), new gviz.math.expression.Variable("x")], !0)])], !0);
  goog.isNull(minimum) || (equation = new gviz.math.expression.Add([equation, new gviz.math.expression.Number(minimum)]));
  equation = (new gviz.math.expression.Eq([new gviz.math.expression.Variable("y"), equation])).simplify();
  return{data:outdata, r2:trendline.r2, equation:equation};
};
// INPUT (javascript/gviz/devel/jsapi/common/math/expression/variable.js)
gviz.math.expression.Variable = function(name) {
  gviz.math.expression.Expression.call(this);
  this.name = name;
};
goog.inherits(gviz.math.expression.Variable, gviz.math.expression.Expression);
gviz.math.expression.Variable.prototype.compose = function() {
  return[new gviz.math.expression.tokens.Identifier(this.name)];
};
gviz.math.expression.Variable.prototype.getName = function() {
  return this.name;
};
// INPUT (javascript/gviz/devel/canviz/trendlines/linear-trendline.js)
gviz.canviz.trendlines.linearTrendline = function(dataSize, domainGetter, dataGetter, options) {
  var trendline = gviz.canviz.trendlines.linearRegression(dataSize, domainGetter, dataGetter, options);
  if (goog.isNull(trendline)) {
    return null;
  }
  var equation = new gviz.math.expression.Eq([new gviz.math.expression.Variable("y"), new gviz.math.expression.Add([new gviz.math.expression.Mul([new gviz.math.expression.Number(trendline.equation.slope), new gviz.math.expression.Variable("x")]), new gviz.math.expression.Number(trendline.equation.offset)])]);
  return{data:trendline.data, r2:trendline.r2, equation:equation.simplify()};
};
// INPUT (javascript/gviz/devel/canviz/trendlines/polynomial-trendline-definer.js)
gviz.canviz.trendlines.PolynomialTrendlineDefiner = function(options) {
  this.degree_ = options.degree + 1;
  this.range_ = options.range;
  this.maxGap_ = options.maxGap;
  this.ySum_ = this.gapSum_ = 0;
  this.data_ = [];
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.add = function(x, y) {
  goog.asserts.assert(goog.math.isFiniteNumber(x));
  goog.asserts.assert(goog.math.isFiniteNumber(y));
  if (0 < this.data_.length) {
    var gap = x - this.data_[this.data_.length - 1].x;
    0 < gap && (this.gapSum_ += gap);
  }
  this.ySum_ += y;
  this.data_.push({x:x, y:y});
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.hasValidRangeMin = function() {
  return goog.isDefAndNotNull(this.range_) && goog.isDefAndNotNull(this.range_.min) && goog.math.isFiniteNumber(this.range_.min);
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.hasValidRangeMax = function() {
  return goog.isDefAndNotNull(this.range_) && goog.isDefAndNotNull(this.range_.max) && goog.math.isFiniteNumber(this.range_.max);
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.hasValidRange = function() {
  return goog.isDefAndNotNull(this.range_) && goog.isDefAndNotNull(this.range_.min) && goog.math.isFiniteNumber(this.range_.min) && goog.isDefAndNotNull(this.range_.max) && goog.math.isFiniteNumber(this.range_.max);
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.calculateGapSize_ = function() {
  var gap = this.maxGap_ || this.hasValidRange() && (this.range_.max - this.range_.min) / 100 || void 0;
  goog.isDefAndNotNull(gap) && goog.math.isFiniteNumber(gap) || (gap = this.gapSum_ / (this.data_.length - 1));
  return gap;
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.getMatrixCoefficient_ = function(exponent) {
  return goog.array.reduce(this.data_, function(r, v) {
    return r + Math.pow(v.x, exponent);
  }, 0);
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.getMatrixRHSCoefficient_ = function(exponent) {
  return goog.array.reduce(this.data_, function(r, v) {
    return r + Math.pow(v.x, exponent) * v.y;
  }, 0);
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.getMatrix_ = function() {
  for (var rows = [], degree = this.degree_, matrixRowIndex = 0;matrixRowIndex < degree;matrixRowIndex++) {
    for (var row = Array(degree + 1), matrixColumnIndex = 0;matrixColumnIndex <= degree;matrixColumnIndex++) {
      row[matrixColumnIndex] = matrixColumnIndex < degree ? this.getMatrixCoefficient_(matrixRowIndex + matrixColumnIndex) : this.getMatrixRHSCoefficient_(matrixRowIndex);
    }
    rows.push(row);
  }
  return new goog.math.Matrix(rows);
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.getSolutionCoefficients_ = function() {
  var solutionMatrix = this.getMatrix_().getReducedRowEchelonForm();
  return goog.array.map(goog.array.range(this.degree_), function(d) {
    return solutionMatrix.getValueAt(d, this.degree_);
  }, this);
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.getEvaluationFunction_ = function(coefficients) {
  var degree = this.degree_;
  return function(x) {
    for (var sum = 0, i = 0;i < degree;i++) {
      sum += coefficients[i] * Math.pow(x, i);
    }
    return sum;
  };
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.constructEquation_ = function(coefficients) {
  for (var terms = [], c = coefficients.length - 1;0 <= c;c--) {
    var coefficient = coefficients[c];
    if (goog.isDefAndNotNull(coefficient) && 0 !== coefficient) {
      var term = new gviz.math.expression.Number(coefficient);
      if (0 < c) {
        var variable = new gviz.math.expression.Variable("x");
        1 < c && (variable = new gviz.math.expression.Pow([variable, new gviz.math.expression.Number(c)]));
        term = new gviz.math.expression.Mul([term, variable], !0);
      }
      terms.push(term);
    }
  }
  return new gviz.math.expression.Eq([new gviz.math.expression.Variable("y"), new gviz.math.expression.Add(terms)]);
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.constructTrendlineData_ = function(coefficients) {
  var evaluateEquationAt = this.getEvaluationFunction_(coefficients), gapSize = this.calculateGapSize_();
  if (!goog.isDefAndNotNull(gapSize) || isNaN(gapSize) || !goog.math.isFiniteNumber(gapSize) || 0 === gapSize) {
    return null;
  }
  var dataBuilder = new gviz.canviz.trendlines.DataBuilder(gapSize, evaluateEquationAt), data = this.data_;
  goog.array.sort(data, function(a, b) {
    return a.x > b.x ? 1 : a.x < b.x ? -1 : 0;
  });
  var yMean = this.ySum_ / data.length, range = this.range_;
  this.hasValidRangeMin() && range.min < data[0].x && dataBuilder.addData(range.min);
  for (var ssRes = 0, ssTot = 0, isPerfectTrendline = !0, i = 0;i < data.length;i++) {
    var x = data[i].x, y = data[i].y, trendlineY = evaluateEquationAt(x), isPerfectTrendline = isPerfectTrendline && trendlineY === y;
    dataBuilder.addData(x);
    ssRes += Math.pow(y - trendlineY, 2);
    ssTot += Math.pow(y - yMean, 2);
  }
  var r2 = isPerfectTrendline ? 1 : 1 - ssRes / ssTot;
  this.hasValidRangeMax() && range.max > data[data.length - 1].x && dataBuilder.addData(range.max);
  return{data:dataBuilder.build(), r2:r2};
};
gviz.canviz.trendlines.PolynomialTrendlineDefiner.prototype.getTrendline = function() {
  var coefficients = this.getSolutionCoefficients_(), equation = this.constructEquation_(coefficients), trendline = this.constructTrendlineData_(coefficients);
  return goog.isDefAndNotNull(trendline) && 0 !== trendline.data.length ? {coefficients:coefficients, data:trendline.data, r2:trendline.r2, equation:equation.simplify()} : null;
};
// INPUT (javascript/gviz/devel/canviz/trendlines/polynomial-trendline.js)
gviz.canviz.trendlines.polynomialTrendline = function(dataSize, domainGetter, dataGetter, options) {
  var trendlineDefiner = new gviz.canviz.trendlines.PolynomialTrendlineDefiner(options);
  goog.iter.forEach(goog.iter.range(dataSize), function(i) {
    var x = domainGetter(i), y = dataGetter(i);
    goog.isDefAndNotNull(x) && goog.math.isFiniteNumber(x) && goog.isDefAndNotNull(y) && goog.math.isFiniteNumber(y) && trendlineDefiner.add(x, y);
  });
  return trendlineDefiner.getTrendline();
};
// INPUT (javascript/gviz/devel/canviz/trendlines/trendlines.js)
gviz.canviz.trendlines.TrendlineType = {LINEAR:"linear", EXPONENTIAL:"exponential", POLYNOMIAL:"polynomial"};
gviz.canviz.trendlines.Trendline = {};
gviz.canviz.trendlines.Trendline[gviz.canviz.trendlines.TrendlineType.LINEAR] = gviz.canviz.trendlines.linearTrendline;
gviz.canviz.trendlines.Trendline[gviz.canviz.trendlines.TrendlineType.EXPONENTIAL] = gviz.canviz.trendlines.exponentialTrendline;
gviz.canviz.trendlines.Trendline[gviz.canviz.trendlines.TrendlineType.POLYNOMIAL] = gviz.canviz.trendlines.polynomialTrendline;
// INPUT (javascript/gviz/devel/canviz/options.js)
gviz.canviz.Options = {};
gviz.canviz.Options.ChartType = {NONE:"none", PIE:"pie", FUNCTION:"function", SCATTER:"scatter", BUBBLE:"bubble", HISTOGRAM:"histogram"};
gviz.canviz.Options.SerieType = {NONE:"none", LINE:"line", AREA:"area", STEPPED_AREA:"steppedArea", BARS:"bars", CANDLESTICKS:"candlesticks", SCATTER:"scatter", BUBBLES:"bubbles"};
gviz.canviz.Options.IntervalStyle = {BARS:"bars", STICKS:"sticks", BOXES:"boxes", POINTS:"points", LINE:"line", AREA:"area", NONE:"none"};
gviz.canviz.Options.SeriesRelativeColor = {DARK:"series-color-dark", LIGHT:"series-color-light", COLOR:"series-color"};
gviz.canviz.Options.AxisType = {CATEGORY:"category", VALUE:"value", CATEGORY_POINT:"categorypoint"};
gviz.canviz.Options.ViewWindowMode = {PRETTY:"pretty", MAXIMIZED:"maximized", EXPLICIT:"explicit"};
gviz.canviz.Options.LegendPosition = {NONE:"none", RIGHT:"right", LEFT:"left", TOP:"top", BOTTOM:"bottom", INSIDE:"in", LABELED:"labeled", BOTTOM_VERT:"bottom-vert"};
gviz.canviz.Options.ColorBarPosition = {NONE:"none", TOP:"top", BOTTOM:"bottom", INSIDE:"in"};
gviz.canviz.Options.Orientation = {VERTICAL:"vertical", HORIZONTAL:"horizontal"};
gviz.canviz.Options.Direction = {FORWARD:1, BACKWARD:-1};
gviz.canviz.Options.Alignment = {START:"start", CENTER:"center", END:"end"};
gviz.canviz.Options.InOutPosition = {NONE:"none", INSIDE:"in", OUTSIDE:"out"};
gviz.canviz.Options.BoundUnboundPosition = {BOUND:"bound", UNBOUND:"unbound"};
gviz.canviz.Options.HighLowPosition = {HIGH:"high", LOW:"low"};
gviz.canviz.Options.PieSliceText = {NONE:"none", LABEL:"label", VALUE:"value", PERCENTAGE:"percentage", VALUE_AND_PERCENTAGE:"value-and-percentage"};
gviz.canviz.Options.PieValueText = {BOTH:"both", VALUE:"value", PERCENTAGE:"percentage"};
gviz.canviz.Options.InteractivityModel = {DEFAULT:"default", DIVE:"dive"};
gviz.canviz.Options.FocusTarget = {DATUM:"datum", CATEGORY:"category", SERIES:"series"};
gviz.canviz.Options.AggregationTarget = {AUTO:"auto", CATEGORY:"category", SERIES:"series", NONE:"none"};
gviz.canviz.Options.CurveType = {NONE:"none", FUNCTION:"function", PHASE:"phase", CLOSED_PHASE:"closedPhase"};
gviz.canviz.Options.TextSkipMode = {ATTACH_TO_START:"attachToStart", ATTACH_TO_END:"attachToEnd"};
gviz.canviz.Options.AnnotationStyle = {LETTER:"letter", LINE:"line"};
gviz.canviz.Options.DEFAULT_TRENDLINE_TYPE = gviz.canviz.trendlines.TrendlineType.LINEAR;
gviz.canviz.Options.DEFAULT_DISCRETE_COLORS = [{color:"#3366CC", lighter:"#45AFE2"}, {color:"#DC3912", lighter:"#FF3300"}, {color:"#FF9900", lighter:"#FFCC00"}, {color:"#109618", lighter:"#14C21D"}, {color:"#990099", lighter:"#DF51FD"}, {color:"#0099C6", lighter:"#15CBFF"}, {color:"#DD4477", lighter:"#FF97D2"}, {color:"#66AA00", lighter:"#97FB00"}, {color:"#B82E2E", lighter:"#DB6651"}, {color:"#316395", lighter:"#518BC6"}, {color:"#994499", lighter:"#BD6CBD"}, {color:"#22AA99", lighter:"#35D7C2"}, 
{color:"#AAAA11", lighter:"#E9E91F"}, {color:"#6633CC", lighter:"#9877DD"}, {color:"#E67300", lighter:"#FF8F20"}, {color:"#8B0707", lighter:"#D20B0B"}, {color:"#651067", lighter:"#B61DBA"}, {color:"#329262", lighter:"#40BD7E"}, {color:"#5574A6", lighter:"#6AA7C4"}, {color:"#3B3EAC", lighter:"#6D70CD"}, {color:"#B77322", lighter:"#DA9136"}, {color:"#16D620", lighter:"#2DEA36"}, {color:"#B91383", lighter:"#E81EA6"}, {color:"#F4359E", lighter:"#F558AE"}, {color:"#9C5935", lighter:"#C07145"}, {color:"#A9C413", 
lighter:"#D7EE53"}, {color:"#2A778D", lighter:"#3EA7C6"}, {color:"#668D1C", lighter:"#97D129"}, {color:"#BEA413", lighter:"#E9CA1D"}, {color:"#0C5922", lighter:"#149638"}, {color:"#743411", lighter:"#C5571D"}];
gviz.canviz.Options.DEFAULT_DIFF_NEW_DATA_PREFIX_TEXT = "Current: ";
gviz.canviz.Options.DEFAULT_DIFF_OLD_DATA_PREFIX_TEXT = "Previous: ";
gviz.canviz.Options.DEFAULT_SCATTER_TOOLTIP_X_PREFIX_TEXT = "X";
gviz.canviz.Options.DEFAULT_SCATTER_TOOLTIP_Y_PREFIX_TEXT = "Y";
gviz.canviz.Options.DEFAULT_DIFF_SERIES_BACKGROUND_COLOR = {color:"#EEEEEE", lighter:"#FEFEFE"};
gviz.canviz.Options.DEFAULT_DIFF_OLD_DATA_OPACITY = .5;
gviz.canviz.Options.DEFAULT_DIFF_NEW_DATA_OPACITY = 1;
gviz.canviz.Options.DEFAULT_DIFF_NEW_DATA_WIDTH_FACTOR = .3;
gviz.canviz.Options.DEFAULT_PIE_DIFF_INNER_OUTER_RADIUS_RATIO = .6;
gviz.canviz.Options.DEFAULT_PIE_DIFF_INNER_BORDER_RATIO = .01;
gviz.canviz.Options.DEFAULT_PIE_DIFF_IS_OLD_DATA_IN_CENTER = !0;
gviz.canviz.Options.DEFAULT_DIFF_LEGEND_ICON_WIDTH_SCALE_FACTOR = 2;
gviz.canviz.Options.LEGEND_ICON_WIDTH_SCALE_FACTOR_MIN = 1;
gviz.canviz.Options.LEGEND_ICON_WIDTH_SCALE_FACTOR_MAX = 2;
gviz.canviz.Options.DEFAULT_LINE_WIDTH = 2;
gviz.canviz.Options.DEFAULT_POINT_SIZE_FOR_SCATTER = 7;
gviz.canviz.Options.DEFAULT_POINT_SIZE_FOR_LINE = 6;
gviz.canviz.Options.DEFAULT_POINT_SENSITIVITY_AREA_RADIUS = 12;
gviz.canviz.Options.DEFAULT_FONT_SIZE = 13;
gviz.canviz.Options.DEFAULT_LOG_MINOR_TICK_ALTERNATIVES = [[5], [2, 5], [2, 5], [2, 4, 6, 8], [2, 4, 6, 8], [2, 3, 4, 5, 6, 7], [2, 3, 4, 5, 6, 7, 8], [2, 3, 4, 5, 6, 7, 8, 9]];
gviz.canviz.Options.DEFAULT_DATE_TICKS_MAJOR = {milliseconds:{format:["h:mm:ss.SSS a"], interval:[1, 5, 10, 50, 100, 200, 500]}, seconds:{format:["h:mm:ss a"], interval:[1, 5, 10, 15, 30]}, minutes:{format:["h:mm a"], interval:[1, 2, 5, 15, 30]}, hours:{format:["h a"], interval:[1, 2, 6, 12]}, days:{format:["MMM d", "d"], interval:[1, 2, 7]}, months:{format:["MMM y", "MMM yy", "MMM"], interval:[1, 3, 6]}, years:{format:["y"], interval:[1, 2, 5, 10, 20, 50, 100, 200, 500, 1E3]}};
gviz.canviz.Options.DEFAULT_DATE_TICKS_MINOR = {milliseconds:{format:[".SSS"], interval:[50, 100, 200, 500]}, seconds:{format:[":ss"], interval:[1, 5, 10, 15]}, minutes:{format:[":mm"], interval:[1, 2, 5, 15]}, hours:{format:["h a"], interval:[1, 2, 6]}, days:{format:["d"], interval:[1, 7]}, months:{format:["MMM", "MM", "MMMMM"], interval:[1, 3]}, years:{format:["y"], interval:[1, 2, 5, 10, 20, 50, 100, 200, 500, 1E3]}};
gviz.canviz.Options.DEFAULT_AXIS_OPTIONS = {titleTextStyle:{color:"#222222", italic:!0}, gridlines:{baseline:"auto", minorTextOpacity:.7, minorGridlineOpacity:.4, newTimeline:!1, allowMinor:!0, minStrongLineDistance:40, minWeakLineDistance:40, minStrongToWeakLineDistance:5, minNotchDistance:10, minMajorTextDistance:10, minMinorTextDistance:5, unitThreshold:1.5, units:gviz.canviz.Options.DEFAULT_DATE_TICKS_MAJOR}, minorGridlines:{units:gviz.canviz.Options.DEFAULT_DATE_TICKS_MINOR}};
gviz.canviz.Options.CHART_SPECIFIC_DEFAULTS = {histogram:{hAxis:{baselineColor:"none", gridlines:{color:"none"}}, bar:{groupWidth:"100%"}}};
gviz.canviz.Options.DEFAULTS = {vAxis:gviz.canviz.Options.DEFAULT_AXIS_OPTIONS, hAxis:gviz.canviz.Options.DEFAULT_AXIS_OPTIONS, sizeAxis:{minSize:5, maxSize:30}, fontName:"Arial", titleTextStyle:{color:"#000000", bold:!0}, bubble:{textStyle:{color:"#000000"}}, candlestick:{hollowIsRising:!1}, annotations:{datum:{textStyle:{color:gviz.canviz.Options.SeriesRelativeColor.COLOR}, stemColor:"#999999"}, domain:{textStyle:{color:"#222222"}, stemColor:"#999999"}}, majorAxisTextColor:"#222222", minorAxisTextColor:"#444444", 
backgroundColor:{fill:"#fff", stroke:"#666666", strokeWidth:0}, chartArea:{backgroundColor:{fill:"none"}}, tooltip:{textStyle:{color:"#000000"}}, baselineColor:"#333333", gridlineColor:"#cccccc", pieSliceBorderColor:"#ffffff", pieResidueSliceColor:"#cccccc", pieSliceTextStyle:{color:"#ffffff"}, areaOpacity:.3, intervals:{style:gviz.canviz.Options.IntervalStyle.BARS, color:gviz.canviz.Options.SeriesRelativeColor.DARK, lineWidth:gviz.canviz.Options.DEFAULT_LINE_WIDTH / 2, fillOpacity:.3, barWidth:.25, 
shortBarWidth:.1, boxWidth:.25, dataOpacity:1, pointSize:gviz.canviz.Options.DEFAULT_POINT_SIZE_FOR_LINE}, actionsMenu:{textStyle:{color:"#000000"}, disabledTextStyle:{color:"#c0c0c0"}}, legend:{newLegend:!1, textStyle:{color:"#222222"}, pagingTextStyle:{color:"#0011cc"}, scrollArrows:{activeColor:"#0011cc", inactiveColor:"#cccccc"}}, aggregationTarget:gviz.canviz.Options.AggregationTarget.AUTO, colorAxis:{legend:{textStyle:{color:"#000000"}}}, bar:{groupWidth:100 / gviz.canviz.Constants.GOLDEN_RATIO + 
"%"}, histogram:{lastBucketPercentile:0, hideBucketItems:!1, bucketSize:-1, minNumBuckets:5, maxNumBuckets:50}};
// INPUT (javascript/gviz/devel/jsapi/common/animation.js)
gviz.animation = {};
gviz.animation.EasingType = {LINEAR:"linear", IN:"in", OUT:"out", IN_AND_OUT:"inAndOut"};
gviz.animation.getEasingFunction_ = function(easingType) {
  switch(easingType) {
    case gviz.animation.EasingType.LINEAR:
      return goog.functions.identity;
    case gviz.animation.EasingType.IN:
      return goog.fx.easing.easeIn;
    case gviz.animation.EasingType.OUT:
      return goog.fx.easing.easeOut;
    case gviz.animation.EasingType.IN_AND_OUT:
      return goog.fx.easing.inAndOut;
    default:
      return goog.asserts.fail('Invalid easing type "' + easingType + '"'), goog.functions.identity;
  }
};
gviz.animation.getProperties = function(options, defaultDuration, defaultMaxFramesPerSecond, defaultEasingType) {
  var duration = options.inferNonNegativeNumberValue("animation.duration", defaultDuration);
  if (!duration) {
    return null;
  }
  var maxFramesPerSecond = options.inferNonNegativeNumberValue("animation.maxFramesPerSecond", defaultMaxFramesPerSecond), easingType = options.inferEnumValue("animation.easing", gviz.animation.EasingType, defaultEasingType), easingFunction = gviz.animation.getEasingFunction_(easingType);
  return{duration:duration, easing:easingFunction, maxFramesPerSecond:maxFramesPerSecond};
};
// INPUT (javascript/closure/dom/classes.js)
goog.dom.classes = {};
goog.dom.classes.set = function(element, className) {
  element.className = className;
};
goog.dom.classes.get = function(element) {
  var className = element.className;
  return goog.isString(className) && className.match(/\S+/g) || [];
};
goog.dom.classes.add = function(element, var_args) {
  var classes = goog.dom.classes.get(element), args = goog.array.slice(arguments, 1), expectedCount = classes.length + args.length;
  goog.dom.classes.add_(classes, args);
  goog.dom.classes.set(element, classes.join(" "));
  return classes.length == expectedCount;
};
goog.dom.classes.remove = function(element, var_args) {
  var classes = goog.dom.classes.get(element), args = goog.array.slice(arguments, 1), newClasses = goog.dom.classes.getDifference_(classes, args);
  goog.dom.classes.set(element, newClasses.join(" "));
  return newClasses.length == classes.length - args.length;
};
goog.dom.classes.add_ = function(classes, args) {
  for (var i = 0;i < args.length;i++) {
    goog.array.contains(classes, args[i]) || classes.push(args[i]);
  }
};
goog.dom.classes.getDifference_ = function(arr1, arr2) {
  return goog.array.filter(arr1, function(item) {
    return!goog.array.contains(arr2, item);
  });
};
goog.dom.classes.swap = function(element, fromClass, toClass) {
  for (var classes = goog.dom.classes.get(element), removed = !1, i = 0;i < classes.length;i++) {
    classes[i] == fromClass && (goog.array.splice(classes, i--, 1), removed = !0);
  }
  removed && (classes.push(toClass), goog.dom.classes.set(element, classes.join(" ")));
  return removed;
};
goog.dom.classes.addRemove = function(element, classesToRemove, classesToAdd) {
  var classes = goog.dom.classes.get(element);
  goog.isString(classesToRemove) ? goog.array.remove(classes, classesToRemove) : goog.isArray(classesToRemove) && (classes = goog.dom.classes.getDifference_(classes, classesToRemove));
  goog.isString(classesToAdd) && !goog.array.contains(classes, classesToAdd) ? classes.push(classesToAdd) : goog.isArray(classesToAdd) && goog.dom.classes.add_(classes, classesToAdd);
  goog.dom.classes.set(element, classes.join(" "));
};
goog.dom.classes.has = function(element, className) {
  return goog.array.contains(goog.dom.classes.get(element), className);
};
goog.dom.classes.enable = function(element, className, enabled) {
  enabled ? goog.dom.classes.add(element, className) : goog.dom.classes.remove(element, className);
};
goog.dom.classes.toggle = function(element, className) {
  var add = !goog.dom.classes.has(element, className);
  goog.dom.classes.enable(element, className, add);
  return add;
};
// INPUT (javascript/closure/ui/flatbuttonrenderer.js)
goog.ui.FlatButtonRenderer = function() {
};
goog.inherits(goog.ui.FlatButtonRenderer, goog.ui.ButtonRenderer);
goog.addSingletonGetter(goog.ui.FlatButtonRenderer);
goog.ui.FlatButtonRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-flat-button";
goog.ui.FlatButtonRenderer.prototype.createDom = function(button) {
  var classNames = this.getClassNames(button), attributes = {"class":goog.ui.INLINE_BLOCK_CLASSNAME + " " + classNames.join(" ")}, element = button.getDomHelper().createDom("div", attributes, button.getContent());
  this.setTooltip(element, button.getTooltip());
  this.setAriaStates(button, element);
  return element;
};
goog.ui.FlatButtonRenderer.prototype.getAriaRole = function() {
  return goog.a11y.aria.Role.BUTTON;
};
goog.ui.FlatButtonRenderer.prototype.canDecorate = function(element) {
  return "DIV" == element.tagName;
};
goog.ui.FlatButtonRenderer.prototype.decorate = function(button, element) {
  goog.asserts.assert(element);
  goog.dom.classlist.add(element, goog.ui.INLINE_BLOCK_CLASSNAME);
  return goog.ui.FlatButtonRenderer.superClass_.decorate.call(this, button, element);
};
goog.ui.FlatButtonRenderer.prototype.getValue = function() {
  return "";
};
goog.ui.FlatButtonRenderer.prototype.getCssClass = function() {
  return goog.ui.FlatButtonRenderer.CSS_CLASS;
};
goog.ui.registry.setDecoratorByClassName(goog.ui.FlatButtonRenderer.CSS_CLASS, function() {
  return new goog.ui.Button(null, goog.ui.FlatButtonRenderer.getInstance());
});
// INPUT (javascript/closure/ui/linkbuttonrenderer.js)
goog.ui.LinkButtonRenderer = function() {
};
goog.inherits(goog.ui.LinkButtonRenderer, goog.ui.FlatButtonRenderer);
goog.addSingletonGetter(goog.ui.LinkButtonRenderer);
goog.ui.LinkButtonRenderer.CSS_CLASS = "aAAaGVIZSENTINELaAAa-link-button";
goog.ui.LinkButtonRenderer.prototype.getCssClass = function() {
  return goog.ui.LinkButtonRenderer.CSS_CLASS;
};
goog.ui.registry.setDecoratorByClassName(goog.ui.LinkButtonRenderer.CSS_CLASS, function() {
  return new goog.ui.Button(null, goog.ui.LinkButtonRenderer.getInstance());
});
// INPUT (javascript/gviz/devel/canviz/legend/labeled-legend-definition.js)
gviz.canviz.legend = {};
gviz.canviz.legend.LabeledLegendDefinition = {};
// INPUT (javascript/gviz/devel/canviz/color-bar-definition.js)
// INPUT (javascript/gviz/devel/canviz/legend-definition.js)
gviz.canviz.LegendDefinition = {};
// INPUT (javascript/gviz/devel/canviz/timeutil.js)
gviz.canviz.timeutil = {};
gviz.canviz.timeutil.floorDate = function(date, unit) {
  return gviz.canviz.timeutil.roundDateInternal_(date, unit, 0);
};
gviz.canviz.timeutil.ceilDate = function(date, unit) {
  return gviz.canviz.timeutil.roundDateInternal_(date, unit, 1);
};
gviz.canviz.timeutil.roundDateInternal_ = function(date, unit, direction) {
  for (var newDate = new Date(date.getTime()), carry = !1, unitLength = unit.length, roundingFunction = [Math.floor, Math.ceil][direction], i = 0;i < unitLength;++i) {
    var getter = date["get" + gviz.canviz.timeutil.dateMethodNames_[i]], setter = date["set" + gviz.canviz.timeutil.dateMethodNames_[i]], dateDigit = getter.apply(date), unitDigit = unit[i], zeroDigit = gviz.canviz.timeutil.durationZeros_[i];
    if (0 == unitDigit) {
      carry = carry || 0 != dateDigit && 0 != direction, setter.apply(newDate, [zeroDigit]);
    } else {
      carry ? setter.apply(newDate, [zeroDigit + unitDigit * (1 + Math.floor((dateDigit - zeroDigit) / unitDigit))]) : setter.apply(newDate, [zeroDigit + unitDigit * roundingFunction((dateDigit - zeroDigit) / unitDigit)]);
      break;
    }
  }
  return newDate;
};
gviz.canviz.timeutil.floorDuration = function(duration, unit) {
  return gviz.canviz.timeutil.roundDurationInternal_(duration, unit, Math.floor);
};
gviz.canviz.timeutil.ceilDuration = function(duration, unit) {
  return gviz.canviz.timeutil.roundDurationInternal_(duration, unit, Math.ceil);
};
gviz.canviz.timeutil.roundDuration = function(duration, unit) {
  return gviz.canviz.timeutil.roundDurationInternal_(duration, unit, Math.round);
};
gviz.canviz.timeutil.roundDurationInternal_ = function(duration, unit, func) {
  var newduration = goog.array.clone(duration), i;
  for (i = 0;i < newduration.length && 0 == unit[i];++i) {
    newduration[i] = 0;
  }
  goog.asserts.assert(i != newduration.length);
  if (0 == i) {
    return newduration[0] = func(duration[0] / unit[0]) * unit[0], newduration;
  }
  var fraction = 0;
  duration[i - 1] >= gviz.canviz.timeutil.durationHalfs_[i - 1] ? fraction = .7 : 0 < duration[i - 1] && (fraction = .1);
  newduration[i] = func((duration[i] + fraction) / unit[i]) * unit[i];
  return newduration;
};
gviz.canviz.timeutil.floorDateToMonday = function(date) {
  date = gviz.canviz.timeutil.floorDate(date, [0, 0, 0, 0, 1]);
  var numDays = (7 + date.getDay() - 1) % 7;
  return date = gviz.canviz.timeutil.subtractDuration(date, [0, 0, 0, 0, numDays]);
};
gviz.canviz.timeutil.roundMillisAccordingToTable = function(millis, durationTable, opt_numOfRepeatingSubIntervals) {
  var logTable = goog.array.map(durationTable, function(v) {
    return[Math.log(gviz.canviz.timeutil.durationAsMillis(v))];
  });
  if (!opt_numOfRepeatingSubIntervals) {
    var index = gviz.canviz.util.closestValueTo(Math.log(millis), logTable);
    return durationTable[index];
  }
  var roundIndexValueTuple = gviz.canviz.util.extrapolatedClosestValueTo(Math.log(millis), logTable, opt_numOfRepeatingSubIntervals), index = roundIndexValueTuple[0];
  if (index <= logTable.length - 1) {
    return durationTable[index];
  }
  var logMillis = roundIndexValueTuple[1], largestUnitInTable = goog.array.peek(durationTable);
  return gviz.canviz.timeutil.roundDuration(gviz.canviz.timeutil.millisAsDuration(Math.exp(logMillis)), largestUnitInTable);
};
gviz.canviz.timeutil.addDuration = function(date, duration) {
  return gviz.canviz.timeutil.addDuration_(date, duration, 1);
};
gviz.canviz.timeutil.subtractDuration = function(date, duration) {
  return gviz.canviz.timeutil.addDuration_(date, duration, -1);
};
gviz.canviz.timeutil.addDuration_ = function(date, duration, factor) {
  var newDate = new Date(date.getTime());
  if (gviz.canviz.timeutil.isDurationZero(duration)) {
    return newDate;
  }
  for (var i = 0;i < duration.length;++i) {
    if (0 != duration[i]) {
      var methodName = gviz.canviz.timeutil.dateMethodNames_[i], setter = newDate["set" + methodName], getter = newDate["get" + methodName], value = getter.apply(newDate, []);
      setter.apply(newDate, [value + factor * duration[i]]);
    }
  }
  return newDate;
};
gviz.canviz.timeutil.DateRangeIter = function(startDate, endDate, unit, quantity) {
  this.startMs_ = startDate.getTime();
  this.endDate_ = endDate;
  this.quantity_ = quantity;
  var getter = startDate["get" + gviz.canviz.timeutil.dateMethodNames_[unit]];
  this.unitValue_ = getter.apply(startDate, []);
  this.setter_ = startDate["set" + gviz.canviz.timeutil.dateMethodNames_[unit]];
  this.next_ = new Date(this.startMs_);
};
gviz.canviz.timeutil.DateRangeIter.prototype.hasNext = function() {
  return this.next_ < this.endDate_;
};
gviz.canviz.timeutil.DateRangeIter.prototype.next = function() {
  goog.asserts.assert(this.hasNext());
  var ret = this.next_;
  this.next_ = new Date(this.startMs_);
  this.unitValue_ += this.quantity_;
  this.setter_.apply(this.next_, [this.unitValue_]);
  return ret;
};
gviz.canviz.timeutil.DateRangeIter.prototype.peek = function() {
  return this.hasNext() ? this.next_ : null;
};
gviz.canviz.timeutil.isDurationZero = function(duration) {
  for (var i = 0;i < duration.length;++i) {
    if (0 != duration[i]) {
      return!1;
    }
  }
  return!0;
};
gviz.canviz.timeutil.parseDuration = function(text) {
  var result = [0, 0, 0, 0, 0, 0, 0];
  if (null == text.match(gviz.canviz.timeutil.durationRegularExpression_)) {
    return null;
  }
  var letters = text.match(/(\d+[YMDHS]|[PT])/g);
  if (null == letters) {
    return null;
  }
  for (var length = letters.length, dso_index = 0, dso = gviz.canviz.timeutil.durationSymbolOrder_, dso_length = dso.length, i = 0;i < length;++i) {
    var letter = letters[i].match(/[YMDHSPT]/);
    if (null == letter) {
      return null;
    }
    for (var letter = letter[0], number = letters[i].match(/\d+/g), number = number && number[0] || 0;dso[dso_index][0] != letter && dso_index < dso_length;) {
      "P" != dso[dso_index][0] && "T" != dso[dso_index][0] && (result[dso[dso_index][2]] = 0), dso_index += 1;
    }
    if (dso_index < dso_length && null != number) {
      result[dso[dso_index][2]] = number && parseInt(number, 10), dso_index += 1;
    } else {
      return null;
    }
  }
  if (i < length) {
    return null;
  }
  for (;dso_index < dso_length;) {
    "P" != dso[dso_index][0] && "T" != dso[dso_index][0] && (result[dso[dso_index][2]] = 0), dso_index += 1;
  }
  return result;
};
gviz.canviz.timeutil.formatDuration = function(duration) {
  var withT = !(0 != duration[2] && 0 != duration[5]) && !(0 == duration[2] && 0 == duration[5]), l = goog.array.findIndex(duration, function(v) {
    return 0 != v;
  }), r = goog.array.findIndexRight(duration, function(v) {
    return 0 != v;
  });
  if (r < l) {
    return "0";
  }
  var builtString = [];
  withT && 3 > r && builtString.push("T");
  for (var i = r;i >= l;--i) {
    withT && 3 == i && builtString.push("T"), 0 != duration[i] && (builtString.push(duration[i]), builtString.push("#SMHDMY".charAt(i)));
  }
  withT && 3 < l && builtString.push("T");
  return builtString.join("");
};
gviz.canviz.timeutil.durationGranularity = function(duration) {
  var n = goog.array.findIndex(duration, function(v) {
    return 0 != v;
  });
  return Math.max(0, n);
};
gviz.canviz.timeutil.durationStringAsMillis = function(durationString) {
  return gviz.canviz.timeutil.durationAsMillis(gviz.canviz.timeutil.parseDuration(durationString));
};
gviz.canviz.timeutil.millisAsDurationString = function(millis) {
  return gviz.canviz.timeutil.formatDuration(gviz.canviz.timeutil.millisAsDuration(millis));
};
gviz.canviz.timeutil.durationAsMillis = function(duration) {
  if (null == duration) {
    return-1;
  }
  for (var millis = 0, l = duration.length, i = 0;i < l;++i) {
    millis += duration[i] * gviz.canviz.timeutil.durationCoefficients_[i];
  }
  return millis;
};
gviz.canviz.timeutil.millisAsDuration = function(millis) {
  for (var result = [], i = gviz.canviz.timeutil.durationCoefficients_.length - 1;0 <= i;i--) {
    result[i] = Math.floor(millis / gviz.canviz.timeutil.durationCoefficients_[i]), millis -= result[i] * gviz.canviz.timeutil.durationCoefficients_[i];
  }
  return result;
};
gviz.canviz.timeutil.timeOfDayAsMillis = function(timeofday) {
  var duration = gviz.canviz.timeutil.timeOfDayAsDuration(timeofday);
  return gviz.canviz.timeutil.durationAsMillis(duration);
};
gviz.canviz.timeutil.millisAsTimeOfDay = function(millis) {
  var duration = gviz.canviz.timeutil.millisAsDuration(millis), timeofday = duration.reverse();
  return timeofday;
};
gviz.canviz.timeutil.timeOfDayAsDuration = function(timeofday) {
  timeofday = 4 > timeofday.length ? goog.array.concat(timeofday, goog.array.repeat(0, 4 - timeofday.length)) : goog.array.clone(timeofday);
  return timeofday.reverse();
};
gviz.canviz.timeutil.timeOfDayAsDate = function(timeofday) {
  var duration = gviz.canviz.timeutil.timeOfDayAsDuration(timeofday);
  return gviz.canviz.timeutil.durationAsDate(duration);
};
gviz.canviz.timeutil.dateAsDuration = function(date) {
  return[date.getMilliseconds(), date.getSeconds(), date.getMinutes(), date.getHours(), date.getDate() - 1, date.getMonth(), date.getFullYear() - 1970];
};
gviz.canviz.timeutil.durationAsDate = function(duration) {
  var date = new Date(1970, 0, 1, 0, 0, 0, 0);
  date.setFullYear((duration[6] || 0) + 1970);
  date.setMonth(duration[5] || 0);
  date.setDate((duration[4] || 0) + 1);
  date.setHours(duration[3] || 0);
  date.setMinutes(duration[2] || 0);
  date.setSeconds(duration[1] || 0);
  date.setMilliseconds(duration[0] || 0);
  return date;
};
gviz.canviz.timeutil.smallerUnit = function(inputUnit) {
  if (inputUnit[0]) {
    return[1];
  }
  for (var unit = [], i = 1;i < inputUnit.length;++i) {
    if (inputUnit[i]) {
      return unit.push(1), unit;
    }
    unit.push(0);
  }
  unit.push(1);
  return unit;
};
gviz.canviz.timeutil.multiplyDuration = function(duration, multiplier) {
  return goog.array.map(duration, function(x) {
    return x * multiplier;
  });
};
gviz.canviz.timeutil.dateMethodNames_ = "Milliseconds Seconds Minutes Hours Date Month FullYear".split(" ");
gviz.canviz.timeutil.TimeUnit = {MILLISECONDS:"milliseconds", SECONDS:"seconds", MINUTES:"minutes", HOURS:"hours", DAYS:"days", MONTHS:"months", YEARS:"years"};
gviz.canviz.timeutil.timeUnitOrder = [gviz.canviz.timeutil.TimeUnit.MILLISECONDS, gviz.canviz.timeutil.TimeUnit.SECONDS, gviz.canviz.timeutil.TimeUnit.MINUTES, gviz.canviz.timeutil.TimeUnit.HOURS, gviz.canviz.timeutil.TimeUnit.DAYS, gviz.canviz.timeutil.TimeUnit.MONTHS, gviz.canviz.timeutil.TimeUnit.YEARS];
gviz.canviz.timeutil.timeUnitIndex = {};
goog.array.forEach(gviz.canviz.timeutil.timeUnitOrder, function(unit, index) {
  gviz.canviz.timeutil.timeUnitIndex[unit] = index;
});
gviz.canviz.timeutil.timeUnitDurations = [[1], [0, 1], [0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1]];
gviz.canviz.timeutil.durationZeros_ = [0, 0, 0, 0, 1, 0, 0];
gviz.canviz.timeutil.durationHalfs_ = [500, 30, 30, 12, 15, 6, 0];
gviz.canviz.timeutil.durationCoefficients_ = [1, 1E3, 6E4, 36E5, 864E5, 2629743830, 31556926E3];
gviz.canviz.timeutil.durationRegularExpression_ = /^P?(\d+[YMDHMS])*T?(\d+[YMDHMS])*$/;
gviz.canviz.timeutil.durationSymbolOrder_ = [["P", "prefix", -1], ["Y", "years", 6], ["M", "months", 5], ["D", "days", 4], ["T", "delimiter", -1], ["H", "hours", 3], ["M", "minutes", 2], ["S", "seconds", 1]];
// INPUT (javascript/gviz/devel/canviz/value-number-converter.js)
gviz.canviz.valuenumberconverter = {};
gviz.canviz.valuenumberconverter.getByType = function(type) {
  switch(type) {
    case "date":
    ;
    case "datetime":
      return{toNumber:gviz.canviz.valuenumberconverter.dateToNumber, fromNumber:gviz.canviz.valuenumberconverter.dateFromNumber};
    case "timeofday":
      return{toNumber:gviz.canviz.valuenumberconverter.timeOfDayToNumber, fromNumber:gviz.canviz.valuenumberconverter.timeOfDayFromNumber};
    case "number":
    ;
    case "string":
      return{toNumber:gviz.canviz.valuenumberconverter.numberToNumber, fromNumber:gviz.canviz.valuenumberconverter.numberFromNumber};
    default:
      return goog.asserts.fail("invalid type passed to valuenumberconverter.getByType"), {toNumber:gviz.canviz.valuenumberconverter.numberToNumber, fromNumber:gviz.canviz.valuenumberconverter.numberFromNumber};
  }
};
gviz.canviz.valuenumberconverter.numberToNumber = function(v) {
  goog.asserts.assert(goog.isNumber(v) || goog.isString(v) && !isNaN(v));
  return Number(v);
};
gviz.canviz.valuenumberconverter.numberFromNumber = function(n) {
  return n;
};
gviz.canviz.valuenumberconverter.dateToNumber = function(v) {
  goog.asserts.assert(goog.isDateLike(v));
  return v.getTime();
};
gviz.canviz.valuenumberconverter.dateFromNumber = function(n) {
  return new Date(n);
};
gviz.canviz.valuenumberconverter.timeOfDayToNumber = function(v) {
  goog.asserts.assert(goog.isArray(v));
  return gviz.canviz.timeutil.timeOfDayAsMillis(v);
};
gviz.canviz.valuenumberconverter.timeOfDayFromNumber = function(n) {
  return gviz.canviz.timeutil.millisAsTimeOfDay(n);
};
// INPUT (javascript/gviz/devel/canviz/datetime-value-scale.js)
gviz.canviz.DatetimeValueScale = function(roundDurationTable, durationTableRepeatingIntervals, dateFormats) {
  this.roundDurationTable_ = roundDurationTable;
  this.durationTableRepeatingIntervals_ = durationTableRepeatingIntervals;
  this.dateFormats_ = dateFormats;
};
goog.inherits(gviz.canviz.DatetimeValueScale, gviz.canviz.ValueScale);
gviz.canviz.DatetimeValueScale.prototype.init = function(options, optionsPath, numberOfTicks) {
  gviz.canviz.DatetimeValueScale.superClass_.init.call(this, options, optionsPath, numberOfTicks);
  var formatOptions = options.inferObjectValue(this.getAbsoluteOptionsPath("formatOptions")), userFormats = gviz.canviz.DatetimeValueScale.formatOptionsToArray_(formatOptions), formatLayers = [userFormats, goog.array.repeat(this.format, userFormats.length), this.dateFormats_];
  this.dateFormats_ = gviz.canviz.DatetimeValueScale.mergeArrays_(formatLayers);
};
gviz.canviz.DatetimeValueScale.formatOptionsToArray_ = function(formatOptions) {
  var formats = [];
  formats.push(formatOptions.millisecond);
  formats.push(formatOptions.second);
  formats.push(formatOptions.minute);
  formats.push(formatOptions.hour);
  formats.push(formatOptions.day);
  formats.push(formatOptions.month);
  formats.push(formatOptions.year);
  return formats;
};
gviz.canviz.DatetimeValueScale.mergeArrays_ = function(arrs) {
  var zippedArrays = goog.array.zip.apply(null, arrs), merged = goog.array.map(zippedArrays, function(arr) {
    return goog.array.find(arr, function(val) {
      return val;
    });
  });
  return merged;
};
gviz.canviz.DatetimeValueScale.prototype.inferValue = function(options, path) {
  return options.inferValue(path);
};
gviz.canviz.DatetimeValueScale.prototype.valueToNumberInternal = function(v) {
  return gviz.canviz.valuenumberconverter.dateToNumber(v);
};
gviz.canviz.DatetimeValueScale.prototype.numberToValueInternal = function(v) {
  return gviz.canviz.valuenumberconverter.dateFromNumber(v);
};
gviz.canviz.DatetimeValueScale.prototype.gapValueToNumberInternal = function(gapValue) {
  return gapValue;
};
gviz.canviz.DatetimeValueScale.prototype.getDefaultBaseline = function() {
  var d = new Date(0);
  d.setFullYear(0);
  return d;
};
gviz.canviz.DatetimeValueScale.prototype.calibrateInternal = function(numericMinValue, numericMaxValue, shouldExpand) {
  var numberOfSections = this.numberOfSections;
  -1 === numberOfSections && (numberOfSections = 6);
  var unroundedTickSize = (numericMaxValue - numericMinValue) / numberOfSections, unit = gviz.canviz.timeutil.roundMillisAccordingToTable(unroundedTickSize, this.roundDurationTable_, this.durationTableRepeatingIntervals_), minDate, maxDate;
  shouldExpand ? (minDate = gviz.canviz.timeutil.floorDate(new Date(numericMinValue), unit), maxDate = gviz.canviz.timeutil.ceilDate(new Date(numericMaxValue), unit)) : (minDate = gviz.canviz.timeutil.ceilDate(new Date(numericMinValue), unit), maxDate = gviz.canviz.timeutil.floorDate(new Date(numericMaxValue), unit));
  var tickDuration = gviz.canviz.timeutil.millisAsDuration(unroundedTickSize), tickDuration = gviz.canviz.timeutil.roundDuration(tickDuration, unit);
  this.tickDuration_ = tickDuration = 0 < gviz.canviz.timeutil.durationAsMillis(tickDuration) ? tickDuration : unit;
  this.minDate_ = minDate;
  this.maxDate_ = maxDate;
  shouldExpand && (this.numericMinValue = minDate.getTime(), this.numericMaxValue = maxDate.getTime());
};
gviz.canviz.DatetimeValueScale.prototype.generateTicks = function(numericMinValue, numericMaxValue, shouldExpand) {
  for (var ticks = [], tickDate = this.minDate_;tickDate < this.maxDate_;) {
    ticks.push(tickDate.getTime()), tickDate = gviz.canviz.timeutil.addDuration(tickDate, this.tickDuration_);
  }
  if (shouldExpand || tickDate <= this.maxDate_) {
    ticks.push(tickDate.getTime()), this.numericMaxValue = Math.max(this.numericMaxValue, tickDate.getTime());
  }
  this.setTicks(ticks);
};
gviz.canviz.DatetimeValueScale.prototype.getDateFormatter_ = function(tickDuration) {
  var granularity = gviz.canviz.timeutil.durationGranularity(tickDuration), format = this.dateFormats_[granularity];
  return "object" === typeof format ? new google.visualization.DateFormat(format) : new google.visualization.DateFormat({pattern:format});
};
gviz.canviz.DatetimeValueScale.prototype.createFormatter = function() {
  this.formatter_ = this.getDateFormatter_(this.tickDuration_);
};
gviz.canviz.DatetimeValueScale.dateRoundUnits_ = [[0, 0, 0, 0, 1], [0, 0, 0, 0, 2], [0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 12], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 10], [0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 0, 50], [0, 0, 0, 0, 0, 0, 100]];
gviz.canviz.DatetimeValueScale.dateRoundUnitsRepeatingIntervals_ = 3;
gviz.canviz.DatetimeValueScale.dateFormatsPerGranularity_ = [google.visualization.DateFormat.Format.MEDIUM_DATE, google.visualization.DateFormat.Format.MEDIUM_DATE, google.visualization.DateFormat.Format.MEDIUM_DATE, google.visualization.DateFormat.Format.MEDIUM_DATE, google.visualization.DateFormat.Format.MEDIUM_DATE, google.visualization.DateFormat.Patterns.YEAR_MONTH_ABBR, "y"];
gviz.canviz.DatetimeValueScale.datetimeRoundUnits_ = [[1], [2], [5], [10], [20], [50], [100], [200], [500], [0, 1], [0, 2], [0, 5], [0, 10], [0, 15], [0, 30], [0, 0, 1], [0, 0, 2], [0, 0, 5], [0, 0, 10], [0, 0, 15], [0, 0, 30], [0, 0, 0, 1], [0, 0, 0, 2], [0, 0, 0, 3], [0, 0, 0, 4], [0, 0, 0, 6], [0, 0, 0, 12], [0, 0, 0, 0, 1], [0, 0, 0, 0, 2], [0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 12], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 5], [0, 0, 0, 
0, 0, 0, 10], [0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 0, 50], [0, 0, 0, 0, 0, 0, 100]];
gviz.canviz.DatetimeValueScale.datetimeRoundUnitsRepeatingIntervals_ = 3;
gviz.canviz.DatetimeValueScale.datetimeFormatsPerGranularity_ = [google.visualization.DateFormat.Format.MEDIUM_TIME, google.visualization.DateFormat.Format.MEDIUM_TIME, google.visualization.DateFormat.Format.SHORT_TIME, {pattern:google.visualization.DateFormat.Format.SHORT_TIME, clearMinutes:!0}, google.visualization.DateFormat.Format.MEDIUM_DATE, google.visualization.DateFormat.Patterns.YEAR_MONTH_ABBR, "y"];
gviz.canviz.DatetimeValueScale.buildDateValueScale = function() {
  return new gviz.canviz.DatetimeValueScale(gviz.canviz.DatetimeValueScale.dateRoundUnits_, gviz.canviz.DatetimeValueScale.dateRoundUnitsRepeatingIntervals_, gviz.canviz.DatetimeValueScale.dateFormatsPerGranularity_);
};
gviz.canviz.DatetimeValueScale.buildDateTimeValueScale = function() {
  return new gviz.canviz.DatetimeValueScale(gviz.canviz.DatetimeValueScale.datetimeRoundUnits_, gviz.canviz.DatetimeValueScale.datetimeRoundUnitsRepeatingIntervals_, gviz.canviz.DatetimeValueScale.datetimeFormatsPerGranularity_);
};
// INPUT (javascript/gviz/devel/canviz/tick-util.js)
gviz.canviz.tickutil = {};
gviz.canviz.tickutil.MAX_SEARCH_DEPTH_ = 5;
gviz.canviz.tickutil.positionTicksAroundRange = function(startTarget, endTarget, startInsideMargin, startOutsideMargin, endInsideMargin, endOutsideMargin, numberOfSections, scoringFunction) {
  var totalOutsideMargin = endOutsideMargin + startOutsideMargin;
  goog.asserts.assert(endTarget > startTarget, "End target must be strictly greater than start target");
  goog.asserts.assert(1 > totalOutsideMargin, "Total outside margin must be smaller than 1");
  goog.asserts.assert(startInsideMargin <= startOutsideMargin, "start inside margin must be smaller than start outside margin");
  goog.asserts.assert(endInsideMargin <= endOutsideMargin, "end inside margin must be smaller than end outside margin");
  return gviz.canviz.tickutil.searchForRoundTickPositioning_(startTarget, endTarget, startInsideMargin, startOutsideMargin, endInsideMargin, endOutsideMargin, numberOfSections, scoringFunction) || gviz.canviz.tickutil.robustFindTicksAroundRange_(startTarget, endTarget, numberOfSections);
};
gviz.canviz.tickutil.searchForRoundTickPositioning_ = function(startTarget, endTarget, startInsideMargin, startOutsideMargin, endInsideMargin, endOutsideMargin, numberOfSections, scoringFunction) {
  var rangeSize = endTarget - startTarget;
  if (0 >= rangeSize) {
    return null;
  }
  for (var magnitude = Math.floor(Math.log(rangeSize) / Math.log(10)), units = gviz.canviz.util.rangeMap(gviz.canviz.tickutil.MAX_SEARCH_DEPTH_, function(i) {
    return{base:Math.pow(10, magnitude - i), coefficient:5};
  }), possiblePositionings = [], foundSome = !1, i$$0 = 0;i$$0 < units.length;++i$$0) {
    var unit$$0 = units[i$$0], normalizedStartTarget = startTarget / (unit$$0.base * unit$$0.coefficient), normalizedEndTarget = endTarget / (unit$$0.base * unit$$0.coefficient), unitPositionings = gviz.canviz.tickutil.listIntegerPositionedTickPositionings_(normalizedStartTarget, normalizedEndTarget, startInsideMargin, startOutsideMargin, endInsideMargin, endOutsideMargin, numberOfSections), possiblePositionings = possiblePositionings.concat(goog.array.map(unitPositionings, function(positioning) {
      return[unit$$0, positioning];
    }));
    if (foundSome) {
      break;
    }
    foundSome = !goog.array.isEmpty(unitPositionings);
  }
  return goog.array.reduce(possiblePositionings, function(bestPositioningYet, candidate) {
    for (var unit = candidate[0], positioning = candidate[1], lastStartPoint = null, normalizedStartPoint = positioning.minStartPoint;normalizedStartPoint <= positioning.maxStartPoint && lastStartPoint != normalizedStartPoint;lastStartPoint = normalizedStartPoint, normalizedStartPoint += positioning.offsetStep) {
      var startPoint = Math.round(unit.coefficient * normalizedStartPoint), endPoint = Math.round(unit.coefficient * (normalizedStartPoint + numberOfSections * positioning.sectionSize)), score = scoringFunction(startPoint, endPoint, unit.base);
      score > bestPositioningYet.score && (bestPositioningYet = {score:score, positioning:{startPoint:Math.round(startPoint) * unit.base, endPoint:Math.round(endPoint) * unit.base}});
    }
    return bestPositioningYet;
  }, {score:-Infinity, positioning:null}).positioning;
};
gviz.canviz.tickutil.robustFindTicksAroundRange_ = function(start, end, numberOfSections) {
  if (0 <= start || 0 >= end || 1 == numberOfSections) {
    return{startPoint:start, endPoint:end};
  }
  var sectionsAboveZero = Math.max(1, Math.min(numberOfSections - 1, Math.round(end / (end - start) * numberOfSections))), sectionsBelowZero = numberOfSections - sectionsAboveZero, sectionSize = Math.max(end / sectionsAboveZero, -start / sectionsBelowZero);
  return{startPoint:-sectionsBelowZero * sectionSize, endPoint:sectionsAboveZero * sectionSize};
};
gviz.canviz.tickutil.listIntegerPositionedTickPositionings_ = function(startTarget, endTarget, startInsideMargin, startOutsideMargin, endInsideMargin, endOutsideMargin, numberOfSections) {
  for (var possiblePositionings = [], targetRangeSize = endTarget - startTarget, totalInsideMargin = startInsideMargin + endInsideMargin, totalOutsideMargin = startOutsideMargin + endOutsideMargin, minSectionSize = Math.ceil(targetRangeSize / (1 - totalInsideMargin) / numberOfSections), maxSectionSize = Math.floor(targetRangeSize / (1 - totalOutsideMargin) / numberOfSections), sectionSize = minSectionSize;Infinity > sectionSize && sectionSize <= maxSectionSize;++sectionSize) {
    var resultRangeSize = sectionSize * numberOfSections, minStartPoint = Math.ceil(Math.max(startTarget - startOutsideMargin * resultRangeSize, endTarget - (1 - endInsideMargin) * resultRangeSize)), maxStartPoint = Math.floor(Math.min(startTarget - startInsideMargin * resultRangeSize, endTarget - (1 - endOutsideMargin) * resultRangeSize)), offsetStep = 1;
    0 < endTarget && 0 > startTarget ? 1 < numberOfSections && (minStartPoint = Math.ceil(minStartPoint / sectionSize) * sectionSize, maxStartPoint = Math.floor(maxStartPoint / sectionSize) * sectionSize, offsetStep = sectionSize) : 0 <= startTarget ? minStartPoint = Math.max(0, minStartPoint) : maxStartPoint = Math.min(-resultRangeSize, maxStartPoint);
    0 <= maxStartPoint - minStartPoint && possiblePositionings.push({sectionSize:sectionSize, offsetStep:offsetStep, minStartPoint:minStartPoint, maxStartPoint:maxStartPoint});
  }
  return possiblePositionings;
};
gviz.canviz.tickutil.scoreNumber = function(number) {
  if (0 == number) {
    return 0;
  }
  0 > number && (number = -number);
  if (.5 > number) {
    return 0;
  }
  for (;0 == Math.round(number % 10);) {
    number = Math.round(number / 10);
  }
  return 1 == number || 5 == number ? .5 : Math.floor(Math.log(number) / Math.log(10)) + 1;
};
// INPUT (javascript/gviz/devel/canviz/numeric-value-scale.js)
gviz.canviz.NumericValueScale = function() {
  this.decimalPoints_ = 0;
};
goog.inherits(gviz.canviz.NumericValueScale, gviz.canviz.ValueScale);
gviz.canviz.NumericValueScale.DEFAULT_NUMBER_OF_SECTIONS = 4;
gviz.canviz.NumericValueScale.DEFAULT_TIGHTNESS_OF_TICKS_WEIGHT = 10;
gviz.canviz.NumericValueScale.DEFAULT_ROUNDNESS_OF_INNER_TICK_WEIGHT = 2;
gviz.canviz.NumericValueScale.DEFAULT_ROUNDNESS_OF_OUTER_TICK_WEIGHT = 5;
gviz.canviz.NumericValueScale.DEFAULT_ROUNDNESS_OF_TICK_SIZE_WEIGHT = 1;
gviz.canviz.NumericValueScale.prototype.getDefaultNumberOfSections = function() {
  return gviz.canviz.NumericValueScale.DEFAULT_NUMBER_OF_SECTIONS;
};
gviz.canviz.NumericValueScale.prototype.init = function(options, optionsPath, numberOfTicks) {
  gviz.canviz.NumericValueScale.superClass_.init.call(this, options, optionsPath, numberOfTicks);
  this.formatter_ = null;
  this.scaleFactor_ = options.inferNumberValue(this.getAbsoluteOptionsPath("formatOptions.scaleFactor"), 1);
  this.tickScoringWeights = options.inferValue(this.getAbsoluteOptionsPath("tickScoringWeights"), [gviz.canviz.NumericValueScale.DEFAULT_TIGHTNESS_OF_TICKS_WEIGHT, gviz.canviz.NumericValueScale.DEFAULT_ROUNDNESS_OF_INNER_TICK_WEIGHT, gviz.canviz.NumericValueScale.DEFAULT_ROUNDNESS_OF_OUTER_TICK_WEIGHT, gviz.canviz.NumericValueScale.DEFAULT_ROUNDNESS_OF_TICK_SIZE_WEIGHT]);
};
gviz.canviz.NumericValueScale.prototype.generateTicks = function(numericMinValue, numericMaxValue, shouldExpand) {
  var scoringFunction, startInsideMargin, startOutsideMargin, endInsideMargin, endOutsideMargin;
  shouldExpand ? (scoringFunction = goog.bind(gviz.canviz.NumericValueScale.scoringFunction_, null, this.tickScoringWeights, this.numberOfSections, numericMinValue, numericMaxValue), startInsideMargin = -1E-4, startOutsideMargin = 1 / Math.max(this.numberOfSections, 3), endInsideMargin = startInsideMargin, endOutsideMargin = startOutsideMargin) : (startInsideMargin = -1 / Math.max(this.numberOfSections, 3), startOutsideMargin = 0, endInsideMargin = startInsideMargin, endOutsideMargin = startOutsideMargin, 
  this.tickScoringWeights[0] *= -1, scoringFunction = goog.bind(gviz.canviz.NumericValueScale.scoringFunction_, null, this.tickScoringWeights, this.numberOfSections, this.numericMinValue, this.numericMaxValue));
  for (var tickPositioning = gviz.canviz.tickutil.positionTicksAroundRange(numericMinValue, numericMaxValue, startInsideMargin, startOutsideMargin, endInsideMargin, endOutsideMargin, this.numberOfSections, scoringFunction), tickSize = (tickPositioning.endPoint - tickPositioning.startPoint) / this.numberOfSections, ticks = [], i = 0;i <= this.numberOfSections;++i) {
    ticks.push(tickPositioning.startPoint + tickSize * i);
  }
  this.numericMinValue = Math.min(ticks[0], this.numericMinValue);
  this.numericMaxValue = Math.max(ticks[ticks.length - 1], this.numericMaxValue);
  this.setTicks(ticks);
};
gviz.canviz.NumericValueScale.prototype.setTicks = function(ticks) {
  gviz.canviz.NumericValueScale.superClass_.setTicks.call(this, ticks);
  var precision = 0;
  goog.array.forEach(this.ticks, function(tick) {
    var value = this.numberToValue(tick);
    precision = Math.max(precision, gviz.canviz.util.countRequiredDecimalPrecision(value / this.scaleFactor_));
  }, this);
  this.decimalPoints_ = precision;
};
gviz.canviz.NumericValueScale.prototype.createFormatter = function() {
  var formatterOptions = {pattern:this.format, fractionDigits:this.format ? null : this.decimalPoints_, scaleFactor:this.scaleFactor_, prefix:this.options_.inferOptionalStringValue(this.getAbsoluteOptionsPath("formatOptions.prefix")), suffix:this.options_.inferOptionalStringValue(this.getAbsoluteOptionsPath("formatOptions.suffix"))};
  this.formatter_ = new google.visualization.NumberFormat(formatterOptions);
};
gviz.canviz.NumericValueScale.scoringFunction_ = function(tickScoringWeights, numberOfSections, minValue, maxValue, startPoint, endPoint, unit) {
  for (var score = tickScoringWeights[0] * (maxValue - minValue) / (unit * (endPoint - startPoint)), tickSize = (endPoint - startPoint) / numberOfSections, numberScorer = function(n) {
    return Math.pow(gviz.canviz.tickutil.scoreNumber(n), 1.2);
  }, i = 1;i < numberOfSections;++i) {
    score -= tickScoringWeights[1] * numberScorer(startPoint + i * tickSize);
  }
  score -= tickScoringWeights[2] * numberScorer(startPoint);
  score -= tickScoringWeights[2] * numberScorer(endPoint);
  return score -= tickScoringWeights[3] * numberScorer(tickSize);
};
gviz.canviz.NumericValueScale.prototype.inferValue = function(options, path) {
  return options.inferOptionalNumberValue(path);
};
gviz.canviz.NumericValueScale.prototype.valueToNumberInternal = function(value) {
  return gviz.canviz.valuenumberconverter.numberToNumber(value);
};
gviz.canviz.NumericValueScale.prototype.numberToValueInternal = function(value) {
  return gviz.canviz.valuenumberconverter.numberFromNumber(value);
};
gviz.canviz.NumericValueScale.prototype.gapValueToNumberInternal = function(gapValue) {
  return gapValue;
};
gviz.canviz.NumericValueScale.prototype.getDefaultBaseline = function() {
  return 0;
};
gviz.canviz.NumericValueScale.buildNumericValueScale = function() {
  return new gviz.canviz.NumericValueScale;
};
// INPUT (javascript/gviz/devel/canviz/scale-repository.js)
gviz.canviz.ScaleRepository = function() {
  this.repository_ = {};
};
gviz.canviz.ScaleRepository.instance_ = null;
gviz.canviz.ScaleRepository.instance = function() {
  if (gviz.canviz.ScaleRepository.instance_) {
    return gviz.canviz.ScaleRepository.instance_;
  }
  gviz.canviz.ScaleRepository.instance_ = new gviz.canviz.ScaleRepository;
  return gviz.canviz.ScaleRepository.instance_;
};
gviz.canviz.ScaleRepository.prototype.getScale = function(datatype) {
  var ctor = this.repository_[datatype];
  if (ctor) {
    var scale = ctor.apply(null, []);
    return scale;
  }
  return null;
};
gviz.canviz.ScaleRepository.prototype.registerScale = function(datatype, ctor) {
  this.repository_[datatype] = ctor;
};
// INPUT (javascript/gviz/devel/canviz/timeofday-value-scale.js)
gviz.canviz.TimeofdayValueScale = function() {
  this.granularity_ = 1;
};
goog.inherits(gviz.canviz.TimeofdayValueScale, gviz.canviz.ValueScale);
gviz.canviz.TimeofdayValueScale.prototype.inferValue = function(options, path) {
  return options.inferValue(path);
};
gviz.canviz.TimeofdayValueScale.prototype.compareValues = function(value1, value2) {
  var millis1 = gviz.canviz.valuenumberconverter.timeOfDayToNumber(value1), millis2 = gviz.canviz.valuenumberconverter.timeOfDayToNumber(value2);
  return millis1 < millis2 ? -1 : millis1 > millis2 ? 1 : 0;
};
gviz.canviz.TimeofdayValueScale.prototype.valueToNumberInternal = function(v) {
  return gviz.canviz.valuenumberconverter.timeOfDayToNumber(v);
};
gviz.canviz.TimeofdayValueScale.prototype.numberToValueInternal = function(v) {
  return gviz.canviz.valuenumberconverter.timeOfDayFromNumber(v);
};
gviz.canviz.TimeofdayValueScale.prototype.gapValueToNumberInternal = function(gapValue) {
  return gapValue;
};
gviz.canviz.TimeofdayValueScale.prototype.getDefaultBaseline = function() {
  return gviz.canviz.timeutil.millisAsTimeOfDay(0);
};
gviz.canviz.TimeofdayValueScale.prototype.calibrateInternal = function(numericMinValue, numericMaxValue, shouldExpand) {
  var numberOfSections = this.numberOfSections;
  -1 === numberOfSections && (numberOfSections = 6);
  var unroundedTickSize = (numericMaxValue - numericMinValue) / numberOfSections, unit = gviz.canviz.timeutil.roundMillisAccordingToTable(unroundedTickSize, gviz.canviz.TimeofdayValueScale.niceDurationTable_, 0);
  this.granularity_ = gviz.canviz.timeutil.durationGranularity(unit);
  var unitMillis = gviz.canviz.timeutil.durationAsMillis(unit), tickSize = Math.max(1, Math.round(unroundedTickSize / unitMillis)) * unitMillis;
  this.tickSize = tickSize;
  shouldExpand ? (numericMinValue = Math.floor(numericMinValue / tickSize) * tickSize, numericMaxValue = Math.ceil(numericMaxValue / tickSize) * tickSize) : (numericMinValue = Math.ceil(numericMinValue / tickSize) * tickSize, numericMaxValue = Math.floor(numericMaxValue / tickSize) * tickSize);
  this.minValue_ = numericMinValue;
  this.maxValue_ = numericMaxValue;
  shouldExpand && (this.numericMinValue = numericMinValue, this.numericMaxValue = numericMaxValue);
};
gviz.canviz.TimeofdayValueScale.prototype.generateTicks = function() {
  for (var ticks = [], value = this.minValue_;value < this.maxValue_;) {
    ticks.push(value), value += this.tickSize;
  }
  ticks.push(value);
  this.setTicks(ticks);
};
gviz.canviz.TimeofdayValueScale.prototype.createFormatter = function() {
  var format = this.format ? this.format : 1 < this.granularity_ ? "HH:mm" : 1 === this.granularity_ ? "HH:mm:ss" : "HH:mm:ss.SSS", dateFormatter = new google.visualization.DateFormat({pattern:format}), formatter = {formatValue:function(value) {
    var dateValue = gviz.canviz.timeutil.timeOfDayAsDate(value);
    return dateFormatter.formatValue(dateValue);
  }};
  this.formatter_ = formatter;
};
gviz.canviz.TimeofdayValueScale.niceDurationTable_ = [[0, 1, 0, 0], [0, 2, 0, 0], [0, 5, 0, 0], [0, 10, 0, 0], [0, 20, 0, 0], [0, 30, 0, 0], [0, 0, 1, 0], [0, 0, 5, 0], [0, 0, 10, 0], [0, 0, 15, 0], [0, 0, 30, 0], [0, 0, 0, 1], [0, 0, 0, 2], [0, 0, 0, 3], [0, 0, 0, 4], [0, 0, 0, 6], [0, 0, 0, 12]];
gviz.canviz.TimeofdayValueScale.buildTimeofdayValueScale = function() {
  return new gviz.canviz.TimeofdayValueScale;
};
// INPUT (javascript/gviz/devel/canviz/scale-initializer.js)
gviz.canviz.scaleinit = {};
gviz.canviz.ScaleRepository.instance().registerScale("timeofday", gviz.canviz.TimeofdayValueScale.buildTimeofdayValueScale);
gviz.canviz.ScaleRepository.instance().registerScale("date", gviz.canviz.DatetimeValueScale.buildDateValueScale);
gviz.canviz.ScaleRepository.instance().registerScale("datetime", gviz.canviz.DatetimeValueScale.buildDateTimeValueScale);
gviz.canviz.ScaleRepository.instance().registerScale("number", gviz.canviz.NumericValueScale.buildNumericValueScale);
// INPUT (javascript/gviz/devel/canviz/serie-columns.js)
gviz.canviz.ColumnRole = {ANNOTATION:"annotation", ANNOTATION_TEXT:"annotationText", CERTAINTY:"certainty", DATA:"data", DOMAIN:"domain", EMPHASIS:"emphasis", GAP:"gap", INTERVAL:"interval", SCOPE:"scope", TOOLTIP:"tooltip", DIFF_OLD_DATA:"old-data", STYLE:"style"};
// INPUT (javascript/gviz/devel/canviz/chart-definition.js)
gviz.canviz.PointShapeType = {CIRCLE:"circle", TRIANGLE:"triangle", SQUARE:"square", DIAMOND:"diamond", POLYGON:"polygon", STAR:"star"};
gviz.canviz.ChartDefinition = function() {
};
gviz.canviz.ChartDefinition.prototype.getCategoryTitleForDatum = function(datum) {
  var seriesIndex = datum.serie, categoryIndex = datum.category, title, datumIndex = gviz.canviz.chartdefinitionutil.getCanonicalCategoryIndex(this, seriesIndex, categoryIndex);
  return title = this.series[seriesIndex].points[datumIndex].tooltipText.categoryTitle || (this.categories[datumIndex] ? this.categories[categoryIndex].titles[0] : null);
};
gviz.canviz.ChartDefinition.prototype.getSeriesTitleForDatum = function(datum) {
  var seriesIndex = datum.serie, categoryIndex = datum.category, datumIndex = gviz.canviz.chartdefinitionutil.getCanonicalCategoryIndex(this, seriesIndex, categoryIndex), title = this.series[seriesIndex].points[datumIndex].tooltipText.serieTitle || this.series[seriesIndex].title;
  return title;
};
gviz.canviz.ChartDefinition.prototype.getCategoryIndexForDatum = function(datum) {
  return datum.category;
};
gviz.canviz.ChartDefinition.prototype.getSeriesIndexForDatum = function(datum) {
  return datum.serie;
};
gviz.canviz.ChartDefinition.prototype.getCellRefForDatum = function(datum) {
  var serie = this.series[datum.serie], column = serie.dataTableIdx;
  return{row:datum.category, column:column};
};
gviz.canviz.ChartDefinition.prototype.getDatumForCellRef = function(cell) {
  var columnInfo = this.dataTableColumnRoleInfo[cell.column], serieIndex = columnInfo.serieIndex;
  if (!goog.isDefAndNotNull(serieIndex)) {
    return null;
  }
  var datum = {serie:serieIndex, category:this.dataTableToCategoryMap[cell.row]};
  return datum;
};
gviz.canviz.ChartDefinition.prototype.getTooltipText = function(seriesIndex, categoryIndex) {
  var series = this.series[seriesIndex], tooltipText = series.points[categoryIndex].tooltipText;
  return tooltipText;
};
// INPUT (javascript/gviz/devel/canviz/annotation.js)
// INPUT (javascript/gviz/devel/canviz/chart-builder.js)
gviz.canviz.ChartBuilder = function(overlayArea, renderer) {
  this.renderer = renderer;
  this.overlayArea = overlayArea;
  this.colorBarDrawingGroup = this.legendDrawingGroup = this.tooltipDrawingGroup_ = this.chartDefinition = this.groupIDToElementIDs_ = this.idToElementMapping_ = this.drawnRefreshLayer = null;
};
gviz.canviz.ChartBuilder.prototype.drawChart = function(baseLayer, refreshLayer) {
  this.clearChart_();
  this.updateDefinition(baseLayer, refreshLayer);
  var chartDefinition = this.chartDefinition, chartCanvas = this.renderer.createCanvas(chartDefinition.width, chartDefinition.height);
  this.internalDrawChart(baseLayer, refreshLayer, chartCanvas);
};
gviz.canviz.ChartBuilder.prototype.redrawChart = function(baseLayer, refreshLayer) {
  this.idToElementMapping_ = {};
  this.groupIDToElementIDs_ = {};
  this.updateDefinition(baseLayer, refreshLayer);
  this.renderer.deleteContents(!0);
  this.internalDrawChart(baseLayer, refreshLayer, this.renderer.getCanvas());
  this.renderer.flush();
};
gviz.canviz.ChartBuilder.prototype.updateDefinition = function(baseLayer, refreshLayer) {
  var layeredChartDefinition = new gviz.util.LayeredObject(2);
  layeredChartDefinition.setLayer(0, baseLayer);
  layeredChartDefinition.setLayer(1, refreshLayer);
  this.chartDefinition = layeredChartDefinition.compact();
};
gviz.canviz.ChartBuilder.prototype.internalDrawChart = function(baseLayer, refreshLayer, chartCanvas) {
  this.registerElement(chartCanvas.getElement(), gviz.canviz.idutils.Token.CHART);
  var chartDefinition = this.chartDefinition, renderer = this.renderer, backgroundBrush = chartDefinition.backgroundBrush;
  backgroundBrush.isTransparent() || renderer.drawRect(0, 0, chartDefinition.width, chartDefinition.height, backgroundBrush, chartCanvas);
  var titlePosition = chartDefinition.titlePosition;
  if (titlePosition == gviz.canviz.Options.InOutPosition.OUTSIDE) {
    goog.asserts.assert(chartDefinition.title);
    var titleTextBlock = this.drawTextBlock(chartDefinition.title, chartCanvas);
    this.registerElement(titleTextBlock, gviz.canviz.idutils.Token.TITLE);
  }
  this.legendDrawingGroup = renderer.createGroup(!0);
  var legendDefinition = chartDefinition.legend;
  this.drawLegend(legendDefinition);
  legendDefinition && legendDefinition.position != gviz.canviz.Options.LegendPosition.INSIDE && (renderer.appendChild(chartCanvas, this.legendDrawingGroup), this.registerElement(this.legendDrawingGroup.getElement(), gviz.canviz.idutils.Token.LEGEND));
  this.colorBarDrawingGroup = renderer.createGroup(!0);
  var colorBarDefinition = chartDefinition.colorBar;
  this.drawColorBar(colorBarDefinition);
  colorBarDefinition && colorBarDefinition.position != gviz.canviz.Options.ColorBarPosition.INSIDE && (renderer.appendChild(chartCanvas, this.colorBarDrawingGroup), this.idToElementMapping_[gviz.canviz.idutils.Token.COLOR_BAR] = this.colorBarDrawingGroup.getElement());
  this.tooltipDrawingGroup_ = renderer.createGroup(!1);
  this.drawChartContent(chartDefinition, chartCanvas) || this.drawEmptyChart_(chartDefinition, chartCanvas);
  renderer.appendChild(chartCanvas, this.tooltipDrawingGroup_);
  this.drawnRefreshLayer = refreshLayer;
  renderer.flushRenderingCommands();
};
gviz.canviz.ChartBuilder.prototype.refreshChart = function(baseLayer, refreshLayer) {
  var shortCircuitedPropsObj = {series:null, categories:null, legend:null, labeledLegend:null, colorBar:null, overlayBox:null}, shortCircuitedProps = goog.object.getKeys(shortCircuitedPropsObj), containsNoOtherProperties = gviz.canviz.util.containsNoOtherProperties;
  containsNoOtherProperties(refreshLayer, shortCircuitedProps) && containsNoOtherProperties(this.drawnRefreshLayer, shortCircuitedProps) ? (this.refreshLegend_(baseLayer, refreshLayer), this.refreshColorBar_(baseLayer, refreshLayer), this.refreshChartContent(baseLayer, refreshLayer), this.refreshOverlayBox_(baseLayer, refreshLayer), this.drawnRefreshLayer = refreshLayer) : this.drawChart(baseLayer, refreshLayer);
};
gviz.canviz.ChartBuilder.prototype.refreshLegend_ = function(baseLayer, refreshLayer) {
  if (!gviz.object.unsafeEquals(refreshLayer.legend, this.drawnRefreshLayer.legend)) {
    goog.asserts.assert(!refreshLayer.legend || !this.drawnRefreshLayer.legend || refreshLayer.legend.position == this.drawnRefreshLayer.legend.position, "Legend position should not be changed by the interactivity layer");
    this.renderer.removeChildren(this.legendDrawingGroup);
    var layeredLegendDefinition = new gviz.util.LayeredObject(2);
    layeredLegendDefinition.setLayer(0, baseLayer.legend || {});
    layeredLegendDefinition.setLayer(1, refreshLayer.legend || {});
    var legendDefinition = layeredLegendDefinition.compact();
    this.drawLegend(legendDefinition);
  }
};
gviz.canviz.ChartBuilder.prototype.refreshColorBar_ = function(baseLayer, refreshLayer) {
  if (!gviz.object.unsafeEquals(refreshLayer.colorBar, this.drawnRefreshLayer.colorBar)) {
    this.renderer.removeChildren(this.colorBarDrawingGroup);
    var layeredColorBarDefinition = new gviz.util.LayeredObject(2);
    layeredColorBarDefinition.setLayer(0, baseLayer.colorBar || {});
    layeredColorBarDefinition.setLayer(1, refreshLayer.colorBar || {});
    var colorBarDefinition = layeredColorBarDefinition.compact();
    this.drawColorBar(colorBarDefinition);
  }
};
gviz.canviz.ChartBuilder.prototype.refreshOverlayBox_ = function(baseLayer, refreshLayer) {
  gviz.object.unsafeEquals(refreshLayer.overlayBox, this.drawnRefreshLayer.overlayBox) || (this.deleteElementByID(gviz.canviz.idutils.Token.OVERLAY_BOX), this.drawOverlayBox(refreshLayer.overlayBox));
};
gviz.canviz.ChartBuilder.prototype.drawEmptyChart_ = function(chartDef, drawingGroup) {
  var msg = gviz.canviz.Messages.MSG_NO_DATA, fontName = chartDef.defaultFontName, fontSize = chartDef.defaultFontSize, textStyle = {color:"black", fontName:fontName, fontSize:fontSize, bold:!1, italic:!1, underline:!1};
  this.fitFontSize(msg, textStyle, chartDef.chartArea.width);
  var y = chartDef.chartArea.top + Math.round(chartDef.chartArea.height / 2);
  this.renderer.drawTextOnLine(msg, chartDef.chartArea.left, y, chartDef.chartArea.left + chartDef.chartArea.width, y, gviz.graphics.TextAlign.CENTER, gviz.graphics.TextAlign.CENTER, textStyle, drawingGroup);
};
gviz.canviz.ChartBuilder.prototype.drawLegend = function(legendDefinition) {
  if (legendDefinition) {
    var currentPage = legendDefinition.currentPage;
    if (currentPage) {
      var legendBoundingBox;
      if (legendDefinition.scrollItems) {
        legendBoundingBox = legendDefinition.area;
      } else {
        var legendEntryBoundingBoxes = goog.array.map(currentPage, function(legendEntry) {
          return this.calcLegendEntryBoundingBox_(legendEntry);
        }, this);
        legendBoundingBox = gviz.util.calcBoundingBox(legendEntryBoundingBoxes);
      }
      if (legendBoundingBox) {
        var legendBoundingRect = goog.math.Rect.createFromBox(legendBoundingBox);
        goog.asserts.assert(this.legendDrawingGroup);
        this.renderer.drawRect(legendBoundingRect.left, legendBoundingRect.top, legendBoundingRect.width, legendBoundingRect.height, gviz.graphics.Brush.TRANSPARENT_BRUSH, this.legendDrawingGroup);
      }
      for (var i = 0;i < currentPage.length;i++) {
        this.drawLegendEntry_(currentPage[i]);
      }
      this.drawLegendScrollItems_(legendDefinition.scrollItems);
    }
  }
};
gviz.canviz.ChartBuilder.prototype.calcLegendEntryBoundingBox_ = function(legendEntry) {
  var legendEntryItemsBoundingBoxes = [];
  if (legendEntry.textBlock) {
    var textBlockBoundingBox = gviz.canviz.TextBlockUtil.calcBoundingBox(legendEntry.textBlock);
    textBlockBoundingBox && legendEntryItemsBoundingBoxes.push(textBlockBoundingBox);
  }
  legendEntry.square && legendEntryItemsBoundingBoxes.push(legendEntry.square.coordinates.toBox());
  return gviz.util.calcBoundingBox(legendEntryItemsBoundingBoxes);
};
gviz.canviz.ChartBuilder.prototype.drawMarker = function(centerX, centerY, radius, brush, shape, opt_group) {
  var clipRect = this.renderer.disableClipping(), type = shape.type, sides = Number(shape.sides);
  goog.isDefAndNotNull(sides) && goog.math.isFiniteNumber(sides) || (sides = 5);
  var rotation = Number(shape.rotation);
  goog.isDefAndNotNull(rotation) && goog.math.isFiniteNumber(rotation) || (rotation = 0);
  rotation = rotation / 180 * Math.PI - Math.PI / 2;
  type === gviz.canviz.PointShapeType.TRIANGLE ? (type = gviz.canviz.PointShapeType.POLYGON, sides = 3) : type === gviz.canviz.PointShapeType.SQUARE ? (type = gviz.canviz.PointShapeType.POLYGON, sides = 4, rotation += Math.PI / 4) : type === gviz.canviz.PointShapeType.DIAMOND && (type = gviz.canviz.PointShapeType.POLYGON, sides = 4);
  var isStar = type === gviz.canviz.PointShapeType.STAR;
  500 < sides && (type === gviz.canviz.PointShapeType.POLYGON || type === gviz.canviz.PointShapeType.STAR) && (type = gviz.canviz.PointShapeType.CIRCLE);
  var element = null;
  if (type === gviz.canviz.PointShapeType.POLYGON || type === gviz.canviz.PointShapeType.STAR) {
    var dentRadius = Number(shape.dent);
    goog.isDefAndNotNull(dentRadius) && goog.math.isFiniteNumber(dentRadius) || (5 <= sides ? (dentRadius = Math.cos(Math.PI / sides), dentRadius -= Math.pow(Math.sin(Math.PI / sides), 2) / Math.sin(Math.PI / 2 - Math.PI / sides)) : dentRadius = .3);
    dentRadius *= radius;
    type === gviz.canviz.PointShapeType.STAR && (sides *= 2);
    for (var path = new gviz.graphics.PathSegments, p = 0;p < sides;p++) {
      var pointRadius = radius;
      isStar && p % 2 && (pointRadius = dentRadius);
      var r = 2 * Math.PI / sides * p + rotation, x = Math.cos(r) * pointRadius + centerX, y = Math.sin(r) * pointRadius + centerY;
      0 < p ? path.addLine(x, y) : path.move(x, y);
    }
    path.close();
    element = this.renderer.createPath(path, brush);
  } else {
    element = this.renderer.createCircle(centerX, centerY, radius, brush);
  }
  element && opt_group && this.renderer.appendChild(opt_group, element);
  this.renderer.describeClipRegion(clipRect);
  return element;
};
gviz.canviz.ChartBuilder.prototype.drawLegendEntrySquare_ = function(legendEntry, legendEntryDrawingGroup) {
  var series = this.chartDefinition.series[legendEntry.index];
  if (this.chartDefinition.useNewLegend && series && !series.diff && series.pointShape) {
    var squareLeft = legendEntry.square.coordinates.left, squareTop = legendEntry.square.coordinates.top, squareWidth = legendEntry.square.coordinates.width, squareHeight = legendEntry.square.coordinates.height, midX = squareLeft + squareWidth / 2, midY = squareTop + squareHeight / 2;
    series.areaBrush && this.renderer.drawRect(squareLeft, midY, squareWidth, squareHeight / 2, series.areaBrush, legendEntryDrawingGroup);
    var lineWidthCap = .5 * squareHeight, lineBrush = series.lineBrush;
    lineBrush && (lineBrush.getStrokeWidth() > lineWidthCap && (lineBrush = lineBrush.clone(), lineBrush.setStrokeWidth(lineWidthCap)), this.renderer.drawLine(squareLeft, midY, squareLeft + squareWidth, midY, lineBrush, legendEntryDrawingGroup));
    if (series.pointBrush) {
      var pointShape = series.pointShape;
      pointShape || (pointShape = {type:gviz.canviz.PointShapeType.CIRCLE});
      this.drawMarker(midX, midY, squareHeight / 2, series.pointBrush, pointShape, legendEntryDrawingGroup);
    }
  } else {
    this.renderer.drawRect(legendEntry.square.coordinates.left, legendEntry.square.coordinates.top, legendEntry.square.coordinates.width, legendEntry.square.coordinates.height, legendEntry.square.brush, legendEntryDrawingGroup);
  }
};
gviz.canviz.ChartBuilder.prototype.drawLegendEntry_ = function(legendEntry) {
  if (legendEntry.isVisible) {
    var legendEntryDrawingGroup = this.renderer.createGroup(!1), legendEntryID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.LEGEND_ENTRY, legendEntry.index]);
    this.registerElement(legendEntryDrawingGroup.getElement(), legendEntryID, gviz.canviz.idutils.Token.LEGEND_ENTRY);
    var legendEntryBoundingBox = this.calcLegendEntryBoundingBox_(legendEntry);
    if (legendEntryBoundingBox) {
      var legendEntryBoundingRect = goog.math.Rect.createFromBox(legendEntryBoundingBox);
      this.renderer.drawRect(legendEntryBoundingRect.left, legendEntryBoundingRect.top, legendEntryBoundingRect.width, legendEntryBoundingRect.height, gviz.graphics.Brush.TRANSPARENT_BRUSH, legendEntryDrawingGroup);
    }
    legendEntry.textBlock && this.drawTextBlock(legendEntry.textBlock, legendEntryDrawingGroup);
    legendEntry.square && this.drawLegendEntrySquare_(legendEntry, legendEntryDrawingGroup);
    var removeSerieButtonElement = null;
    if (legendEntry.removeSerieButton && legendEntry.removeSerieButton.isVisible) {
      var removeSerieButtonElement = this.drawRemoveSerieButton(legendEntry.removeSerieButton.coordinates.x, legendEntry.removeSerieButton.coordinates.y, legendEntry.removeSerieButton.brush, legendEntryDrawingGroup), removeSerieButtonID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.REMOVE_SERIE_BUTTON, legendEntry.index]);
      this.registerElement(removeSerieButtonElement, removeSerieButtonID);
    }
    goog.asserts.assert(this.legendDrawingGroup);
    this.renderer.appendChild(this.legendDrawingGroup, legendEntryDrawingGroup);
  }
};
gviz.canviz.ChartBuilder.prototype.drawLegendScrollItems_ = function(scrollItems) {
  scrollItems && (this.drawLegendScrollButton_(scrollItems.previousButton, -1), scrollItems.pageIndexTextBlock && (goog.asserts.assert(this.legendDrawingGroup), this.drawTextBlock(scrollItems.pageIndexTextBlock, this.legendDrawingGroup)), this.drawLegendScrollButton_(scrollItems.nextButton, 1));
};
gviz.canviz.ChartBuilder.prototype.drawLegendScrollButton_ = function(button, scrollStep) {
  if (button) {
    goog.asserts.assert(this.legendDrawingGroup);
    var buttonPathSegments = gviz.graphics.PathSegments.fromVertices(button.path), buttonElement = this.renderer.drawPath(buttonPathSegments, button.brush, this.legendDrawingGroup);
    if (button.active) {
      var buttonID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.LEGEND_SCROLL_BUTTON, scrollStep]);
      this.registerElement(buttonElement, buttonID);
    }
  }
};
gviz.canviz.ChartBuilder.prototype.drawRemoveSerieButton = function(x, y, brush, drawingGroup) {
  var renderer = this.renderer, group = renderer.createGroup();
  renderer.drawRect(x, y, 12, 12, brush, group);
  renderer.appendChild(drawingGroup, group);
  var path = new gviz.graphics.PathSegments;
  path.move(x + 2, y + 2);
  path.addLine(x + 12 - 2, y + 12 - 2);
  path.move(x + 12 - 2, y + 2);
  path.addLine(x + 2, y + 12 - 2);
  var crossBrush = new gviz.graphics.Brush;
  crossBrush.setStroke("#ffffff");
  crossBrush.setStrokeWidth(2);
  renderer.drawPath(path, crossBrush, group);
  return group.getElement();
};
gviz.canviz.ChartBuilder.prototype.drawColorBar = function(colorBarDefinition) {
  if (colorBarDefinition) {
    goog.asserts.assert(this.colorBarDrawingGroup);
    gviz.colorbar.builder.draw(colorBarDefinition.definition, this.renderer, this.colorBarDrawingGroup);
    goog.asserts.assert(this.colorBarDrawingGroup);
    var foreground = this.renderer.drawRect(colorBarDefinition.drawingOptions.left, colorBarDefinition.drawingOptions.top, colorBarDefinition.drawingOptions.width, colorBarDefinition.drawingOptions.height, gviz.graphics.Brush.TRANSPARENT_BRUSH, this.colorBarDrawingGroup);
    this.registerElement(foreground, gviz.canviz.idutils.Token.COLOR_BAR);
  }
};
gviz.canviz.ChartBuilder.prototype.fitFontSize = function(text, textStyle, maximalLength) {
  var fontSize = textStyle.fontSize, textWidth = this.renderer.getTextWidth(text, textStyle);
  textWidth > maximalLength && (fontSize = Math.max(1, Math.floor(textStyle.fontSize * maximalLength / textWidth)));
  return fontSize;
};
gviz.canviz.ChartBuilder.prototype.closeTooltip = function(tooltipID) {
  var tooltipElement = this.idToElementMapping_[tooltipID];
  tooltipElement && (this.renderer.removeElement(tooltipElement), delete this.idToElementMapping_[tooltipID]);
};
gviz.canviz.ChartBuilder.prototype.openTooltip = function(tooltipDefinition, tooltipID) {
  goog.asserts.assert(this.tooltipDrawingGroup_);
  var tooltipElement = tooltipDefinition.html ? gviz.util.tooltip.htmlbuilder.draw(tooltipDefinition, this.overlayArea.getContainer()) : gviz.util.tooltip.builder.draw(tooltipDefinition, this.renderer, this.tooltipDrawingGroup_).getElement();
  this.registerElement(tooltipElement, tooltipID);
};
gviz.canviz.ChartBuilder.prototype.drawTextBlock = function(textBlock, drawingGroup, opt_addSensitivityArea) {
  var element = this.createTextBlock(textBlock, opt_addSensitivityArea);
  element && this.renderer.appendChild(drawingGroup, element);
  return element;
};
gviz.canviz.ChartBuilder.prototype.createTextBlock = function(textBlock, opt_addSensitivityArea) {
  var lines = textBlock.lines;
  if (!lines || 0 == lines.length) {
    return null;
  }
  var renderer = this.renderer, textStyle = textBlock.textStyle, boxStyle = textBlock.boxStyle, angle = goog.isDefAndNotNull(textBlock.angle) ? textBlock.angle : 0, anchor = textBlock.anchor ? textBlock.anchor : {x:0, y:0}, tooltip = textBlock.tooltip, addSensitivityArea = !!tooltip || opt_addSensitivityArea || !1, group = renderer.createGroup();
  if (0 === angle && boxStyle) {
    var box = gviz.canviz.TextBlockUtil.calcBoundingBox(textBlock);
    if (box) {
      var left = Math.ceil(box.left - 3) + .5, right = Math.floor(box.right + 3) + .5, top = Math.floor(box.top - 1) + .5, bottom = Math.floor(box.bottom + 1) + .5;
      renderer.drawRect(left, top, right - left, bottom - top, boxStyle, group);
    }
  }
  for (var i = 0;i < lines.length;i++) {
    var line = lines[i];
    0 === angle ? renderer.drawText(line.text, line.x + anchor.x, line.y + anchor.y, line.length, textBlock.paralAlign, textBlock.perpenAlign, textStyle, group) : renderer.drawTextOnLineByAngle(line.text, line.x + anchor.x, line.y + anchor.y, line.length, angle, textBlock.paralAlign, textBlock.perpenAlign, textStyle, group);
  }
  if (addSensitivityArea) {
    var sensitivityArea = null;
    if (0 === angle) {
      (box = gviz.canviz.TextBlockUtil.calcBoundingBox(textBlock)) && (sensitivityArea = renderer.drawRect(box.left, box.top, box.right - box.left, box.bottom - box.top, gviz.graphics.Brush.TRANSPARENT_BRUSH, group));
    } else {
      var radians = goog.math.toRadians(angle), rotatedTextBlock = goog.object.unsafeClone(textBlock);
      rotatedTextBlock.angle = 0;
      var rotatedAnchor = (new goog.math.Vec2(anchor.x, anchor.y)).rotate(-radians);
      rotatedTextBlock.anchor = new gviz.math.Coordinate(rotatedAnchor.x, rotatedAnchor.y);
      for (i = 0;i < lines.length;i++) {
        var rotatedLinePoint = (new goog.math.Vec2(lines[i].x, lines[i].y)).rotate(-radians);
        rotatedTextBlock.lines[i].x = rotatedLinePoint.x;
        rotatedTextBlock.lines[i].y = rotatedLinePoint.y;
      }
      if (box = gviz.canviz.TextBlockUtil.calcBoundingBox(rotatedTextBlock)) {
        var boxPoints = [new goog.math.Vec2(box.left, box.top), new goog.math.Vec2(box.right, box.top), new goog.math.Vec2(box.right, box.bottom), new goog.math.Vec2(box.left, box.bottom)];
        goog.array.forEach(boxPoints, function(point) {
          point.rotate(radians);
        });
        var path = gviz.graphics.PathSegments.fromVertices(boxPoints, !1), sensitivityArea = renderer.drawPath(path, gviz.graphics.Brush.TRANSPARENT_BRUSH, group);
      }
    }
    tooltip && sensitivityArea && renderer.addTooltip(sensitivityArea, tooltip, gviz.canviz.textutils.tooltipCssStyle(textStyle));
  }
  return group.getElement();
};
gviz.canviz.ChartBuilder.prototype.drawOverlayBox = function(overlayBox) {
  var brush = new gviz.graphics.Brush;
  brush.setFill(overlayBox.color);
  brush.setFillOpacity(overlayBox.opacity);
  var box = this.renderer.drawRect(overlayBox.left, overlayBox.top, overlayBox.width, overlayBox.height, brush, this.renderer.getCanvas());
  this.registerElement(box, gviz.canviz.idutils.Token.OVERLAY_BOX);
};
gviz.canviz.ChartBuilder.prototype.drawElement = function(group, elementID, newElement) {
  var oldElement = this.idToElementMapping_[elementID];
  goog.isDefAndNotNull(oldElement) ? this.renderer.replaceChild(group, newElement, oldElement) : this.renderer.appendChild(group, newElement);
  this.registerElement(newElement, elementID);
};
gviz.canviz.ChartBuilder.prototype.registerElement = function(element, elementID, opt_parentID) {
  element && (this.renderer.setLogicalName(element, elementID), this.idToElementMapping_[elementID] = element, opt_parentID && this.addChildElementID_(opt_parentID, elementID));
};
gviz.canviz.ChartBuilder.prototype.deleteElementByID = function(elementID) {
  var element = this.idToElementMapping_[elementID];
  element && (this.renderer.removeElement(element), delete this.idToElementMapping_[elementID]);
};
gviz.canviz.ChartBuilder.prototype.clearChart_ = function() {
  this.idToElementMapping_ = {};
  this.groupIDToElementIDs_ = {};
  this.renderer.clear();
  this.overlayArea.clear();
};
gviz.canviz.ChartBuilder.prototype.addChildElementID_ = function(parentID, childID) {
  this.groupIDToElementIDs_[parentID] || (this.groupIDToElementIDs_[parentID] = []);
  goog.array.contains(this.groupIDToElementIDs_[parentID], childID) || this.groupIDToElementIDs_[parentID].push(childID);
};
gviz.canviz.ChartBuilder.prototype.getBoundingBox = function(id) {
  var boxes = [];
  if (this.idToElementMapping_[id]) {
    var box = this.renderer.getBoundingBox(this.idToElementMapping_[id]);
    box && boxes.push(box);
  }
  for (var childElements = this.groupIDToElementIDs_[id] || [], i = 0;i < childElements.length;++i) {
    (box = this.renderer.getBoundingBox(this.idToElementMapping_[childElements[i]])) && boxes.push(box);
  }
  return gviz.util.calcBoundingBox(boxes);
};
// INPUT (javascript/gviz/devel/canviz/chart-definition-util.js)
gviz.canviz.chartdefinitionutil = {};
gviz.canviz.chartdefinitionutil.getDatumBrush = function(datum, serie) {
  return datum.scaled && datum.scaled.brush || datum.brush || serie.pointBrush;
};
gviz.canviz.chartdefinitionutil.getIncomingLineBrush = function(datum, serie) {
  goog.asserts.assert(serie.lineBrush);
  return goog.isNull(datum.incomingLineBrush) ? null : datum.incomingLineBrush || serie.lineBrush;
};
gviz.canviz.chartdefinitionutil.getIncomingAreaBrush = function(datum, serie) {
  goog.asserts.assert(serie.areaBrush);
  return datum.incomingAreaBrush || serie.areaBrush;
};
gviz.canviz.chartdefinitionutil.isDatumNull = function(datum) {
  return!datum || datum.isNull;
};
gviz.canviz.chartdefinitionutil.isSeriePathBased = function(serie) {
  return serie.type == gviz.canviz.Options.SerieType.LINE || serie.type == gviz.canviz.Options.SerieType.AREA || serie.type == gviz.canviz.Options.SerieType.SCATTER;
};
gviz.canviz.chartdefinitionutil.isDatumVisible = function(datum, serie) {
  return goog.isDefAndNotNull(datum.visible) ? datum.visible : serie.visiblePoints;
};
gviz.canviz.chartdefinitionutil.isLonelyPoint = function(series, pointIndex) {
  var point = series.points[pointIndex], prevPoint = series.points[pointIndex - 1], nextPoint = series.points[pointIndex + 1], pointIsNull = !point || !point.scaled || point.isNull, prevPointIsNull = !prevPoint || !prevPoint.scaled || prevPoint.isNull, nextPointIsNull = !nextPoint || !nextPoint.scaled || nextPoint.isNull;
  return!pointIsNull && prevPointIsNull && nextPointIsNull;
};
gviz.canviz.chartdefinitionutil.getCanonicalCategoryIndex = function(chartDefinition, seriesIndex, categoryIndex) {
  var series = chartDefinition.series[seriesIndex];
  if (series.isVirtual && goog.isDef(series.originalSeries)) {
    var originalSeries = chartDefinition.series[series.originalSeries], categoryValue = originalSeries.points[categoryIndex], categoryValue = goog.isDefAndNotNull(categoryValue) ? categoryValue.nonScaled.d : categoryValue;
    return goog.isDefAndNotNull(categoryValue) ? goog.array.binarySearch(series.points, categoryValue, function(target, p) {
      return target - p.nonScaled.d;
    }) : categoryIndex;
  }
  return categoryIndex;
};
gviz.canviz.chartdefinitionutil.getPointRadius = function(point, serie) {
  return point.scaled && goog.isDefAndNotNull(point.scaled.radius) ? point.scaled.radius : goog.isDefAndNotNull(point.radius) ? point.radius : serie.pointRadius;
};
gviz.canviz.chartdefinitionutil.getPointSensitivityAreaRadius = function(point, serie) {
  return point.scaled && goog.isDefAndNotNull(point.scaled.sensitivityAreaRadius) ? point.scaled.sensitivityAreaRadius : goog.isDefAndNotNull(point.sensitivityAreaRadius) ? point.sensitivityAreaRadius : serie.pointSensitivityAreaRadius;
};
gviz.canviz.chartdefinitionutil.getPointTotalRadius = function(point, serie) {
  var radius = gviz.canviz.chartdefinitionutil.getPointRadius(point, serie), brush = gviz.canviz.chartdefinitionutil.getDatumBrush(point, serie), visibleRadius = radius + brush.getVisibleStrokeWidth() / 2;
  return visibleRadius;
};
gviz.canviz.chartdefinitionutil.isTooltipTriggeredBySelection = function(tooltipTrigger) {
  return tooltipTrigger == gviz.Options.TooltipTrigger.SELECTION || tooltipTrigger == gviz.Options.TooltipTrigger.BOTH;
};
gviz.canviz.chartdefinitionutil.isTooltipTriggeredByFocus = function(tooltipTrigger) {
  return tooltipTrigger == gviz.Options.TooltipTrigger.FOCUS || tooltipTrigger == gviz.Options.TooltipTrigger.BOTH;
};
gviz.canviz.chartdefinitionutil.reverseSeriesLabelsVertically = function(chartDef) {
  return chartDef.isStacked && chartDef.chartType == gviz.canviz.Options.ChartType.FUNCTION && chartDef.orientation == gviz.canviz.Options.Orientation.HORIZONTAL;
};
gviz.canviz.chartdefinitionutil.createPathSegments = function(serie, interpolateNulls) {
  for (var pathSegments = new gviz.graphics.MultiBrushPathSegments, allPointsAreNull = !0, isFirstPointOfComponent = !0, firstConcretePoint = null, previousConcretePoint = null, i = 0;i < serie.points.length;i++) {
    var point = serie.points[i];
    if (point && point.scaled && goog.isDefAndNotNull(point.scaled.x) && goog.isDefAndNotNull(point.scaled.y)) {
      allPointsAreNull && (firstConcretePoint = i, allPointsAreNull = !1);
      var scaledPoint = point.scaled;
      goog.asserts.assert(!isNaN(scaledPoint.x));
      goog.asserts.assert(!isNaN(scaledPoint.y));
      var brush = gviz.canviz.chartdefinitionutil.getIncomingLineBrush(point, serie);
      isFirstPointOfComponent || goog.isNull(brush) ? (pathSegments.move(scaledPoint.x, scaledPoint.y), isFirstPointOfComponent = !1) : serie.isCurved ? pathSegments.addCurve(brush, serie.points[previousConcretePoint].rightControlPoint.x, serie.points[previousConcretePoint].rightControlPoint.y, point.leftControlPoint.x, point.leftControlPoint.y, scaledPoint.x, scaledPoint.y) : pathSegments.addLine(brush, scaledPoint.x, scaledPoint.y);
      previousConcretePoint = i;
    } else {
      isFirstPointOfComponent = !interpolateNulls || allPointsAreNull;
    }
  }
  if (!allPointsAreNull & serie.isClosed) {
    var connectFrom = interpolateNulls ? previousConcretePoint : serie.points.length - 1, connectTo = interpolateNulls ? firstConcretePoint : 0;
    goog.isDefAndNotNull(connectFrom) && goog.isDefAndNotNull(connectTo) && serie.points[connectFrom] && serie.points[connectTo] && (brush = gviz.canviz.chartdefinitionutil.getIncomingLineBrush(serie.points[connectTo], serie), serie.isCurved ? pathSegments.addCurve(brush, serie.points[connectFrom].rightControlPoint.x, serie.points[connectFrom].rightControlPoint.y, serie.points[connectTo].leftControlPoint.x, serie.points[connectTo].leftControlPoint.y, serie.points[connectTo].scaled.x, serie.points[connectTo].scaled.y) : 
    pathSegments.close(brush));
  }
  return pathSegments;
};
gviz.canviz.chartdefinitionutil.createPathSegmentsForStackedArea = function(serie) {
  for (var pathSegments = new gviz.graphics.MultiBrushPathSegments, isFirstPointOfComponent = !0, i = 0;i < serie.points.length;i++) {
    var scaledPoint = serie.points[i].scaled;
    if (goog.isDefAndNotNull(scaledPoint.x) && goog.isDefAndNotNull(scaledPoint.y)) {
      if (!isFirstPointOfComponent) {
        var brush = gviz.canviz.chartdefinitionutil.getIncomingLineBrush(serie.points[i], serie);
        pathSegments.addLine(brush, scaledPoint.continueToX, scaledPoint.continueToY);
      }
      (isFirstPointOfComponent || scaledPoint.continueToX != scaledPoint.continueFromX || scaledPoint.continueToY != scaledPoint.continueFromY) && pathSegments.move(scaledPoint.continueFromX, scaledPoint.continueFromY);
      isFirstPointOfComponent = !1;
    } else {
      isFirstPointOfComponent = !0;
    }
  }
  return pathSegments;
};
gviz.canviz.chartdefinitionutil.getXLocation = function(chartDef, hValue, opt_hAxisIndex) {
  var hAxes = chartDef.hAxes, axis = hAxes && hAxes[opt_hAxisIndex || 0];
  return axis && axis.position.fromValue(hValue);
};
gviz.canviz.chartdefinitionutil.getYLocation = function(chartDef, vValue, opt_vAxisIndex) {
  var vAxes = chartDef.vAxes, axis = vAxes && vAxes[opt_vAxisIndex || 0];
  return axis && axis.position.fromValue(vValue);
};
gviz.canviz.chartdefinitionutil.getHAxisValue = function(chartDef, xLocation, opt_hAxisIndex) {
  var hAxes = chartDef.hAxes, axis = hAxes && hAxes[opt_hAxisIndex || 0];
  return axis && axis.position.toValue(xLocation);
};
gviz.canviz.chartdefinitionutil.getVAxisValue = function(chartDef, yLocation, opt_vAxisIndex) {
  var vAxes = chartDef.vAxes, axis = vAxes && vAxes[opt_vAxisIndex || 0];
  return axis && axis.position.toValue(yLocation);
};
gviz.canviz.chartdefinitionutil.getHAxisTicks = function(chartDef, opt_hAxisIndex) {
  for (var hAxes = chartDef.hAxes, axis = hAxes && hAxes[opt_hAxisIndex || 0], ticksData = axis.gridlines, tickValues = [], i = 0;i < ticksData.length;i++) {
    tickValues.push(ticksData[i].dataValue);
  }
  return tickValues;
};
gviz.canviz.chartdefinitionutil.getVAxisTicks = function(chartDef, opt_vAxisIndex) {
  for (var vAxes = chartDef.vAxes, axis = vAxes && vAxes[opt_vAxisIndex || 0], ticksData = axis.gridlines, tickValues = [], i = 0;i < ticksData.length;i++) {
    tickValues.push(ticksData[i].dataValue);
  }
  return tickValues;
};
gviz.canviz.chartdefinitionutil.getPointDatum = function(chartDef, x, y, r) {
  for (var series = chartDef.series, match = null, dist = Infinity, distance, testPoint = new goog.math.Coordinate(x, y), i = 0, leni = series.length;i < leni;i++) {
    var singleSeries = series[i];
    if (!singleSeries.isVirtual) {
      if ("pie" === chartDef.chartType) {
        if (gviz.canviz.chartdefinitionutil.getPointDatumPie(singleSeries, x, y, r)) {
          return{row:i};
        }
      } else {
        for (var j = 0, lenj = singleSeries.points.length;j < lenj;j++) {
          var pointObj = singleSeries.points[j];
          if (pointObj && null != pointObj.scaled) {
            var point = pointObj.scaled;
            switch(singleSeries.type) {
              case "line":
              ;
              case "bubbles":
              ;
              case "scatter":
                distance = goog.math.Coordinate.distance(testPoint, point);
                distance < r && distance < dist && (match = {col:j, row:i}, dist = distance);
                break;
              case "candlesticks":
              ;
              case "bars":
                var box = null;
                if ("bars" === singleSeries.type) {
                  box = new goog.math.Rect(point.left, point.top, point.width, point.height);
                } else {
                  if ("candlesticks" === singleSeries.type) {
                    var line = point.line, boxTop = Math.min(point.rect.top, line.top), box = new goog.math.Rect(point.rect.left, boxTop, point.rect.width, Math.max(point.rect.top + point.rect.height, line.top + line.height) - boxTop)
                  }
                }
                (distance = gviz.canviz.chartdefinitionutil.getPointDatumBox(box, testPoint, r)) && distance < dist && (match = {col:j, row:i}, dist = distance);
                break;
              default:
                throw "unknown chart type for getPointDatum.";;
            }
          }
        }
        if (0 === dist) {
          break;
        }
      }
    }
  }
  return match;
};
gviz.canviz.chartdefinitionutil.getPointDatumBox = function(box, point, r) {
  var distance = box.distance(point);
  return distance > r ? null : distance;
};
gviz.canviz.chartdefinitionutil.getPointDatumPie = function(singleSeries, x, y, r) {
  goog.asserts.assert(singleSeries.innerFromPixel.toString() === singleSeries.innerToPixel.toString(), "getPointDatumPie cannot handle donut holes yet.");
  var vectorTo = {x:singleSeries.innerToPixel.x - singleSeries.toPixel.x, y:singleSeries.innerToPixel.y - singleSeries.toPixel.y}, vectorFrom = {x:singleSeries.innerFromPixel.x - singleSeries.fromPixel.x, y:singleSeries.innerFromPixel.y - singleSeries.fromPixel.y}, vectorTestPoint = {x:singleSeries.innerFromPixel.x - x, y:singleSeries.innerFromPixel.y - y}, clockwiseTo = 0 < -vectorTo.x * vectorTestPoint.y + vectorTo.y * vectorTestPoint.x, counterClockwiseFrom = 0 < -vectorTestPoint.x * vectorFrom.y + 
  vectorTestPoint.y * vectorFrom.x;
  if (clockwiseTo && counterClockwiseFrom) {
    var distance = Math.sqrt(Math.pow(singleSeries.innerToPixel.x - singleSeries.toPixel.x, 2) + Math.pow(singleSeries.innerToPixel.y - singleSeries.toPixel.y, 2)), pointDistance = Math.sqrt(Math.pow(singleSeries.innerToPixel.x - x, 2) + Math.pow(singleSeries.innerToPixel.y - y, 2));
    if (pointDistance < distance + r) {
      return!0;
    }
  }
  return!1;
};
// INPUT (javascript/gviz/devel/canviz/axis-chart-builder.js)
gviz.canviz.AxisChartBuilder = function(overlayArea, renderer) {
  gviz.canviz.ChartBuilder.call(this, overlayArea, renderer);
  this.drawingGroupInfo_ = null;
  this.tooltipQueue_ = [];
};
goog.inherits(gviz.canviz.AxisChartBuilder, gviz.canviz.ChartBuilder);
gviz.canviz.AxisChartBuilder.DrawingGroupPosition = {OUTSIDE:"outside", INSIDE:"inside", CLIPPED:"clipped"};
gviz.canviz.AxisChartBuilder.prototype.queueTooltip_ = function(tooltipDefinition, tooltipID) {
  this.tooltipQueue_.push({definition:tooltipDefinition, id:tooltipID});
};
gviz.canviz.AxisChartBuilder.prototype.renderTooltips_ = function() {
  var clipRect = this.renderer.disableClipping();
  goog.array.forEach(this.tooltipQueue_, goog.bind(function(entry) {
    this.openTooltip(entry.definition, entry.id);
  }, this));
  this.renderer.describeClipRegion(clipRect);
  this.tooltipQueue_ = [];
};
gviz.canviz.AxisChartBuilder.prototype.drawChartContent = function(chartDef, drawingGroup) {
  this.initDrawingGroupInfo_(chartDef);
  var chartAreaDrawingGroup = this.renderer.createGroup(!1);
  this.renderer.appendChild(drawingGroup, chartAreaDrawingGroup);
  this.registerElement(chartAreaDrawingGroup.getElement(), gviz.canviz.idutils.Token.CHART_AREA);
  goog.object.forEach(this.drawingGroupInfo_, function(info) {
    if (!info.drawingGroup) {
      var allowLazyCreation = !goog.isDef(info.allowLazyCreation) || info.allowLazyCreation;
      info.drawingGroup = this.renderer.createGroup(!!allowLazyCreation);
    }
  }, this);
  this.renderer.drawRect(chartDef.chartArea.left, chartDef.chartArea.top, chartDef.chartArea.width, chartDef.chartArea.height, chartDef.chartAreaBackgroundBrush, chartAreaDrawingGroup);
  chartDef.titlePosition == gviz.canviz.Options.InOutPosition.INSIDE && (goog.asserts.assert(chartDef.title), this.drawTextBlock(chartDef.title, this.drawingGroupInfo_[gviz.canviz.idutils.Token.TITLE].drawingGroup));
  chartDef.innerAxisTitle && this.drawTextBlock(chartDef.innerAxisTitle, this.drawingGroupInfo_[gviz.canviz.idutils.Token.AXIS_TITLE].drawingGroup);
  goog.array.forEach(chartDef.categories, function(category, index) {
    category.annotation && this.drawAnnotation_(category.annotation, null, null, index);
  }, this);
  var isSerieVisible = function(serieIndex) {
    var serie = chartDef.series[serieIndex];
    return!chartDef.isDiff || serie.type !== gviz.canviz.Options.SerieType.SCATTER || serie.visiblePoints;
  };
  goog.object.forEach(chartDef.hAxes, function(hAxis) {
    this.drawHorizontalAxisLines(chartDef, hAxis);
  }, this);
  goog.object.forEach(chartDef.vAxes, function(vAxis) {
    this.drawVerticalAxisLines(chartDef, vAxis);
  }, this);
  var clipRect = new goog.math.Rect(chartDef.chartArea.left, chartDef.chartArea.top, chartDef.chartArea.width, chartDef.chartArea.height);
  this.renderer.describeClipRegion(clipRect);
  for (var sortedSeries = [], i = 0;i < chartDef.series.length;i++) {
    isSerieVisible(i) && sortedSeries.push({zOrder:chartDef.series[i].zOrder, index:i});
  }
  goog.array.stableSort(sortedSeries, function(a, b) {
    return goog.array.defaultCompare(a.zOrder, b.zOrder);
  });
  for (i = 0;i < sortedSeries.length;i++) {
    var serieIndex$$0 = sortedSeries[i].index, serie$$0 = chartDef.series[serieIndex$$0];
    this.drawSerie_(serie$$0, serieIndex$$0);
  }
  chartDef.isDiff && chartDef.series[0].type === gviz.canviz.Options.SerieType.SCATTER && this.drawLinesBetweenOldAndNewData_(chartDef, drawingGroup);
  for (i = 0;i < chartDef.categories.length;i++) {
    if (chartDef.categories[i].tooltip) {
      var tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, i]);
      this.queueTooltip_(chartDef.categories[i].tooltip, tooltipID);
    }
  }
  var oldClipRect = this.renderer.disableClipping();
  goog.object.forEach(chartDef.hAxes, function(hAxis) {
    this.drawAxisText(chartDef, hAxis);
  }, this);
  goog.object.forEach(chartDef.vAxes, function(vAxis) {
    this.drawAxisText(chartDef, vAxis);
  }, this);
  this.renderer.describeClipRegion(oldClipRect);
  this.renderTooltips_();
  var clippedDrawingGroup = this.renderer.createGroup(!1), clippingElement = this.renderer.clipGroup(clippedDrawingGroup, clipRect);
  this.renderer.appendChild(chartAreaDrawingGroup, clippingElement);
  goog.array.forEach(gviz.canviz.idutils.TOKEN_PRECEDENCE, function(token) {
    var elementDrawingGroup = this.drawingGroupInfo_[token].drawingGroup;
    if (elementDrawingGroup) {
      var parentDrawingGroup, drawingGroupPosition = this.drawingGroupInfo_[token].position;
      switch(drawingGroupPosition) {
        case gviz.canviz.AxisChartBuilder.DrawingGroupPosition.CLIPPED:
          parentDrawingGroup = clippedDrawingGroup;
          break;
        case gviz.canviz.AxisChartBuilder.DrawingGroupPosition.INSIDE:
          parentDrawingGroup = chartAreaDrawingGroup;
          break;
        case gviz.canviz.AxisChartBuilder.DrawingGroupPosition.OUTSIDE:
          parentDrawingGroup = drawingGroup;
          break;
        default:
          goog.asserts.fail('Invalid drawing group position "' + drawingGroupPosition + '"');
      }
      goog.asserts.assert(parentDrawingGroup);
      this.renderer.appendChild(parentDrawingGroup, elementDrawingGroup);
    }
  }, this);
  return!0;
};
gviz.canviz.AxisChartBuilder.prototype.initDrawingGroupInfo_ = function(chartDef) {
  this.drawingGroupInfo_ = {};
  var Token = gviz.canviz.idutils.Token, DrawingGroupPosition = gviz.canviz.AxisChartBuilder.DrawingGroupPosition, info = this.drawingGroupInfo_;
  info[Token.ACTIONS_MENU_ENTRY] = {position:DrawingGroupPosition.OUTSIDE};
  info[Token.ANNOTATION] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.ANNOTATION_TEXT] = {position:DrawingGroupPosition.INSIDE};
  info[Token.AREA] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.BAR] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.BASELINE] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.BUBBLE] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.CATEGORY_SENSITIVITY_AREA] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.CANDLESTICK] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.HISTOGRAM] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.GRIDLINE] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.INTERVAL] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.LINE] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.MINOR_GRIDLINE] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.OVERLAY_BOX] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.PATH_INTERVAL] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.POINT] = {position:DrawingGroupPosition.INSIDE, allowLazyCreation:!1};
  info[Token.POINT_SENSITIVITY_AREA] = {position:DrawingGroupPosition.INSIDE};
  info[Token.STEPPED_AREA_BAR] = {position:DrawingGroupPosition.CLIPPED};
  info[Token.TOOLTIP] = {position:DrawingGroupPosition.OUTSIDE};
  var titlePosition = chartDef.titlePosition == gviz.canviz.Options.InOutPosition.INSIDE ? DrawingGroupPosition.INSIDE : DrawingGroupPosition.OUTSIDE;
  info[Token.TITLE] = {position:titlePosition};
  info[Token.AXIS_TICK] = {position:DrawingGroupPosition.INSIDE};
  var axisTitlePosition = chartDef.axisTitlesPosition == gviz.canviz.Options.InOutPosition.INSIDE ? DrawingGroupPosition.INSIDE : DrawingGroupPosition.OUTSIDE;
  info[Token.AXIS_TITLE] = {position:axisTitlePosition};
  var insideLegend = chartDef.legend && chartDef.legend.position == gviz.canviz.Options.LegendPosition.INSIDE, legendDrawingGroup = insideLegend ? this.legendDrawingGroup : null, legendDrawingGroupPosition = insideLegend ? DrawingGroupPosition.INSIDE : DrawingGroupPosition.OUTSIDE;
  info[Token.LEGEND] = {drawingGroup:legendDrawingGroup, position:legendDrawingGroupPosition};
  info[Token.LEGEND_SCROLL_BUTTON] = {drawingGroup:legendDrawingGroup, position:legendDrawingGroupPosition};
  info[Token.LEGEND_ENTRY] = {drawingGroup:legendDrawingGroup, position:legendDrawingGroupPosition};
  var insideColorBar = chartDef.colorBar && chartDef.colorBar.position == gviz.canviz.Options.ColorBarPosition.INSIDE, colorBarDrawingGroup = insideColorBar ? this.colorBarDrawingGroup : null, colorBarDrawingGroupPosition = insideColorBar ? DrawingGroupPosition.INSIDE : DrawingGroupPosition.OUTSIDE;
  info[Token.COLOR_BAR] = {drawingGroup:colorBarDrawingGroup, position:colorBarDrawingGroupPosition};
};
gviz.canviz.AxisChartBuilder.prototype.drawSerie_ = function(serie, serieIndex) {
  serie.type == gviz.canviz.Options.SerieType.BUBBLES ? this.drawBubbleSerie_(serie, serieIndex) : serie.type == gviz.canviz.Options.SerieType.BARS ? this.drawBarSerie_(serie, serieIndex) : serie.type == gviz.canviz.Options.SerieType.STEPPED_AREA ? this.drawBarSerie_(serie, serieIndex) : serie.type == gviz.canviz.Options.SerieType.CANDLESTICKS ? this.drawCandlestickSerie_(serie, serieIndex) : serie.type == gviz.canviz.Options.SerieType.AREA ? this.drawAreaSerie_(serie, serieIndex, this.chartDefinition.isStacked, 
  this.chartDefinition.interpolateNulls) : this.drawPathBasedSerie_(serie, serieIndex, this.chartDefinition.interpolateNulls);
  serie.intervals && serie.intervals.paths && this.drawPathIntervals_(serie, serieIndex);
};
gviz.canviz.AxisChartBuilder.prototype.drawPathIntervals_ = function(serie, serieIndex) {
  for (var intervalPaths = serie.intervals.paths, i = 0, intervalPath;intervalPath = intervalPaths[i];++i) {
    if (0 != intervalPath.line.length) {
      var path = new gviz.graphics.PathSegments;
      path.extendFromVertices(intervalPath.line, intervalPath.controlPoints);
      intervalPath.bottom && path.extendFromVertices(intervalPath.bottom, intervalPath.bottomControlPoints);
      var intervalsGroup = this.renderer.createGroup();
      this.renderer.drawPath(path, intervalPath.brush, intervalsGroup);
      var intervalsElement = intervalsGroup.getElement(), intervalToken = gviz.canviz.idutils.Token.PATH_INTERVAL, intervalsId = gviz.canviz.idutils.generateId([intervalToken, serieIndex, i]), pathIntervalsDrawingGroup = this.drawingGroupInfo_[intervalToken].drawingGroup;
      this.drawElement(pathIntervalsDrawingGroup, intervalsId, intervalsElement);
    }
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawDatum_ = function(serie, serieIndex, datum, datumIndex, opt_interpolateNulls) {
  serie.type == gviz.canviz.Options.SerieType.BARS || serie.type == gviz.canviz.Options.SerieType.STEPPED_AREA ? this.drawBar_(serie, serieIndex, datum, datumIndex) : serie.type == gviz.canviz.Options.SerieType.CANDLESTICKS ? this.drawCandlestick_(serie, serieIndex, datum, datumIndex) : serie.type == gviz.canviz.Options.SerieType.BUBBLES ? this.drawBubble_(serie, serieIndex, datum, datumIndex) : this.drawPoint_(serie, serieIndex, datum, datumIndex, opt_interpolateNulls);
};
gviz.canviz.AxisChartBuilder.prototype.drawBubbleSerie_ = function(serie, serieIndex) {
  var bubblesGroup = this.drawingGroupInfo_[gviz.canviz.idutils.Token.BUBBLE].drawingGroup, bubbleIndices = gviz.canviz.util.rangeMap(serie.points.length, function(i) {
    return i;
  });
  serie.sortBySize && goog.array.sort(bubbleIndices, function(i1, i2) {
    var bubble1 = serie.points[i1], bubble2 = serie.points[i2], size1 = bubble1 ? bubble1.scaled.radius : 0, size2 = bubble2 ? bubble2.scaled.radius : 0;
    return size2 - size1;
  });
  for (var i$$0 = 0;i$$0 < bubbleIndices.length;i$$0++) {
    var bubbleIndex = bubbleIndices[i$$0], bubble = serie.points[bubbleIndex];
    if (bubble) {
      this.drawBubble_(serie, serieIndex, bubble, bubbleIndex);
      var bubbleTextElement = this.renderer.drawText(bubble.text, bubble.scaled.x, bubble.scaled.y, bubble.textLength, gviz.graphics.TextAlign.CENTER, gviz.graphics.TextAlign.CENTER, bubble.textStyle, bubblesGroup), bubbleID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.BUBBLE, serieIndex, bubbleIndex]);
      this.renderer.setLogicalName(bubbleTextElement, bubbleID);
    }
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawBarSerie_ = function(serie, serieIndex) {
  for (var i = 0;i < serie.points.length;i++) {
    this.drawBar_(serie, serieIndex, serie.points[i], i);
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawBar_ = function(serie, serieIndex, bar, barIndex) {
  if (bar && bar.scaled) {
    var barBrush = bar.brush || gviz.canviz.chartdefinitionutil.getDatumBrush(bar, serie);
    goog.asserts.assert(barBrush);
    var barToken = serie.type == gviz.canviz.Options.SerieType.BARS ? gviz.canviz.idutils.Token.BAR : gviz.canviz.idutils.Token.STEPPED_AREA_BAR, barID = gviz.canviz.idutils.generateId([barToken, serieIndex, barIndex]), scaledBar = bar.scaled.bar || bar.scaled, barElement = this.renderer.createRect(scaledBar.left, scaledBar.top, scaledBar.width, scaledBar.height, barBrush), barGroup = null, outline = bar.scaled.outline, glow = bar.glow, ring = bar.ring;
    if (outline || glow || ring) {
      barGroup = this.renderer.createGroup();
      this.renderer.appendChild(barGroup, barElement);
      if (outline) {
        var lineBrush = bar.lineBrush || serie.lineBrush, pathSegments = gviz.graphics.PathSegments.fromVertices(outline, !0);
        this.renderer.drawPath(pathSegments, lineBrush, barGroup);
      }
      if (glow) {
        for (var i = 0;i < glow.levels.length;i++) {
          var glowRect = glow.levels[i].rect;
          this.renderer.drawRect(glowRect.left, glowRect.top, glowRect.width, glowRect.height, glow.levels[i].brush, barGroup);
        }
      }
      ring && this.renderer.drawRect(ring.rect.left, ring.rect.top, ring.rect.width, ring.rect.height, ring.brush, barGroup);
    }
    var barEventTarget = barGroup ? barGroup.getElement() : barElement, barsGroup = this.drawingGroupInfo_[barToken].drawingGroup;
    this.drawElement(barsGroup, barID, barEventTarget);
    if (bar.tooltip) {
      var tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, serieIndex, barIndex]);
      this.queueTooltip_(bar.tooltip, tooltipID);
    }
    bar.annotation && this.drawAnnotation_(bar.annotation, serie, serieIndex, barIndex);
    bar.scaled.intervalRects && this.drawIntervals_(serie, serieIndex, barIndex, bar.scaled.intervalRects);
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawAreaSerie_ = function(serie, serieIndex, isStacked, interpolateNulls) {
  if (0 != serie.points.length) {
    interpolateNulls = interpolateNulls && !isStacked;
    for (var areaPathRanges = [], areaPathRange = {start:null, end:null, brush:null}, i = 0;i <= serie.points.length;i++) {
      var point = serie.points[i];
      if (point && !point.isNull) {
        if (goog.isNull(areaPathRange.start)) {
          areaPathRange.start = i;
        } else {
          var areaBrush = gviz.canviz.chartdefinitionutil.getIncomingAreaBrush(point, serie);
          goog.isNull(areaPathRange.brush) || gviz.graphics.Brush.equals(areaPathRange.brush, areaBrush) ? (areaPathRange.end = i, areaPathRange.brush = areaBrush) : (areaPathRanges.push(areaPathRange), areaPathRange = {start:i - 1, end:i, brush:areaBrush});
        }
      } else {
        interpolateNulls && i !== serie.points.length || (goog.isNull(areaPathRange.start) || goog.isNull(areaPathRange.end) || areaPathRanges.push(areaPathRange), i < serie.points.length && (areaPathRange = {start:null, end:null, brush:null}));
      }
    }
    for (var areaGroup = this.renderer.createGroup(), i = 0;i < areaPathRanges.length;i++) {
      var areaPathRange = areaPathRanges[i], areaPath = {brush:areaPathRange.brush, segments:new gviz.graphics.PathSegments};
      this.addAreaPathSegments_(areaPath.segments, serie, isStacked, areaPathRange.start, areaPathRange.end);
      this.renderer.drawPath(areaPath.segments, areaPath.brush, areaGroup);
    }
    var areaID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.AREA, serieIndex]), areasGroup = this.drawingGroupInfo_[gviz.canviz.idutils.Token.AREA].drawingGroup;
    this.drawElement(areasGroup, areaID, areaGroup.getElement());
    if (isStacked) {
      var linePathSegments = gviz.canviz.chartdefinitionutil.createPathSegmentsForStackedArea(serie), lineID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.LINE, serieIndex]), lineElement = linePathSegments.createPath(this.renderer), lineGroup = this.findAndRenderLonelyPoints_(serie);
      if (lineElement) {
        var glow = serie.glow, ring = serie.ring;
        if (glow || ring) {
          lineGroup = lineGroup || this.renderer.createGroup();
          if (glow) {
            for (i = 0;i < glow.levels.length;i++) {
              this.renderer.drawPath(glow.levels[i].path, glow.levels[i].brush, lineGroup);
            }
          }
          ring && this.renderer.drawPath(ring.path, ring.brush, lineGroup);
        }
        lineGroup && this.renderer.appendChild(lineGroup, lineElement);
      }
      var lineEventTarget = lineGroup ? lineGroup.getElement() : lineElement;
      if (goog.isDefAndNotNull(lineEventTarget)) {
        var linesGroup = this.drawingGroupInfo_[gviz.canviz.idutils.Token.LINE].drawingGroup;
        this.drawElement(linesGroup, lineID, lineEventTarget);
      }
      this.drawPoints_(serie, serieIndex, interpolateNulls);
    } else {
      this.drawPathBasedSerie_(serie, serieIndex, interpolateNulls);
    }
  }
};
gviz.canviz.AxisChartBuilder.prototype.addAreaPathSegments_ = function(areaPathSegments, serie, isStacked, fromPoint, toPoint) {
  var allPointsAreNull = !0, lastConcretePoint = null;
  areaPathSegments.move(serie.points[fromPoint].scaled.bottomFromX, serie.points[fromPoint].scaled.bottomFromY);
  for (var i = fromPoint;i <= toPoint;i++) {
    var point = serie.points[i];
    goog.asserts.assert(point && point.scaled);
    var scaledPoint = point.scaled;
    point.isNull || (areaPathSegments.addLine(scaledPoint.continueToX, scaledPoint.continueToY), scaledPoint.continueFromX == scaledPoint.continueToX && scaledPoint.continueFromY == scaledPoint.continueToY || areaPathSegments.addLine(scaledPoint.continueFromX, scaledPoint.continueFromY), goog.isDefAndNotNull(scaledPoint.x) && goog.isDefAndNotNull(scaledPoint.y) && (allPointsAreNull = !1, lastConcretePoint = i));
  }
  if (!allPointsAreNull) {
    if (isStacked) {
      for (i = toPoint;i >= fromPoint;i--) {
        scaledPoint = serie.points[i].scaled, areaPathSegments.addLine(scaledPoint.bottomToX, scaledPoint.bottomToY), scaledPoint.bottomFromX == scaledPoint.bottomToX && scaledPoint.bottomFromY == scaledPoint.bottomToY || areaPathSegments.addLine(scaledPoint.bottomFromX, scaledPoint.bottomFromY);
      }
    } else {
      scaledPoint = serie.points[lastConcretePoint].scaled, areaPathSegments.addLine(scaledPoint.bottomToX, scaledPoint.bottomToY), areaPathSegments.close();
    }
  }
};
gviz.canviz.AxisChartBuilder.prototype.findAndRenderLonelyPoints_ = function(serie) {
  var pathGroup = null, lonelyPointBrush = null;
  goog.array.forEach(serie.points, function(point, pointIndex) {
    gviz.canviz.chartdefinitionutil.isLonelyPoint(serie, pointIndex) && (pathGroup || (pathGroup = this.renderer.createGroup()), lonelyPointBrush || (lonelyPointBrush = gviz.graphics.Brush.createFillBrush(serie.lineBrush.getStroke(), serie.lineBrush.getStrokeOpacity())), gviz.canviz.chartdefinitionutil.isDatumVisible(point, serie) || this.renderer.drawCircle(point.scaled.x, point.scaled.y, serie.lineWidth, lonelyPointBrush, pathGroup));
  }, this);
  return pathGroup;
};
gviz.canviz.AxisChartBuilder.prototype.drawPathBasedSerie_ = function(serie, serieIndex, interpolateNulls) {
  var pathID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.LINE, serieIndex]);
  if (0 >= serie.lineWidth) {
    this.deleteElementByID(pathID), this.drawPoints_(serie, serieIndex);
  } else {
    var pathSegments = gviz.canviz.chartdefinitionutil.createPathSegments(serie, interpolateNulls);
    if (!goog.array.isEmpty(pathSegments.segments)) {
      var pathElement = pathSegments.createPath(this.renderer), pathGroup = pathElement && interpolateNulls ? null : this.findAndRenderLonelyPoints_(serie);
      if (pathElement) {
        var glow = serie.glow, ring = serie.ring;
        if (glow || ring) {
          pathGroup || (pathGroup = this.renderer.createGroup());
          pathGroup = goog.asserts.assertObject(pathGroup);
          if (glow) {
            for (var i = 0;i < glow.levels.length;i++) {
              this.renderer.drawPath(glow.levels[i].path, glow.levels[i].brush, pathGroup);
            }
          }
          ring && this.renderer.drawPath(ring.path, ring.brush, pathGroup);
        }
        pathGroup && this.renderer.appendChild(pathGroup, pathElement);
      }
      var pathEventTarget = pathGroup ? pathGroup.getElement() : pathElement;
      if (goog.isDefAndNotNull(pathEventTarget)) {
        var linesGroup = this.drawingGroupInfo_[gviz.canviz.idutils.Token.LINE].drawingGroup;
        this.drawElement(linesGroup, pathID, pathEventTarget);
      }
      this.drawPoints_(serie, serieIndex, interpolateNulls);
    }
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawLinesBetweenOldAndNewData_ = function(chartDef, drawingGroup) {
  for (var serieIndex = 0, lenSeries = chartDef.series.length;serieIndex < lenSeries;serieIndex += 2) {
    var oldDataSerie = chartDef.series[serieIndex], newDataSerie = chartDef.series[serieIndex + 1], numberOfPoints = oldDataSerie.points.length;
    goog.asserts.assert(numberOfPoints == newDataSerie.points.length);
    if (0 != numberOfPoints) {
      for (var color = oldDataSerie.pointBrush.getFill(), opacity = oldDataSerie.pointBrush.getFillOpacity(), brush = new gviz.graphics.Brush({stroke:color, strokeOpacity:opacity, strokeWidth:1}), pointIndex = 0;pointIndex < numberOfPoints;pointIndex++) {
        var oldDataPoint = oldDataSerie.points[pointIndex], newDataPoint = newDataSerie.points[pointIndex];
        if (oldDataPoint && oldDataPoint.scaled && !oldDataPoint.isNull) {
          goog.asserts.assert(newDataPoint && newDataPoint.scaled || !newDataPoint.isNull);
          var x1 = oldDataPoint.scaled.x, y1 = oldDataPoint.scaled.y, x2 = newDataPoint.scaled.x, y2 = newDataPoint.scaled.y;
          this.renderer.drawLine(x1, y1, x2, y2, brush, drawingGroup);
        } else {
          goog.asserts.assert(!newDataPoint || !newDataPoint.scaled || newDataPoint.isNull);
        }
      }
    }
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawPoints_ = function(serie, serieIndex, opt_interpolateNulls) {
  for (var i = 0;i < serie.points.length;i++) {
    this.drawPoint_(serie, serieIndex, serie.points[i], i, opt_interpolateNulls);
  }
};
gviz.canviz.AxisChartBuilder.prototype.isPointInsideViewWindow_ = function(pointCenter, pointRadius) {
  var chartArea = this.chartDefinition.chartArea;
  if (pointCenter.x - pointRadius >= chartArea.right || pointCenter.x + pointRadius <= chartArea.left || pointCenter.y - pointRadius >= chartArea.bottom || pointCenter.y + pointRadius <= chartArea.top) {
    return!1;
  }
  if ((pointCenter.x >= chartArea.right || pointCenter.x <= chartArea.left) && (pointCenter.y >= chartArea.bottom || pointCenter.y <= chartArea.top)) {
    var r2 = pointRadius * pointRadius, xr = pointCenter.x - chartArea.right, xl = pointCenter.x - chartArea.left, yb = pointCenter.y - chartArea.bottom, yt = pointCenter.y - chartArea.top, xr2 = xr * xr, xl2 = xl * xl, yb2 = yb * yb, yt2 = yt * yt;
    if (xr2 + yb2 >= r2 && xr2 + yt2 >= r2 && xl2 + yt2 >= r2 && xl2 + yb2 >= r2) {
      return!1;
    }
  }
  return!0;
};
gviz.canviz.AxisChartBuilder.prototype.drawPoint_ = function(serie, serieIndex, point, pointIndex, opt_interpolateNulls) {
  var pointsGroup = this.drawingGroupInfo_[gviz.canviz.idutils.Token.POINT].drawingGroup, sensitivityAreasGroup = this.drawingGroupInfo_[gviz.canviz.idutils.Token.POINT_SENSITIVITY_AREA].drawingGroup;
  this.drawPointOrBubble_(serie, serieIndex, point, pointIndex, pointsGroup, sensitivityAreasGroup, opt_interpolateNulls);
};
gviz.canviz.AxisChartBuilder.prototype.drawBubble_ = function(serie, serieIndex, point, pointIndex) {
  var bubblesGroup = this.drawingGroupInfo_[gviz.canviz.idutils.Token.BUBBLE].drawingGroup;
  this.drawPointOrBubble_(serie, serieIndex, point, pointIndex, bubblesGroup, null);
};
gviz.canviz.AxisChartBuilder.prototype.createPoint_ = function(point, radius, brush) {
  var pointGroup = null, ring = point.ring, glow = point.glow, crosshair = point.crosshair;
  if (ring || glow || crosshair) {
    pointGroup = this.renderer.createGroup();
  }
  crosshair && this.renderer.drawPath(crosshair.path, crosshair.brush, pointGroup);
  var shape = point.shape;
  shape && shape.type || (shape = {type:"circle"});
  ring && this.drawMarker(ring.x, ring.y, ring.radius + .5, ring.brush, shape, pointGroup);
  if (glow) {
    for (var i = 0;i < glow.levels.length;i++) {
      this.drawMarker(glow.x, glow.y, glow.levels[i].radius, glow.levels[i].brush, shape, pointGroup);
    }
  }
  var pointElement = this.drawMarker(point.scaled.x, point.scaled.y, radius, brush, shape);
  pointGroup && this.renderer.appendChild(pointGroup, pointElement);
  return pointGroup ? pointGroup.getElement() : pointElement;
};
gviz.canviz.AxisChartBuilder.prototype.drawPointOrBubble_ = function(serie, serieIndex, point, pointIndex, pointsDrawingGroup) {
  if (point && point.scaled && !point.isNull) {
    var pointTotalRadius = gviz.canviz.chartdefinitionutil.getPointTotalRadius(point, serie);
    goog.asserts.assert(goog.isDefAndNotNull(pointTotalRadius));
    if (this.isPointInsideViewWindow_(point.scaled, pointTotalRadius)) {
      var pointOrBubble = serie.type == gviz.canviz.Options.SerieType.BUBBLES ? gviz.canviz.idutils.Token.BUBBLE : gviz.canviz.idutils.Token.POINT, pointID = gviz.canviz.idutils.generateId([pointOrBubble, serieIndex, pointIndex]), pointIsVisible = gviz.canviz.chartdefinitionutil.isDatumVisible(point, serie);
      goog.asserts.assert(goog.isDefAndNotNull(pointIsVisible));
      if (pointIsVisible) {
        var pointBrush = gviz.canviz.chartdefinitionutil.getDatumBrush(point, serie), pointRadius = gviz.canviz.chartdefinitionutil.getPointRadius(point, serie);
        goog.asserts.assert(goog.isDefAndNotNull(pointRadius));
        this.drawElement(pointsDrawingGroup, pointID, this.createPoint_(point, pointRadius, pointBrush));
      } else {
        this.deleteElementByID(pointID);
      }
      if (point.tooltip) {
        var tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, serieIndex, pointIndex]);
        this.queueTooltip_(point.tooltip, tooltipID);
      }
      point.annotation && this.drawAnnotation_(point.annotation, serie, serieIndex, pointIndex);
      point.scaled.intervalRects && this.drawIntervals_(serie, serieIndex, pointIndex, point.scaled.intervalRects);
    }
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawCandlestickSerie_ = function(serie, serieIndex) {
  for (var i = 0;i < serie.points.length;i++) {
    this.drawCandlestick_(serie, serieIndex, serie.points[i], i);
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawCandlestick_ = function(serie, serieIndex, candlestick, candlestickIndex) {
  if (candlestick && candlestick.scaled) {
    goog.asserts.assert(candlestick.barBrush);
    goog.asserts.assert(candlestick.lineBrush);
    var lineElement = this.renderer.createRect(candlestick.scaled.line.left, candlestick.scaled.line.top, candlestick.scaled.line.width, candlestick.scaled.line.height, candlestick.lineBrush), barElement = this.renderer.createRect(candlestick.scaled.rect.left, candlestick.scaled.rect.top, candlestick.scaled.rect.width, candlestick.scaled.rect.height, candlestick.barBrush), candlestickGroup = this.renderer.createGroup();
    this.renderer.appendChild(candlestickGroup, lineElement);
    this.renderer.appendChild(candlestickGroup, barElement);
    var glow = candlestick.glow;
    if (glow) {
      for (var i = 0;i < glow.levels.length;i++) {
        var glowRect = glow.levels[i].rect;
        this.renderer.drawRect(glowRect.left, glowRect.top, glowRect.width, glowRect.height, glow.levels[i].brush, candlestickGroup);
      }
    }
    var ring = candlestick.ring;
    ring && this.renderer.drawRect(ring.rect.left, ring.rect.top, ring.rect.width, ring.rect.height, ring.brush, candlestickGroup);
    var candlestickToken = gviz.canviz.idutils.Token.CANDLESTICK, candlestickID = gviz.canviz.idutils.generateId([candlestickToken, serieIndex, candlestickIndex]), candlesticksGroup = this.drawingGroupInfo_[candlestickToken].drawingGroup;
    this.drawElement(candlesticksGroup, candlestickID, candlestickGroup.getElement());
    if (candlestick.tooltip) {
      var tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, serieIndex, candlestickIndex]);
      this.queueTooltip_(candlestick.tooltip, tooltipID);
    }
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawAnnotation_ = function(annotation, serie, serieIndex, categoryIndex) {
  if (annotation) {
    var stem = annotation.stem, chartArea = this.chartDefinition.chartArea;
    if (!(!stem || stem.x < chartArea.left || stem.x > chartArea.right)) {
      var labels = annotation.labels;
      if (labels && !goog.array.isEmpty(labels)) {
        var idTokens = [gviz.canviz.idutils.Token.ANNOTATION, categoryIndex];
        goog.isDefAndNotNull(serieIndex) && goog.array.insertAt(idTokens, serieIndex, 1);
        var annotationID = gviz.canviz.idutils.generateId(idTokens), annotationGroup = this.createAxisAlignedLine_(stem.orientation, stem.x, stem.y, stem.length, stem.color);
        this.drawElement(this.drawingGroupInfo_[gviz.canviz.idutils.Token.ANNOTATION].drawingGroup, annotationID, annotationGroup);
        var annotationTextGroup = this.renderer.createGroup(), idTokens = [gviz.canviz.idutils.Token.ANNOTATION_TEXT, categoryIndex];
        goog.isDefAndNotNull(serieIndex) && goog.array.insertAt(idTokens, serieIndex, 1);
        var annotationIndex = null;
        annotation.bundle && !annotation.bundle.isExpanded && (labels = [annotation.bundle.label], annotationIndex = -1);
        for (var rect = this.renderer.disableClipping(), i = 0;i < labels.length;i++) {
          var label = labels[i], annotationLabelGroup = this.createTextBlock(label, !0);
          if (annotationLabelGroup) {
            if (label.tooltip_) {
              var tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, serieIndex, categoryIndex, i]);
              this.queueTooltip_(label.tooltip_, tooltipID);
            }
            this.renderer.appendChild(annotationTextGroup, annotationLabelGroup);
            var labelIdTokens = goog.array.clone(idTokens);
            labelIdTokens.push(annotationIndex || i);
            var annotationLabelID = gviz.canviz.idutils.generateId(labelIdTokens);
            this.registerElement(annotationLabelGroup, annotationLabelID);
          }
        }
        this.renderer.describeClipRegion(rect);
        var annotationBundleID = gviz.canviz.idutils.generateId(idTokens);
        this.drawElement(this.drawingGroupInfo_[gviz.canviz.idutils.Token.ANNOTATION_TEXT].drawingGroup, annotationBundleID, annotationTextGroup.getElement());
      }
    }
  }
};
gviz.canviz.AxisChartBuilder.prototype.createAxisAlignedLine_ = function(orientation, x, y, length, color) {
  var v = orientation == gviz.canviz.Options.Orientation.HORIZONTAL ? [length, 1] : [1, length];
  return this.renderer.createRect(Math.min(x, x + v[0]), Math.min(y, y + v[1]), Math.abs(v[0]), Math.abs(v[1]), new gviz.graphics.Brush({fill:color}));
};
gviz.canviz.AxisChartBuilder.prototype.drawIntervals_ = function(serie, serieIndex, datumIndex, intervalRects) {
  if (!goog.isDefAndNotNull(serie.intervals)) {
    return null;
  }
  for (var intervalsGroup = this.renderer.createGroup(), settingsOfColumn = serie.intervals.settings, i = 0;i < intervalRects.length;i++) {
    var columnIndex = intervalRects[i].columnIndex, rect = intervalRects[i].rect, settings = settingsOfColumn[columnIndex];
    if (settings && settings.style != gviz.canviz.Options.IntervalStyle.AREA && settings.style != gviz.canviz.Options.IntervalStyle.LINE) {
      var brush = settings.brush;
      if (0 == rect.width && 0 == rect.height) {
        var pointRadius = settings.pointSize / 2;
        if (0 < pointRadius) {
          var point = this.renderer.createCircle(rect.left, rect.top, pointRadius, brush);
          this.renderer.appendChild(intervalsGroup, point);
        }
      } else {
        if (0 == rect.width || 0 == rect.height) {
          var path = new gviz.graphics.PathSegments;
          path.move(rect.left, rect.top);
          path.addLine(rect.left + rect.width, rect.top + rect.height);
          this.renderer.drawPath(path, brush, intervalsGroup);
        } else {
          this.renderer.appendChild(intervalsGroup, this.renderer.createRect(rect.left, rect.top, rect.width, rect.height, brush));
        }
      }
    }
  }
  if (!intervalsGroup.isElementCreated()) {
    return null;
  }
  var intervalToken = gviz.canviz.idutils.Token.INTERVAL, intervalsId = gviz.canviz.idutils.generateId([intervalToken, serieIndex, datumIndex]), intervalsElement = intervalsGroup.getElement();
  this.drawElement(this.drawingGroupInfo_[intervalToken].drawingGroup, intervalsId, intervalsElement);
  return intervalsElement;
};
gviz.canviz.AxisChartBuilder.prototype.drawHorizontalAxisLines = function(chartDef, axisDef) {
  var drawAxisGridlineElement = goog.bind(function(tickline, drawingGroup) {
    var x = Math.floor(tickline.coordinate), length = goog.isDefAndNotNull(tickline.length) ? tickline.length : chartDef.chartArea.height, y1 = axisDef.ticklinesOrigin.coordinate, y2 = y1 + axisDef.ticklinesOrigin.direction * length, y = Math.min(y1, y2);
    return this.renderer.drawRect(x, y, 1, length, tickline.brush, drawingGroup);
  }, this), drawAxisTicklineElement = goog.bind(function(tickline, drawingGroup) {
    var x = Math.floor(tickline.coordinate), length = goog.isDefAndNotNull(tickline.length) ? tickline.length : chartDef.chartArea.bottom, y1 = axisDef.ticklinesOrigin.coordinate, y2 = y1 - axisDef.ticklinesOrigin.direction * length, y = Math.min(y1, y2);
    return this.renderer.drawRect(x, y, 1, length, tickline.brush, drawingGroup);
  }, this);
  this.drawAxisLines(axisDef, drawAxisGridlineElement, drawAxisTicklineElement);
};
gviz.canviz.AxisChartBuilder.prototype.drawVerticalAxisLines = function(chartDef, axisDef) {
  var drawAxisGridlineElement = goog.bind(function(tickline, drawingGroup) {
    var y = Math.floor(tickline.coordinate), length = goog.isDefAndNotNull(tickline.length) ? tickline.length : chartDef.chartArea.width, x1 = axisDef.ticklinesOrigin.coordinate, x2 = x1 + axisDef.ticklinesOrigin.direction * length, x = Math.min(x1, x2);
    return this.renderer.drawRect(x, y, length, 1, tickline.brush, drawingGroup);
  }, this), drawAxisTicklineElement = goog.bind(function(tickline, drawingGroup) {
    var y = Math.floor(tickline.coordinate), length = goog.isDefAndNotNull(tickline.length) ? tickline.length : chartDef.chartArea.left, x1 = axisDef.ticklinesOrigin.coordinate, x2 = x1 - axisDef.ticklinesOrigin.direction * length, x = Math.min(x1, x2);
    return this.renderer.drawRect(x, y, length, 1, tickline.brush, drawingGroup);
  }, this);
  this.drawAxisLines(axisDef, drawAxisGridlineElement, drawAxisTicklineElement);
};
gviz.canviz.AxisChartBuilder.prototype.drawAxisLines = function(axisDef, drawAxisGridlineElement, drawAxisTicklineElement) {
  var drawFunc = goog.bind(function(lines, token, drawAxisLineElement) {
    if (lines) {
      var drawingGroup = this.drawingGroupInfo_[token].drawingGroup, linesID = gviz.canviz.idutils.generateId([axisDef.name, token]);
      goog.array.forEach(lines, function(line, index) {
        var lineID = gviz.canviz.idutils.generateId([axisDef.name, token, index]);
        this.drawAxisLine(line, drawAxisLineElement, drawingGroup, lineID, linesID);
      }, this);
    }
  }, this);
  drawFunc(axisDef.gridlines, gviz.canviz.idutils.Token.GRIDLINE, drawAxisGridlineElement);
  drawFunc(axisDef.ticklines, gviz.canviz.idutils.Token.AXIS_TICK, drawAxisTicklineElement);
  var baselineDrawingGroup = this.drawingGroupInfo_[gviz.canviz.idutils.Token.BASELINE].drawingGroup, baselineID = gviz.canviz.idutils.generateId([axisDef.name, gviz.canviz.idutils.Token.BASELINE]);
  this.drawAxisLine(axisDef.baseline, drawAxisGridlineElement, baselineDrawingGroup, baselineID);
};
gviz.canviz.AxisChartBuilder.prototype.drawAxisLine = function(tickline, drawAxisLineElement, drawingGroup, id, opt_parentID) {
  if (tickline && tickline.isVisible && !tickline.brush.isTransparent()) {
    var element = drawAxisLineElement(tickline, drawingGroup);
    this.registerElement(element, id, opt_parentID);
  }
};
gviz.canviz.AxisChartBuilder.prototype.drawAxisText = function(chartDef, axisDef) {
  var drawingGroupInfo = this.drawingGroupInfo_, axisTitlesGroup = drawingGroupInfo[gviz.canviz.idutils.Token.AXIS_TITLE].drawingGroup, titleTextBlock = this.drawTextBlock(axisDef.title, axisTitlesGroup), axisTitleID = gviz.canviz.idutils.generateId([axisDef.name, gviz.canviz.idutils.Token.TITLE]);
  this.registerElement(titleTextBlock, axisTitleID);
  if (axisDef.text) {
    var axisTicksGroup = drawingGroupInfo[gviz.canviz.idutils.Token.AXIS_TICK].drawingGroup, axisLabelsID = gviz.canviz.idutils.generateId([axisDef.name, "label"]);
    goog.array.forEach(axisDef.text, function(textItem, index) {
      if (textItem.isVisible) {
        var labelTextBlock = this.drawTextBlock(textItem.textBlock, axisTicksGroup), axisLabelID = gviz.canviz.idutils.generateId([axisDef.name, "label", index]);
        this.registerElement(labelTextBlock, axisLabelID, axisLabelsID);
      }
    }, this);
  }
};
gviz.canviz.AxisChartBuilder.prototype.refreshChartContent = function(baseLayer, refreshLayer) {
  this.revertChartContentChanges(baseLayer);
  this.applyChartContentChanges_(baseLayer, refreshLayer);
};
gviz.canviz.AxisChartBuilder.prototype.revertChartContentChanges = function(baseLayer) {
  var refreshLayer = this.drawnRefreshLayer;
  if (refreshLayer) {
    for (var serieIndex in refreshLayer.series) {
      var serie = baseLayer.series[serieIndex], shortCircuitedPropsObj = {points:null}, shortCircuitedProps = goog.object.getKeys(shortCircuitedPropsObj);
      if (gviz.canviz.util.containsNoOtherProperties(refreshLayer.series[serieIndex], shortCircuitedProps)) {
        var changedDataPoints = refreshLayer.series[serieIndex].points, datumIndex;
        for (datumIndex in changedDataPoints) {
          var changedDatum = changedDataPoints[datumIndex];
          if (changedDatum.tooltip) {
            var tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, Number(serieIndex), Number(datumIndex)]);
            this.closeTooltip(tooltipID);
          }
          var changedAnnotation = changedDatum.annotation;
          if (changedAnnotation) {
            for (var annotationIndex in changedAnnotation.labels) {
              changedAnnotation.labels[annotationIndex].tooltip_ && (tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, Number(serieIndex), Number(datumIndex), Number(annotationIndex)]), this.closeTooltip(tooltipID));
            }
          }
          var datum = serie.points[datumIndex];
          this.drawDatum_(serie, Number(serieIndex), datum, Number(datumIndex), null != refreshLayer.interpolateNulls ? refreshLayer.interpolateNulls : baseLayer.interpolateNulls);
        }
      } else {
        for (datumIndex in refreshLayer.series[serieIndex].points) {
          refreshLayer.series[serieIndex].points[datumIndex].tooltip && (tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, Number(serieIndex), Number(datumIndex)]), this.closeTooltip(tooltipID));
        }
        this.drawSerie_(serie, Number(serieIndex));
      }
    }
    for (var categoryIndex in refreshLayer.categories) {
      var changedCategory = refreshLayer.categories[categoryIndex];
      changedCategory.tooltip && (tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, Number(categoryIndex)]), this.closeTooltip(tooltipID));
      if (changedAnnotation = changedCategory.annotation) {
        for (annotationIndex in changedAnnotation.labels) {
          changedAnnotation.labels[annotationIndex].tooltip_ && (tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, null, Number(categoryIndex), Number(annotationIndex)]), this.closeTooltip(tooltipID));
        }
        var annotation = baseLayer.categories[categoryIndex].annotation;
        this.drawAnnotation_(annotation, null, null, Number(categoryIndex));
      }
    }
    this.renderTooltips_();
  }
};
gviz.canviz.AxisChartBuilder.prototype.applyChartContentChanges_ = function(baseLayer, refreshLayer) {
  for (var serieIndex in refreshLayer.series) {
    var serie = baseLayer.series[serieIndex], shortCircuitedPropsObj = {points:null}, shortCircuitedProps = goog.object.getKeys(shortCircuitedPropsObj);
    if (gviz.canviz.util.containsNoOtherProperties(refreshLayer.series[serieIndex], shortCircuitedProps)) {
      for (var datumIndex in refreshLayer.series[serieIndex].points) {
        var layeredDatum = new gviz.util.LayeredObject(2);
        layeredDatum.setLayer(0, serie.points[datumIndex]);
        layeredDatum.setLayer(1, refreshLayer.series[serieIndex].points[datumIndex]);
        var datum = layeredDatum.compact();
        this.drawDatum_(serie, Number(serieIndex), datum, Number(datumIndex), refreshLayer.interpolateNulls);
      }
    } else {
      var layeredSerie = new gviz.util.LayeredObject(2);
      layeredSerie.setLayer(0, serie);
      layeredSerie.setLayer(1, refreshLayer.series[serieIndex]);
      var compactSerie = layeredSerie.compact();
      this.drawSerie_(compactSerie, Number(serieIndex));
    }
  }
  for (var categoryIndex in refreshLayer.categories) {
    if (refreshLayer.categories[categoryIndex].tooltip) {
      var tooltipID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.TOOLTIP, Number(categoryIndex)]);
      this.queueTooltip_(refreshLayer.categories[categoryIndex].tooltip, tooltipID);
    }
    if (refreshLayer.categories[categoryIndex].annotation) {
      var layeredAnnotation = new gviz.util.LayeredObject(2);
      layeredAnnotation.setLayer(0, baseLayer.categories[categoryIndex].annotation);
      layeredAnnotation.setLayer(1, refreshLayer.categories[categoryIndex].annotation);
      var annotation = layeredAnnotation.compact();
      this.drawAnnotation_(annotation, null, null, Number(categoryIndex));
    }
  }
  this.renderTooltips_();
};
// INPUT (javascript/gviz/devel/jsapi/common/text/line.js)
gviz.common.text = {};
gviz.common.text.Line = function(line) {
  this.x = line.x || 0;
  this.y = line.y || 0;
  this.coord_ = new gviz.math.Coordinate(this.x, this.y);
  this.length = line.length;
  this.text = line.text;
};
// INPUT (javascript/gviz/devel/jsapi/common/text/text-block.js)
gviz.common.text.TextBlock = function(textBlock) {
  this.text = textBlock.text;
  this.textStyle = textBlock.textStyle;
  this.lines = textBlock.lines;
  this.paralAlign = textBlock.paralAlign;
  this.perpenAlign = textBlock.perpenAlign;
  this.tooltip = void 0 !== textBlock.tooltip ? textBlock.tooltip : "";
  this.tooltipText = textBlock.tooltipText;
  this.angle = goog.isDefAndNotNull(textBlock.angle) ? textBlock.angle : 0;
  this.anchor = void 0 !== textBlock.anchor ? textBlock.anchor : null;
  this.truncated = !!textBlock.truncated;
};
gviz.common.text.TextBlock.Position = {TOP:"top", RIGHT:"right"};
gviz.common.text.TextBlock.prototype.calcLineBoundingBox = function(textLine) {
  goog.asserts.assert(!goog.isDefAndNotNull(this.angle) || 0 == this.angle, "Can only calculate the bounding box of axis aligned texts (angle is 0)");
  var anchor = this.anchor ? this.anchor : {x:0, y:0}, xStartEnd = gviz.graphics.TextAlign.getAbsoluteCoordinates(textLine.x + anchor.x, textLine.length, this.paralAlign), yStartEnd = gviz.graphics.TextAlign.getAbsoluteCoordinates(textLine.y + anchor.y, this.textStyle.fontSize, this.perpenAlign);
  return xStartEnd.start == xStartEnd.end || yStartEnd.start == yStartEnd.end ? null : new goog.math.Box(yStartEnd.start, xStartEnd.end, yStartEnd.end, xStartEnd.start);
};
gviz.common.text.TextBlock.prototype.calcBoundingBox = function() {
  var self = this, linesBoundingBoxes = goog.array.map(this.lines, function(line) {
    return self.calcLineBoundingBox(line);
  }), linesBoundingBoxes = goog.array.filter(linesBoundingBoxes, goog.isDefAndNotNull);
  return gviz.util.calcBoundingBox(linesBoundingBoxes);
};
gviz.common.text.TextBlock.createToFit = function(text, textStyle, position, boundingRect, textMeasureFunction, appendTooltips, opt_sideMargin, opt_topMargin) {
  var sideMargin = goog.isNumber(opt_sideMargin) ? opt_sideMargin : 0, topMargin = goog.isNumber(opt_topMargin) ? opt_topMargin : 0, textSize = textMeasureFunction(text, textStyle), fits = textSize.fitsInside(boundingRect.getSize()), label = {}, lines = [];
  label.text = text;
  label.textStyle = textStyle;
  if (position === gviz.common.text.TextBlock.Position.TOP) {
    var labelX = Math.floor(boundingRect.getCenter().x), labelY = boundingRect.top + topMargin;
    label.paralAlign = gviz.graphics.TextAlign.CENTER;
    label.perpenAlign = gviz.graphics.TextAlign.START;
  } else {
    if (position === gviz.common.text.TextBlock.Position.RIGHT) {
      labelX = boundingRect.left + (boundingRect.width - sideMargin), labelY = Math.floor(boundingRect.getCenter().y), label.paralAlign = gviz.graphics.TextAlign.END, label.perpenAlign = gviz.graphics.TextAlign.CENTER;
    } else {
      throw Error("Invalid text block position.");
    }
  }
  if (!fits || textSize.width > boundingRect.width - sideMargin) {
    if (textSize.height < boundingRect.height) {
      var maxLines = boundingRect.height / (textSize.height + 2), textLayout = gviz.canviz.textutils.calcTextLayout(textMeasureFunction, text, textStyle, boundingRect.width - sideMargin, maxLines), lines = textLayout.lines;
      if (textLayout.needTooltip) {
        var tooltipText = text;
        label.truncated = !0;
      }
    } else {
      if (boundingRect.height > textStyle.fontSize / 3) {
        tooltipText = text, lines = [gviz.canviz.Messages.MSG_MISSING_TEXT_INDICATION], labelY = Math.floor(boundingRect.getCenter().y), label.perpenAlign = gviz.graphics.TextAlign.CENTER, label.truncated = !0;
      } else {
        return null;
      }
    }
  }
  label.lines = [];
  if (lines.length) {
    for (var y = 0, i = 0, leni = lines.length;i < leni;i++) {
      label.lines.push(new gviz.common.text.Line({x:0, y:y, length:boundingRect.width, text:lines[i]})), y += textSize.height;
    }
  } else {
    label.lines.push(new gviz.common.text.Line({x:0, y:0, length:textSize.width, text:text}));
  }
  label.angle = 0;
  label.anchor = new gviz.math.Coordinate(labelX, labelY);
  appendTooltips && tooltipText && (label.tooltipText = {hasHtmlContent:!1, hasCustomContent:!1, content:tooltipText});
  return new gviz.common.text.TextBlock(label);
};
// INPUT (javascript/gviz/devel/jsapi/common/style.js)
google.visualization.style = {};
google.visualization.style.parseStyle = function(css) {
  for (var ruleSets = goog.array.filter(css.split("}"), function(item) {
    return goog.isDefAndNotNull(item) && "" !== goog.string.trim(item);
  }), rules = {}, i = 0;i < ruleSets.length;i++) {
    var ruleSet = ruleSets[i].split("{"), selectors = goog.array.map(ruleSet[0].split(","), goog.string.trim), style = goog.style.parseStyleAttribute(goog.string.trim(ruleSet[1]));
    0 === selectors.length ? goog.object.extend(rules, style) : goog.array.forEach(selectors, function(selector) {
      rules[selector] = rules[selector] || {};
      goog.object.extend(rules[selector], style);
    });
  }
  return rules;
};
// INPUT (javascript/gviz/devel/canviz/theme.js)
gviz.canviz.Theme = {};
gviz.canviz.Theme.themes_ = {};
gviz.canviz.Theme.predefinedThemesRegistered_ = !1;
gviz.canviz.Theme.THEME_NAME_CLASSIC = "classic";
gviz.canviz.Theme.THEME_NAME_MAXIMIZED = "maximized";
gviz.canviz.Theme.THEME_NAME_SPARKLINE = "sparkline";
gviz.canviz.Theme.registerTheme = function(theme, name) {
  gviz.canviz.Theme.themes_[name] = theme;
};
gviz.canviz.Theme.registerPredefinedThemes_ = function() {
  var registerTheme = gviz.canviz.Theme.registerTheme, theme = {colors:[{color:"#dea19b", dark:"#ad7d79", light:"#ffd1c9"}, {color:"#cdc785", dark:"#aea971", light:"#eeeeac"}, {color:"#d6b9db", dark:"#a992ad", light:"#fff0db"}, {color:"#a2c488", dark:"#7f9a6b", light:"#d2feb0"}, {color:"#ffbc46", dark:"#ce9839", light:"#eeee5b"}, {color:"#9bbdde", dark:"#7993ad", light:"#c991ff"}], backgroundColor:{gradient:{color1:"#8080ff", color2:"#000020", x1:"0%", y1:"0%", x2:"100%", y2:"100%"}}, titleTextStyle:{color:"white"}, 
  hAxis:{textStyle:{color:"white"}, titleTextStyle:{color:"white"}}, vAxis:{textStyle:{color:"white"}, titleTextStyle:{color:"white"}}, legend:{textStyle:{color:"white"}}, chartArea:{backgroundColor:{stroke:"#e0e0e0", fill:"none"}}, areaOpacity:.8};
  registerTheme(theme, gviz.canviz.Theme.THEME_NAME_CLASSIC);
  theme = {titlePosition:"in", axisTitlesPosition:"in", legend:{position:"in"}, chartArea:{width:"100%", height:"100%"}, vAxis:{textPosition:"in"}, hAxis:{textPosition:"in"}};
  registerTheme(theme, gviz.canviz.Theme.THEME_NAME_MAXIMIZED);
  theme = {enableInteractivity:!1, legend:{position:"none"}, seriesType:"area", lineWidth:1.6, chartArea:{width:"100%", height:"100%"}, vAxis:{textPosition:"none", gridlines:{color:"none"}, baselineColor:"none"}, hAxis:{textPosition:"none", gridlines:{color:"none"}, baselineColor:"none"}};
  registerTheme(theme, gviz.canviz.Theme.THEME_NAME_SPARKLINE);
  gviz.canviz.Theme.predefinedThemesRegistered_ = !0;
};
gviz.canviz.Theme.getTheme = function(name) {
  gviz.canviz.Theme.predefinedThemesRegistered_ || gviz.canviz.Theme.registerPredefinedThemes_();
  return gviz.canviz.Theme.themes_[name];
};
gviz.canviz.Theme.toStandardColor = function(color) {
  var standardColor = {};
  standardColor.color = color.color || color;
  var hexColor = gviz.graphics.util.parseColor(standardColor.color);
  if (hexColor == gviz.graphics.util.NO_COLOR) {
    standardColor.dark = color.darker || hexColor, standardColor.light = color.lighter || hexColor;
  } else {
    var rgbColor = goog.color.hexToRgb(hexColor);
    standardColor.dark = color.darker || goog.color.rgbArrayToHex(goog.color.darken(rgbColor, .25));
    standardColor.light = color.lighter || goog.color.rgbArrayToHex(goog.color.lighten(rgbColor, .25));
  }
  return standardColor;
};
// INPUT (javascript/gviz/devel/canviz/bubble-chart-definer.js)
gviz.canviz.BubbleChartDefiner = function(dataView, options, textMeasureFunction, chartDef) {
  this.dataView_ = dataView;
  this.options_ = options;
  this.chartDef_ = chartDef;
  this.textMeasureFunction_ = textMeasureFunction;
  var defaultTextStyle = {fontName:chartDef.defaultFontName, fontSize:chartDef.defaultFontSize, auraColor:chartDef.insideLabelsAuraColor};
  this.textStyle_ = this.options_.inferTextStyleValue("bubble.textStyle", defaultTextStyle);
  this.stroke_ = this.options_.inferColorValue("bubble.stroke", gviz.canviz.BubbleChartDefiner.DEFAULT_BUBBLE_STROKE);
  this.opacity_ = this.options_.inferRatioNumberValue("bubble.opacity", gviz.canviz.BubbleChartDefiner.DEFAULT_BUBBLE_OPACITY);
  this.nameColumnIdx_ = 0;
  this.xColumnIdx_ = 1;
  this.yColumnIdx_ = 2;
  this.colorColumnIdx_ = 3;
  this.sizeColumnIdx_ = 4;
  this.colorDataType_ = this.sizeColumnLabel_ = this.colorColumnLabel_ = this.yColumnLabel_ = this.xColumnLabel_ = "";
  this.discreteColors_ = this.options_.inferValue("colors", gviz.canviz.Options.DEFAULT_DISCRETE_COLORS);
  this.defaultColor_ = gviz.canviz.Theme.toStandardColor(this.discreteColors_[0]).color;
  this.sizeScale_ = this.colorScale_ = this.sizeRange_ = this.colorRange_ = this.orderedColorGroups_ = this.colorGroups_ = null;
  this.init_();
};
gviz.canviz.BubbleChartDefiner.DEFAULT_BUBBLE_OPACITY = .8;
gviz.canviz.BubbleChartDefiner.DEFAULT_BUBBLE_STROKE = "#ccc";
gviz.canviz.BubbleChartDefiner.prototype.init_ = function() {
  var chartDef = this.chartDef_, dataView = this.dataView_, numOfCols = dataView.getNumberOfColumns();
  if (3 > numOfCols) {
    throw Error("Data table should have at least 3 columns");
  }
  var validateColumnType = function(columnIndex, shouldEqual, expectedTypes) {
    if (dataView.getNumberOfColumns() <= columnIndex) {
      return "";
    }
    var actualType = dataView.getColumnType(columnIndex);
    if (shouldEqual && !goog.array.contains(expectedTypes, actualType)) {
      throw Error("Column " + columnIndex + " must be of type " + expectedTypes.join("/"));
    }
    if (!shouldEqual && goog.array.contains(expectedTypes, actualType)) {
      throw Error("Column " + columnIndex + " cannot be of type " + expectedTypes.join("/"));
    }
    return actualType;
  };
  validateColumnType(this.nameColumnIdx_, !0, ["string"]);
  var xDataType = validateColumnType(this.xColumnIdx_, !1, ["string"]), yDataType = validateColumnType(this.yColumnIdx_, !1, ["string"]);
  this.xColumnLabel_ = dataView.getColumnLabel(this.xColumnIdx_);
  this.yColumnLabel_ = dataView.getColumnLabel(this.yColumnIdx_);
  goog.isNumber(this.colorColumnIdx_) && this.colorColumnIdx_ < numOfCols ? (this.colorDataType_ = validateColumnType(this.colorColumnIdx_, !0, ["number", "string"]), "string" == this.colorDataType_ && (this.colorGroups_ = {}, this.orderedColorGroups_ = []), this.colorColumnLabel_ = dataView.getColumnLabel(this.colorColumnIdx_)) : this.colorColumnIdx_ = null;
  var sortBySize = !1;
  goog.isNumber(this.sizeColumnIdx_) && this.sizeColumnIdx_ < numOfCols ? (validateColumnType(this.sizeColumnIdx_, !0, ["number"]), this.sizeColumnLabel_ = dataView.getColumnLabel(this.sizeColumnIdx_), sortBySize = this.options_.inferBooleanValue("sortBubblesBySize", !0)) : this.sizeColumnIdx_ = null;
  chartDef.categories = [];
  chartDef.dataTableToCategoryMap = {};
  for (var i = 0;i < dataView.getNumberOfRows();i++) {
    var dataTableIdx = dataView.getTableRowIndex(i);
    chartDef.dataTableToCategoryMap[dataTableIdx] = i;
  }
  chartDef.series = [{type:gviz.canviz.Options.SerieType.BUBBLES, enableInteractivity:this.options_.inferBooleanValue(["series.0.enableInteractivity", "enableInteractivity"], !0), visiblePoints:!0, showTooltip:!0, sortBySize:sortBySize, points:[], colorGroups:this.colorGroups_, orderedColorGroups:this.orderedColorGroups_}];
  chartDef.domainDataType = xDataType;
  chartDef.targetAxisToDataType = [yDataType];
  chartDef.serieTypeCount = {};
  chartDef.serieTypeCount[gviz.canviz.Options.SerieType.BUBBLES] = 1;
  chartDef.legendEntries = [];
};
gviz.canviz.BubbleChartDefiner.prototype.isContinuousColorMode = function() {
  return "number" == this.colorDataType_;
};
gviz.canviz.BubbleChartDefiner.prototype.findValuesClosestToZero = function(hAxis, vAxis) {
  for (var dataView = this.dataView_, i = 0;i < dataView.getNumberOfRows();i++) {
    var xValue = dataView.getValue(i, this.xColumnIdx_), yValue = dataView.getValue(i, this.yColumnIdx_), xNumeric = hAxis.valueScale.valueToUnscaledNumber(xValue), yNumeric = vAxis.valueScale.valueToUnscaledNumber(yValue);
    goog.isDefAndNotNull(xNumeric) && hAxis.markClosestValueToZero(xNumeric);
    goog.isDefAndNotNull(yNumeric) && vAxis.markClosestValueToZero(yNumeric);
  }
};
gviz.canviz.BubbleChartDefiner.prototype.calcBubblesLayout = function(hAxis, vAxis, colorBarDefiner) {
  for (var i = 0;i < this.dataView_.getNumberOfRows();i++) {
    var point = this.calcBubbleLayout_(hAxis, vAxis, i);
    this.chartDef_.series[0].points.push(point);
  }
  if ("number" == this.colorDataType_) {
    this.colorScale_ = gviz.colorbar.Scale.create(this.options_, this.colorRange_), colorBarDefiner.setScale(this.colorScale_);
  } else {
    if ("string" == this.colorDataType_) {
      for (i = 0;i < this.orderedColorGroups_.length;i++) {
        var colorGroupName = this.orderedColorGroups_[i], colorGroup = this.colorGroups_[colorGroupName];
        colorGroup.visibleInLegend && this.chartDef_.legendEntries.push({index:i, id:colorGroupName, text:colorGroup.labelInLegend, brush:new gviz.graphics.Brush({fill:colorGroup.color}), isVisible:!0});
      }
    }
  }
  this.sizeScale_ = gviz.SizeScale.create(this.options_, this.sizeRange_);
};
gviz.canviz.BubbleChartDefiner.prototype.calcBubbleLayout_ = function(hAxis, vAxis, idx) {
  var dataView = this.dataView_, id = dataView.getValue(idx, this.nameColumnIdx_), name = dataView.getFormattedValue(idx, this.nameColumnIdx_), xValue = dataView.getValue(idx, this.xColumnIdx_), yValue = dataView.getValue(idx, this.yColumnIdx_), color = null;
  if (goog.isDefAndNotNull(this.colorColumnIdx_) && (color = dataView.getValue(idx, this.colorColumnIdx_), !goog.isDefAndNotNull(color))) {
    return null;
  }
  var size = null;
  if (goog.isDefAndNotNull(this.sizeColumnIdx_) && (size = dataView.getValue(idx, this.sizeColumnIdx_), !goog.isDefAndNotNull(size))) {
    return null;
  }
  var nameLength = this.textMeasureFunction_(name, this.textStyle_).width;
  if ("number" == this.colorDataType_) {
    this.colorRange_ = gviz.util.extendRangeToInclude(this.colorRange_, color);
  } else {
    if ("string" == this.colorDataType_) {
      var colorGroupName = color, colorGroup = this.colorGroups_[colorGroupName];
      if (!colorGroup) {
        var index = this.orderedColorGroups_.length, optionPrefix = "series." + colorGroupName + ".", rawColor = this.options_.inferColorValue(optionPrefix + "color", this.discreteColors_[index % this.discreteColors_.length]), realColor = gviz.canviz.Theme.toStandardColor(rawColor), visibleInLegend = this.options_.inferBooleanValue(optionPrefix + "visibleInLegend", !0), labelInLegend = this.options_.inferStringValue(optionPrefix + "labelInLegend", colorGroupName), colorGroup = {color:realColor.color, 
        visibleInLegend:visibleInLegend, labelInLegend:labelInLegend};
        this.colorGroups_[colorGroupName] = colorGroup;
        this.orderedColorGroups_.push(colorGroupName);
      }
    }
  }
  this.sizeRange_ = gviz.util.extendRangeToInclude(this.sizeRange_, size);
  var xNumeric = hAxis.valueScale.valueToNumber(xValue), yNumeric = vAxis.valueScale.valueToNumber(yValue);
  if (goog.isNull(xNumeric) || goog.isNull(yNumeric)) {
    return null;
  }
  var shouldExtendAxesRange = hAxis.isValueInViewWindow(xNumeric) && vAxis.isValueInViewWindow(yNumeric);
  shouldExtendAxesRange && (hAxis.extendRangeToIncludeNumber(xNumeric), vAxis.extendRangeToIncludeNumber(yNumeric));
  var tooltipText = this.calcTooltipText_(idx, name);
  return{id:id, text:name, textLength:nameLength, textStyle:this.textStyle_, tooltipText:tooltipText, nonScaled:{x:xNumeric, y:yNumeric, color:color, size:size}};
};
gviz.canviz.BubbleChartDefiner.prototype.calcTooltipText_ = function(idx, name) {
  var dataView = this.dataView_, x = dataView.getFormattedValue(idx, this.xColumnIdx_), y = dataView.getFormattedValue(idx, this.yColumnIdx_), lines = [{title:this.xColumnLabel_, value:x}, {title:this.yColumnLabel_, value:y}];
  if (goog.isDefAndNotNull(this.colorColumnIdx_)) {
    var color = dataView.getFormattedValue(idx, this.colorColumnIdx_);
    lines.push({title:this.colorColumnLabel_, value:color});
  }
  if (goog.isDefAndNotNull(this.sizeColumnIdx_)) {
    var size = dataView.getFormattedValue(idx, this.sizeColumnIdx_);
    lines.push({title:this.sizeColumnLabel_, value:size});
  }
  return{title:name, lines:lines};
};
gviz.canviz.BubbleChartDefiner.prototype.scaleBubble = function(hAxis, vAxis, nonScaledPoint) {
  var x = hAxis.calcPositionForNumericValue(nonScaledPoint.x), y = vAxis.calcPositionForNumericValue(nonScaledPoint.y), color;
  "number" == this.colorDataType_ ? (goog.asserts.assert(this.colorScale_), color = this.colorScale_.getColorFor(nonScaledPoint.color)) : color = "string" == this.colorDataType_ ? this.colorGroups_[nonScaledPoint.color].color : this.defaultColor_;
  var brush = new gviz.graphics.Brush({fill:color, fillOpacity:this.opacity_, stroke:this.stroke_});
  goog.asserts.assert(this.sizeScale_);
  var radius = this.sizeScale_.getRadiusFor(nonScaledPoint.size);
  return{x:x, y:y, brush:brush, radius:radius, sensitivityAreaRadius:radius};
};
// INPUT (research/infovis/autovis/ui/js/value.js)
var autovis = {Value:{}};
autovis.Value.Types = {DATE:"date", DATE_YMD:"date-ymd", DATE_YM:"date-ym", DATE_MD:"date-md", NUMBER:"number", NUMBER_Y:"number-y", STRING:"string", UNKNOWN:"unknown"};
autovis.Value.PATTERN_YEAR_ = /(\s|^)(1[1-9]|20)[0-9](0s|[0-9])(\s|$)/g;
autovis.Value.PRETTY_NUMBER_MAX_SIG_FIG_ = 5;
autovis.Value.isUnknownType = function(value) {
  return 0 == value.length || /^n[.\/]a.?$/i.test(value) || /^[^a-z0-9]+$/i.test(value);
};
autovis.Value.isGvizDateType = function(type) {
  return 0 <= goog.array.indexOf([autovis.Value.Types.DATE, autovis.Value.Types.DATE_YMD, autovis.Value.Types.DATE_YM, autovis.Value.Types.DATE_MD], type);
};
autovis.Value.isDateType = function(type) {
  return autovis.Value.isGvizDateType(type) || type == autovis.Value.Types.NUMBER_Y;
};
autovis.Value.getGvizDataType = function(type) {
  return autovis.Value.isGvizDateType(type) ? "date" : autovis.Value.isGvizNumberType(type) ? "number" : type == autovis.Value.Types.UNKNOWN ? "string" : type;
};
autovis.Value.isGvizNumberType = function(type) {
  return 0 <= goog.array.indexOf([autovis.Value.Types.NUMBER, autovis.Value.Types.NUMBER_Y], type);
};
autovis.Value.getYears = function(value) {
  return goog.isDefAndNotNull(value) ? value.match(autovis.Value.PATTERN_YEAR_) : null;
};
autovis.Value.isYear = function(value) {
  autovis.Value.PATTERN_YEAR_.lastIndex = 0;
  return goog.isDefAndNotNull(value) && autovis.Value.PATTERN_YEAR_.test(value);
};
autovis.Value.isYearRange = function(value) {
  for (var fragments = value.split(/\s*[^a-z0-9]\s*/i), i = 0;i < fragments.length;i++) {
    if (!autovis.Value.isYear(fragments[i])) {
      return!1;
    }
  }
  return!0;
};
autovis.Value.stripYears = function(value) {
  return value.replace(autovis.Value.PATTERN_YEAR_, "");
};
autovis.Value.removeBrackets = function(value) {
  return value.replace(/\s*\(.*\)\s*/g, "").replace(/\s*\[.*\]\s*/g, "");
};
autovis.Value.calculateNormalizeFactor = function(value) {
  return 0 == value ? 1 : Math.pow(10, Math.ceil(-Math.log(Math.abs(value)) / Math.LN10) - 1);
};
autovis.Value.getPrettyNumberInRange = function(value, lowerBound, upperBound, roundFn) {
  if (value > upperBound || value < lowerBound || lowerBound >= upperBound) {
    return value;
  }
  var sigfig = 1, prettyValue = value;
  do {
    prettyValue = autovis.Value.getPrettyNumberWithSigFig(value, sigfig, roundFn), sigfig++;
  } while (!(prettyValue >= lowerBound && prettyValue <= upperBound) && sigfig < autovis.Value.PRETTY_NUMBER_MAX_SIG_FIG_);
  return sigfig < autovis.Value.PRETTY_NUMBER_MAX_SIG_FIG_ ? prettyValue : value;
};
autovis.Value.getPrettyNumberWithSigFig = function(value, maxSigFig, roundFn) {
  if (0 == value || !goog.math.isFiniteNumber(value) || 0 >= maxSigFig) {
    return value;
  }
  var normalizeFactor = autovis.Value.calculateNormalizeFactor(value) * Math.pow(10, Math.max(0, maxSigFig)), normalizeFactor = normalizeFactor * (0 < value ? 1 : -1);
  return Math.max(5 * roundFn(normalizeFactor * value / 5), 1) / normalizeFactor;
};
autovis.Value.isNegNumber_ = function(value) {
  return/^\$?\s*[\u002d\u2010\u2011\u2012\u2013\u2212\ufe63]/.test(value);
};
autovis.Value.isStringLikelyNumeric = function(value) {
  if (!/[0-9]/g.test(value) || /^[0-9]+[a-z]+[0-9]+$/i.test(value)) {
    return 0;
  }
  var score = 1, testValue = autovis.Value.removeBrackets(value);
  0 == testValue.length ? testValue = value : testValue.length != value.length && (score = .5);
  var testValue = testValue.replace(/^[^0-9a-z]/i, ""), nonNumberCharacters = testValue.match(/[^0-9.%,\s$]/g), nonNumberCount = goog.isDefAndNotNull(nonNumberCharacters) ? nonNumberCharacters.length : 0;
  return 10 < nonNumberCount ? 0 : 0 < nonNumberCount ? .5 : score;
};
autovis.Value.getFormatter = function(type) {
  var format = autovis.Value.getFormat(type);
  return goog.isDefAndNotNull(format) ? new google.visualization.DateFormat({pattern:format}) : null;
};
autovis.Value.getFormat = function(type) {
  return type == autovis.Value.Types.DATE_YM ? "MMM yyyy" : type == autovis.Value.Types.DATE_MD ? "MMM d" : type == autovis.Value.Types.NUMBER_Y ? "yyyy" : null;
};
autovis.Value.getColumnPattern = function(type) {
  return type == autovis.Value.Types.NUMBER_Y ? "####" : autovis.Value.getFormat(type);
};
autovis.Value.isPhoneNumber = function(value) {
  return!/^[0-9]+\.[0-9]{3}$/.test(value) && (/^(\+?[0-9]{2,3}[-|\s])?([0-9]{3}-){1,2}[0-9]{3,4}$/.test(value) || /^(\+?[0-9]{2,3}[\.|\s])?([0-9]{3}\.){1,2}[0-9]{3,4}$/.test(value));
};
autovis.Value.convertToDurationAsSeconds = function(value) {
  var matchedValue = value.match(/^([0-9]+:){1,2}[0-9]{2}(\.[0-9]+)?$/);
  if (!goog.isDefAndNotNull(matchedValue)) {
    return null;
  }
  for (var timeComponents = matchedValue[0].split(":"), seconds = 0, i = timeComponents.length - 1;0 <= i;i--) {
    seconds += parseFloat(timeComponents[i]) * Math.pow(60, timeComponents.length - 1 - i);
  }
  return isNaN(seconds) ? null : seconds;
};
autovis.Value.convertFeetInchesToInches = function(value) {
  var matchedValue = value.match(/^[0-9]+\'\s?([0-9]+(\s1\/2)?)?\"?/);
  if (!goog.isDefAndNotNull(matchedValue)) {
    return null;
  }
  var components = matchedValue[0].split("'"), feet = parseInt(components[0], 10);
  if (isNaN(feet)) {
    return null;
  }
  var inches = parseInt(components[1], 10);
  if (isNaN(inches)) {
    return null;
  }
  goog.isDefAndNotNull(components[1].match(/1\/2/)) && (inches += .5);
  return 12 * feet + inches;
};
// INPUT (research/infovis/autovis/ui/js/columnbuckets.js)
autovis.ColumnBuckets = function() {
  this.bucketSize_ = 0;
  this.lastBucketStartBoundary_ = this.firstValueBucketStartBoundary_ = -1;
  this.firstValueBucketIndex_ = 0;
  this.lastBucketIndex_ = -1;
};
autovis.ColumnBuckets.LABEL_NUMBER_PRECISION_ = 10;
autovis.ColumnBuckets.prototype.create = function(arr, excludePercentile, opt_bucketSize, opt_minBucketNum, opt_maxBucketNum) {
  if (0 != arr.length && (arr = goog.array.filter(arr, function(item) {
    return goog.isDefAndNotNull(item);
  }), goog.array.sort(arr), 0 != arr.length)) {
    if (arr[0] == arr[arr.length - 1]) {
      this.bucketSize_ = 1, this.firstValueBucketStartBoundary_ = arr[0], this.lastBucketStartBoundary_ = arr[0], this.lastBucketIndex_ = 0;
    } else {
      var medianIndex = this.calcPercentileRank_(arr, 50) - 1, pctMaxIndex = Math.min(arr.length - 1, this.calcPercentileRank_(arr, 100 - excludePercentile) - 1), pctMinIndex = Math.max(0, this.calcPercentileRank_(arr, excludePercentile) - 1), isInt = this.isColumnInt_(arr), bucketMin = arr[medianIndex] - Math.min(arr[medianIndex] - arr[0], 1.5 * (arr[medianIndex] - arr[pctMinIndex]));
      bucketMin != arr[0] && (this.firstValueBucketIndex_ = 1, isInt && (bucketMin = Math.floor(bucketMin)));
      var bucketMax = arr[medianIndex] + Math.min(arr[arr.length - 1] - arr[medianIndex], 1.5 * (arr[pctMaxIndex] - arr[medianIndex])), bucketValues = goog.array.filter(arr, function(item) {
        return item < bucketMax && item > bucketMin;
      });
      this.bucketSize_ = goog.isNumber(opt_bucketSize) && 0 < opt_bucketSize ? opt_bucketSize : this.calcBucketSize_(bucketMin, bucketMax, bucketValues.length, isInt, opt_minBucketNum, opt_maxBucketNum);
      this.firstValueBucketStartBoundary_ = this.bucketSize_ * (1 == this.firstValueBucketIndex_ ? Math.round(bucketMin / this.bucketSize_) : Math.floor(bucketMin / this.bucketSize_));
      1 == this.firstValueBucketIndex_ && this.firstValueBucketStartBoundary_ < arr[0] && (this.firstValueBucketIndex_ = 0);
      var lastValueBucketIndex = Math.floor((bucketMax - this.firstValueBucketStartBoundary_) / this.bucketSize_);
      this.lastBucketStartBoundary_ = this.bucketSize_ * lastValueBucketIndex + this.firstValueBucketStartBoundary_;
      this.lastBucketIndex_ = lastValueBucketIndex + this.firstValueBucketIndex_;
    }
  }
};
autovis.ColumnBuckets.prototype.isColumnInt_ = function(columnValues) {
  for (var i = 0;i < columnValues.length;i++) {
    if (!goog.math.isInt(columnValues[i])) {
      return!1;
    }
  }
  return!0;
};
autovis.ColumnBuckets.prototype.getBucketIndexByValue = function(value) {
  return 0 == this.bucketSize_ || value < this.firstValueBucketStartBoundary_ ? 0 : value >= this.lastBucketStartBoundary_ ? this.lastBucketIndex_ : Math.floor((value - this.firstValueBucketStartBoundary_) / this.bucketSize_) + this.firstValueBucketIndex_;
};
autovis.ColumnBuckets.prototype.getBucketLabels = function() {
  var bucketLabels = [];
  1 == this.firstValueBucketIndex_ && bucketLabels.push("< " + (this.firstValueBucketStartBoundary_.toPrecision(autovis.ColumnBuckets.LABEL_NUMBER_PRECISION_) - 0));
  for (var lastValueIndex = this.lastBucketIndex_ - this.firstValueBucketIndex_, i = 0;i < lastValueIndex + 1;i++) {
    bucketLabels.push((i * this.bucketSize_ + this.firstValueBucketStartBoundary_).toPrecision(autovis.ColumnBuckets.LABEL_NUMBER_PRECISION_) - 0 + "+");
  }
  return bucketLabels;
};
autovis.ColumnBuckets.prototype.getBucketValues = function() {
  for (var bucketValues = [], i = 0;i <= this.lastBucketIndex_ + 1;i++) {
    bucketValues.push((i - this.firstValueBucketIndex_) * this.bucketSize_ + this.firstValueBucketStartBoundary_);
  }
  return bucketValues;
};
autovis.ColumnBuckets.prototype.getBucketSize = function() {
  return this.bucketSize_;
};
autovis.ColumnBuckets.prototype.calcBucketSize_ = function(min, max, length, isInt, opt_minBucketNum, opt_maxBucketNum) {
  if (min == max) {
    return 1;
  }
  if (0 == length) {
    return max - min;
  }
  var targetBucketSize = (max - min) / this.getOptimalBucketNum_(length, opt_minBucketNum, opt_maxBucketNum), prettyValue = autovis.Value.getPrettyNumberInRange(targetBucketSize, .8 * targetBucketSize, 1.2 * targetBucketSize, Math.round);
  return isInt ? .5 < prettyValue ? Math.round(prettyValue) : 1 : prettyValue;
};
autovis.ColumnBuckets.prototype.getOptimalBucketNum_ = function(length, opt_minBucketNum, opt_maxBucketNum) {
  var bucketNum = Math.sqrt(length), hasValidMinBucketNum = goog.isDefAndNotNull(opt_minBucketNum) && 0 < opt_minBucketNum, hasValidMaxBucketNum = goog.isDefAndNotNull(opt_maxBucketNum) && 0 < opt_maxBucketNum;
  return hasValidMinBucketNum && hasValidMaxBucketNum ? opt_maxBucketNum > opt_minBucketNum ? goog.math.clamp(bucketNum, opt_minBucketNum, opt_maxBucketNum) : bucketNum : hasValidMinBucketNum ? Math.max(bucketNum, opt_minBucketNum) : hasValidMaxBucketNum ? Math.min(bucketNum, opt_maxBucketNum) : bucketNum;
};
autovis.ColumnBuckets.prototype.calcPercentileRank_ = function(arr, percentile) {
  return Math.ceil(percentile / 100 * arr.length);
};
// INPUT (javascript/gviz/devel/canviz/color-bar-definer.js)
gviz.canviz.ColorBarDefiner = function(chartDefinition, options, defaultPosition) {
  this.chartDef_ = chartDefinition;
  var optionsPath = gviz.colorbar.Scale.OPTIONS_PATH + ".legend.";
  this.position_ = defaultPosition ? options.inferEnumValue(optionsPath + "position", gviz.canviz.Options.ColorBarPosition, defaultPosition) : gviz.canviz.Options.ColorBarPosition.NONE;
  var defaultTextStyle = {fontName:chartDefinition.defaultFontName, fontSize:chartDefinition.defaultFontSize, auraColor:this.position_ == gviz.canviz.Options.ColorBarPosition.INSIDE ? chartDefinition.insideLabelsAuraColor : "none"};
  this.textStyle_ = options.inferTextStyleValue(optionsPath + "textStyle", defaultTextStyle);
  this.numberFormat_ = options.inferOptionalStringValue(optionsPath + "numberFormat");
  this.scale_ = this.area_ = null;
};
gviz.canviz.ColorBarDefiner.prototype.getPosition = function() {
  return this.position_;
};
gviz.canviz.ColorBarDefiner.prototype.getTextStyle = function() {
  return this.textStyle_;
};
gviz.canviz.ColorBarDefiner.prototype.getHeight = function() {
  return 1.5 * this.textStyle_.fontSize;
};
gviz.canviz.ColorBarDefiner.prototype.getArea = function() {
  return this.area_;
};
gviz.canviz.ColorBarDefiner.prototype.setArea = function(area) {
  this.area_ = area;
};
gviz.canviz.ColorBarDefiner.prototype.setScale = function(scale) {
  this.scale_ = scale;
};
gviz.canviz.ColorBarDefiner.prototype.define = function() {
  if (!this.area_ || !this.scale_) {
    return null;
  }
  var drawingOptions = {top:this.area_.top, left:this.area_.left, width:this.area_.right - this.area_.left, height:this.area_.bottom - this.area_.top, orientation:gviz.colorbar.Orientation.HORIZONTAL, textStyle:this.textStyle_, markerColor:"black", numberFormat:this.numberFormat_}, definition = gviz.colorbar.definer.define(this.scale_, drawingOptions, [], this.chartDef_.textMeasureFunction);
  return goog.isDefAndNotNull(definition) ? {position:this.position_, scale:this.scale_, drawingOptions:drawingOptions, definition:definition} : null;
};
// INPUT (javascript/gviz/devel/canviz/line-label-descriptor.js)
gviz.canviz.LineLabelDescriptor = function(dataYPos, height, labelEntry) {
  this.dataYPos_ = dataYPos;
  this.height_ = height;
  this.labelPos_ = dataYPos - height / 2;
  this.labelEntry_ = labelEntry;
  this.index = 0;
};
gviz.canviz.LineLabelDescriptor.prototype.getTop = function() {
  return this.labelPos_;
};
gviz.canviz.LineLabelDescriptor.prototype.setTop = function(top) {
  this.labelPos_ = top;
};
gviz.canviz.LineLabelDescriptor.prototype.getCenter = function() {
  return this.labelPos_ + this.height_ / 2;
};
gviz.canviz.LineLabelDescriptor.prototype.getBottom = function() {
  return this.labelPos_ + this.height_;
};
gviz.canviz.LineLabelDescriptor.prototype.getHeight = function() {
  return this.height_;
};
gviz.canviz.LineLabelDescriptor.prototype.getDataYPos = function() {
  return this.dataYPos_;
};
gviz.canviz.LineLabelDescriptor.prototype.getLabelEntry = function() {
  return this.labelEntry_;
};
// INPUT (javascript/gviz/devel/canviz/line-label-positioner.js)
gviz.canviz.LineLabelPositioner = function(totalHeight, labelDescriptors) {
  this.totalHeight_ = totalHeight;
  this.labelDescriptors_ = labelDescriptors;
  for (var i = 0, len = labelDescriptors.length;i < len;i++) {
    labelDescriptors[i].index = i;
  }
};
gviz.canviz.LineLabelPositioner.prototype.adjustPositions = function() {
  for (var heightSum = 0, i = 0, len = this.labelDescriptors_.length;i < len;i++) {
    heightSum += this.labelDescriptors_[i].getHeight();
  }
  if (heightSum > this.totalHeight_) {
    throw Error("Not enough space for labels. Need: " + heightSum + " got: " + this.totalHeight_);
  }
  this.labelDescriptors_.sort(function(a, b) {
    var aPos = a.getDataYPos(), bPos = b.getDataYPos();
    return aPos == bPos ? a.index > b.index ? 1 : 0 : aPos > bPos ? 1 : -1;
  });
  i = 0;
  for (len = this.labelDescriptors_.length;i < len;i++) {
    var descriptor = this.labelDescriptors_[i], pos = this.adjustToFitInRange_(descriptor.getTop(), descriptor.getHeight());
    descriptor.setTop(pos);
  }
  for (var descriptorGroups = [], j = 0, len = this.labelDescriptors_.length;j < len;j++) {
    descriptorGroups.push([this.labelDescriptors_[j]]);
  }
  for (;this.adjustNextOverlap_(descriptorGroups);) {
  }
};
gviz.canviz.LineLabelPositioner.prototype.adjustNextOverlap_ = function(descriptorGroups) {
  for (var i = 0;i < descriptorGroups.length - 1;i++) {
    var thisGroup = descriptorGroups[i], nextGroup = descriptorGroups[i + 1];
    if (this.overlaps_(thisGroup, nextGroup)) {
      return this.mergeGroups_(thisGroup, nextGroup), descriptorGroups.splice(i + 1, 1), !0;
    }
  }
  return!1;
};
gviz.canviz.LineLabelPositioner.prototype.overlaps_ = function(thisGroup, nextGroup) {
  var bottom = thisGroup[thisGroup.length - 1];
  return bottom.getBottom() > nextGroup[0].getTop();
};
gviz.canviz.LineLabelPositioner.prototype.mergeGroups_ = function(thisGroup, nextGroup) {
  for (var i = 0;i < nextGroup.length;i++) {
    thisGroup.push(nextGroup[i]);
  }
  for (var sumY = 0, sumHeight = 0, i = 0;i < thisGroup.length;i++) {
    sumY += thisGroup[i].getDataYPos(), sumHeight += thisGroup[i].getHeight();
  }
  for (var avgY = sumY / thisGroup.length, startPos = avgY - sumHeight / 2, startPos = this.adjustToFitInRange_(startPos, sumHeight), i = 0;i < thisGroup.length;i++) {
    var descriptor = thisGroup[i];
    descriptor.setTop(startPos);
    startPos += descriptor.getHeight();
  }
};
gviz.canviz.LineLabelPositioner.prototype.adjustToFitInRange_ = function(pos, height) {
  return goog.math.clamp(pos, 0, this.totalHeight_ - height);
};
// INPUT (javascript/gviz/devel/canviz/legend-definer.js)
gviz.canviz.LegendDefiner = function(chartDefinition, options, defaultPosition, opt_iconWidthScaleFactor) {
  this.chartDef_ = chartDefinition;
  this.position_ = defaultPosition ? options.inferEnumValue("legend.position", gviz.canviz.Options.LegendPosition, defaultPosition) : gviz.canviz.Options.LegendPosition.NONE;
  var defaultAlignment = this.position_ == gviz.canviz.Options.LegendPosition.BOTTOM ? gviz.canviz.Options.Alignment.CENTER : gviz.canviz.Options.Alignment.START;
  this.alignment_ = options.inferEnumValue("legend.alignment", gviz.canviz.Options.Alignment, defaultAlignment);
  var orientation = gviz.canviz.Options.Orientation.HORIZONTAL;
  if (this.position_ == gviz.canviz.Options.LegendPosition.LEFT || this.position_ == gviz.canviz.Options.LegendPosition.RIGHT || this.position_ == gviz.canviz.Options.LegendPosition.LABELED || this.position_ == gviz.canviz.Options.LegendPosition.BOTTOM_VERT) {
    orientation = gviz.canviz.Options.Orientation.VERTICAL;
  }
  this.orientation_ = orientation;
  var defaultTextStyle = {fontName:chartDefinition.defaultFontName, fontSize:chartDefinition.defaultFontSize, auraColor:this.position_ == gviz.canviz.Options.LegendPosition.INSIDE ? chartDefinition.insideLabelsAuraColor : "none"};
  this.textStyle_ = options.inferTextStyleValue("legend.textStyle", defaultTextStyle);
  this.showScrollButtons_ = !1;
  this.pagingTextStyle_ = options.inferTextStyleValue("legend.pagingTextStyle", this.textStyle_);
  this.textMeasureFunction_ = chartDefinition.textMeasureFunction;
  this.iconHeight = this.textStyle_.fontSize;
  opt_iconWidthScaleFactor = opt_iconWidthScaleFactor ? goog.math.clamp(opt_iconWidthScaleFactor, gviz.canviz.Options.LEGEND_ICON_WIDTH_SCALE_FACTOR_MIN, gviz.canviz.Options.LEGEND_ICON_WIDTH_SCALE_FACTOR_MAX) : 1;
  this.iconWidth = this.iconHeight * opt_iconWidthScaleFactor;
  this.gapIconRight = Math.round(this.textStyle_.fontSize / (gviz.canviz.Constants.GOLDEN_RATIO * gviz.canviz.Constants.GOLDEN_RATIO));
  this.allVisibleEntries_ = this.area_ = null;
  this.showPageIndex = options.inferBooleanValue("legend.showPageIndex", !0);
  this.scrollArrowsOrientation = options.inferEnumValue("legend.scrollArrows.orientation", gviz.canviz.Options.Orientation, this.orientation_);
  this.scrollArrowsActiveBrush = options.inferBrushValue("legend.scrollArrows.activeColor");
  this.scrollArrowsInactiveBrush = options.inferBrushValue("legend.scrollArrows.inactiveColor");
  this.pages = null;
  this.gapScrollText_ = this.gapIconRight;
  this.scrollNextX_ = this.scrollPreviousX_ = this.scrollItemsY_ = 0;
  this.maxLinesPerHorizontalPage = this.position_ == gviz.canviz.Options.LegendPosition.TOP ? options.inferNonNegativeNumberValue("legend.maxLines", 1) : 1;
  this.actualLinesPerHorizontalPage = 0;
};
gviz.canviz.LegendDefiner.prototype.getPosition = function() {
  return this.position_;
};
gviz.canviz.LegendDefiner.prototype.getTextStyle = function() {
  return this.textStyle_;
};
gviz.canviz.LegendDefiner.prototype.getArea = function() {
  return this.area_;
};
gviz.canviz.LegendDefiner.prototype.setArea = function(area) {
  this.area_ = area;
};
gviz.canviz.LegendDefiner.prototype.calcLegendEntries = function() {
  this.allVisibleEntries_ = goog.array.filter(this.chartDef_.legendEntries, function(legendEntry) {
    return legendEntry.isVisible;
  });
};
gviz.canviz.LegendDefiner.prototype.define = function() {
  if (!this.area_) {
    return null;
  }
  goog.asserts.assert(this.allVisibleEntries_);
  this.position_ != gviz.canviz.Options.LegendPosition.NONE && (this.orientation_ == gviz.canviz.Options.Orientation.VERTICAL ? this.calcVerticalLayout_() : this.calcHorizontalLayout_());
  var currentPage = this.pages && 0 < this.pages.length ? this.pages[0] : null, scrollItems = this.showScrollButtons_ ? this.calcScrollItems_(0, !1, 1 < this.pages.length) : null;
  return{position:this.position_, area:this.area_, pages:this.pages, currentPage:currentPage, scrollItems:scrollItems};
};
gviz.canviz.LegendDefiner.prototype.calcVerticalLayout_ = function() {
  var nonTextWidth = this.iconWidth + this.gapIconRight, textWidth = Math.max(this.area_.right - this.area_.left - nonTextWidth, 0), legendHeight = this.area_.bottom - this.area_.top, legendWithPagingHeight = Math.max(legendHeight - 2 * this.iconHeight, 0), allVisibleEntries = this.allVisibleEntries_, chartDef = this.chartDef_;
  gviz.canviz.chartdefinitionutil.reverseSeriesLabelsVertically(chartDef) && allVisibleEntries.reverse();
  var optimisticLayouts = goog.array.map(allVisibleEntries, function(entry) {
    var layout = gviz.canviz.textutils.calcTextLayout(this.textMeasureFunction_, entry.text, this.textStyle_, textWidth, Infinity);
    0 == layout.lines.length && (layout.lines = [""]);
    return layout;
  }, this);
  if (this.position_ != gviz.canviz.Options.LegendPosition.LABELED || chartDef.defaultSerieType != gviz.canviz.Options.SerieType.LINE && chartDef.defaultSerieType != gviz.canviz.Options.SerieType.AREA) {
    var allocated = this.allocateHeightsForVerticalEntries_(optimisticLayouts, legendHeight);
    if (this.showScrollButtons_ = this.hasNextVerticalEntries_(allVisibleEntries, allocated)) {
      if (allocated = this.allocateHeightsForVerticalEntries_(optimisticLayouts, legendWithPagingHeight), goog.isDef(allocated[0]) && 0 != allocated[0].length) {
        this.pages = [];
        for (var entries = allVisibleEntries;0 < entries.length;) {
          page = this.calcVerticalEntriesByAllocation_(allocated, entries);
          this.pages.push(page);
          for (var index = 0;goog.isDef(allocated[index]) && 0 != allocated[index].length;) {
            ++index;
          }
          optimisticLayouts = goog.array.slice(optimisticLayouts, index);
          allocated = this.allocateHeightsForVerticalEntries_(optimisticLayouts, legendWithPagingHeight);
          entries = goog.array.slice(entries, index);
        }
        if (this.showScrollButtons_ && (this.scrollItemsY_ = Math.round(this.area_.bottom - this.iconHeight), this.scrollPreviousX_ = this.area_.left, this.scrollNextX_ = this.scrollPreviousX_ + this.iconWidth + this.gapScrollText_, this.showPageIndex)) {
          var pageIndexSize = this.calcMaxPageIndexSize_(this.pages.length);
          this.scrollNextX_ += pageIndexSize + this.gapScrollText_;
        }
      } else {
        this.showScrollButtons_ = !1;
      }
    } else {
      page = this.calcVerticalEntriesByAllocation_(allocated, allVisibleEntries), this.pages = [page];
    }
  } else {
    var page = this.calcVerticalEntriesByDataPosition_(optimisticLayouts, legendHeight, allVisibleEntries);
    this.pages = [page];
  }
};
gviz.canviz.LegendDefiner.prototype.allocateHeightsForVerticalEntries_ = function(optimisticLayouts, legendHeight) {
  var fontSize = this.textStyle_.fontSize, vPadBetweenEntries = Math.round(fontSize / gviz.canviz.Constants.GOLDEN_RATIO), vPadBetweenLines = Math.round(fontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO)), entryFirstLineHeight = fontSize + vPadBetweenEntries, entryNextLinesHeight = fontSize + vPadBetweenLines, entriesRealEstate = this.calcVerticalEntriesRealEstate_(optimisticLayouts, entryFirstLineHeight, entryNextLinesHeight);
  return gviz.canviz.util.distributeRealEstateWithKeys(entriesRealEstate, legendHeight);
};
gviz.canviz.LegendDefiner.prototype.getLastLineValueOfSerie_ = function(serieIndex) {
  var hAxis = goog.object.getAnyValue(this.chartDef_.hAxes), serie = this.chartDef_.series[serieIndex], points = goog.array.map(serie.points, function(point) {
    return gviz.canviz.chartdefinitionutil.isDatumNull(point) ? null : new goog.math.Coordinate(point.scaled.x, point.scaled.y);
  }), lineValueAtViewWindowMax = gviz.canviz.util.piecewiseLinearInterpolation(points, hAxis.endPos, serie.interpolateNulls);
  return goog.isNull(lineValueAtViewWindowMax) ? this.getLastValuePreceding_(points, hAxis.endPos) : lineValueAtViewWindowMax;
};
gviz.canviz.LegendDefiner.prototype.getLastValuePreceding_ = function(coordinates, x$$0) {
  coordinates = goog.array.filter(coordinates, goog.isDefAndNotNull);
  var compareFn = function(x, coordinate) {
    return goog.array.defaultCompare(x, coordinate.x);
  }, i = goog.array.binarySearch(coordinates, x$$0, compareFn), insertionIndex = -(i + 1), precedingCoordinates = goog.array.slice(coordinates, 0, insertionIndex), coordinate$$0 = goog.array.findRight(precedingCoordinates, function(coordinate) {
    return!goog.isNull(coordinate.y);
  });
  return coordinate$$0 ? coordinate$$0.y : null;
};
gviz.canviz.LegendDefiner.prototype.calcVerticalEntriesByDataPosition_ = function(optimisticLayouts, legendHeight, allVisibleEntries) {
  for (var maxTextWidth = this.area_.right - this.area_.left, labelStartXPos = Math.round(this.area_.left), labelDescriptors = [], entries = [], useDiveLegend = this.chartDef_.interactivityModel == gviz.canviz.Options.InteractivityModel.DIVE, i = 0;i < allVisibleEntries.length;i++) {
    var originalEntry = allVisibleEntries[i], allocatedRowsForEntry = optimisticLayouts[i].lines.length, textLayout = gviz.canviz.textutils.calcTextLayout(this.textMeasureFunction_, originalEntry.text, this.textStyle_, maxTextWidth, allocatedRowsForEntry), entry = {};
    entry.id = originalEntry.id;
    entry.brush = originalEntry.brush.clone();
    var textStyle = goog.object.clone(this.textStyle_);
    textStyle.color = entry.brush.getFill();
    entry.textBlock = {text:originalEntry.text, textStyle:textStyle, boxStyle:null, lines:[], paralAlign:gviz.graphics.TextAlign.START, perpenAlign:gviz.graphics.TextAlign.START, tooltip:textLayout.needTooltip ? originalEntry.text : "", anchor:null, angle:0};
    textStyle.auraColor && entry.brush.setStroke(textStyle.auraColor, 1);
    entry.isVisible = !0;
    for (var j = 0;j < textLayout.lines.length;j++) {
      entry.textBlock.lines.push({length:maxTextWidth, text:textLayout.lines[j]});
    }
    if (useDiveLegend) {
      var textWidth = this.textMeasureFunction_(entry.textBlock.lines[0].text, textStyle).width;
      entry.removeSerieButton = {};
      entry.removeSerieButton.coordinates = {x:labelStartXPos + textWidth + 5};
      entry.removeSerieButton.brush = entry.brush;
      entry.removeSerieButton.isVisible = !1;
    }
    entry.index = originalEntry.index;
    var desiredPosition = this.getLastLineValueOfSerie_(entry.index) || 0, firstLine = entry.textBlock.lines[0], lineHeight = this.textMeasureFunction_(firstLine, textStyle).height, textHeight = entry.textBlock.lines.length * lineHeight, descriptor = new gviz.canviz.LineLabelDescriptor(desiredPosition, textHeight, entry);
    labelDescriptors.push(descriptor);
    entries.push(entry);
  }
  var lineLabelPositioner = new gviz.canviz.LineLabelPositioner(legendHeight, labelDescriptors);
  lineLabelPositioner.adjustPositions();
  for (j = 0;j < labelDescriptors.length;j++) {
    for (var descriptor = labelDescriptors[j], calculatedYPos = descriptor.getTop(), entry = descriptor.getLabelEntry(), lines = entry.textBlock.lines, i = 0;i < lines.length;i++) {
      lines[i].y = Math.round(i * lineHeight + calculatedYPos), lines[i].x = labelStartXPos, useDiveLegend && (entry.removeSerieButton.coordinates.y = lines[i].y);
    }
  }
  return entries;
};
gviz.canviz.LegendDefiner.prototype.calcVerticalEntriesByAllocation_ = function(allocated, allVisibleEntries) {
  for (var nonTextWidth = this.iconWidth + this.gapIconRight, maxTextWidth = this.area_.right - this.area_.left - nonTextWidth, fontSize = this.textStyle_.fontSize, vPadBetweenEntries = Math.round(fontSize / gviz.canviz.Constants.GOLDEN_RATIO), vPadBetweenLines = Math.round(fontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO)), entryFirstLineHeight = fontSize + vPadBetweenEntries, entryNextLinesHeight = fontSize + vPadBetweenLines, entries = [], y = 0, x = Math.round(this.area_.left), i = 0;i < allVisibleEntries.length;i++) {
    var originalEntry = allVisibleEntries[i], allocatedForEntry = allocated[i].length;
    if (0 != allocatedForEntry) {
      var textLayout = gviz.canviz.textutils.calcTextLayout(this.textMeasureFunction_, originalEntry.text, this.textStyle_, maxTextWidth, allocatedForEntry), entry = {};
      entry.id = originalEntry.id;
      entry.textBlock = {text:originalEntry.text, textStyle:this.textStyle_, boxStyle:null, lines:[], anchor:new gviz.math.Coordinate(x, 0), paralAlign:gviz.graphics.TextAlign.START, perpenAlign:gviz.graphics.TextAlign.START, tooltip:textLayout.needTooltip ? originalEntry.text : "", angle:0};
      entry.square = {};
      entry.square.coordinates = new goog.math.Rect(x, y, this.iconWidth, this.iconHeight);
      entry.square.brush = originalEntry.brush.clone();
      this.textStyle_.auraColor && entry.square.brush.setStroke(this.textStyle_.auraColor, 1);
      entry.isVisible = !0;
      for (var j = 0;j < textLayout.lines.length;j++) {
        0 < j && (y += entryNextLinesHeight), entry.textBlock.lines.push({x:nonTextWidth, y:y, length:maxTextWidth, text:textLayout.lines[j]});
      }
      entry.index = originalEntry.index;
      y += entryFirstLineHeight;
      entries.push(entry);
    }
  }
  var offsetY = Math.round(this.area_.top);
  if (!this.showScrollButtons_) {
    var usedHeight = y - vPadBetweenEntries, totalHeight = this.area_.bottom - this.area_.top;
    this.alignment_ == gviz.canviz.Options.Alignment.END ? offsetY += totalHeight - usedHeight : this.alignment_ == gviz.canviz.Options.Alignment.CENTER && (offsetY += Math.floor((totalHeight - usedHeight) / 2));
  }
  for (i = 0;i < entries.length;i++) {
    entry = entries[i], entry.square.coordinates.top += offsetY, entry.textBlock.anchor.y += offsetY;
  }
  return entries;
};
gviz.canviz.LegendDefiner.prototype.calcVerticalEntriesRealEstate_ = function(optimisticLayouts, entryFirstLineHeight, entryNextLinesHeight) {
  for (var maxEntryNumOfLines = goog.array.reduce(optimisticLayouts, function(max, layout) {
    return Math.max(max, layout.lines.length);
  }, 0), entriesRealEstate = [], i = 0;i < maxEntryNumOfLines;i++) {
    var lineHeight = 0 == i ? entryFirstLineHeight : entryNextLinesHeight;
    goog.array.forEach(optimisticLayouts, function(layout, j) {
      if (i < layout.lines.length) {
        var height = 0 == i && 0 == j ? this.textStyle_.fontSize : lineHeight;
        entriesRealEstate.push({key:j, min:height, extra:[]});
      }
    }, this);
  }
  return entriesRealEstate;
};
gviz.canviz.LegendDefiner.prototype.hasNextVerticalEntries_ = function(allVisibleEntries, allocated) {
  var lastEntryIndex = allVisibleEntries.length - 1;
  return 1 < allVisibleEntries.length && 1 > allocated[lastEntryIndex].length;
};
gviz.canviz.LegendDefiner.prototype.calcMaxNeededLines = function(legendWidth) {
  goog.asserts.assert(this.allVisibleEntries_);
  for (var entries = this.allVisibleEntries_, allocated = this.allocateWidthsForHorizontalEntries_(entries, legendWidth), lines = 1;(0 == this.maxLinesPerHorizontalPage || this.maxLinesPerHorizontalPage > lines) && allocated.length < entries.length;) {
    ++lines, entries = goog.array.slice(entries, allocated.length), allocated = this.allocateWidthsForHorizontalEntries_(entries, legendWidth);
  }
  return lines;
};
gviz.canviz.LegendDefiner.prototype.calcHorizontalLayout_ = function() {
  for (var maxAllowedPages = [1, 9, 99, 0], i = 0;i < maxAllowedPages.length && !this.setHorizontalPages_(maxAllowedPages[i]);++i) {
  }
  if (this.showScrollButtons_ && (this.scrollItemsY_ = Math.round((this.area_.top + this.area_.bottom - this.iconWidth) / 2), this.scrollNextX_ = this.area_.right - this.iconWidth, this.scrollPreviousX_ = this.scrollNextX_ - this.gapScrollText_ - this.iconWidth, this.showPageIndex)) {
    var pageIndexSize = this.calcMaxPageIndexSize_(this.pages.length);
    this.scrollPreviousX_ -= pageIndexSize + this.gapScrollText_;
  }
};
gviz.canviz.LegendDefiner.prototype.setHorizontalPages_ = function(maxAllowedPages) {
  var totalWidth = this.area_.right - this.area_.left, singlePage = !1;
  1 != maxAllowedPages && (totalWidth -= 2 * (this.iconWidth + this.gapIconRight), singlePage = !0, 0 != maxAllowedPages && (totalWidth -= this.calcMaxPageIndexSize_(maxAllowedPages) + this.gapIconRight));
  var allocated = this.allocateWidthsForHorizontalEntries_(this.allVisibleEntries_, totalWidth);
  if (0 == allocated.length) {
    return this.showScrollButtons_ = !1, !0;
  }
  this.pages = [];
  for (var entries = this.allVisibleEntries_;0 < entries.length;) {
    if (0 < maxAllowedPages && this.pages.length == maxAllowedPages) {
      return!1;
    }
    for (var row = this.calcHorizontalEntriesByAllocation_(allocated, entries, singlePage), rows = [row], linesCount = 1;linesCount < this.actualLinesPerHorizontalPage && entries.length != allocated.length;linesCount++) {
      entries = goog.array.slice(entries, allocated.length), allocated = this.allocateWidthsForHorizontalEntries_(entries, totalWidth), rows.push(this.calcHorizontalEntriesByAllocation_(allocated, entries, singlePage));
    }
    var page = this.distributeHeightsForHorizontalPage_(rows);
    this.pages.push(page);
    entries = goog.array.slice(entries, allocated.length);
    allocated = this.allocateWidthsForHorizontalEntries_(entries, totalWidth);
  }
  this.showScrollButtons_ = 1 < this.pages.length;
  return!0;
};
gviz.canviz.LegendDefiner.prototype.distributeHeightsForHorizontalPage_ = function(pageRows) {
  var topY = this.area_.top, bottomY = this.area_.bottom, totalHeight = bottomY - topY, heightForOneLine = this.textStyle_.fontSize, heightForAllText = this.actualLinesPerHorizontalPage * heightForOneLine, heightForAllSpaces = totalHeight - heightForAllText, heightForOneSpace = 1 < this.actualLinesPerHorizontalPage ? heightForAllSpaces / (this.actualLinesPerHorizontalPage - 1) : 0, actualHeight = (heightForOneLine + heightForOneSpace) * pageRows.length - heightForOneSpace, offset = (totalHeight - 
  actualHeight) / 2, page = [];
  goog.array.forEach(pageRows, function(row) {
    var roundOffset = Math.round(offset);
    goog.array.forEach(row, function(entry) {
      entry.textBlock.anchor.y += roundOffset;
      entry.square.coordinates.top += roundOffset;
    });
    offset += heightForOneLine + heightForOneSpace;
    goog.array.extend(page, row);
  });
  return page;
};
gviz.canviz.LegendDefiner.prototype.allocateWidthsForHorizontalEntries_ = function(allVisibleEntries, totalWidth) {
  var nonTextWidth = this.iconWidth + this.gapIconRight, minTrimmedWidth = Math.min(this.chartDef_.width * (2 - gviz.canviz.Constants.GOLDEN_RATIO) / 2, totalWidth);
  if (minTrimmedWidth < nonTextWidth) {
    return[];
  }
  var entriesRealEstate = this.calcHorizontalEntriesRealEstate_(minTrimmedWidth, allVisibleEntries);
  return gviz.canviz.util.distributeRealEstate(entriesRealEstate, totalWidth);
};
gviz.canviz.LegendDefiner.prototype.calcHorizontalEntriesByAllocation_ = function(allocatedWidths, allVisibleEntries, singlePage) {
  for (var totalWidth = this.area_.right - this.area_.left, nonTextWidth = this.iconWidth + this.gapIconRight, gapBetweenItems = Math.round(this.textStyle_.fontSize * gviz.canviz.Constants.GOLDEN_RATIO), entries = [], x = 0, y = Math.round(this.area_.top), i = 0;i < allocatedWidths.length;i++) {
    var originalEntry = allVisibleEntries[i], allowedTextWidth = allocatedWidths[i] - nonTextWidth - (0 < i ? gapBetweenItems : 0), textLayout = gviz.canviz.textutils.calcTextLayout(this.textMeasureFunction_, originalEntry.text, this.textStyle_, allowedTextWidth, 1), displayedText = 0 < textLayout.lines.length ? textLayout.lines[0] : "", displayedTextWidth = this.textMeasureFunction_(displayedText, this.textStyle_).width, lines = [{x:x + nonTextWidth, y:0, length:displayedTextWidth, text:displayedText}], 
    entry = {};
    entry.id = originalEntry.id;
    entry.textBlock = {text:originalEntry.text, textStyle:this.textStyle_, boxStyle:null, lines:displayedText ? lines : [], anchor:new gviz.math.Coordinate(0, y), paralAlign:gviz.graphics.TextAlign.START, perpenAlign:gviz.graphics.TextAlign.START, tooltip:textLayout.needTooltip ? originalEntry.text : "", angle:0};
    entry.isVisible = !0;
    entry.square = {};
    entry.square.brush = originalEntry.brush.clone();
    this.textStyle_.auraColor && entry.square.brush.setStroke(this.textStyle_.auraColor, 1);
    entry.square.coordinates = new goog.math.Rect(x, y, this.iconWidth, this.iconHeight);
    entry.index = originalEntry.index;
    entries.push(entry);
    x += displayedTextWidth + nonTextWidth + gapBetweenItems;
  }
  var offsetX = this.area_.left;
  if (!singlePage) {
    var usedWidth = x - gapBetweenItems;
    this.alignment_ == gviz.canviz.Options.Alignment.END ? offsetX += totalWidth - usedWidth : this.alignment_ == gviz.canviz.Options.Alignment.CENTER && (offsetX += Math.floor((totalWidth - usedWidth) / 2));
  }
  for (i = 0;i < entries.length;i++) {
    entry = entries[i], entry.square.coordinates.left += offsetX, entry.textBlock.anchor.x += offsetX;
  }
  return entries;
};
gviz.canviz.LegendDefiner.prototype.calcHorizontalEntriesRealEstate_ = function(minTrimmedWidth, allVisibleEntries) {
  var nonTextWidth = this.iconWidth + this.gapIconRight, gapBetweenItems = Math.round(this.textStyle_.fontSize * gviz.canviz.Constants.GOLDEN_RATIO);
  goog.asserts.assert(minTrimmedWidth >= nonTextWidth);
  var entriesRealEstate = goog.array.map(allVisibleEntries, function(entry, i) {
    var textWidth = this.textMeasureFunction_(entry.text, this.textStyle_).width, maxWidth = textWidth + nonTextWidth, minWidth = Math.min(minTrimmedWidth, maxWidth), extra = maxWidth - minWidth;
    0 < i && (minWidth += gapBetweenItems);
    return{min:minWidth, extra:[extra]};
  }, this);
  return entriesRealEstate;
};
gviz.canviz.LegendDefiner.prototype.calcMaxPageIndexSize_ = function(lastPage) {
  for (var pageIndex = "0";10 <= lastPage;) {
    pageIndex += "0", lastPage /= 10;
  }
  var pageText = pageIndex + "/" + pageIndex;
  return this.textMeasureFunction_(pageText, this.pagingTextStyle_).width;
};
gviz.canviz.LegendDefiner.prototype.calcScrollItems_ = function(pageIndex, hasPrevious, hasNext) {
  var y = this.scrollItemsY_, pageIndexTextBlock = null;
  if (this.showPageIndex) {
    var pageIndexText = pageIndex + 1 + "/" + this.pages.length, x = this.scrollPreviousX_ + this.iconWidth, length = this.scrollNextX_ - x, pageIndexTextBlock = {text:pageIndexText, textStyle:this.pagingTextStyle_, boxStyle:null, lines:[{x:x + length / 2, y:y, text:pageIndexText, length:length}], paralAlign:gviz.graphics.TextAlign.CENTER, perpenAlign:gviz.graphics.TextAlign.START, tooltip:"", anchor:null, angle:0}
  }
  var useUpDown = this.scrollArrowsOrientation == gviz.canviz.Options.Orientation.VERTICAL, buttonWidth = this.iconWidth, halfButtonWidth = Math.round(buttonWidth / 2), prevButtonX = this.scrollPreviousX_, nextButtonX = this.scrollNextX_, previousPath = null, nextPath = null;
  useUpDown ? (previousPath = [{x:prevButtonX + buttonWidth, y:y + buttonWidth}, {x:prevButtonX + halfButtonWidth, y:y}, {x:prevButtonX, y:y + buttonWidth}], nextPath = [{x:nextButtonX, y:y}, {x:nextButtonX + buttonWidth, y:y}, {x:nextButtonX + halfButtonWidth, y:y + buttonWidth}]) : (previousPath = [{x:prevButtonX + buttonWidth, y:y + buttonWidth}, {x:prevButtonX + buttonWidth, y:y}, {x:prevButtonX, y:y + halfButtonWidth}], nextPath = [{x:nextButtonX, y:y}, {x:nextButtonX + buttonWidth, y:y + halfButtonWidth}, 
  {x:nextButtonX, y:y + buttonWidth}]);
  var brushes = {active:this.scrollArrowsActiveBrush, inactive:this.scrollArrowsInactiveBrush}, previousButton = {path:previousPath, active:hasPrevious, brushes:brushes, brush:hasPrevious ? brushes.active : brushes.inactive}, nextButton = {path:nextPath, active:hasNext, brushes:brushes, brush:hasNext ? brushes.active : brushes.inactive};
  return{previousButton:previousButton, nextButton:nextButton, pageIndexTextBlock:pageIndexTextBlock};
};
// INPUT (javascript/gviz/devel/canviz/chart-definer.js)
gviz.canviz.ChartDefiner = function(dataTable, options, textMeasureFunction, width, height) {
  goog.asserts.assert(dataTable);
  this.dataTable = dataTable;
  this.dataView = null;
  this.options = options;
  this.textMeasureFunction = textMeasureFunction;
  this.colorBarDefiner = this.legendDefiner = null;
  var chartDef = this.chartDef = this.constructChartDefinition();
  chartDef.textMeasureFunction = textMeasureFunction;
  chartDef.width = width;
  chartDef.height = height;
  chartDef.chartType = options.inferEnumValue("type", gviz.canviz.Options.ChartType, gviz.canviz.Options.ChartType.NONE);
  chartDef.defaultFontName = options.inferStringValue("fontName");
  chartDef.defaultFontSize = options.inferNonNegativeNumberValue("fontSize", Math.round(Math.pow(2 * (chartDef.width + chartDef.height), 1 / 3)));
  chartDef.defaultSerieType = options.inferEnumValue("seriesType", gviz.canviz.Options.SerieType, gviz.canviz.Options.SerieType.LINE);
  chartDef.enableInteractivity = options.inferBooleanValue("enableInteractivity", !0);
  chartDef.isHtmlTooltip = options.inferBooleanValue("tooltip.isHtml");
  chartDef.selectionMode = options.inferEnumValue("selectionMode", gviz.Options.SelectionMode, gviz.Options.SelectionMode.SINGLE);
  chartDef.useNewLegend = options.inferBooleanValue("legend.newLegend");
  chartDef.backgroundBrush = options.inferBrushValue("backgroundColor");
  chartDef.chartAreaBackgroundBrush = options.inferBrushValue("chartArea.backgroundColor");
  chartDef.actualChartAreaBackgoundColor = gviz.graphics.Brush.blendFills(chartDef.chartAreaBackgroundBrush, chartDef.backgroundBrush);
  chartDef.baselineColor = options.inferColorValue("baselineColor", "");
  chartDef.gridlineColor = options.inferColorValue("gridlineColor", "");
  chartDef.insideLabelsAuraColor = chartDef.actualChartAreaBackgoundColor || "";
  var titleText = options.inferStringValue("title");
  chartDef.titlePosition = options.inferEnumValue("titlePosition", gviz.canviz.Options.InOutPosition, gviz.canviz.Options.InOutPosition.OUTSIDE);
  var auraColor = chartDef.titlePosition == gviz.canviz.Options.InOutPosition.INSIDE ? chartDef.insideLabelsAuraColor : chartDef.backgroundBrush.getFill(), defaultTitleTextStyle = {fontName:chartDef.defaultFontName, fontSize:chartDef.defaultFontSize, auraColor:auraColor}, titleTextStyle = options.inferTextStyleValue("titleTextStyle", defaultTitleTextStyle);
  chartDef.title = {text:titleText, textStyle:titleTextStyle, boxStyle:null, lines:[], paralAlign:gviz.graphics.TextAlign.START, perpenAlign:gviz.graphics.TextAlign.END, tooltip:"", anchor:null, angle:0};
  chartDef.axisTitlesPosition = options.inferEnumValue("axisTitlesPosition", gviz.canviz.Options.InOutPosition, gviz.canviz.Options.InOutPosition.OUTSIDE);
  chartDef.is3D = options.inferBooleanValue("is3D");
  chartDef.isRtl = options.inferBooleanValue("isRtl", !1);
  chartDef.shouldHighlightSelection = options.inferBooleanValue("shouldHighlightSelection", !0);
  chartDef.interpolateNulls = options.inferBooleanValue("interpolateNulls");
  chartDef.interactivityModel = options.inferEnumValue("interactivityModel", gviz.canviz.Options.InteractivityModel, gviz.canviz.Options.InteractivityModel.DEFAULT);
  this.calcDataView();
  this.init();
  var diveInteractivityModel = gviz.canviz.Options.InteractivityModel.DIVE, lineSerieType = gviz.canviz.Options.SerieType.LINE;
  if (chartDef.interactivityModel == diveInteractivityModel && (!chartDef.serieTypeCount || chartDef.serieTypeCount[lineSerieType] != chartDef.series.length)) {
    throw Error("DIVE interactivity model is only supported when all series are of type line.");
  }
};
gviz.canviz.ChartDefiner.prototype.constructChartDefinition = function() {
  return new gviz.canviz.ChartDefinition;
};
gviz.canviz.ChartDefiner.prototype.getChartDefinition = function() {
  return this.chartDef;
};
gviz.canviz.ChartDefiner.prototype.init = function() {
  var chartDef = this.chartDef;
  this.calcChartAreaLayout_();
  var defaultLegendPosition = this.getDefaultLegendPosition(), defaultColorBarPosition = this.getDefaultColorBarPosition(), legendIconWidthScaleFactor = null, chartType = chartDef.chartType;
  !chartDef.isDiff || chartType !== gviz.canviz.Options.ChartType.PIE && chartType !== gviz.canviz.Options.ChartType.SCATTER ? chartDef.useNewLegend && chartType !== gviz.canviz.Options.ChartType.PIE && chartType !== gviz.canviz.Options.ChartType.BUBBLE && (legendIconWidthScaleFactor = 2) : legendIconWidthScaleFactor = gviz.canviz.Options.DEFAULT_DIFF_LEGEND_ICON_WIDTH_SCALE_FACTOR;
  this.legendDefiner = new gviz.canviz.LegendDefiner(chartDef, this.options, defaultLegendPosition, legendIconWidthScaleFactor);
  this.colorBarDefiner = new gviz.canviz.ColorBarDefiner(chartDef, this.options, defaultColorBarPosition);
  this.calcLayout();
  this.legendDefiner.calcLegendEntries();
  this.calcTopCanvasAreaLayout_();
  chartDef.legend = this.legendDefiner.define();
  chartDef.colorBar = this.colorBarDefiner.define();
};
gviz.canviz.ChartDefiner.prototype.calcDataView = function() {
  var dataTable = this.dataTable, dataView = new google.visualization.DataView(dataTable);
  if (2 > dataView.getNumberOfColumns()) {
    throw Error("Not enough columns given to draw the requested chart.");
  }
  if (this.options.inferBooleanValue("reverseCategories")) {
    for (var newRowsOrder = [], i = dataTable.getNumberOfRows() - 1;0 <= i;i--) {
      newRowsOrder.push(i);
    }
    dataView.setRows(newRowsOrder);
  }
  this.dataView = dataView;
};
gviz.canviz.ChartDefiner.prototype.calcChartAreaDimension_ = function(start, size, totalSize, calcDefaultSizeFunc) {
  goog.isDefAndNotNull(size) || (size = calcDefaultSizeFunc());
  size = Math.round(size);
  goog.isDefAndNotNull(start) || (start = (totalSize - size) / 2);
  start = Math.round(start);
  var end = Math.min(start + size, totalSize);
  return{start:start, end:end};
};
gviz.canviz.ChartDefiner.prototype.calcChartAreaLayout_ = function() {
  var chartDef = this.chartDef, userWidth = this.options.inferOptionalAbsOrPercentageValue("chartArea.width", chartDef.width), userHeight = this.options.inferOptionalAbsOrPercentageValue("chartArea.height", chartDef.height), userTop = this.options.inferOptionalAbsOrPercentageValue("chartArea.top", chartDef.height), userLeft = this.options.inferOptionalAbsOrPercentageValue("chartArea.left", chartDef.width), calcWidth = goog.bind(function() {
    var w1 = chartDef.width / gviz.canviz.Constants.GOLDEN_RATIO, w2 = chartDef.width - chartDef.height * (gviz.canviz.Constants.GOLDEN_RATIO - 1);
    return Math.round(w1 > w2 ? w1 : (w1 + 2 * w2) / 3);
  }, this), horizontalDimension = this.calcChartAreaDimension_(userLeft, userWidth, chartDef.width, calcWidth), left = Math.min(horizontalDimension.start, horizontalDimension.end), right = horizontalDimension.end, width = right - left, calcHeight = goog.bind(function() {
    var h1 = chartDef.height / gviz.canviz.Constants.GOLDEN_RATIO, h2 = chartDef.height - chartDef.width * (gviz.canviz.Constants.GOLDEN_RATIO - 1);
    return Math.round(h1 > h2 ? h1 : (h1 + 2 * h2) / 3);
  }, this), verticalDimension = this.calcChartAreaDimension_(userTop, userHeight, chartDef.height, calcHeight), top = Math.min(verticalDimension.start, verticalDimension.end), bottom = verticalDimension.end, height = bottom - top;
  chartDef.chartArea = {left:left, right:right, width:width, top:top, bottom:bottom, height:height};
};
gviz.canviz.ChartDefiner.prototype.calcTopCanvasAreaLayout_ = function() {
  var chartDef = this.chartDef, titleFontSize = chartDef.title.textStyle.fontSize, legendFontSize = this.legendDefiner.getTextStyle().fontSize, legendPosition = this.legendDefiner.getPosition(), colorBarFontSize = this.colorBarDefiner.getTextStyle().fontSize, colorBarPosition = this.colorBarDefiner.getPosition(), titleText = chartDef.titlePosition == gviz.canviz.Options.InOutPosition.OUTSIDE ? chartDef.title.text : "", optimisticTitleLayout = gviz.canviz.textutils.calcTextLayout(this.textMeasureFunction, 
  titleText, chartDef.title.textStyle, chartDef.chartArea.width, Infinity), gapBetweenTitleLines = Math.max(2, Math.round(titleFontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO))), gapAboveLegend = Math.max(2, Math.round(legendFontSize / gviz.canviz.Constants.GOLDEN_RATIO)), gapAboveColorBar = Math.max(2, Math.round(colorBarFontSize / gviz.canviz.Constants.GOLDEN_RATIO)), gapAboveChart = Math.max(2, Math.round(chartDef.defaultFontSize * gviz.canviz.Constants.GOLDEN_RATIO)), items = [];
  items.push({key:"bottom-space", min:2, extra:[gapAboveChart - 2]});
  items.push({key:"top-space", min:0, extra:[Infinity]});
  0 < optimisticTitleLayout.lines.length && items.push({key:"title", min:titleFontSize + 2, extra:[]});
  if (legendPosition == gviz.canviz.Options.LegendPosition.TOP) {
    for (var lines = this.legendDefiner.calcMaxNeededLines(chartDef.chartArea.width), i = 0;i < lines;++i) {
      items.push({key:"legend", min:legendFontSize + 2, extra:[gapAboveLegend - 2]});
    }
  }
  colorBarPosition == gviz.canviz.Options.ColorBarPosition.TOP && items.push({key:"colorBar", min:this.colorBarDefiner.getHeight() + 2, extra:[gapAboveColorBar - 2]});
  for (i = 1;i < optimisticTitleLayout.lines.length;i++) {
    items.push({key:"title", min:titleFontSize + 2, extra:[gapBetweenTitleLines - 2]});
  }
  for (var allocatedHeights = gviz.canviz.util.distributeRealEstateWithKeys(items, chartDef.chartArea.top), y = allocatedHeights["top-space"][0] || 0, actualTitleLines = allocatedHeights.title || [], layout = gviz.canviz.textutils.calcTextLayout(this.textMeasureFunction, titleText, chartDef.title.textStyle, chartDef.chartArea.width, actualTitleLines.length), i = 0;i < layout.lines.length;i++) {
    y += actualTitleLines[i], chartDef.title.lines.push({text:layout.lines[i], x:chartDef.chartArea.left, y:y, length:chartDef.chartArea.width});
  }
  chartDef.title.tooltip = layout.needTooltip ? titleText : "";
  var actualLegendLines = allocatedHeights.legend || [];
  if (0 < actualLegendLines.length) {
    this.legendDefiner.actualLinesPerHorizontalPage = actualLegendLines.length;
    var top = y + actualLegendLines[0] - legendFontSize, y = y + goog.math.sum.apply(null, actualLegendLines), legendArea = new goog.math.Box(top, chartDef.chartArea.right, y, chartDef.chartArea.left);
    this.legendDefiner.setArea(legendArea);
  }
  var actualColorBarLines = allocatedHeights.colorBar || [];
  if (0 < actualColorBarLines.length) {
    var y = y + actualColorBarLines[0], colorBarArea = new goog.math.Box(y - this.colorBarDefiner.getHeight(), chartDef.chartArea.right, y, chartDef.chartArea.left);
    this.colorBarDefiner.setArea(colorBarArea);
  }
};
// INPUT (javascript/gviz/devel/canviz/order-of-magnitudes.js)
gviz.canviz.formatting = {};
gviz.canviz.formatting.OrderOfMagnitudeFactory = {};
gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_4 = "\u4e07";
gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_7 = "\u5343\u4e07";
gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_8 = "\u5104";
gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_16 = "\u4eac";
gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_TEN_POW_4 = "\u4e07";
gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_TEN_POW_7 = "\u5343\u4e07";
gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_TEN_POW_8 = "\u4ebf";
gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_4 = "\u842c";
gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_7 = "\u5343\u842c";
gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_8 = "\u5104";
gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_16 = "\u4eac";
gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_4 = "\ub9cc";
gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_7 = "\ucc9c\ub9cc";
gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_8 = "\uc5b5";
gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_16 = "\uacbd";
gviz.canviz.formatting.OrderOfMagnitudeFactory.getShortI18NOOMFormatters = function(maxNumDecimals) {
  var basePattern = gviz.canviz.util.getNumDecimalsPattern(maxNumDecimals), factory = gviz.canviz.formatting.OrderOfMagnitudeFactory;
  return[factory.getQuadrillionMagnitudeShort_(basePattern), factory.getTrillionMagnitudeShort_(basePattern), factory.getBillionMagnitudeShort_(basePattern), factory.getMillionMagnitudeShort_(basePattern)];
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getLongI18NOOMFormatters = function(maxNumDecimals) {
  var basePattern = gviz.canviz.util.getNumDecimalsPattern(maxNumDecimals), factory = gviz.canviz.formatting.OrderOfMagnitudeFactory;
  return[factory.getQuadrillionMagnitudeLong_(basePattern), factory.getTrillionMagnitudeLong_(basePattern), factory.getBillionMagnitudeLong_(basePattern), factory.getMillionMagnitudeLong_(basePattern)];
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.addOOM_ = function(basePattern, orderOfMagnitudeString) {
  var MSG_NUMBER_WITH_ORDER_OF_MAGNITUDE = basePattern + (" " + orderOfMagnitudeString);
  return MSG_NUMBER_WITH_ORDER_OF_MAGNITUDE;
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getMillionMagnitudeLong_ = function(basePattern) {
  return gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 6), "Million", "Million");
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getBillionMagnitudeLong_ = function(basePattern) {
  return gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 9), "Billion", "Billion");
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getTrillionMagnitudeLong_ = function(basePattern) {
  return gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 12), "Trillion", "Trillion");
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getQuadrillionMagnitudeLong_ = function(basePattern) {
  return gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 15), "Quadrillion", "Quadrillion");
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getMillionMagnitudeShort_ = function(basePattern) {
  return gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 6), "M", "M");
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getBillionMagnitudeShort_ = function(basePattern) {
  return gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 9), "B", "B");
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getTrillionMagnitudeShort_ = function(basePattern) {
  return gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 12), "T", "T");
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getQuadrillionMagnitudeShort_ = function(basePattern) {
  return gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 15), "Q", "Q");
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_ = function(basePattern, magnitude, singularString, pluralString) {
  return new gviz.canviz.formatting.OrderOfMagnitudeFormatter(basePattern, magnitude, singularString, pluralString);
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getJapaneseFormatters_ = function(basePattern) {
  var factory = gviz.canviz.formatting.OrderOfMagnitudeFactory;
  return[gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 16), gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_16, gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_16), factory.getBillionMagnitudeLong_(basePattern), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 8), gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_8, gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_8), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, 
  Math.pow(10, 7), gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_7, gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_7), factory.getMillionMagnitudeLong_(basePattern), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 4), gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_4, gviz.canviz.formatting.OrderOfMagnitudeFactory.JA_TEN_POW_4)];
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getSimplifiedCNFormatters_ = function(basePattern) {
  var factory = gviz.canviz.formatting.OrderOfMagnitudeFactory;
  return[factory.getBillionMagnitudeLong_(basePattern), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 8), gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_TEN_POW_8, gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_TEN_POW_8), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 7), gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_TEN_POW_7, gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_TEN_POW_7), factory.getMillionMagnitudeLong_(basePattern), 
  gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 4), gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_TEN_POW_4, gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_TEN_POW_4)];
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getTraditionalCNFormatters_ = function(basePattern) {
  var factory = gviz.canviz.formatting.OrderOfMagnitudeFactory;
  return[gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 16), gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_16, gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_16), factory.getBillionMagnitudeLong_(basePattern), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 8), gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_8, gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_8), 
  gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 7), gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_7, gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_7), factory.getMillionMagnitudeLong_(basePattern), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 4), gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_4, gviz.canviz.formatting.OrderOfMagnitudeFactory.CN_CH_TEN_POW_4)];
};
gviz.canviz.formatting.OrderOfMagnitudeFactory.getKoreanFormatters_ = function(basePattern) {
  var factory = gviz.canviz.formatting.OrderOfMagnitudeFactory;
  return[gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 16), gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_16, gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_16), factory.getBillionMagnitudeLong_(basePattern), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 8), gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_8, gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_8), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, 
  Math.pow(10, 7), gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_7, gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_7), factory.getMillionMagnitudeLong_(basePattern), gviz.canviz.formatting.OrderOfMagnitudeFactory.createFormatter_(basePattern, Math.pow(10, 4), gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_4, gviz.canviz.formatting.OrderOfMagnitudeFactory.KO_TEN_POW_4)];
};
gviz.canviz.formatting.OrderOfMagnitudeFormatter = function(pattern, magnitude, singularString, pluralString) {
  this.magnitude_ = magnitude;
  this.formatter_ = new google.visualization.NumberFormat({pattern:pattern});
  this.singularString_ = singularString;
  this.pluralString_ = pluralString;
};
gviz.canviz.formatting.OrderOfMagnitudeFormatter.prototype.format = function(value) {
  var adjusted = value / this.magnitude_, formattedValue = this.formatter_.formatValue(adjusted), magnitudeString = 2 > Math.abs(adjusted) ? this.singularString_ : this.pluralString_, result = gviz.canviz.formatting.OrderOfMagnitudeFactory.addOOM_(formattedValue, magnitudeString);
  goog.i18n.bidi.IS_RTL && (result = goog.i18n.bidi.enforceRtlInText(result));
  return result;
};
gviz.canviz.formatting.OrderOfMagnitudeFormatter.prototype.getMagnitude = function() {
  return this.magnitude_;
};
// INPUT (javascript/gviz/devel/canviz/formatter.js)
gviz.canviz.formatting.INumberFormatter = function() {
};
gviz.canviz.formatting.TimeFormatter = function() {
};
gviz.canviz.formatting.TimeFormatterImpl = function() {
  this.date_ = new Date;
  this.setTimeUnit(gviz.canviz.axis.Milliseconds.TIME_UNIT.MILLISECOND);
};
gviz.canviz.formatting.TimeFormatterImpl.prototype.setTimeUnit = function(timeUnit) {
  this.formatter_ = gviz.canviz.formatting.getDateFormatter_(timeUnit);
};
gviz.canviz.formatting.TimeFormatterImpl.prototype.format = function(time) {
  this.date_.setTime(time);
  return this.formatter_.formatValue(this.date_);
};
gviz.canviz.formatting.getDateFormatter_ = function(timeUnit) {
  var pattern;
  switch(timeUnit) {
    case gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR:
      pattern = gviz.i18n.DateTimePatterns.YEAR_FULL;
      break;
    case gviz.canviz.axis.Milliseconds.TIME_UNIT.QUARTER:
      pattern = "Q yyyy";
      break;
    case gviz.canviz.axis.Milliseconds.TIME_UNIT.MONTH:
      pattern = gviz.i18n.DateTimePatterns.YEAR_MONTH_ABBR;
      break;
    case gviz.canviz.axis.Milliseconds.TIME_UNIT.DAY:
      pattern = gviz.i18n.DateTimeFormat.Format.SHORT_DATE;
      break;
    default:
      pattern = gviz.i18n.DateTimeFormat.Format.SHORT_DATETIME;
  }
  return new google.visualization.DateFormat({pattern:pattern, timeZone:0});
};
gviz.canviz.formatting.DUMMY_UNIT = {symbol:"", position:"right", usePadding:!1};
gviz.canviz.formatting.DUMMY_MAGNITUDE = {value:0, pattern:"", singularString:"", pluralString:""};
gviz.canviz.formatting.NumberFormatterBuilder = function() {
  this.maxNumDecimals_ = null;
  this.orderOfMagnitudes_ = [];
  this.formatterOptions_ = this.unit_ = this.numSignificantDigits_ = null;
};
gviz.canviz.formatting.NumberFormatterBuilder.DEFAULT_NUM_DECIMALS = 16;
gviz.canviz.formatting.NumberFormatterBuilder.prototype.useFormatterOptions = function(formatterOptions) {
  this.formatterOptions_ = formatterOptions;
  return this;
};
gviz.canviz.formatting.NumberFormatterBuilder.prototype.maxNumDecimals = function(maxNumDecimals) {
  this.maxNumDecimals_ = maxNumDecimals;
  return this;
};
gviz.canviz.formatting.NumberFormatterBuilder.prototype.numSignificantDigits = function(numSignificantDigits) {
  this.numSignificantDigits_ = numSignificantDigits;
  return this;
};
gviz.canviz.formatting.NumberFormatterBuilder.prototype.unit = function(unit) {
  this.unit_ = unit;
  return this;
};
gviz.canviz.formatting.NumberFormatterBuilder.prototype.useLongI18nMagnitudes = function(opt_maxNumDecimals) {
  var maxNumDecimals = goog.isNumber(opt_maxNumDecimals) ? opt_maxNumDecimals : 3;
  this.orderOfMagnitudes_ = gviz.canviz.formatting.OrderOfMagnitudeFactory.getLongI18NOOMFormatters(maxNumDecimals);
  return this;
};
gviz.canviz.formatting.NumberFormatterBuilder.prototype.useShortI18nMagnitudes = function(opt_maxNumDecimals) {
  var maxNumDecimals = goog.isNumber(opt_maxNumDecimals) ? opt_maxNumDecimals : 3;
  this.orderOfMagnitudes_ = gviz.canviz.formatting.OrderOfMagnitudeFactory.getShortI18NOOMFormatters(maxNumDecimals);
  return this;
};
gviz.canviz.formatting.NumberFormatterBuilder.prototype.build = function() {
  var defaultFormatter;
  if (this.formatterOptions_) {
    goog.asserts.assert(!this.maxNumDecimals_, "maxNumDecimals cannot be specified when customPattern is used"), defaultFormatter = new google.visualization.NumberFormat(this.formatterOptions_);
  } else {
    var maxNumDecimals = goog.isNumber(this.maxNumDecimals_) ? this.maxNumDecimals_ : gviz.canviz.formatting.NumberFormatterBuilder.DEFAULT_NUM_DECIMALS;
    defaultFormatter = gviz.canviz.util.getNumDecimalsFormatter(maxNumDecimals);
  }
  return new gviz.canviz.formatting.NumberFormatter(defaultFormatter, this.orderOfMagnitudes_, this.numSignificantDigits_, this.unit_);
};
gviz.canviz.formatting.NumberFormatter = function(defaultFormatter, opt_orderOfMagnitudes, opt_numSignificantDigits, opt_unit) {
  this.defaultFormatter_ = defaultFormatter;
  this.orderOfMagnitudes_ = opt_orderOfMagnitudes || [];
  this.numSignificantDigits_ = opt_numSignificantDigits || null;
  this.unit_ = opt_unit || null;
  goog.asserts.assert(gviz.canviz.formatting.NumberFormatter.isSorted_(this.orderOfMagnitudes_), "Magnitudes are not sorted in descending order.");
  goog.isNumber(opt_numSignificantDigits) && (goog.asserts.assert(!isNaN(opt_numSignificantDigits), "opt_numSignificantDigits can't be NaN."), goog.asserts.assert(isFinite(opt_numSignificantDigits), "opt_numSignificantDigits must be finite."), goog.asserts.assert(0 < opt_numSignificantDigits, "opt_numSignificantDigits must be a positive number if passed in."));
};
gviz.canviz.formatting.NumberFormatter.isSorted_ = function(magnitudes) {
  for (var lastSize = Infinity, i = 0;i < magnitudes.length;i++) {
    var magnitude = magnitudes[i];
    if (lastSize < magnitude.getMagnitude()) {
      return!1;
    }
    lastSize = magnitude.getMagnitude();
  }
  return!0;
};
gviz.canviz.formatting.NumberFormatter.prototype.format = function(value) {
  var isNegative = 0 > value;
  value = Math.abs(value);
  this.numSignificantDigits_ && (value = gviz.canviz.util.roundToNumSignificantDigits(this.numSignificantDigits_, value));
  for (var formatted = null, i = 0;i < this.orderOfMagnitudes_.length;i++) {
    var orderOfMagnitudeFormatter = this.orderOfMagnitudes_[i];
    if (value >= orderOfMagnitudeFormatter.getMagnitude()) {
      formatted = orderOfMagnitudeFormatter.format(value);
      break;
    }
  }
  null == formatted && (formatted = this.defaultFormatter_.formatValue(value));
  formatted = this.addUnit_(formatted);
  return isNegative ? "-" + formatted : formatted;
};
gviz.canviz.formatting.NumberFormatter.prototype.addUnit_ = function(formattedValue) {
  if (!this.unit_) {
    return formattedValue;
  }
  var symbol = this.unit_.symbol, padding = this.unit_.usePadding ? " " : "";
  return "right" == this.unit_.position ? formattedValue + padding + symbol : symbol + padding + formattedValue;
};
// INPUT (javascript/gviz/devel/canviz/axis/axis-decoration.js)
gviz.canviz.axis.AxisDecoration = function(value, position, hasLine, hasTick, isTickHeavy, label) {
  this.value_ = value;
  this.position_ = position;
  this.hasLine_ = hasLine;
  this.hasTick_ = hasTick;
  this.label_ = label;
};
gviz.canviz.axis.AxisDecoration.Alignment = {LEFT:1, CENTER:2, RIGHT:3};
gviz.canviz.axis.AxisDecoration.makeLabeledLineWithHeavyTick = function(value, position, label) {
  return new gviz.canviz.axis.AxisDecoration(value, position, !0, !0, !0, label);
};
gviz.canviz.axis.AxisDecoration.makeLabel = function(value, position, label) {
  return new gviz.canviz.axis.AxisDecoration(value, position, !1, !1, !1, label);
};
gviz.canviz.axis.AxisDecoration.makeLeftAlignedLabel = function(value, position, label) {
  return new gviz.canviz.axis.AxisDecoration(value, position, !1, !1, !1, label, gviz.canviz.axis.AxisDecoration.Alignment.LEFT);
};
gviz.canviz.axis.AxisDecoration.makeLeftAlignedLabelWithLineAndTick = function(value, position, label) {
  return new gviz.canviz.axis.AxisDecoration(value, position, !0, !0, !1, label, gviz.canviz.axis.AxisDecoration.Alignment.LEFT);
};
gviz.canviz.axis.AxisDecoration.makeTick = function(value, position) {
  return new gviz.canviz.axis.AxisDecoration(value, position, !1, !0, !1, null);
};
gviz.canviz.axis.AxisDecoration.makeLineWithTick = function(value, position) {
  return new gviz.canviz.axis.AxisDecoration(value, position, !0, !0, !1, null);
};
gviz.canviz.axis.AxisDecoration.makeLineWithHeavyTick = function(value, position) {
  return new gviz.canviz.axis.AxisDecoration(value, position, !0, !0, !0, null);
};
gviz.canviz.axis.AxisDecoration.prototype.getPosition = function() {
  return Math.round(this.position_);
};
gviz.canviz.axis.AxisDecoration.prototype.getValue = function() {
  return this.value_;
};
gviz.canviz.axis.AxisDecoration.prototype.hasLine = function() {
  return this.hasLine_;
};
gviz.canviz.axis.AxisDecoration.prototype.hasTick = function() {
  return this.hasTick_;
};
gviz.canviz.axis.AxisDecoration.prototype.getLabel = function() {
  return this.label_;
};
gviz.canviz.axis.AxisDecoration.prototype.setLabel = function(label) {
  this.label_ = label;
};
// INPUT (javascript/gviz/devel/canviz/axis/sequence.js)
// INPUT (javascript/gviz/devel/canviz/axis/linear-sequence.js)
gviz.canviz.axis.LinearSequence = function(spacing, opt_offset) {
  this.spacing_ = spacing;
  this.offset_ = opt_offset || 0;
  this.normalizer_ = this.calculateNormalizer(this.spacing_ + this.offset_);
  this.position_ = 0;
};
gviz.canviz.axis.LinearSequence.prototype.next = function() {
  this.position_++;
  return this.getValue();
};
gviz.canviz.axis.LinearSequence.prototype.previous = function() {
  this.position_--;
  return this.getValue();
};
gviz.canviz.axis.LinearSequence.prototype.getValue = function() {
  var result = this.position_ * this.spacing_ + this.offset_;
  return Math.round(result * this.normalizer_) / this.normalizer_;
};
gviz.canviz.axis.LinearSequence.prototype.floor = function(newValue) {
  this.position_ = Math.floor((newValue - this.offset_) / this.spacing_);
  return this.getValue();
};
gviz.canviz.axis.LinearSequence.prototype.ceil = function(newValue) {
  this.position_ = Math.ceil((newValue - this.offset_) / this.spacing_);
  return this.getValue();
};
gviz.canviz.axis.LinearSequence.prototype.round = function(newValue) {
  this.position_ = Math.round((newValue - this.offset_) / this.spacing_);
  return this.getValue();
};
gviz.canviz.axis.LinearSequence.prototype.calculateNormalizer = function(value) {
  if (1 <= value) {
    return 1;
  }
  var stringValue = value.toString(), orderOfMagnitude = 0, endPos = stringValue.indexOf("e");
  -1 != endPos ? orderOfMagnitude = parseInt(stringValue.substr(endPos + 1), 10) : endPos = stringValue.length;
  var decimalPos = stringValue.indexOf(".");
  -1 != decimalPos && (orderOfMagnitude -= endPos - 1 - decimalPos);
  return Math.pow(10, -orderOfMagnitude);
};
// INPUT (javascript/gviz/devel/canviz/axis/mapper.js)
gviz.canviz.axis.Mapper = function() {
};
gviz.canviz.axis.Mapper.prototype.getScreenValue = function() {
};
gviz.canviz.axis.Mapper.prototype.getDataValue = function() {
};
gviz.canviz.axis.Mapper.prototype.getScreenStart = function() {
};
gviz.canviz.axis.Mapper.prototype.getScreenEnd = function() {
};
gviz.canviz.axis.Mapper.prototype.getDataMin = function() {
};
gviz.canviz.axis.Mapper.prototype.getDataMax = function() {
};
// INPUT (javascript/gviz/devel/canviz/axis/axis-tools.js)
gviz.canviz.axis.AxisTools = function(mapper, textMeasurer, orientation, formatter) {
  this.mapper_ = mapper;
  this.textMeasurer_ = textMeasurer;
  this.orientation_ = orientation;
  this.formatter_ = formatter;
};
gviz.canviz.axis.AxisTools.Orientation = {HORIZONTAL:"horizontal", VERTICAL:"vertical"};
gviz.canviz.axis.AxisTools.prototype.allLabelsFit = function(dataValues) {
  var i = dataValues.length;
  if (0 < i) {
    for (;--i;) {
      if (this.detectLabelCollision(dataValues[i - 1], dataValues[i])) {
        return!1;
      }
    }
  }
  return!0;
};
gviz.canviz.axis.AxisTools.prototype.detectLabelCollision = function(value1, value2) {
  var size1 = this.getLabelSize(value1), size2 = this.getLabelSize(value2);
  return Math.abs(this.mapper_.getScreenValue(value1) - this.mapper_.getScreenValue(value2)) < (size1 + size2) / 2;
};
gviz.canviz.axis.AxisTools.prototype.removeCollisionsWithZero = function(dataValues) {
  var result = [];
  if (1 >= dataValues.length || 0 != dataValues[0]) {
    return dataValues;
  }
  result.push(dataValues[0]);
  for (var i = 1, len = dataValues.length;i < len;i++) {
    this.detectLabelCollision(dataValues[0], dataValues[i]) || result.push(dataValues[i]);
  }
  return result;
};
gviz.canviz.axis.AxisTools.prototype.getLabelSize = function(value) {
  var str = this.formatter_.format(value);
  return this.textMeasurer_.getSizeByOrientation(str, this.orientation_);
};
gviz.canviz.axis.AxisTools.prototype.getDataSpanSize = function(screenStart, screenEnd) {
  var dataStart = this.mapper_.getDataValue(screenStart), dataEnd = this.mapper_.getDataValue(screenEnd);
  return Math.abs(dataEnd - dataStart);
};
gviz.canviz.axis.AxisTools.prototype.makeLabels = function(dataValues) {
  for (var decorations = [], i = 0;i < dataValues.length;i++) {
    var dataValue = dataValues[i];
    decorations.push(gviz.canviz.axis.AxisDecoration.makeLabeledLineWithHeavyTick(dataValue, this.mapper_.getScreenValue(dataValue), this.formatter_.format(dataValue)));
  }
  return decorations;
};
gviz.canviz.axis.AxisTools.prototype.findDataValues = function(lineSequence, dataMin, dataMax, spacingValue) {
  if (dataMin == dataMax) {
    return[dataMin];
  }
  if (!goog.math.isFiniteNumber(dataMin)) {
    return[dataMax];
  }
  for (var dataValues = [], value = lineSequence.ceil(dataMin);value <= dataMax;) {
    dataValues.push(value), value = lineSequence.next();
  }
  if (1 == dataValues.length) {
    var attemptSecondLineSequence = new gviz.canviz.axis.LinearSequence(spacingValue / 10), value = attemptSecondLineSequence.floor(dataMax);
    value != dataValues[0] && dataValues.push(value);
  }
  return dataValues;
};
// INPUT (javascript/gviz/devel/canviz/axis/box-cox-signed-mapper.js)
gviz.canviz.axis.BoxCoxSignedMapper = function(dataMin, dataMax, screenStart, screenEnd, boxCoxLambda) {
  this.dataMin_ = dataMin;
  this.dataMax_ = dataMax;
  this.screenStart_ = screenStart;
  this.screenEnd_ = screenEnd;
  this.boxCoxLambda_ = boxCoxLambda;
  var boxCoxDataStart = this.boxCox_(dataMin), boxCoxDataDelta = this.boxCox_(dataMax) - boxCoxDataStart;
  this.deltaQuotient_ = (screenEnd - screenStart) / boxCoxDataDelta;
  this.screenOffset_ = this.deltaQuotient_ * boxCoxDataStart - screenStart;
};
gviz.canviz.axis.BoxCoxSignedMapper.prototype.getScreenValue = function(dataValue) {
  return this.boxCox_(dataValue) * this.deltaQuotient_ - this.screenOffset_;
};
gviz.canviz.axis.BoxCoxSignedMapper.prototype.getDataValue = function(screenValue) {
  return this.antiBoxCox_((screenValue + this.screenOffset_) / this.deltaQuotient_);
};
gviz.canviz.axis.BoxCoxSignedMapper.prototype.boxCox_ = function(value) {
  switch(this.boxCoxLambda_) {
    case 0:
      return Math.log(value);
    case 1:
      return value;
    default:
      return(Math.pow(value, this.boxCoxLambda_) - 1) / this.boxCoxLambda_;
  }
};
gviz.canviz.axis.BoxCoxSignedMapper.prototype.antiBoxCox_ = function(value) {
  switch(this.boxCoxLambda_) {
    case 0:
      return Math.pow(Math.E, value);
    case 1:
      return value;
    default:
      return Math.pow(value * this.boxCoxLambda_ + 1, 1 / this.boxCoxLambda_);
  }
};
// INPUT (javascript/gviz/devel/canviz/axis/box-cox-mapper.js)
gviz.canviz.axis.BoxCoxMapper = function(dataMin, dataMax, screenStart, screenEnd, boxCoxLambda, opt_epsilonValue) {
  this.dataMin = dataMin;
  this.dataMax = dataMax;
  this.screenStart = screenStart;
  this.screenEnd = screenEnd;
  this.boxCoxLambda = boxCoxLambda;
  this.epsilonValue = opt_epsilonValue;
  this.zeroThreshold = this.calculateZeroThreshold_();
  var scrEnd;
  if (dataMin >= this.zeroThreshold) {
    this.mapper = this.newMapper_(dataMin, dataMax, screenStart, screenEnd), this.screenZero = Math.round(this.mapper.getScreenValue(this.zeroThreshold));
  } else {
    if (dataMax <= -this.zeroThreshold) {
      this.mapper = this.newMapper_(-dataMax, -dataMin, screenEnd, screenStart);
      this.screenZero = Math.round(this.mapper.getScreenValue(this.zeroThreshold));
      var scrStart = 2 * this.screenZero - screenEnd;
      scrEnd = 2 * this.screenZero - screenStart;
      this.mapper = this.newMapper_(-dataMax, -dataMin, scrStart, scrEnd);
    } else {
      if (dataMin >= -this.zeroThreshold) {
        this.screenZero = Math.round(screenStart), this.mapper = this.newMapper_(this.zeroThreshold, dataMax, this.screenZero, screenEnd);
      } else {
        if (dataMax <= this.zeroThreshold) {
          this.screenZero = Math.round(screenEnd), scrEnd = 2 * this.screenZero - screenStart, this.mapper = this.newMapper_(this.zeroThreshold, -dataMin, this.screenZero, scrEnd);
        } else {
          this.mapper = this.newMapper_(this.zeroThreshold, dataMax, 0, 1);
          var part = this.mapper.getScreenValue(-dataMin), offset = part / (part + 1) * (screenEnd - screenStart);
          this.screenZero = Math.round(screenStart + offset);
          dataMax >= -dataMin ? this.mapper = this.newMapper_(this.zeroThreshold, dataMax, this.screenZero, screenEnd) : (scrEnd = 2 * this.screenZero - screenStart, this.mapper = this.newMapper_(this.zeroThreshold, -dataMin, this.screenZero, scrEnd));
        }
      }
    }
  }
  this.reversed = screenEnd < screenStart;
};
gviz.canviz.axis.BoxCoxMapper.prototype.getDataMin = function() {
  return this.dataMin;
};
gviz.canviz.axis.BoxCoxMapper.prototype.getDataMax = function() {
  return this.dataMax;
};
gviz.canviz.axis.BoxCoxMapper.prototype.getScreenStart = function() {
  return this.screenStart;
};
gviz.canviz.axis.BoxCoxMapper.prototype.getScreenEnd = function() {
  return this.screenEnd;
};
gviz.canviz.axis.BoxCoxMapper.prototype.calculateZeroThreshold_ = function() {
  var zeroThreshold;
  this.dataMin == this.dataMax ? zeroThreshold = this.dataMin / 2 : isNaN(this.epsilonValue) ? zeroThreshold = gviz.canviz.axis.Pow10Math.floor(this.dataMax - this.dataMin) / 1E3 : (zeroThreshold = this.epsilonValue / 2, 0 < this.dataMin && (zeroThreshold = Math.min(this.dataMin, zeroThreshold)));
  return zeroThreshold;
};
gviz.canviz.axis.BoxCoxMapper.prototype.newMapper_ = function(dataMin, dataMax, screenStart, screenEnd) {
  return new gviz.canviz.axis.BoxCoxSignedMapper(dataMin, dataMax, screenStart, screenEnd, this.boxCoxLambda);
};
gviz.canviz.axis.BoxCoxMapper.prototype.getDataValue = function(screenValue) {
  if (this.dataMin == this.dataMax) {
    return this.dataMin;
  }
  var sign = this.reversed ? -1 : 1;
  return screenValue * sign > this.screenZero * sign ? this.mapper.getDataValue(screenValue) : screenValue * sign < this.screenZero * sign ? -this.mapper.getDataValue(2 * this.screenZero - screenValue) : 0;
};
gviz.canviz.axis.BoxCoxMapper.prototype.getScreenValue = function(dataValue) {
  return this.dataMin == this.dataMax ? Math.abs(this.screenStart - this.screenEnd) / 2 : dataValue > this.zeroThreshold ? this.mapper.getScreenValue(dataValue) : dataValue < -this.zeroThreshold ? 2 * this.screenZero - this.mapper.getScreenValue(-dataValue) : this.screenZero;
};
// INPUT (javascript/gviz/devel/canviz/axis/custom-powers-of-10.js)
gviz.canviz.axis.CustomPowersOf10 = function(multipliers) {
  this.checkMultipliers(multipliers);
  this.multipliers_ = multipliers.concat();
  this.levelLength_ = multipliers.length;
  this.position_ = 0;
};
gviz.canviz.axis.CustomPowersOf10.prototype.next = function() {
  this.position_++;
  return this.getValue();
};
gviz.canviz.axis.CustomPowersOf10.prototype.previous = function() {
  this.position_--;
  return this.getValue();
};
gviz.canviz.axis.CustomPowersOf10.prototype.checkMultipliers = function(multipliers) {
  var length = multipliers.length;
  goog.asserts.assert(0 < length, "Multiplier is empty.");
  goog.asserts.assert(1 <= multipliers[0], "Multipliers first value is too low.");
  goog.asserts.assert(10 > multipliers[length - 1], "Multipliers last value is too high.");
  for (var previous = 0, value, i = 0;i < length;i++) {
    value = multipliers[i], goog.asserts.assert(goog.isNumber(multipliers[i]), "MultiplierList contains non-numerical value."), goog.asserts.assert(value > previous, "MultiplierList is not sorted."), previous = value;
  }
};
gviz.canviz.axis.CustomPowersOf10.prototype.getValue = function() {
  var k = Math.floor(this.position_ / this.levelLength_), i = this.position_ - k * this.levelLength_;
  return gviz.canviz.axis.Pow10Math.exactScientific(this.multipliers_[i], k);
};
gviz.canviz.axis.CustomPowersOf10.prototype.floor = function(value) {
  goog.asserts.assert(0 < value, "Value must be positive");
  this.position_ = this.levelLength_ * gviz.canviz.axis.Pow10Math.ceilExponent(value);
  if (this.getValue() != value) {
    for (;this.previous() > value;) {
    }
  }
  return this.getValue();
};
gviz.canviz.axis.CustomPowersOf10.prototype.ceil = function(value) {
  goog.asserts.assert(0 < value, "Value must be positive");
  this.position_ = this.levelLength_ * gviz.canviz.axis.Pow10Math.floorExponent(value);
  if (this.getValue() != value) {
    for (;this.next() < value;) {
    }
  }
  return this.getValue();
};
gviz.canviz.axis.CustomPowersOf10.prototype.round = function(value) {
  goog.asserts.assert(0 < value, "Value must be positive");
  this.position_ = this.levelLength_ * gviz.canviz.axis.Pow10Math.ceilExponent(value);
  if (this.getValue() != value) {
    for (;this.previous() > value;) {
    }
    if (value - this.getValue() < this.next() - value) {
      return this.previous();
    }
  }
  return this.getValue();
};
// INPUT (javascript/gviz/devel/canviz/axis/lin-axis-decoration-supplier.js)
gviz.canviz.axis.LinAxisDecorationSupplier = function(mapper, formatter, textMeasurer, orientation, minScreenDistance) {
  this.mapper = mapper;
  this.minScreenDistance = minScreenDistance;
  this.axisTools_ = new gviz.canviz.axis.AxisTools(mapper, textMeasurer, orientation, formatter);
  this.spacingSequence_ = new gviz.canviz.axis.CustomPowersOf10([1, 2, 5]);
};
gviz.canviz.axis.LinAxisDecorationSupplier.prototype.getDecorations = function() {
  var spacingValue = this.getSpacingValue_(), dataValues;
  this.spacingSequence_.floor(spacingValue);
  do {
    var attemptSequence = new gviz.canviz.axis.LinearSequence(spacingValue);
    dataValues = this.axisTools_.findDataValues(attemptSequence, this.mapper.getDataMin(), this.mapper.getDataMax(), spacingValue);
    spacingValue = this.spacingSequence_.next();
  } while (!this.axisTools_.allLabelsFit(dataValues));
  return this.axisTools_.makeLabels(dataValues);
};
gviz.canviz.axis.LinAxisDecorationSupplier.prototype.getSpacingValue_ = function() {
  var screenMin = this.mapper.getScreenStart(), screenMax = this.mapper.getScreenEnd(), valueCloseToMax = this.axisTools_.getDataSpanSize(screenMax - this.minScreenDistance, screenMax), valueCloseToMin = this.axisTools_.getDataSpanSize(screenMin, screenMin + this.minScreenDistance), largestSpacing = Math.max(valueCloseToMin, valueCloseToMax), screenZero = this.mapper.getScreenValue(0);
  if (screenZero >= screenMin && screenZero <= screenMax) {
    var valueCloseToZero = this.mapper.getDataValue(this.mapper.getScreenValue(0) + this.minScreenDistance), largestSpacing = Math.max(largestSpacing, valueCloseToZero)
  }
  return this.spacingSequence_.ceil(largestSpacing);
};
// INPUT (javascript/gviz/devel/canviz/axis/lin-mapper.js)
gviz.canviz.axis.LinMapper = function(dataMin, dataMax, screenMin, screenMax) {
  this.dataMin_ = dataMin;
  this.dataMax_ = dataMax;
  this.screenMin_ = screenMin;
  this.screenMax_ = screenMax;
  this.deltaQuotient_ = (this.screenMax_ - this.screenMin_) / (this.dataMax_ - this.dataMin_);
  this.screenOffset_ = this.deltaQuotient_ * this.dataMin_ - this.screenMin_;
};
gviz.canviz.axis.LinMapper.prototype.getDataValue = function(screenValue) {
  return(screenValue + this.screenOffset_) / this.deltaQuotient_;
};
gviz.canviz.axis.LinMapper.prototype.getScreenValue = function(dataValue) {
  return dataValue * this.deltaQuotient_ - this.screenOffset_;
};
gviz.canviz.axis.LinMapper.prototype.getScreenStart = function() {
  return this.screenMin_;
};
gviz.canviz.axis.LinMapper.prototype.getScreenEnd = function() {
  return this.screenMax_;
};
gviz.canviz.axis.LinMapper.prototype.getDataMin = function() {
  return this.dataMin_;
};
gviz.canviz.axis.LinMapper.prototype.getDataMax = function() {
  return this.dataMax_;
};
// INPUT (javascript/gviz/devel/canviz/axis/paced-powers-of-10-mirror.js)
gviz.canviz.axis.PacedPowersOf10Mirror = function(numSteps, minimumValue) {
  this.numSteps_ = numSteps;
  this.numExcluded_ = Math.floor(numSteps / 10);
  this.actualNumSteps_ = numSteps - this.numExcluded_;
  this.location_ = 0;
  this.minExponent_ = gviz.canviz.axis.Pow10Math.floorExponent(Math.abs(minimumValue));
  this.zeroOffset_ = this.actualNumSteps_ * this.minExponent_;
  this.position_ = 0;
};
gviz.canviz.axis.PacedPowersOf10Mirror.prototype.getValueInternal_ = function() {
  var k = Math.floor(this.position_ / this.actualNumSteps_), i;
  i = 10 * (this.position_ + this.numExcluded_ - k * this.actualNumSteps_) / this.numSteps_;
  0 == i && (i = 1);
  return gviz.canviz.axis.Pow10Math.exactScientific(i, k);
};
gviz.canviz.axis.PacedPowersOf10Mirror.prototype.getValue = function() {
  this.position_ = Math.abs(this.location_) + this.zeroOffset_;
  return 0 < this.location_ ? this.getValueInternal_() : 0 > this.location_ ? -this.getValueInternal_() : 0;
};
gviz.canviz.axis.PacedPowersOf10Mirror.prototype.next = function() {
  this.location_++;
  return this.getValue();
};
gviz.canviz.axis.PacedPowersOf10Mirror.prototype.previous = function() {
  this.location_--;
  return this.getValue();
};
gviz.canviz.axis.PacedPowersOf10Mirror.prototype.floor = function(newValue) {
  var excludedOffset = this.numExcluded_, tmp = gviz.canviz.axis.Pow10Math.floorExponent(Math.abs(newValue));
  if (Math.abs(newValue) <= Math.pow(10, this.minExponent_)) {
    return this.location_ = 0 > newValue ? -1 : 0, this.getValue();
  }
  0 < newValue ? this.location_ = this.actualNumSteps_ * tmp - this.zeroOffset_ : 0 > newValue && (this.location_ = this.zeroOffset_ - this.actualNumSteps_ * tmp, excludedOffset = -excludedOffset);
  this.getValue() != newValue && (tmp = this.numSteps_ * newValue / gviz.canviz.axis.Pow10Math.ceil(Math.abs(newValue)), this.location_ += Math.floor(tmp) - excludedOffset);
  return this.getValue();
};
gviz.canviz.axis.PacedPowersOf10Mirror.prototype.ceil = function(newValue) {
  var excludedOffset = this.numExcluded_, tmp = gviz.canviz.axis.Pow10Math.floorExponent(Math.abs(newValue));
  if (Math.abs(newValue) <= Math.pow(10, this.minExponent_)) {
    return this.location_ = 0 < newValue ? 1 : 0, this.getValue();
  }
  0 < newValue ? this.location_ = this.actualNumSteps_ * tmp - this.zeroOffset_ : 0 > newValue && (this.location_ = this.zeroOffset_ - this.actualNumSteps_ * tmp, excludedOffset = -excludedOffset);
  this.getValue() != newValue && (tmp = this.numSteps_ * newValue / gviz.canviz.axis.Pow10Math.ceil(Math.abs(newValue)), this.location_ += Math.ceil(tmp) - excludedOffset);
  return this.getValue();
};
gviz.canviz.axis.PacedPowersOf10Mirror.prototype.round = function(newValue) {
  var tmp = gviz.canviz.axis.Pow10Math.floorExponent(Math.abs(newValue));
  if (Math.abs(newValue) <= Math.pow(10, this.minExponent_)) {
    return this.location_ = 0;
  }
  if (0 < newValue) {
    this.location_ = this.actualNumSteps_ * tmp - this.zeroOffset_;
    if (this.next() > newValue) {
      return newValue - this.getValue() >= this.previous() - newValue ? this.next() : this.getValue();
    }
    this.previous();
  } else {
    if (0 > newValue) {
      this.location_ = this.zeroOffset_ - this.actualNumSteps_ * tmp;
      if (this.previous() < newValue) {
        return newValue - this.getValue() < this.next() - newValue ? this.previous() : this.getValue();
      }
      this.next();
    }
  }
  this.getValue() != newValue && (tmp = this.numSteps_ * newValue / gviz.canviz.axis.Pow10Math.ceil(Math.abs(newValue)), this.location_ += Math.round(tmp) - this.numExcluded_);
  return this.getValue();
};
// INPUT (javascript/gviz/devel/canviz/axis/log-axis-decoration-supplier.js)
gviz.canviz.axis.LogAxisDecorationSupplier = function(mapper, formatter, textMeasurer, orientation, minScreenDistance, epsilon) {
  this.mapper_ = mapper;
  this.formatter_ = formatter;
  this.textMeasurer_ = textMeasurer;
  this.orientation_ = orientation;
  this.epsilon_ = epsilon;
  this.minScreenDistance_ = minScreenDistance;
  this.axisTools_ = new gviz.canviz.axis.AxisTools(mapper, textMeasurer, orientation, formatter);
  this.spacingSequence_ = new gviz.canviz.axis.CustomPowersOf10([1, 2, 5]);
};
gviz.canviz.axis.LogAxisDecorationSupplier.prototype.getDecorations = function() {
  var epsilon = this.epsilon_ / 10, spacingValue = this.getSpacingValue_(), lineSequence = new gviz.canviz.axis.PacedPowersOf10Mirror(spacingValue, epsilon), dataValues = this.axisTools_.findDataValues(lineSequence, this.mapper_.getDataMin(), this.mapper_.getDataMax(), spacingValue);
  if (2 > dataValues.length) {
    return this.axisTools_.makeLabels(dataValues);
  }
  var firstValue = dataValues[0], secondValue = dataValues[1];
  if (0 == firstValue) {
    if (3 > dataValues.length) {
      return this.axisTools_.makeLabels(dataValues);
    }
    firstValue = secondValue;
    secondValue = dataValues[2];
  }
  var firstPowerOfTen = gviz.canviz.axis.Pow10Math.ceil(Math.abs(firstValue));
  firstPowerOfTen == firstValue && (firstPowerOfTen *= 10);
  var largestPossibleNumSteps = firstPowerOfTen / Math.abs(secondValue - firstValue);
  this.spacingSequence_.ceil(largestPossibleNumSteps);
  do {
    var spacingValue = this.spacingSequence_.previous(), attemptSequence = new gviz.canviz.axis.PacedPowersOf10Mirror(spacingValue, epsilon), dataValues = this.axisTools_.findDataValues(attemptSequence, this.mapper_.getDataMin(), this.mapper_.getDataMax(), spacingValue), dataValues = this.axisTools_.removeCollisionsWithZero(dataValues)
  } while (!this.axisTools_.allLabelsFit(dataValues));
  return this.axisTools_.makeLabels(dataValues);
};
gviz.canviz.axis.LogAxisDecorationSupplier.prototype.getSpacingValue_ = function() {
  var powTen = this.mapper_.getScreenValue(10 * this.epsilon_), belowPowTen, numSteps;
  this.spacingSequence_.floor(1);
  do {
    numSteps = this.spacingSequence_.next(), belowPowTen = this.mapper_.getScreenValue(10 * this.epsilon_ * (numSteps - 1) / numSteps);
  } while (Math.abs(powTen - belowPowTen) >= this.minScreenDistance_);
  return this.spacingSequence_.previous();
};
// INPUT (javascript/gviz/devel/canviz/axis/month-sequence.js)
gviz.canviz.axis.MonthSequence = function(opt_monthsPerStep, opt_monthOffset) {
  goog.isDefAndNotNull(opt_monthsPerStep) ? (goog.asserts.assert(1 <= opt_monthsPerStep), goog.asserts.assert(opt_monthsPerStep == Math.round(opt_monthsPerStep)), this.stepSize_ = opt_monthsPerStep) : this.stepSize_ = 1;
  12 < this.stepSize_ && (this.yearSequence_ = new gviz.canviz.axis.LinearSequence(Math.floor(this.stepSize_ / 12)));
  var monthOffset = opt_monthOffset || 0;
  goog.asserts.assert(monthOffset == Math.round(monthOffset));
  goog.asserts.assert(-11 <= monthOffset && 11 >= monthOffset);
  this.fullOffset_ = monthOffset;
  this.monthStepper_ = new Date;
  this.floor(0);
};
gviz.canviz.axis.MonthSequence.prototype.getValue = function() {
  return this.monthStepper_.getTime();
};
gviz.canviz.axis.MonthSequence.prototype.next = function() {
  var month = this.monthStepper_.getUTCMonth(), month = month + this.stepSize_;
  this.monthStepper_.setUTCMonth(month);
  return this.getValue();
};
gviz.canviz.axis.MonthSequence.prototype.previous = function() {
  this.monthStepper_.setUTCMonth(this.monthStepper_.getUTCMonth() - this.stepSize_);
  return this.getValue();
};
gviz.canviz.axis.MonthSequence.prototype.floor = function(newValue) {
  this.monthStepper_.setTime(newValue);
  if (1 < this.stepSize_) {
    var monthDelta = (this.monthStepper_.getUTCMonth() + 12 - this.fullOffset_) % this.stepSize_ % 12;
    this.monthStepper_.setUTCMonth(this.monthStepper_.getUTCMonth() - monthDelta);
    if (12 < this.stepSize_) {
      var year = this.yearSequence_.floor(this.monthStepper_.getUTCFullYear());
      this.monthStepper_.setUTCFullYear(year);
    }
  }
  this.monthStepper_.setUTCDate(1);
  this.monthStepper_.setUTCHours(0, 0, 0, 0);
  return this.getValue();
};
gviz.canviz.axis.MonthSequence.prototype.ceil = function(newValue) {
  return this.floor(newValue) < newValue ? this.next() : this.getValue();
};
gviz.canviz.axis.MonthSequence.prototype.round = function(newValue) {
  return this.floor(newValue) != newValue && newValue - this.getValue() < this.next() - newValue ? this.previous() : this.getValue();
};
// INPUT (javascript/gviz/devel/canviz/axis/powers-of-10-sequence.js)
gviz.canviz.axis.PowersOf10Sequence = function() {
  this.position_ = 0;
};
gviz.canviz.axis.PowersOf10Sequence.prototype.next = function() {
  this.position_++;
  return this.getValue();
};
gviz.canviz.axis.PowersOf10Sequence.prototype.previous = function() {
  this.position_--;
  return this.getValue();
};
gviz.canviz.axis.PowersOf10Sequence.prototype.getValue = function() {
  return gviz.canviz.axis.Pow10Math.exactScientific(1, this.position_);
};
gviz.canviz.axis.PowersOf10Sequence.prototype.floor = function(newValue) {
  goog.asserts.assert(0 < newValue, "newValue must be > 0");
  this.position_ = gviz.canviz.axis.Pow10Math.floorExponent(newValue);
  return this.getValue();
};
gviz.canviz.axis.PowersOf10Sequence.prototype.ceil = function(newValue) {
  goog.asserts.assert(0 < newValue, "newValue must be > 0");
  this.position_ = gviz.canviz.axis.Pow10Math.ceilExponent(newValue);
  return this.getValue();
};
gviz.canviz.axis.PowersOf10Sequence.prototype.round = function(newValue) {
  goog.asserts.assert(0 < newValue, "newValue must be > 0");
  this.position_ = gviz.canviz.axis.Pow10Math.roundExponent(gviz.canviz.axis.Pow10Math.round(newValue));
  return this.getValue();
};
// INPUT (javascript/gviz/devel/canviz/axis/time-unit-sequence.js)
gviz.canviz.axis.TimeUnitSequence = function(opt_granular) {
  opt_granular ? (this.definedUnits_ = [gviz.canviz.axis.Milliseconds.SECOND, 5 * gviz.canviz.axis.Milliseconds.SECOND, 10 * gviz.canviz.axis.Milliseconds.SECOND, 15 * gviz.canviz.axis.Milliseconds.SECOND, 30 * gviz.canviz.axis.Milliseconds.SECOND, gviz.canviz.axis.Milliseconds.MINUTE, 5 * gviz.canviz.axis.Milliseconds.MINUTE, 10 * gviz.canviz.axis.Milliseconds.MINUTE, 15 * gviz.canviz.axis.Milliseconds.MINUTE, 30 * gviz.canviz.axis.Milliseconds.MINUTE, gviz.canviz.axis.Milliseconds.HOUR, 3 * gviz.canviz.axis.Milliseconds.HOUR, 
  6 * gviz.canviz.axis.Milliseconds.HOUR, 12 * gviz.canviz.axis.Milliseconds.HOUR, gviz.canviz.axis.Milliseconds.DAY, gviz.canviz.axis.Milliseconds.WEEK, gviz.canviz.axis.Milliseconds.MONTH, gviz.canviz.axis.Milliseconds.QUARTER, gviz.canviz.axis.Milliseconds.YEAR], this.sequence_ = new gviz.canviz.axis.CustomPowersOf10([1, 2, 5])) : (this.definedUnits_ = [gviz.canviz.axis.Milliseconds.SECOND, gviz.canviz.axis.Milliseconds.MINUTE, gviz.canviz.axis.Milliseconds.HOUR, gviz.canviz.axis.Milliseconds.DAY, 
  gviz.canviz.axis.Milliseconds.WEEK, gviz.canviz.axis.Milliseconds.MONTH, gviz.canviz.axis.Milliseconds.QUARTER, gviz.canviz.axis.Milliseconds.YEAR], this.sequence_ = new gviz.canviz.axis.PowersOf10Sequence);
  this.minUnitValue_ = this.sequence_.round(this.definedUnits_[0]);
  this.precedingValue_ = this.sequence_.previous();
  this.precedingCutoff_ = this.precedingValue_ + (this.minUnitValue_ - this.precedingValue_) / 2;
  this.maxUnitValue_ = this.definedUnits_[this.definedUnits_.length - 1];
  this.sequence_.round(1);
  this.succeedingValue_ = this.maxUnitValue_ * this.sequence_.next();
  this.succeedingCutoff_ = this.maxUnitValue_ + (this.succeedingValue_ - this.maxUnitValue_) / 2;
  this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.SMALLEST);
};
gviz.canviz.axis.TimeUnitSequence.Phase = {BELOW:1, SMALLEST:2, LARGEST:3, ABOVE:4};
gviz.canviz.axis.TimeUnitSequence.prototype.shiftPhase_ = function(phase) {
  this.usingSequence_ = phase == gviz.canviz.axis.TimeUnitSequence.Phase.BELOW || phase == gviz.canviz.axis.TimeUnitSequence.Phase.ABOVE;
  phase == gviz.canviz.axis.TimeUnitSequence.Phase.SMALLEST ? this.position_ = 0 : phase == gviz.canviz.axis.TimeUnitSequence.Phase.LARGEST ? this.position_ = this.definedUnits_.length - 1 : phase == gviz.canviz.axis.TimeUnitSequence.Phase.BELOW ? this.multiplier_ = 1 : phase == gviz.canviz.axis.TimeUnitSequence.Phase.ABOVE && (this.multiplier_ = this.maxUnitValue_);
};
gviz.canviz.axis.TimeUnitSequence.prototype.getValue = function() {
  return this.usingSequence_ ? this.multiplier_ * this.sequence_.getValue() : this.definedUnits_[this.position_];
};
gviz.canviz.axis.TimeUnitSequence.prototype.floor = function(newValue) {
  if (newValue < this.minUnitValue_) {
    return this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.BELOW), this.sequence_.floor(newValue);
  }
  if (newValue >= this.succeedingValue_) {
    return this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.ABOVE), this.multiplier_ * this.sequence_.floor(newValue / this.multiplier_);
  }
  for (this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.SMALLEST);newValue >= this.definedUnits_[this.position_];) {
    this.position_++;
  }
  return this.definedUnits_[--this.position_];
};
gviz.canviz.axis.TimeUnitSequence.prototype.ceil = function(newValue) {
  if (newValue <= this.precedingValue_) {
    return this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.BELOW), this.sequence_.ceil(newValue);
  }
  if (newValue > this.maxUnitValue_) {
    return this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.ABOVE), this.multiplier_ * this.sequence_.ceil(newValue / this.multiplier_);
  }
  for (this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.LARGEST);newValue <= this.definedUnits_[this.position_];) {
    this.position_--;
  }
  return this.definedUnits_[++this.position_];
};
gviz.canviz.axis.TimeUnitSequence.prototype.round = function(newValue) {
  if (newValue < this.precedingCutoff_) {
    return this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.BELOW), this.sequence_.round(newValue);
  }
  if (newValue >= this.succeedingCutoff_) {
    return this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.ABOVE), this.multiplier_ * this.sequence_.round(newValue / this.multiplier_);
  }
  for (this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.LARGEST);0 < this.position_ && newValue < this.definedUnits_[this.position_];) {
    this.position_--;
  }
  this.definedUnits_[this.position_ + 1] - newValue <= newValue - this.definedUnits_[this.position_] && this.position_++;
  return this.definedUnits_[this.position_];
};
gviz.canviz.axis.TimeUnitSequence.prototype.next = function() {
  this.usingSequence_ ? (this.sequence_.next(), 1 == this.multiplier_ && this.sequence_.getValue() == this.minUnitValue_ && this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.SMALLEST)) : (this.position_++, this.position_ == this.definedUnits_.length && (this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.ABOVE), this.sequence_.round(1), this.sequence_.next()));
  return this.getValue();
};
gviz.canviz.axis.TimeUnitSequence.prototype.previous = function() {
  this.usingSequence_ ? (this.sequence_.previous(), this.multiplier_ == this.maxUnitValue_ && 1 == this.sequence_.getValue() && this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.LARGEST)) : (this.position_--, -1 == this.position_ && (this.shiftPhase_(gviz.canviz.axis.TimeUnitSequence.Phase.BELOW), this.sequence_.round(this.minUnitValue_), this.sequence_.previous()));
  return this.getValue();
};
// INPUT (javascript/gviz/devel/canviz/axis/utils.js)
gviz.canviz.axis.Utils = {};
gviz.canviz.axis.Utils.createTimeSequence = function(timeUnit, opt_firstDayOfWeek) {
  var firstDayOfWeek = goog.isDefAndNotNull(opt_firstDayOfWeek) ? opt_firstDayOfWeek : 1;
  timeUnit = (new gviz.canviz.axis.TimeUnitSequence(!0)).round(timeUnit);
  if (timeUnit < gviz.canviz.axis.Milliseconds.MONTH) {
    if (timeUnit == gviz.canviz.axis.Milliseconds.WEEK) {
      var offset = gviz.canviz.axis.Milliseconds.DAY * (3 + firstDayOfWeek);
      return new gviz.canviz.axis.LinearSequence(timeUnit, offset);
    }
    return new gviz.canviz.axis.LinearSequence(timeUnit);
  }
  return new gviz.canviz.axis.MonthSequence(Math.round(timeUnit / gviz.canviz.axis.Milliseconds.MONTH));
};
gviz.canviz.axis.Utils.millisecondsToIsoStr = function(time) {
  if (!isFinite(time)) {
    return "notime";
  }
  var date = new Date;
  date.setTime(time);
  var res = "", res = res + gviz.canviz.axis.Utils.zeroPad(date.getUTCFullYear().toString(), 4), month = date.getUTCMonth(), day = date.getUTCDate(), showMonth = 0 != month, showDay = 1 != day, hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds(), showTime = 0 != hours || 0 != minutes || 0 != seconds || 0 != milliseconds;
  if (showMonth || showDay || showTime) {
    res += "-", res += gviz.canviz.axis.Utils.zeroPad((month + 1).toString(), 2);
  }
  if (showDay || showTime) {
    res += "-", res += gviz.canviz.axis.Utils.zeroPad(day.toString(), 2);
  }
  showTime && (res += "T", res += gviz.canviz.axis.Utils.zeroPad(hours.toString(), 2), res += ":", res += gviz.canviz.axis.Utils.zeroPad(minutes.toString(), 2), res += ":", res += gviz.canviz.axis.Utils.zeroPad(seconds.toString(), 2), res += ".", res += gviz.canviz.axis.Utils.zeroPad(milliseconds.toString(), 3));
  return res;
};
gviz.canviz.axis.Utils.timeToCustomIsoStr = function(time, timeUnit) {
  goog.asserts.assert(isFinite(time), "Time must be finite");
  var timeUnits = gviz.canviz.axis.Milliseconds.TIME_UNIT, res = "", date = new Date;
  date.setTime(time);
  var year = date.getUTCFullYear(), month = date.getUTCMonth(), day = date.getUTCDate(), hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds(), res = res + gviz.canviz.axis.Utils.zeroPad(year.toString(), 4);
  if (timeUnit == timeUnits.YEAR) {
    return res;
  }
  res += "-";
  res += gviz.canviz.axis.Utils.zeroPad((month + 1).toString(), 2);
  if (timeUnit == timeUnits.MONTH) {
    return res;
  }
  res += "-";
  res += gviz.canviz.axis.Utils.zeroPad(day.toString(), 2);
  if (timeUnit == timeUnits.DAY) {
    return res;
  }
  res += "T";
  res += gviz.canviz.axis.Utils.zeroPad(hours.toString(), 2);
  res += ":";
  res += gviz.canviz.axis.Utils.zeroPad(minutes.toString(), 2);
  res += ":";
  res += gviz.canviz.axis.Utils.zeroPad(seconds.toString(), 2);
  res += ".";
  return res += gviz.canviz.axis.Utils.zeroPad(milliseconds.toString(), 3);
};
gviz.canviz.axis.Utils.zeroPad = function(str, toLength) {
  for (var fromLength = str.length, i = fromLength;i < toLength;i++) {
    str = "0" + str;
  }
  return str;
};
gviz.canviz.axis.Utils.isoStrToMilliseconds = function(str) {
  if ("notime" == str || null == str || "" == str) {
    return NaN;
  }
  var year = 0, month = 0, day = 1, hour = 0, minute = 0, second = 0, millisecond = 0, year = parseInt(str.substr(0, 4), 10);
  4 < str.length && (month = parseInt(str.substr(5, 2), 10) - 1, 7 < str.length && (day = parseInt(str.substr(8, 2), 10), 10 < str.length && (hour = parseInt(str.substr(11, 2), 10), minute = parseInt(str.substr(14, 2), 10), second = parseInt(str.substr(17, 2), 10), millisecond = parseInt(str.substr(20, 3), 10))));
  var value = Date.UTC(year, month, day, hour, minute, second, millisecond);
  return value;
};
gviz.canviz.axis.Utils.timeLengthStr = function(length) {
  if (isNaN(length)) {
    return "Time is NaN.";
  }
  var res = "", years = Math.floor(length / gviz.canviz.axis.Milliseconds.YEAR);
  0 < years && (res += years + " years, ", length -= years * gviz.canviz.axis.Milliseconds.YEAR);
  var days = Math.floor(length / gviz.canviz.axis.Milliseconds.DAY);
  0 < days && (res += days + " days, ", length -= days * gviz.canviz.axis.Milliseconds.DAY);
  var hours = Math.floor(length / gviz.canviz.axis.Milliseconds.HOUR);
  0 < hours && (res += hours + " h, ", length -= hours * gviz.canviz.axis.Milliseconds.HOUR);
  var minutes = Math.floor(length / gviz.canviz.axis.Milliseconds.MINUTE);
  0 < minutes && (res += minutes + " m, ", length -= minutes * gviz.canviz.axis.Milliseconds.MINUTE);
  var seconds = Math.floor(length / gviz.canviz.axis.Milliseconds.SECOND);
  0 < seconds && (res += seconds + " s");
  return res;
};
gviz.canviz.axis.Utils.roundToNextEvenValue = function(value, maxDiff) {
  return 0 > value ? -gviz.canviz.axis.Utils.roundDown_(-value, maxDiff) : gviz.canviz.axis.Utils.roundUp_(value, maxDiff);
};
gviz.canviz.axis.Utils.roundToPrevEvenValue = function(value, maxDiff) {
  return 0 > value ? -gviz.canviz.axis.Utils.roundUp_(-value, maxDiff) : gviz.canviz.axis.Utils.roundDown_(value, maxDiff);
};
gviz.canviz.axis.Utils.expandRange = function(range, maxChange) {
  if (range.start == range.end || 0 == maxChange) {
    return range;
  }
  goog.asserts.assert(isFinite(range.start) && isFinite(range.end), "Range must be finite.");
  goog.asserts.assert(range.start <= range.end, "Range start must be less or equal to end.");
  var maxDiff = (range.end - range.start) * maxChange;
  return new goog.math.Range(gviz.canviz.axis.Utils.roundToPrevEvenValue(range.start, maxDiff), gviz.canviz.axis.Utils.roundToNextEvenValue(range.end, maxDiff));
};
gviz.canviz.axis.Utils.roundDown_ = function(value, maxDiff) {
  function isDone(testVal) {
    return testVal <= value && testVal > value - maxDiff;
  }
  if (0 == value) {
    return 0;
  }
  for (var remaining = value, sum = 0, result = NaN, unRounded;0 < remaining;) {
    var exponent = gviz.canviz.axis.Pow10Math.floorExponent(remaining), power = gviz.canviz.axis.Pow10Math.exactScientific(1, exponent), leadingDigit = gviz.canviz.axis.Utils.getLeadingDigit_(remaining);
    if (5 < leadingDigit && (unRounded = 5 * power + sum, result = gviz.canviz.axis.Utils.roundToNumDecimals(unRounded, exponent), isDone(result))) {
      break;
    }
    unRounded = leadingDigit * power + sum;
    result = gviz.canviz.axis.Utils.roundToNumDecimals(unRounded, exponent);
    if (isDone(result)) {
      break;
    }
    var level = leadingDigit * power, sum = sum + level, remaining = remaining - level;
  }
  return result;
};
gviz.canviz.axis.Utils.roundUp_ = function(value, maxDiff) {
  function isDone(testVal) {
    return testVal <= value + maxDiff && testVal >= value;
  }
  if (0 == value) {
    return 0;
  }
  for (var remaining = value, sum = 0, result = NaN, unRounded;0 < remaining;) {
    var exponent = gviz.canviz.axis.Pow10Math.floorExponent(remaining), power = gviz.canviz.axis.Pow10Math.exactScientific(1, exponent), leadingDigit = gviz.canviz.axis.Utils.getLeadingDigit_(remaining);
    if (5 > leadingDigit && (unRounded = 5 * power + sum, result = gviz.canviz.axis.Utils.roundToNumDecimals(unRounded, exponent), isDone(result))) {
      break;
    }
    unRounded = leadingDigit * power + sum;
    result = gviz.canviz.axis.Utils.roundToNumDecimals(unRounded, exponent);
    if (isDone(result)) {
      break;
    }
    unRounded = (leadingDigit + 1) * power + sum;
    result = gviz.canviz.axis.Utils.roundToNumDecimals(unRounded, exponent);
    if (isDone(result)) {
      break;
    }
    var level = leadingDigit * power, sum = sum + level, remaining = remaining - level;
  }
  return result;
};
gviz.canviz.axis.Utils.roundToNumDecimals = function(value, numDecimals) {
  var rounder = gviz.canviz.axis.Pow10Math.exactScientific(1, Math.abs(numDecimals)), multipliedAndRounded = Math.round(value * rounder);
  return multipliedAndRounded / rounder;
};
gviz.canviz.axis.Utils.getLeadingDigit_ = function(value) {
  var exponent = gviz.canviz.axis.Pow10Math.floorExponent(value), power = gviz.canviz.axis.Pow10Math.exactScientific(1, exponent), normalized = value / power, diff = Math.abs(Math.round(normalized) - normalized);
  0 != diff && 1E-10 > diff && (normalized = Math.round(normalized));
  return Math.floor(normalized);
};
// INPUT (javascript/gviz/devel/canviz/axis/time-axis-strategy.js)
gviz.canviz.axis.TimeAxisStrategy = function(dataGranularity, labelGranularity, unitsPerLabel, textMeasurer, timeFormatter, mapper, minLabelDistance, orientation, includeLastTimePoint) {
  this.dataGranularity_ = dataGranularity;
  this.labelGranularity_ = labelGranularity;
  this.unitsPerLabel_ = unitsPerLabel;
  this.textMeasurer_ = textMeasurer;
  this.timeFormatter_ = timeFormatter;
  this.mapper_ = mapper;
  this.minLabelDistance_ = minLabelDistance;
  this.orientation_ = orientation;
  this.includeLastTimePoint_ = includeLastTimePoint;
  this.dataGranularityInMillis_ = gviz.canviz.axis.Milliseconds.millisecondsForName(dataGranularity);
  this.labelGranularityInMillis_ = gviz.canviz.axis.Milliseconds.millisecondsForName(labelGranularity);
  this.timeFormatter_.setTimeUnit(this.labelGranularity_);
};
gviz.canviz.axis.TimeAxisStrategy.prototype.getLabelDuration = function() {
  return this.labelGranularityInMillis_;
};
gviz.canviz.axis.TimeAxisStrategy.prototype.singleLabel = function(value) {
  return[gviz.canviz.axis.AxisDecoration.makeLabel(value, Math.abs(this.mapper_.getScreenStart() - this.mapper_.getScreenEnd()) / 2, this.timeFormatter_.format(value))];
};
gviz.canviz.axis.TimeAxisStrategy.prototype.attempt = function() {
  var firstTime = this.mapper_.getDataMin(), lastTime = this.mapper_.getDataMax();
  this.timeFormatter_.setTimeUnit(this.dataGranularity_);
  if (firstTime == lastTime) {
    return this.singleLabel(firstTime);
  }
  var lastTimeDecoration = gviz.canviz.axis.AxisDecoration.makeLeftAlignedLabelWithLineAndTick(lastTime, this.mapper_.getScreenEnd(), this.timeFormatter_.format(lastTime));
  this.timeFormatter_.setTimeUnit(this.labelGranularity_);
  for (var labelIntervalsInsteadOfPoints = 1 == this.unitsPerLabel_ && this.labelGranularityInMillis_ > this.dataGranularityInMillis_, lineSequence = gviz.canviz.axis.Utils.createTimeSequence(this.labelGranularityInMillis_ * this.unitsPerLabel_), tickSequence = gviz.canviz.axis.Utils.createTimeSequence(this.labelGranularityInMillis_), decorations = [], previousValue = NaN, nextLineValue = lineSequence.ceil(firstTime), value = tickSequence.ceil(firstTime);value <= lastTime;value = tickSequence.next()) {
    var position = this.mapper_.getScreenValue(value);
    if (value == nextLineValue) {
      nextLineValue = lineSequence.next();
      if (this.twoLabelsCollide_(previousValue, value)) {
        return null;
      }
      if (labelIntervalsInsteadOfPoints) {
        isNaN(previousValue) || decorations.push(this.makeLabelBetween_(previousValue, value)), decorations.push(gviz.canviz.axis.AxisDecoration.makeLineWithHeavyTick(value, position));
      } else {
        var line = gviz.canviz.axis.AxisDecoration.makeLabeledLineWithHeavyTick(value, position, this.timeFormatter_.format(value));
        decorations.push(line);
      }
      previousValue = value;
    } else {
      decorations.push(gviz.canviz.axis.AxisDecoration.makeTick(value, position));
    }
  }
  labelIntervalsInsteadOfPoints && lastTime < value && this.addLabelForIncompleteInterval_(decorations, tickSequence, lastTime);
  this.includeLastTimePoint_ && (this.hideLastLabelIfOverlapsWithMax_(lastTimeDecoration, decorations, this.textMeasurer_), decorations.push(lastTimeDecoration));
  return 2 > this.numberOfLabelsIn_(decorations) ? this.alternativeForLessThanTwoLabels_() : this.ticksCollide_(decorations) ? this.withoutTicks_(decorations) : decorations;
};
gviz.canviz.axis.TimeAxisStrategy.prototype.addLabelForIncompleteInterval_ = function(decorations, tickSequence, max) {
  var label = this.timeFormatter_.format(max), width = this.textMeasurer_.getSizeByOrientation(label, this.orientation_), nextTime = tickSequence.getValue(), prevTime = tickSequence.previous(), prevPos = this.mapper_.getScreenValue(prevTime), nextPos = this.mapper_.getScreenValue(nextTime), endPos = this.mapper_.getScreenValue(max), middlePos = (prevPos + nextPos) / 2;
  endPos - middlePos > width / 2 && decorations.push(gviz.canviz.axis.AxisDecoration.makeLabel(max, middlePos, label));
};
gviz.canviz.axis.TimeAxisStrategy.prototype.hideLastLabelIfOverlapsWithMax_ = function(maxDecoration, decorations) {
  var previous = this.findLastLabeledDecoration_(decorations);
  if (null != previous) {
    var sizeOfPrevious = this.textMeasurer_.getSizeByOrientation(previous.getLabel(), this.orientation_), sizeOfMaxDecoration = this.textMeasurer_.getSizeByOrientation(maxDecoration.getLabel(), this.orientation_), midpointDistance = Math.abs(previous.getPosition() - maxDecoration.getPosition()), distance = midpointDistance - (sizeOfPrevious + sizeOfMaxDecoration) / 2;
    distance < this.minLabelDistance_ && previous.setLabel(null);
  }
};
gviz.canviz.axis.TimeAxisStrategy.prototype.findLastLabeledDecoration_ = function(decorations) {
  for (var i = decorations.length - 1;0 <= i;i--) {
    if (null != decorations[i].getLabel()) {
      return decorations[i];
    }
  }
  return null;
};
gviz.canviz.axis.TimeAxisStrategy.prototype.alternativeForLessThanTwoLabels_ = function() {
  var start = this.timeFormatter_.format(this.mapper_.getDataMin()), end = this.timeFormatter_.format(this.mapper_.getDataMax()), summaryLabel = start + "-" + end, decorations = [];
  if (!this.tooWide_(summaryLabel, this.mapper_)) {
    var midpoint = this.mapper_.getScreenStart() + this.mapper_.getScreenEnd() / 2;
    decorations.push(gviz.canviz.axis.AxisDecoration.makeLabel(NaN, midpoint, summaryLabel));
  }
  return decorations;
};
gviz.canviz.axis.TimeAxisStrategy.prototype.tooWide_ = function(label) {
  var chartWidth = Math.abs(this.mapper_.getScreenStart() - this.mapper_.getScreenEnd());
  return this.textMeasurer_.getWidth(label) > chartWidth + 40;
};
gviz.canviz.axis.TimeAxisStrategy.prototype.numberOfLabelsIn_ = function(decorations) {
  for (var count = 0, i = 0;i < decorations.length;i++) {
    null != decorations[i].getLabel() && count++;
  }
  return count;
};
gviz.canviz.axis.TimeAxisStrategy.prototype.withoutTicks_ = function(listWithTicks) {
  for (var listWithoutTicks = [], i = 0;i < listWithTicks.length;i++) {
    var decoration = listWithTicks[i];
    decoration.hasTick() && !decoration.hasLine() || listWithoutTicks.push(decoration);
  }
  return listWithoutTicks;
};
gviz.canviz.axis.TimeAxisStrategy.prototype.twoLabelsCollide_ = function(value1, value2) {
  var size1 = this.textMeasurer_.getSizeByOrientation(this.timeFormatter_.format(value1), this.orientation_), size2 = this.textMeasurer_.getSizeByOrientation(this.timeFormatter_.format(value2), this.orientation_), midpointDistance = Math.abs(this.mapper_.getScreenValue(value1) - this.mapper_.getScreenValue(value2)), distance = midpointDistance - (size1 + size2) / 2;
  return distance < this.minLabelDistance_;
};
gviz.canviz.axis.TimeAxisStrategy.prototype.ticksCollide_ = function(decorations) {
  if (2 > decorations.length) {
    return!1;
  }
  for (var prevDecoration = decorations[0], i = 1;i < decorations.length;i++) {
    var decoration = decorations[i], distance = Math.abs(decoration.getPosition() - prevDecoration.getPosition());
    if (5 > distance && prevDecoration.getValue() != decoration.getValue()) {
      return!0;
    }
    prevDecoration = decoration;
  }
  return!1;
};
gviz.canviz.axis.TimeAxisStrategy.prototype.makeLabelBetween_ = function(value1, value2) {
  var pos1 = this.mapper_.getScreenValue(value1), pos2 = this.mapper_.getScreenValue(value2), labelPosition = (pos1 + pos2) / 2, labelMarker = gviz.canviz.axis.AxisDecoration.makeLabel(this.mapper_.getDataValue(labelPosition), labelPosition, this.timeFormatter_.format(value1));
  return labelMarker;
};
// INPUT (javascript/gviz/devel/canviz/axis/time-axis-decoration-supplier.js)
gviz.canviz.axis.TimeAxisDecorationSupplier = function(mapper, timeGranularity, textMeasurer, timeFormatter, minLabelDistance, orientation, includeLastTimePoint) {
  this.mapper_ = mapper;
  this.timeGranularity_ = timeGranularity;
  this.textMeasurer_ = textMeasurer;
  this.timeFormatter_ = timeFormatter;
  this.minLabelDistance_ = minLabelDistance;
  this.orientation_ = orientation;
  this.includeLastTimePoint_ = includeLastTimePoint;
  this.strategies_ = this.getStrategies_();
};
gviz.canviz.axis.TimeAxisDecorationSupplier.prototype.getStrategies_ = function() {
  return[this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.DAY, 1), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.DAY, 7), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.MONTH, 1), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.MONTH, 2), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.MONTH, 3), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.QUARTER, 1), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.MONTH, 
  6), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 1), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 2), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 5), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 10), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 20), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 50), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 
  100), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 1E3), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 1E4), this.newTimeAxisStrategy_(gviz.canviz.axis.Milliseconds.TIME_UNIT.YEAR, 1E7)];
};
gviz.canviz.axis.TimeAxisDecorationSupplier.prototype.newTimeAxisStrategy_ = function(labelDuration, unitsPerDuration) {
  return new gviz.canviz.axis.TimeAxisStrategy(this.timeGranularity_, labelDuration, unitsPerDuration, this.textMeasurer_, this.timeFormatter_, this.mapper_, this.minLabelDistance_, this.orientation_, this.includeLastTimePoint_);
};
gviz.canviz.axis.TimeAxisDecorationSupplier.prototype.getDecorations = function() {
  for (var granularityInMillis = gviz.canviz.axis.Milliseconds.millisecondsForName(this.timeGranularity_), i = 0;i < this.strategies_.length;i++) {
    var strategy = this.strategies_[i];
    if (granularityInMillis <= strategy.getLabelDuration()) {
      var lines = strategy.attempt();
      if (null != lines) {
        return lines;
      }
    }
  }
  return[];
};
// INPUT (javascript/gviz/devel/canviz/axis/axis-decorations-creator.js)
gviz.canviz.axis.AxisDecorationsCreator = {};
gviz.canviz.axis.AxisDecorationsCreator.getNumberDecorations = function(dataMin, dataMax, screenStart, screenEnd, reversed, lambda, epsilon, orientation, minLineSpacing, textMeasurer, formatter) {
  if (reversed) {
    var tmp = screenStart;
    screenStart = screenEnd;
    screenEnd = tmp;
  }
  if (dataMin == dataMax) {
    var midScreenPosition = (screenEnd - screenStart) / 2 + screenStart, label = formatter.format(dataMin);
    return[gviz.canviz.axis.AxisDecoration.makeLabel(dataMin, midScreenPosition, label)];
  }
  var mapper;
  mapper = 1 == lambda ? new gviz.canviz.axis.LinMapper(dataMin, dataMax, screenStart, screenEnd) : new gviz.canviz.axis.BoxCoxMapper(dataMin, dataMax, screenStart, screenEnd, lambda, epsilon);
  return gviz.canviz.axis.AxisDecorationsCreator.createNumberDecorations(mapper, minLineSpacing, epsilon, orientation, textMeasurer, formatter);
};
gviz.canviz.axis.AxisDecorationsCreator.getTimeDecorations = function(dataMin, dataMax, screenStart, screenEnd, reversed, timeGranularity, orientation, minLabelDistance, textMeasurer, formatter, includeLastTimePoint) {
  if (reversed) {
    var tmp = screenStart;
    screenStart = screenEnd;
    screenEnd = tmp;
  }
  var mapper = new gviz.canviz.axis.LinMapper(dataMin, dataMax, screenStart, screenEnd), supplier = new gviz.canviz.axis.TimeAxisDecorationSupplier(mapper, timeGranularity, textMeasurer, formatter, minLabelDistance, orientation, includeLastTimePoint);
  return supplier.getDecorations();
};
gviz.canviz.axis.AxisDecorationsCreator.createNumberDecorations = function(mapper, minLineSpacing, epsilon, orientation, textMeasurer, formatter) {
  var ratio = gviz.canviz.axis.AxisDecorationsCreator.calculateDataDensityRatio_(mapper), axisDecorationSupplier;
  axisDecorationSupplier = .65 < ratio ? new gviz.canviz.axis.LinAxisDecorationSupplier(mapper, formatter, textMeasurer, orientation, minLineSpacing) : new gviz.canviz.axis.LogAxisDecorationSupplier(mapper, formatter, textMeasurer, orientation, minLineSpacing, epsilon);
  return axisDecorationSupplier.getDecorations();
};
gviz.canviz.axis.AxisDecorationsCreator.calculateDataDensityRatio_ = function(mapper) {
  if (mapper.getDataMin() == mapper.getDataMax()) {
    return 1;
  }
  var screenMin = Math.min(mapper.getScreenStart(), mapper.getScreenEnd()), screenMax = Math.max(mapper.getScreenStart(), mapper.getScreenEnd()), absEdgeValue1 = Math.abs(mapper.getDataValue(screenMin)), absEdgeValue2 = Math.abs(mapper.getDataValue(screenMax)), maxDataValue = Math.max(absEdgeValue1, absEdgeValue2), minDataValue = 0, screenAtZero = mapper.getScreenValue(0);
  if (screenMin > screenAtZero || screenAtZero > screenMax) {
    minDataValue = Math.min(absEdgeValue1, absEdgeValue2);
  }
  var pixelAtAbsMin = mapper.getScreenValue(minDataValue), pixelAtAbsMax = mapper.getScreenValue(maxDataValue), ratio = gviz.canviz.axis.AxisDecorationsCreator.getDataDensity_(pixelAtAbsMin, mapper) / gviz.canviz.axis.AxisDecorationsCreator.getDataDensity_(pixelAtAbsMax, mapper);
  return ratio;
};
gviz.canviz.axis.AxisDecorationsCreator.getDataDensity_ = function(pixelPosition, mapper) {
  var dataStart = mapper.getDataValue(pixelPosition), dataEnd = mapper.getDataValue(pixelPosition + 10);
  return Math.abs(dataEnd - dataStart);
};
// INPUT (javascript/gviz/devel/canviz/axis/text-measurer.js)
gviz.canviz.axis.TextMeasurer = function() {
};
gviz.canviz.axis.FixedFontTextMeasurer = function(charWidth, charHeight) {
  this.charWidth_ = charWidth;
  this.charHeight_ = charHeight;
};
gviz.canviz.axis.FixedFontTextMeasurer.prototype.getWidth = function(str) {
  return str.length * this.charWidth_;
};
gviz.canviz.axis.FixedFontTextMeasurer.prototype.getHeight = function() {
  return this.charHeight_;
};
gviz.canviz.axis.FixedFontTextMeasurer.prototype.getSizeByOrientation = function(str, orientation) {
  return orientation == gviz.canviz.axis.AxisTools.Orientation.HORIZONTAL ? this.getWidth(str) : this.getHeight(str);
};
gviz.canviz.axis.TextMeasurerAdapter = function(textMeasureFunc, textStyle) {
  this.textMeasureFunc_ = textMeasureFunc;
  this.textStyle_ = textStyle;
};
gviz.canviz.axis.TextMeasurerAdapter.prototype.getWidth = function(str) {
  return this.textMeasureFunc_(str, this.textStyle_).width;
};
gviz.canviz.axis.TextMeasurerAdapter.prototype.getHeight = function(str) {
  return this.textMeasureFunc_(str, this.textStyle_).height;
};
gviz.canviz.axis.TextMeasurerAdapter.prototype.getSizeByOrientation = function(str, orientation) {
  return orientation == gviz.canviz.axis.AxisTools.Orientation.HORIZONTAL ? this.getWidth(str) : this.getHeight(str);
};
// INPUT (javascript/gviz/devel/canviz/axis-definition.js)
gviz.canviz.AxisDefinition = {};
// INPUT (javascript/gviz/devel/canviz/date-tick-definer.js)
gviz.canviz.dateTicks = {};
gviz.canviz.dateTicks.Definer = function(roundDurationTable, durationTableRepeatingIntervals, options, getAbsoluteOptionsPathFunc, isVertical, timeOffset) {
  (this.logger_ = gviz.util.VisCommon.createLogger(gviz.canviz.dateTicks.NAME_)) && this.logger_.setLevel(goog.log.Level.OFF);
  this.roundDurationTable_ = roundDurationTable;
  this.durationTableRepeatingIntervals_ = durationTableRepeatingIntervals;
  this.options_ = options;
  this.getAbsoluteOptionsPathFunc_ = getAbsoluteOptionsPathFunc;
  this.minStrongLineDistance_ = options.inferNonNegativeNumberValue(getAbsoluteOptionsPathFunc("gridlines.minStrongLineDistance"));
  this.minWeakLineDistance_ = options.inferNonNegativeNumberValue(getAbsoluteOptionsPathFunc("gridlines.minWeakLineDistance"));
  this.minStrongToWeakLineDistance_ = options.inferNonNegativeNumberValue(getAbsoluteOptionsPathFunc("gridlines.minStrongToWeakLineDistance"));
  this.minNotchDistance_ = options.inferNonNegativeNumberValue(getAbsoluteOptionsPathFunc("gridlines.minNotchDistance"));
  this.minMajorTextDistance_ = options.inferNonNegativeNumberValue(getAbsoluteOptionsPathFunc("gridlines.minMajorTextDistance"));
  this.minMinorTextDistance_ = options.inferNonNegativeNumberValue(getAbsoluteOptionsPathFunc("gridlines.minMinorTextDistance"));
  this.unitThreshold_ = options.inferNonNegativeNumberValue(getAbsoluteOptionsPathFunc("gridlines.unitThreshold"));
  this.allowMinor_ = options.inferBooleanValue(getAbsoluteOptionsPathFunc("gridlines.allowMinor"));
  this.isVertical_ = isVertical;
  this.timeOffset_ = timeOffset;
};
gviz.canviz.dateTicks.Definer.build = function(options, getAbsoluteOptionsPathFunc, isVertical, timeOffset) {
  return new gviz.canviz.dateTicks.Definer(gviz.canviz.dateTicks.defaultDatetimeRoundUnits_, gviz.canviz.dateTicks.datetimeRoundUnitsRepeatingIntervals_, options, getAbsoluteOptionsPathFunc, isVertical, timeOffset);
};
gviz.canviz.dateTicks.Definer.prototype.calc = function(minValue, maxValue, dataGranularity, numericDateToPositionFunc, tickOptions, measureFunction) {
  var da = this.analyzeData_(minValue, maxValue, dataGranularity), majorUnit = this.options_.inferDateTicksUnitConfigValue(this.getAbsoluteOptionsPathFunc_("gridlines.units." + da.unit)), majorUnitIndex = gviz.canviz.timeutil.timeUnitIndex[da.unit], majorUnitDuration = gviz.canviz.timeutil.timeUnitDurations[majorUnitIndex], gridlinesToAvoid = [], majorGridlinesConfig = {minValue:da.minValue, maxValue:da.maxValue, unitName:da.unit, unitIndex:majorUnitIndex, unitDuration:majorUnitDuration, unitFormats:majorUnit.format, 
  unitMultiples:majorUnit.interval, minLineDistance:this.minStrongLineDistance_, gridlineBrush:tickOptions.gridlineBrush, tickTextStyle:tickOptions.tickTextStyle, minTextDistance:this.minMajorTextDistance_, gridlinesToAvoid:gridlinesToAvoid, minCrossGridlinesDistance:0}, majorG = this.computeGridlines_(majorGridlinesConfig, numericDateToPositionFunc, measureFunction);
  if (!majorG || 0 === majorG.gridlines.length) {
    return{gridlines:[], tickTextLayout:[]};
  }
  goog.log.info(this.logger_, "# major gridlines: " + majorG.gridlines.length);
  if (!(this.allowMinor_ && 1 == majorG.multiple && 0 < majorUnitIndex)) {
    var tickSpan = 1 != majorG.multiple ? gviz.canviz.dateTicks.TickSpanType_.BELOW : gviz.canviz.dateTicks.TickSpanType_.SPAN_LEFT, tickTextLayout = this.getTickText_(tickOptions.tickTextStyle, tickSpan, majorG.gridlines, majorG.texts), gridlines;
    if (this.allowMinor_ && 1 < majorG.multiple) {
      var refinedMajorGridlines = this.computeRefinedMajorGridlines_(da, majorG, tickOptions, numericDateToPositionFunc);
      gridlines = goog.array.concat(majorG.gridlines, refinedMajorGridlines);
    } else {
      gridlines = majorG.gridlines;
    }
    return{gridlines:gridlines, tickTextLayout:tickTextLayout};
  }
  var minorUnitIndex = majorUnitIndex - 1, minorUnitName = gviz.canviz.timeutil.timeUnitOrder[minorUnitIndex], minorUnit = this.options_.inferDateTicksUnitConfigValue(this.getAbsoluteOptionsPathFunc_("minorGridlines.units." + minorUnitName)), minorUnitDuration = gviz.canviz.timeutil.timeUnitDurations[minorUnitIndex], minorGridlinesConfig = {minValue:da.minValue, maxValue:da.maxValue, unitName:minorUnitName, unitIndex:minorUnitIndex, unitDuration:minorUnitDuration, unitFormats:minorUnit.format, unitMultiples:minorUnit.interval, 
  minLineDistance:this.minWeakLineDistance_, gridlineBrush:tickOptions.minorGridlineBrush, tickTextStyle:tickOptions.minorTickTextStyle, minTextDistance:this.minMinorTextDistance_, gridlinesToAvoid:majorG.gridlines, minCrossGridlinesDistance:this.minStrongToWeakLineDistance_}, minorG = this.computeGridlines_(minorGridlinesConfig, numericDateToPositionFunc, measureFunction);
  if (null == minorG) {
    var majorTickTextLayout = this.getTickText_(tickOptions.tickTextStyle, gviz.canviz.dateTicks.TickSpanType_.SPAN_CENTER, majorG.gridlines, majorG.texts);
    return{gridlines:majorG.gridlines, tickTextLayout:majorTickTextLayout};
  }
  goog.log.info(this.logger_, "# minor gridlines: " + minorG.gridlines.length);
  var majorTickTextLayout = this.getTickText_(tickOptions.tickTextStyle, gviz.canviz.dateTicks.TickSpanType_.SPAN_LEFT, majorG.gridlines, majorG.texts), minorTickTextLayout = this.getTickText_(tickOptions.minorTickTextStyle, gviz.canviz.dateTicks.TickSpanType_.SPAN_LEFT, minorG.gridlines, minorG.texts, majorTickTextLayout);
  gridlines = goog.array.concat(minorG.gridlines, majorG.gridlines);
  tickTextLayout = goog.array.concat(majorTickTextLayout, minorTickTextLayout);
  return{gridlines:gridlines, tickTextLayout:tickTextLayout};
};
gviz.canviz.dateTicks.Definer.prototype.analyzeData_ = function(minValue, maxValue, dataGranularity) {
  var extraMs = Math.round(.15 * (maxValue - minValue));
  minValue -= extraMs;
  maxValue += extraMs;
  var granularity = gviz.canviz.timeutil.roundMillisAccordingToTable(dataGranularity, gviz.canviz.dateTicks.granularityRoundUnits_, this.durationTableRepeatingIntervals_);
  goog.log.info(this.logger_, "rounded granularity: " + goog.json.serialize(granularity));
  var rangeGranularity = gviz.canviz.timeutil.roundMillisAccordingToTable((maxValue - minValue) / this.unitThreshold_ / 2, this.roundDurationTable_, this.durationTableRepeatingIntervals_);
  goog.log.info(this.logger_, "rounded range granularity: " + goog.json.serialize(rangeGranularity));
  var majorUnitDuration = gviz.canviz.dateTicks.getUnit(rangeGranularity);
  goog.log.info(this.logger_, "major unit: " + majorUnitDuration);
  var majorUnitIndex = goog.array.findIndex(gviz.canviz.timeutil.timeUnitDurations, function(duration) {
    return goog.array.equals(duration, majorUnitDuration);
  }), majorUnitName = gviz.canviz.timeutil.timeUnitOrder[majorUnitIndex];
  return{minValue:minValue, maxValue:maxValue, unit:majorUnitName};
};
gviz.canviz.dateTicks.Definer.prototype.computeGridlines_ = function(gridlinesConfig, numericDateToPositionFunc, measureFunction) {
  for (var formatters = goog.array.map(gridlinesConfig.unitFormats, function(format) {
    return new google.visualization.DateFormat({pattern:format});
  }), i = 0;i < gridlinesConfig.unitMultiples.length;++i) {
    var multiple = gridlinesConfig.unitMultiples[i], nextGridlineToAvoidIdx = 0, multipleUnitDuration = gviz.canviz.timeutil.multiplyDuration(gridlinesConfig.unitDuration, multiple), firstValue = gviz.canviz.timeutil.floorDate(new Date(gridlinesConfig.minValue + this.timeOffset_), multipleUnitDuration);
    gridlinesConfig.unitName === gviz.canviz.timeutil.TimeUnit.DAYS && (firstValue = gviz.canviz.timeutil.floorDateToMonday(firstValue));
    for (var dateIter = new gviz.canviz.timeutil.DateRangeIter(firstValue, new Date(gridlinesConfig.maxValue + this.timeOffset_), gridlinesConfig.unitIndex, multiple), gridlines = [], gridlinesAreSpaced = !0, minPos = numericDateToPositionFunc(gridlinesConfig.minValue), firstGridlineInView = -1;dateIter.hasNext();) {
      var d = dateIter.next(), pos = numericDateToPositionFunc(d.getTime() - this.timeOffset_);
      -1 == firstGridlineInView && pos >= minPos && (firstGridlineInView = gridlines.length);
      var nextD = dateIter.peek();
      if (null != nextD) {
        var nPos = numericDateToPositionFunc(nextD.getTime() - this.timeOffset_);
        if (nPos < pos + 1) {
          break;
        }
        if (nPos - pos < gridlinesConfig.minLineDistance) {
          gridlinesAreSpaced = !1;
          break;
        }
      }
      for (var tooClose = !1;nextGridlineToAvoidIdx < gridlinesConfig.gridlinesToAvoid.length;) {
        var nextGridlineToAvoid = gridlinesConfig.gridlinesToAvoid[nextGridlineToAvoidIdx];
        if (Math.abs(nextGridlineToAvoid.coordinate - pos) < gridlinesConfig.minCrossGridlinesDistance) {
          tooClose = !0;
          break;
        }
        if (nextGridlineToAvoid.coordinate > pos) {
          nextGridlineToAvoidIdx = Math.max(0, nextGridlineToAvoidIdx - 1);
          break;
        }
        nextGridlineToAvoidIdx++;
      }
      tooClose || gridlines.push({dataValue:d, coordinate:pos, isVisible:!0, brush:gridlinesConfig.gridlineBrush, length:null});
    }
    if (gridlinesAreSpaced) {
      1 < firstGridlineInView && (gridlines = goog.array.slice(gridlines, firstGridlineInView - 1));
      for (var chosenFormatter = null, chosenTexts = null, f = 0;f < formatters.length;++f) {
        for (var formatter = formatters[f], textsFit = !0, texts = [], j = 0;j < gridlines.length;++j) {
          var gridline = gridlines[j], text = formatter.formatValue(gridline.dataValue), textSize = measureFunction(text, gridlinesConfig.tickTextStyle), size = this.isVertical_ ? textSize.height : textSize.width;
          if (j + 1 < gridlines.length) {
            var nextGridline = gridlines[j + 1];
            if (nextGridline.coordinate - gridline.coordinate < gridlinesConfig.minTextDistance + size) {
              textsFit = !1;
              break;
            }
          }
          texts.push({text:text, size:size});
        }
        if (textsFit && 0 < texts.length) {
          chosenFormatter = f;
          chosenTexts = texts;
          break;
        }
      }
      if (null != chosenFormatter) {
        goog.asserts.assert(null != chosenTexts);
        for (var minimumSpaceBetweenGridlines = Infinity, j = 0;j < gridlines.length - 1;++j) {
          minimumSpaceBetweenGridlines = Math.min(minimumSpaceBetweenGridlines, gridlines[j + 1].coordinate - gridlines[j].coordinate);
        }
        return{gridlines:gridlines, texts:chosenTexts, multiple:multiple, minimumSpaceBetweenGridlines:minimumSpaceBetweenGridlines};
      }
    }
  }
  return null;
};
gviz.canviz.dateTicks.Definer.prototype.computeRefinedMajorGridlines_ = function(da, majorG, tickOptions, numericDateToPositionFunc) {
  var approxMinSpaceBetweenGridlines = majorG.minimumSpaceBetweenGridlines / majorG.multiple;
  if (approxMinSpaceBetweenGridlines < this.minNotchDistance_) {
    return[];
  }
  for (var length = gviz.canviz.dateTicks.NOTCH_LENGTH_, brush = tickOptions.gridlineBrush, gridlines = [], firstValue = majorG.gridlines[0].dataValue, majorIndex = gviz.canviz.timeutil.timeUnitIndex[da.unit], majorDateIter = new gviz.canviz.timeutil.DateRangeIter(firstValue, new Date(da.maxValue + this.timeOffset_), majorIndex, 1), modulo = 0;majorDateIter.hasNext();) {
    if (0 != modulo % majorG.multiple) {
      var d = majorDateIter.next(), pos = numericDateToPositionFunc(d.getTime());
      gridlines.push({dataValue:d, coordinate:pos, isVisible:!0, brush:brush, length:length});
    }
    modulo++;
  }
  return gridlines;
};
gviz.canviz.dateTicks.TickSpanType_ = {BELOW:0, SPAN_LEFT:1, SPAN_CENTER:2};
gviz.canviz.dateTicks.Definer.prototype.getTickText_ = function(textStyle, spanType, gridlines, texts, opt_textsToAvoid) {
  var regionsToAvoid = [];
  if (goog.isDefAndNotNull(opt_textsToAvoid)) {
    for (var j = 0;j < opt_textsToAvoid.length;++j) {
      var textBlock = opt_textsToAvoid[j].textBlock, line = textBlock.lines[0];
      regionsToAvoid.push(gviz.canviz.dateTicks.getTextBounds_(line.x, line.length, textBlock.paralAlign, this.minMinorTextDistance_));
    }
  }
  for (var paralTextAlign = spanType == gviz.canviz.dateTicks.TickSpanType_.SPAN_LEFT ? gviz.graphics.TextAlign.START : gviz.graphics.TextAlign.CENTER, nextRegionToAvoidIdx = 0, tickTextLayout = [], length = spanType == gviz.canviz.dateTicks.TickSpanType_.SPAN_CENTER ? gridlines.length - 1 : gridlines.length, i = 0;i < length;++i) {
    var gridline = gridlines[i];
    if (gridline.isVisible && texts[i]) {
      for (var coordinate = Math.round(spanType == gviz.canviz.dateTicks.TickSpanType_.SPAN_CENTER ? (gridlines[i + 1].coordinate + gridline.coordinate) / 2 : gridline.coordinate), size = texts[i].size, textRange = gviz.canviz.dateTicks.getTextBounds_(coordinate, size, paralTextAlign), fits = !0;nextRegionToAvoidIdx < regionsToAvoid.length;) {
        var nextRegionToAvoid = regionsToAvoid[nextRegionToAvoidIdx];
        if (goog.math.Range.hasIntersection(textRange, nextRegionToAvoid)) {
          fits = !1;
          break;
        }
        if (nextRegionToAvoid.start > textRange.end) {
          nextRegionToAvoidIdx = Math.max(0, nextRegionToAvoidIdx - 1);
          break;
        }
        nextRegionToAvoidIdx++;
      }
      fits && tickTextLayout.push({dataValue:gridline.dataValue, isVisible:!0, coordinate:coordinate, textBlock:{text:texts[i].text, textStyle:textStyle, lines:[{x:coordinate, y:0, text:texts[i].text, length:size}], paralAlign:paralTextAlign, perpenAlign:gviz.graphics.TextAlign.END, tooltip1:texts[i].text, anchor:null, angle:0}});
    }
  }
  return tickTextLayout;
};
gviz.canviz.dateTicks.getUnit = function(duration) {
  var unit = goog.array.map(duration, function(value) {
    return 0 < value ? 1 : 0;
  });
  return unit;
};
gviz.canviz.dateTicks.getTextBounds_ = function(base, length, align, opt_padding) {
  var padding = goog.isDef(opt_padding) ? opt_padding : 0, start, end;
  align == gviz.graphics.TextAlign.START ? (start = base, end = start + length) : (goog.asserts.assert(align == gviz.graphics.TextAlign.CENTER), start = Math.round(base - length / 2), end = Math.round(base + length / 2));
  return new goog.math.Range(start - padding, end + padding);
};
gviz.canviz.dateTicks.granularityRoundUnits_ = [[1], [50], [500], [0, 1], [0, 15], [0, 30], [0, 0, 1], [0, 0, 15], [0, 0, 30], [0, 0, 0, 1], [0, 0, 0, 6], [0, 0, 0, 12], [0, 0, 0, 0, 1], [0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 1]];
gviz.canviz.dateTicks.dateRoundUnitsRepeatingIntervals_ = 3;
gviz.canviz.dateTicks.defaultDatetimeRoundUnits_ = [[1], [2], [5], [10], [20], [50], [100], [200], [500], [0, 1], [0, 2], [0, 5], [0, 10], [0, 15], [0, 30], [0, 0, 1], [0, 0, 2], [0, 0, 5], [0, 0, 10], [0, 0, 15], [0, 0, 30], [0, 0, 0, 1], [0, 0, 0, 2], [0, 0, 0, 3], [0, 0, 0, 4], [0, 0, 0, 6], [0, 0, 0, 12], [0, 0, 0, 0, 1], [0, 0, 0, 0, 2], [0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 10], [0, 0, 0, 0, 0, 0, 50], [0, 0, 0, 0, 0, 0, 100]];
gviz.canviz.dateTicks.datetimeRoundUnitsRepeatingIntervals_ = 3;
gviz.canviz.dateTicks.NOTCH_LENGTH_ = 5;
gviz.canviz.dateTicks.NAME_ = "DateTickDefiner";
// INPUT (javascript/gviz/devel/canviz/axis-definer.js)
gviz.canviz.AxisDefiner = function(chartDef, options, optionsPath, index, defaultType, defaultViewWindowMode, opt_explicitTicks) {
  this.optionsPath_ = optionsPath;
  this.options_ = options;
  this.index = index;
  this.type = options.inferEnumValue(this.getAbsoluteOptionsPath("type"), gviz.canviz.Options.AxisType, defaultType);
  goog.asserts.assert(this.type, "Unspecified " + optionsPath + " type.");
  this.maxValue = this.minValue = null;
  this.allNumericValues_ = [];
  this.userBaseline = null;
  this.allowDataTruncation = 0 < chartDef.serieTypeCount[gviz.canviz.Options.SerieType.BARS];
  var titleText = options.inferStringValue(this.getAbsoluteOptionsPath("title")), axisTitlesPosition = chartDef.axisTitlesPosition, auraColor = axisTitlesPosition === gviz.canviz.Options.InOutPosition.INSIDE ? chartDef.insideLabelsAuraColor : chartDef.backgroundBrush.getFill(), defaultTitleTextStyle = {fontName:chartDef.defaultFontName, fontSize:chartDef.defaultFontSize, auraColor:auraColor}, titleTextStyle = options.inferTextStyleValue(this.getAbsoluteOptionsPath("titleTextStyle"), defaultTitleTextStyle);
  this.title = {text:titleText, textStyle:titleTextStyle, boxStyle:null, lines:[], paralAlign:gviz.graphics.TextAlign.CENTER, perpenAlign:gviz.graphics.TextAlign.START, tooltip:"", anchor:null, angle:0};
  this.newTimeline = !1;
  this.tickTextLayout = null;
  this.tickTextPosition = options.inferEnumValue(this.getAbsoluteOptionsPath("textPosition"), gviz.canviz.Options.InOutPosition, gviz.canviz.Options.InOutPosition.OUTSIDE);
  var auraColor = this.tickTextPosition === gviz.canviz.Options.InOutPosition.INSIDE ? chartDef.insideLabelsAuraColor : chartDef.backgroundBrush.getFill(), defaultTickTextColor = this.type != gviz.canviz.Options.AxisType.VALUE || chartDef.chartType == gviz.canviz.Options.ChartType.SCATTER ? options.inferStringValue("majorAxisTextColor") : options.inferStringValue("minorAxisTextColor"), defaultTickTextStyle = {color:defaultTickTextColor, fontName:chartDef.defaultFontName, fontSize:chartDef.defaultFontSize, 
  auraColor:auraColor};
  this.tickTextStyle = options.inferTextStyleValue(this.getAbsoluteOptionsPath("textStyle"), defaultTickTextStyle);
  var labelColorRatio = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("gridlines.minorTextOpacity")), minorLabelColor = gviz.util.blendHexColors(this.tickTextStyle.color, chartDef.actualChartAreaBackgoundColor || "#fff", labelColorRatio);
  this.minorTickTextStyle = options.inferTextStyleValue(this.getAbsoluteOptionsPath("textStyle"), defaultTickTextStyle);
  this.minorTickTextStyle.color = minorLabelColor;
  this.tickOutTextPosition = options.inferEnumValue(this.getAbsoluteOptionsPath("outTextPosition"), gviz.canviz.Options.BoundUnboundPosition, gviz.canviz.Options.BoundUnboundPosition.UNBOUND);
  this.tickInTextPosition = options.inferEnumValue(this.getAbsoluteOptionsPath("inTextPosition"), gviz.canviz.Options.HighLowPosition, gviz.canviz.Options.HighLowPosition.LOW);
  var baselineColor = options.inferColorValue(this.getAbsoluteOptionsPath("baselineColor"), chartDef.baselineColor);
  this.baselineBrush = new gviz.graphics.Brush({fill:baselineColor});
  var gridlineColor = options.inferColorValue(this.getAbsoluteOptionsPath("gridlines.color"), chartDef.gridlineColor);
  this.gridlineBrush = new gviz.graphics.Brush({fill:gridlineColor});
  this.minorGridlinesCount_ = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("minorGridlines.count"), 0);
  var gridlineColorRatio = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("gridlines.minorGridlineOpacity")), defaultMinorGridlineColor = gviz.util.blendHexColors(gridlineColor, chartDef.actualChartAreaBackgoundColor || "#fff", gridlineColorRatio), minorGridlineColor = options.inferColorValue(this.getAbsoluteOptionsPath("minorGridlines.color"), defaultMinorGridlineColor);
  this.minorGridlineBrush = new gviz.graphics.Brush({fill:minorGridlineColor});
  this.minGap = 2;
  this.gapBetweenTitleLines = Math.max(this.minGap, Math.round(this.title.textStyle.fontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO)));
  this.ticks = [];
  if (this.tickValues_ = opt_explicitTicks || options.inferValue(this.getAbsoluteOptionsPath("ticks"))) {
    this.tickValues_ = goog.array.map(this.tickValues_, function(tick) {
      var newTick = {};
      newTick.v = goog.isDef(tick.v) ? tick.v : tick;
      goog.isString(tick.f) && (newTick.f = tick.f);
      return newTick;
    });
  }
  this.axisLength = 0;
  this.direction = this.dataDirection = options.inferNumberValue(this.getAbsoluteOptionsPath("direction"), 1);
  this.endPos = this.startPos = null;
  this.valueAtStartPos_ = this.numericValueToPixelsFactor = 0;
  this.viewWindow_ = {min:-Infinity, max:Infinity};
  this.viewWindowMode = null;
  this.defaultViewWindowMode = defaultViewWindowMode;
  var scaleType = gviz.NumberScaleUtil.getScaleType(this.options_, this.getAbsoluteOptionsPath(gviz.NumberScaleUtil.LOG_SCALE_OPTIONS_KEY), this.getAbsoluteOptionsPath(gviz.NumberScaleUtil.SCALE_TYPE_OPTIONS_KEY));
  this.mirrorLog_ = scaleType === gviz.NumberScaleUtil.SCALE_TYPE.MIRROR_LOG;
  this.logScale_ = scaleType === gviz.NumberScaleUtil.SCALE_TYPE.LOG || this.mirrorLog_;
  this.type == gviz.canviz.Options.AxisType.VALUE ? (this.variableNumberOfGridlines_ = this.baseline = this.valueScale = null, this.timeGranularity_ = options.inferEnumValue(this.getAbsoluteOptionsPath("timeGranularity"), gviz.canviz.axis.Milliseconds.TIME_UNIT, gviz.canviz.axis.Milliseconds.TIME_UNIT.MILLISECOND), this.zeroToClosestValueDistance_ = Infinity) : this.tickValues_ = null;
};
gviz.canviz.AxisDefiner.MIN_TICK_SPACING_ = 40;
gviz.canviz.AxisDefiner.prototype.getAbsoluteOptionsPath = function(property) {
  return gviz.canviz.util.concatSuffix(this.optionsPath_, property);
};
gviz.canviz.AxisDefiner.prototype.markClosestValueToZero = function(numericValue) {
  goog.isNumber(numericValue) && 0 !== numericValue && !isNaN(numericValue) && (this.zeroToClosestValueDistance_ = Math.min(Math.abs(numericValue), this.zeroToClosestValueDistance_));
};
gviz.canviz.AxisDefiner.prototype.initPreCalculator = function(opt_gaps) {
  var gaps = opt_gaps || [];
  this.valueScale.initPreCalculator(this.zeroToClosestValueDistance_ / 10, gaps);
};
gviz.canviz.AxisDefiner.prototype.initScale = function(dataType, options) {
  var valueScale = gviz.canviz.ScaleRepository.instance().getScale(dataType);
  goog.asserts.assert(valueScale, "Type " + dataType + " is not a valid VALUE type");
  this.gridlineCount_ = options.inferOptionalNumberValue(this.getAbsoluteOptionsPath("gridlines.count"));
  var orientation = this.getOrientation(), exploreThisAxis = !this.logScale_ && options.inferWholeObjectValue("explorer") && (!options.inferWholeObjectValue("explorer.axis") || options.inferOptionalStringValue(this.getAbsoluteOptionsPath("explorer.axis." + orientation)));
  !this.tickValues_ && (exploreThisAxis || 0 > this.gridlineCount_ || goog.isNull(this.gridlineCount_) && this.logScale_) && (this.variableNumberOfGridlines_ = !0, this.gridlineCount_ = -1);
  valueScale.init(options, this.optionsPath_, this.gridlineCount_);
  this.valueScale = valueScale;
  this.dataType = dataType;
  this.minValue = valueScale.inferValue(options, this.getAbsoluteOptionsPath("minValue"));
  this.maxValue = valueScale.inferValue(options, this.getAbsoluteOptionsPath("maxValue"));
  this.userBaseline = options.inferValue(this.getAbsoluteOptionsPath("baseline"), gviz.canviz.Options.DEFAULTS.vAxis.gridlines.baseline);
};
gviz.canviz.AxisDefiner.prototype.initViewWindow = function(options) {
  this.viewWindowMode = options.inferOptionalEnumValue(this.getAbsoluteOptionsPath("viewWindowMode"), gviz.canviz.Options.ViewWindowMode);
  if (goog.isNull(this.viewWindowMode) || this.viewWindowMode == gviz.canviz.Options.ViewWindowMode.EXPLICIT) {
    if (this.type == gviz.canviz.Options.AxisType.VALUE) {
      var valueScale = this.valueScale, viewWindowMin = valueScale.inferValue(options, this.getAbsoluteOptionsPath("viewWindow.numericMin"));
      goog.isNumber(viewWindowMin) || (viewWindowMin = valueScale.valueToNumber(valueScale.inferValue(options, this.getAbsoluteOptionsPath("viewWindow.min"))));
      var viewWindowMax = valueScale.inferValue(options, this.getAbsoluteOptionsPath("viewWindow.numericMax"));
      goog.isNumber(viewWindowMax) || (viewWindowMax = valueScale.valueToNumber(valueScale.inferValue(options, this.getAbsoluteOptionsPath("viewWindow.max"))));
      goog.isDefAndNotNull(viewWindowMin) && (this.viewWindow_.min = viewWindowMin);
      goog.isDefAndNotNull(viewWindowMax) && (this.viewWindow_.max = viewWindowMax);
    } else {
      this.viewWindow_.min = options.inferNumberValue(this.getAbsoluteOptionsPath("viewWindow.min"), this.viewWindow_.min), this.viewWindow_.max = options.inferNumberValue(this.getAbsoluteOptionsPath("viewWindow.max"), this.viewWindow_.max);
    }
    if (this.viewWindow_.min > this.viewWindow_.max) {
      var temp = this.viewWindow_.min;
      this.viewWindow_.min = this.viewWindow_.max;
      this.viewWindow_.max = temp;
    }
    this.viewWindowMode = -Infinity != this.viewWindow_.min || Infinity != this.viewWindow_.max ? gviz.canviz.Options.ViewWindowMode.EXPLICIT : this.defaultViewWindowMode;
    this.type == gviz.canviz.Options.AxisType.VALUE && this.viewWindowMode == gviz.canviz.Options.ViewWindowMode.EXPLICIT && (-Infinity != this.viewWindow_.min && (this.valueScale.numericMinValue = this.viewWindow_.min), Infinity != this.viewWindow_.max && (this.valueScale.numericMaxValue = this.viewWindow_.max));
  }
};
gviz.canviz.AxisDefiner.prototype.isViewWindowSemiExplicit_ = function() {
  return this.viewWindowMode == gviz.canviz.Options.ViewWindowMode.EXPLICIT && (-Infinity == this.viewWindow_.min || Infinity == this.viewWindow_.max);
};
gviz.canviz.AxisDefiner.prototype.validateHasScale = function() {
  if (this.type == gviz.canviz.Options.AxisType.VALUE && !this.valueScale) {
    throw Error("Axis type/data type mismatch for " + this.optionsPath_);
  }
};
gviz.canviz.AxisDefiner.prototype.calcCommonAxisDefinition = function(chartDef, axisLength, startPos, legendDefiner, colorBarDefiner) {
  this.startPos = startPos + (1 == this.direction ? .5 : -.5);
  this.axisLength = axisLength - 1;
  this.endPos = startPos + axisLength * this.direction;
  var ticklinesOrigin = this.calcTicklinesOrigin(chartDef);
  this.isDatetimeValueScale_() && (this.variableNumberOfGridlines_ || this.options_.inferBooleanValue(this.getAbsoluteOptionsPath("gridlines.newTimeline"))) && (this.newTimeline = !0);
  var ticklinesInfo = this.newTimeline ? this.calcTicklinesForNewTimeline_(chartDef, legendDefiner, colorBarDefiner) : this.calcTicklines_(chartDef, legendDefiner, colorBarDefiner);
  return{title:this.title, name:this.getAxisName(), type:this.type, logScale:this.logScale_, dataType:this.dataType, dataDirection:this.dataDirection, startPos:this.startPos, endPos:this.endPos, number:{fromValue:goog.bind(this.numberFromValue, this), toValue:goog.bind(this.numberToValue, this)}, position:{fromValue:goog.bind(this.calcPositionFromDataValue, this), toValue:goog.bind(this.calcDataValueFromPosition, this)}, ticklinesOrigin:ticklinesOrigin, baseline:ticklinesInfo.baseline, gridlines:ticklinesInfo.gridlines, 
  ticklines:ticklinesInfo.ticklines, text:this.tickTextLayout};
};
gviz.canviz.AxisDefiner.prototype.calcTicklines_ = function(chartDef, legendDefiner, colorBarDefiner) {
  this.type == gviz.canviz.Options.AxisType.VALUE ? (this.extendMinMaxProps_(), this.tickValues_ ? this.calcExplicitTickValues_() : this.variableNumberOfGridlines_ ? this.isDatetimeValueScale_() ? this.calcAxisLayoutVariableNumOfSectionsForTime_(chartDef) : this.calcAxisLayoutVariableNumOfSections_(chartDef) : this.calcAxisLayoutFixedNumOfSections_()) : this.calcCategoryAxisLayout_(chartDef, this.axisLength + 1);
  var baseline = this.prepareBaseline_(), gridlines = null;
  if (this.type == gviz.canviz.Options.AxisType.VALUE) {
    var gridlines = goog.array.map(this.ticks, function(tick) {
      return{tick:tick, dataValue:tick.dataValue, coordinate:tick.coordinate, isVisible:!0, length:null, brush:this.gridlineBrush};
    }, this), minorGridlineCoordinates;
    if (minorGridlineCoordinates = this.logScale_ ? this.calcLogScaleMinorGridlines_(gridlines) : this.calcMinorGridlines_(gridlines)) {
      var minorGridlines = goog.array.map(minorGridlineCoordinates, function(c) {
        return{dataValue:this.calcDataValueFromPosition(c), coordinate:c, isVisible:!0, length:null, brush:this.minorGridlineBrush};
      }, this);
      goog.array.extend(gridlines, minorGridlines);
    }
    goog.array.forEachRight(gridlines, function(gridline) {
      var invisible = this.isPositionBeforeTheStart(gridline.coordinate) || this.isPositionPastTheEnd(gridline.coordinate);
      invisible && (gridline.isVisible = !1, goog.array.remove(this.ticks, gridline.tick));
      delete gridline.tick;
    }, this);
  }
  var ticklines = null;
  this.options_.inferBooleanValue(this.getAbsoluteOptionsPath("ticklines")) && (gridlines && (ticklines = goog.array.clone(gridlines)), baseline && goog.array.extend(ticklines || [], [baseline]));
  this.calcOutsideTextLayout(chartDef, legendDefiner, colorBarDefiner, null);
  this.calcInsideTextLayout(chartDef);
  return{gridlines:gridlines, ticklines:ticklines, baseline:baseline};
};
gviz.canviz.AxisDefiner.prototype.calcTicklinesForNewTimeline_ = function(chartDef, legendDefiner, colorBarDefiner) {
  this.setMinMaxProps_();
  if (this.valueScale.numericMinValue >= this.valueScale.numericMaxValue) {
    return{gridlines:null, ticklines:null, baseline:null};
  }
  var baseline = this.prepareBaseline_();
  goog.array.sort(this.allNumericValues_);
  for (var dataGranularity = Infinity, i = 1;i < this.allNumericValues_.length;++i) {
    var delta = this.allNumericValues_[i] - this.allNumericValues_[i - 1];
    delta && (dataGranularity = Math.min(dataGranularity, delta));
  }
  Infinity === dataGranularity && (dataGranularity = 0);
  var directionalityParams = this.getAxisDirectionalityParameters(chartDef), isVertical = directionalityParams.orientation === gviz.canviz.axis.AxisTools.Orientation.VERTICAL, timeOffset = 0;
  if (this.valueScale instanceof gviz.canviz.TimeofdayValueScale) {
    var d = new Date(1970, 0, 1), timeOffset = d.getTime()
  }
  var algo = gviz.canviz.dateTicks.Definer.build(this.options_, goog.bind(this.getAbsoluteOptionsPath, this), isVertical, timeOffset), tickOptions = {tickTextStyle:this.tickTextStyle, gridlineBrush:this.gridlineBrush, minorTickTextStyle:this.minorTickTextStyle, minorGridlineBrush:this.minorGridlineBrush}, actualDirection = this.direction;
  this.direction = 1;
  var result = algo.calc(this.valueScale.numericMinValue, this.valueScale.numericMaxValue, dataGranularity, goog.bind(this.calcPositionForNumericValue, this), tickOptions, chartDef.textMeasureFunction);
  this.direction = actualDirection;
  -1 === actualDirection && (goog.array.forEachRight(result.gridlines, function(gridline) {
    gridline.coordinate = this.calcReversePosition(gridline.coordinate);
  }, this), goog.array.forEachRight(result.tickTextLayout, function(tickTL) {
    tickTL.coordinate = this.calcReversePosition(tickTL.coordinate);
    tickTL.textBlock.lines[0].x = this.calcReversePosition(tickTL.textBlock.lines[0].x);
  }, this));
  goog.array.forEachRight(result.tickTextLayout, function(tickTL) {
    tickTL.dataValue = this.valueScale.numberToValue(tickTL.dataValue.getTime());
    if (isVertical) {
      var temp = tickTL.textBlock.lines[0].x;
      tickTL.textBlock.lines[0].x = tickTL.textBlock.lines[0].y;
      tickTL.textBlock.lines[0].y = temp;
    }
  }, this);
  goog.array.forEachRight(result.gridlines, function(gridline) {
    gridline.dataValue = this.valueScale.numberToValue(gridline.dataValue.getTime());
    var invisible = this.isPositionBeforeTheStart(gridline.coordinate) || this.isPositionPastTheEnd(gridline.coordinate);
    invisible && (gridline.isVisible = !1, goog.array.remove(result.gridlines, gridline));
  }, this);
  var ticks = this.ticks = [];
  goog.array.forEachRight(result.tickTextLayout, function(tickTL) {
    var invisible = this.isPositionBeforeTheStart(tickTL.coordinate) || this.isPositionPastTheEnd(tickTL.coordinate);
    if (invisible) {
      goog.array.remove(result.tickTextLayout, tickTL);
    } else {
      var tick = {dataValue:tickTL.dataValue, coordinate:tickTL.coordinate, text:tickTL.textBlock.text, isVisible:tickTL.isVisible};
      ticks.push(tick);
    }
  }, this);
  this.calcOutsideTextLayout(chartDef, legendDefiner, colorBarDefiner, result.tickTextLayout);
  this.calcInsideTextLayout(chartDef);
  return{gridlines:result.gridlines, ticklines:null, baseline:baseline};
};
gviz.canviz.AxisDefiner.prototype.getApproximateTicks = function(chartDef) {
  if (this.approximateTicks_) {
    return this.approximateTicks_;
  }
  switch(this.type) {
    case gviz.canviz.Options.AxisType.VALUE:
      var valueScale = this.valueScale;
      valueScale.calibrate(this.minValue, this.maxValue, !0);
      this.logScale_ && this.fixLogScaleMajorTicks_();
      var ticks = valueScale.ticks, formatter = this.valueScale.getFormatter(), formattedTicks = goog.array.map(ticks, function(tick) {
        var value = valueScale.numberToValue(tick);
        return formatter.formatValue(value);
      }, this);
      this.approximateTicks_ = formattedTicks;
      break;
    case gviz.canviz.Options.AxisType.CATEGORY_POINT:
    ;
    case gviz.canviz.Options.AxisType.CATEGORY:
      this.approximateTicks_ = ticks = goog.array.map(chartDef.categories, function(obj) {
        return obj.data;
      }, this);
      break;
    default:
      goog.asserts.fail('Invalid axis type "' + this.type + '"');
  }
  return this.approximateTicks_;
};
gviz.canviz.AxisDefiner.prototype.calcCategoryAxisLayout_ = function(chartDef, axisLength) {
  var numberOfAxisDivisions;
  this.viewWindowMode == gviz.canviz.Options.ViewWindowMode.EXPLICIT ? (-Infinity == this.viewWindow_.min ? this.viewWindow_.min = Math.min(0, this.viewWindow_.max - 1) : Infinity == this.viewWindow_.max && (this.viewWindow_.max = Math.max(chartDef.categories.length, this.viewWindow_.min + 1)), numberOfAxisDivisions = this.viewWindow_.max - this.viewWindow_.min) : (this.viewWindow_.min = 0, numberOfAxisDivisions = this.viewWindow_.max = chartDef.categories.length);
  this.allowDataTruncation && (numberOfAxisDivisions = Math.min(numberOfAxisDivisions, Math.floor((axisLength + 1) / 2)));
  this.type == gviz.canviz.Options.AxisType.CATEGORY_POINT && (numberOfAxisDivisions = Math.max(1, numberOfAxisDivisions - 1));
  this.valueAtStartPos_ = this.getMinNumericValue();
  this.numericValueToPixelsFactor = this.axisLength / numberOfAxisDivisions;
  this.ticks = gviz.canviz.util.rangeMap(chartDef.categories.length, function(i) {
    var tickIndex = i - this.valueAtStartPos_, tick = {dataValue:chartDef.categories[i].data, coordinate:this.calcPositionForNumericValue(i), text:chartDef.categories[i].titles[0], isVisible:0 <= tickIndex && tickIndex <= numberOfAxisDivisions};
    return tick;
  }, this);
};
gviz.canviz.AxisDefiner.prototype.calcExplicitTickValues_ = function() {
  goog.asserts.assert(this.tickValues_);
  var valueScale = this.valueScale;
  goog.array.sort(this.tickValues_, function(v1, v2) {
    return valueScale.compareValues(v1.v, v2.v);
  });
  0 < this.tickValues_.length && (this.extendRangeToIncludeNumber(valueScale.valueToNumber(this.tickValues_[0].v)), this.extendRangeToIncludeNumber(valueScale.valueToNumber(this.tickValues_[this.tickValues_.length - 1].v)));
  this.setMinMaxProps_();
  valueScale.calibrateInternal(valueScale.numericMinValue, valueScale.numericMaxValue, !1);
  -1 === this.dataDirection && (this.tickValues_ = goog.array.clone(this.tickValues_), this.tickValues_.reverse());
  var ticks = goog.array.map(this.tickValues_, function(tick) {
    return this.valueScale.valueToNumber(tick.v);
  }, this);
  valueScale.setTicks(ticks);
  var formatter = this.valueScale.getFormatter();
  this.ticks = goog.array.map(this.tickValues_, function(tick) {
    var value = tick.v, number = valueScale.valueToNumber(value), coordinate = this.calcPositionForNumericValue(number);
    goog.asserts.assert(!isNaN(coordinate), "Bad explicit tick value: " + value + ".");
    var text = tick.f;
    goog.isString(text) || (text = formatter.formatValue(value));
    return{dataValue:value, coordinate:coordinate, text:text, isVisible:!0};
  }, this);
};
gviz.canviz.AxisDefiner.prototype.calcAxisLayoutFixedNumOfSections_ = function() {
  var shouldExpand = this.viewWindowMode == gviz.canviz.Options.ViewWindowMode.PRETTY || this.isViewWindowSemiExplicit_();
  this.valueScale.calibrate(this.minValue, this.maxValue, shouldExpand);
  this.logScale_ && this.fixLogScaleMajorTicks_();
  var ticks = this.valueScale.ticks;
  this.isViewWindowSemiExplicit_() && (ticks = goog.array.filter(ticks, function(tick) {
    return tick >= this.viewWindow_.min && tick <= this.viewWindow_.max;
  }, this));
  goog.isNumber(this.gridlineCount_) && 2 > this.gridlineCount_ && (ticks = goog.array.slice(ticks, 0, this.gridlineCount_));
  this.valueScale.setTicks(ticks);
  this.valueScale.createFormatter();
  var formatter = this.valueScale.getFormatter();
  this.setMinMaxProps_();
  this.ticks = goog.array.map(this.valueScale.ticks, function(tick) {
    var value = this.valueScale.numberToValue(tick), text = formatter.formatValue(value), coordinate = this.calcPositionForNumericValue(tick);
    goog.asserts.assert(!isNaN(coordinate), "Bad tick value for fixed number of sections.");
    return{dataValue:value, coordinate:coordinate, text:text, isVisible:!0};
  }, this);
};
gviz.canviz.AxisDefiner.prototype.fixLogScaleMajorTicks_ = function() {
  var minTickGap = Infinity, previousTick = null, sign, ticks = this.valueScale.ticks, ticks = goog.array.map(ticks, function(tick) {
    sign = 0 < tick - previousTick ? 1 : -1;
    var newTick = sign * Math.floor(sign * tick);
    previousTick && 0 !== newTick * previousTick && 0 < newTick - previousTick && (minTickGap = Math.min(minTickGap, Math.abs(newTick - previousTick)));
    return previousTick = newTick;
  });
  Infinity !== minTickGap && (previousTick = null, goog.array.forEachRight(ticks, function(tick, index) {
    if (null !== previousTick && (previousTick === tick && goog.array.removeAt(ticks, index), Math.abs(tick - previousTick) > minTickGap)) {
      sign = 0 < tick - previousTick ? 1 : -1;
      var newTick = previousTick + sign * minTickGap;
      goog.array.insertAt(ticks, newTick, index + 1);
    }
    previousTick = tick;
  }));
  this.valueScale.setTicks(ticks);
};
gviz.canviz.AxisDefiner.prototype.calcAxisLayoutVariableNumOfSectionsForTime_ = function(chartDef) {
  this.setMinMaxProps_();
  var valueScale = this.valueScale, directionalityParams = this.getAxisDirectionalityParameters(chartDef);
  valueScale.calibrateInternal(valueScale.numericMinValue, valueScale.numericMaxValue, !1);
  var timeFormatter = valueScale.getFormatter();
  timeFormatter.setTimeUnit(this.timeGranularity_);
  var textMeasurer = new gviz.canviz.axis.TextMeasurerAdapter(chartDef.textMeasureFunction, this.tickTextStyle), decorations = gviz.canviz.axis.AxisDecorationsCreator.getTimeDecorations(valueScale.numericMinValue, valueScale.numericMaxValue, directionalityParams.screenStart, directionalityParams.screenEnd - 1, directionalityParams.reversed, this.timeGranularity_, directionalityParams.orientation, 10, textMeasurer, timeFormatter, !1);
  this.ticks = [];
  for (var i = 0;i < decorations.length;i++) {
    var decoration = decorations[i];
    decoration.getLabel() && this.ticks.push({dataValue:valueScale.numberToValue(decoration.getValue()), coordinate:decoration.getPosition(), text:decoration.getLabel(), isVisible:!0});
  }
};
gviz.canviz.AxisDefiner.prototype.calcMinorGridlines_ = function(gridlines) {
  if (!gridlines || 1 >= gridlines.length || 0 == this.minorGridlinesCount_) {
    return null;
  }
  var numberOfParts = this.minorGridlinesCount_ + 1, jump = (gridlines[1].coordinate - gridlines[0].coordinate) / numberOfParts, minorGridlines = [], i, j, gridlineCoordinate = gridlines[0].coordinate, count = Math.floor((gridlineCoordinate - this.startPos) / jump);
  for (i = count;0 < i;i--) {
    var minorGridlineCoordinate = Math.floor(gridlineCoordinate - jump * i);
    1 < Math.abs(minorGridlineCoordinate - this.startPos) && minorGridlines.push(minorGridlineCoordinate);
  }
  for (i = 0;i < gridlines.length - 1;i++) {
    for (gridlineCoordinate = gridlines[i].coordinate, j = 0;j < this.minorGridlinesCount_;j++) {
      gridlineCoordinate += jump, minorGridlines.push(Math.floor(gridlineCoordinate));
    }
  }
  gridlineCoordinate = goog.array.peek(gridlines).coordinate;
  count = Math.floor((this.endPos - gridlineCoordinate) / jump);
  for (i = 1;i <= count;i++) {
    minorGridlineCoordinate = Math.floor(gridlineCoordinate + jump * i), 1 < Math.abs(minorGridlineCoordinate - this.endPos) && minorGridlines.push(minorGridlineCoordinate);
  }
  return minorGridlines;
};
gviz.canviz.AxisDefiner.prototype.calcLogScaleMinorGridlines_ = function(gridlines) {
  if (!gridlines || 1 >= gridlines.length || 0 == this.minorGridlinesCount_) {
    return null;
  }
  for (var gridline = gridlines[0], thisValue = gridline.dataValue, previousValue = thisValue, newGridlines = [gridline], i = 1;i < gridlines.length - 1;i++) {
    gridline = gridlines[i], previousValue = thisValue, thisValue = gridline.dataValue, 0 !== thisValue && (gviz.canviz.axis.Pow10Math.isPowerOf10(thisValue) || previousValue && gviz.canviz.axis.Pow10Math.isPowerOf10(previousValue / thisValue)) && newGridlines.push(gridline);
  }
  newGridlines.push(gridlines[gridlines.length - 1]);
  gridlines = newGridlines;
  if (1 >= gridlines.length) {
    return null;
  }
  var gapSize = gridlines[1].coordinate - gridlines[0].coordinate, minorGridlines = [], fracts = [], j, alternatives = gviz.canviz.Options.DEFAULT_LOG_MINOR_TICK_ALTERNATIVES;
  this.minorGridlinesCount_ = Math.min(alternatives.length, this.minorGridlinesCount_);
  var units = alternatives[this.minorGridlinesCount_ - 1];
  this.minorGridlinesCount_ = units.length;
  for (i = 0;i < this.minorGridlinesCount_;i++) {
    var unit = units[i], fract = Math.log(unit) / Math.log(10);
    fracts.push(fract);
  }
  for (var gridlineCoordinate, i = 0;i < gridlines.length - 1;i++) {
    gridlineCoordinate = gridlines[i].coordinate;
    var sign = 1, ratio = gridlines[i + 1].dataValue / gridlines[i].dataValue;
    if (!(0 > ratio) && gviz.canviz.axis.Pow10Math.isPowerOf10(ratio)) {
      for (1 > ratio && (sign = -1, gridlineCoordinate = gridlines[i + 1].coordinate), gapSize = gridlines[i + 1].coordinate - gridlines[i].coordinate, j = 0;j < this.minorGridlinesCount_;j++) {
        var minorGridlineCoordinate = gridlineCoordinate + sign * gapSize * fracts[j];
        minorGridlines.push(minorGridlineCoordinate);
      }
    }
  }
  return minorGridlines;
};
gviz.canviz.AxisDefiner.prototype.prepareBaseline_ = function() {
  var baseline = null;
  this.type == gviz.canviz.Options.AxisType.VALUE && this.baseline && (baseline = {dataValue:this.baseline.dataValue, coordinate:this.baseline.coordinate, isVisible:!0, length:null, brush:this.baselineBrush});
  return baseline;
};
gviz.canviz.AxisDefiner.prototype.extendMinMaxProps_ = function() {
  goog.isDefAndNotNull(this.userBaseline) && "auto" !== this.userBaseline && this.extendRangeToIncludeNumber(this.valueScale.valueToNumber(this.userBaseline));
  goog.isDefAndNotNull(this.minValue) && this.extendRangeToIncludeNumber(this.valueScale.valueToNumber(this.minValue));
  goog.isDefAndNotNull(this.maxValue) && this.extendRangeToIncludeNumber(this.valueScale.valueToNumber(this.maxValue));
};
gviz.canviz.AxisDefiner.prototype.setMinMaxProps_ = function() {
  var numericMinValue = goog.math.isFiniteNumber(this.viewWindow_.min) ? this.viewWindow_.min : this.valueScale.numericMinValue, numericMaxValue = goog.math.isFiniteNumber(this.viewWindow_.max) ? this.viewWindow_.max : this.valueScale.numericMaxValue;
  numericMinValue === numericMaxValue && (numericMinValue -= 1, numericMaxValue += 1);
  this.numericValueToPixelsFactor = this.axisLength / (numericMaxValue - numericMinValue);
  Infinity !== numericMinValue && (this.valueAtStartPos_ = numericMinValue);
  var numericBaseline;
  if (goog.isDef(this.userBaseline) && "auto" !== this.userBaseline) {
    numericBaseline = this.valueScale.valueToNumber(this.userBaseline);
  } else {
    var defaultBaseline = this.valueScale.valueToNumber(this.valueScale.getDefaultBaseline());
    numericBaseline = goog.math.clamp(defaultBaseline, numericMinValue, numericMaxValue);
    goog.math.isFiniteNumber(numericBaseline) || (numericBaseline = 0);
  }
  this.baseline = null;
  if (goog.math.isFiniteNumber(numericBaseline)) {
    var coordinate = this.calcPositionForNumericValue(numericBaseline);
    isNaN(coordinate) || (this.baseline = {dataValue:this.valueScale.numberToValue(numericBaseline), coordinate:coordinate});
  }
};
gviz.canviz.AxisDefiner.prototype.calcAxisLayoutVariableNumOfSections_ = function(chartDef) {
  this.extendRangeForPrettyMode_();
  this.setMinMaxProps_();
  var directionalityParams = this.getAxisDirectionalityParameters(chartDef), unscaledMinValue = this.valueScale.unscaleNumericValue(this.valueScale.numericMinValue), unscaledMaxValue = this.valueScale.unscaleNumericValue(this.valueScale.numericMaxValue);
  this.markClosestValueToZero(unscaledMinValue);
  this.markClosestValueToZero(unscaledMaxValue);
  var lambda = this.logScale_ ? 0 : 1, textMeasurer = new gviz.canviz.axis.TextMeasurerAdapter(chartDef.textMeasureFunction, this.tickTextStyle), formatter = this.createDiveFormatter_(this.options_), decorations = [];
  goog.math.isFiniteNumber(unscaledMinValue) && (decorations = gviz.canviz.axis.AxisDecorationsCreator.getNumberDecorations(unscaledMinValue, unscaledMaxValue, directionalityParams.screenStart, directionalityParams.screenEnd - 1, directionalityParams.reversed, lambda, this.zeroToClosestValueDistance_, directionalityParams.orientation, gviz.canviz.AxisDefiner.MIN_TICK_SPACING_, textMeasurer, formatter));
  this.ticks = [];
  for (var i = 0;i < decorations.length;i++) {
    var decoration = decorations[i], value = decoration.getValue(), tick = this.valueScale.scaleNumericValue(value), coordinate = this.calcPositionForNumericValue(tick);
    goog.asserts.assert(!isNaN(coordinate), "Bad tick value for variable number of sections.");
    this.ticks.push({dataValue:value, coordinate:coordinate, text:decoration.getLabel(), isVisible:!0});
  }
};
gviz.canviz.AxisDefiner.prototype.createDiveFormatter_ = function(options) {
  var builder = new gviz.canviz.formatting.NumberFormatterBuilder, customPattern = options.inferOptionalStringValue(this.getAbsoluteOptionsPath("format"));
  options.inferWholeObjectValue(this.getAbsoluteOptionsPath("formatOptions"));
  var scaleFactor = options.inferOptionalNumberValue(this.getAbsoluteOptionsPath("formatOptions.scaleFactor")), prefix = options.inferOptionalStringValue(this.getAbsoluteOptionsPath("formatOptions.prefix")), suffix = this.options_.inferOptionalStringValue(this.getAbsoluteOptionsPath("formatOptions.suffix"));
  if (customPattern || scaleFactor || prefix || suffix) {
    var formatterOptions = {pattern:customPattern, scaleFactor:scaleFactor, prefix:prefix, suffix:suffix};
    builder.useFormatterOptions(formatterOptions);
  } else {
    var numDecimals = options.inferOptionalNumberValue(this.getAbsoluteOptionsPath("formatter.numDecimals"));
    goog.isNumber(numDecimals) && builder.maxNumDecimals(numDecimals);
    var numSignificantDigits = options.inferOptionalNumberValue(this.getAbsoluteOptionsPath("formatter.numSignificantDigits"));
    goog.isNumber(numSignificantDigits) && builder.numSignificantDigits(numSignificantDigits);
    var unit = options.inferValue(this.getAbsoluteOptionsPath("formatter.unit"));
    unit && builder.unit({symbol:unit.symbol, position:unit.position, usePadding:unit.usePadding});
    options.inferBooleanValue(this.getAbsoluteOptionsPath("formatter.useMagnitudes")) && builder.useShortI18nMagnitudes(5);
  }
  return builder.build();
};
gviz.canviz.AxisDefiner.prototype.extendRangeForPrettyMode_ = function() {
  if (this.viewWindowMode == gviz.canviz.Options.ViewWindowMode.PRETTY && isFinite(this.valueScale.numericMinValue) && isFinite(this.valueScale.numericMaxValue)) {
    var newRange = gviz.canviz.axis.Utils.expandRange(new goog.math.Range(this.valueScale.numericMinValue, this.valueScale.numericMaxValue), .1);
    this.extendRangeToIncludeNumber(newRange.start);
    this.extendRangeToIncludeNumber(newRange.end);
  }
};
gviz.canviz.AxisDefiner.prototype.extendRangeToIncludeNumber = function(number) {
  this.type == gviz.canviz.Options.AxisType.VALUE && goog.isDefAndNotNull(number) && this.isValueInViewWindow(number) && (this.valueScale.extendRangeToIncludeNumber(number), this.allNumericValues_.push(number));
};
gviz.canviz.AxisDefiner.prototype.expandRangeABit = function() {
  if (this.type == gviz.canviz.Options.AxisType.VALUE) {
    var scale = this.valueScale, expand = .01 * (scale.numericMaxValue - scale.numericMinValue);
    0 < scale.numericMinValue && -Infinity == this.viewWindow_.min && (scale.numericMinValue = Math.max(scale.numericMinValue - expand, 0));
    0 > scale.numericMaxValue && Infinity == this.viewWindow_.max && (scale.numericMaxValue = Math.min(scale.numericMaxValue + expand, 0));
  }
};
gviz.canviz.AxisDefiner.prototype.calcPositionForNumericValue = function(value) {
  if (!goog.isDefAndNotNull(value)) {
    return null;
  }
  var result = this.startPos + (value - this.valueAtStartPos_) * this.direction * this.numericValueToPixelsFactor;
  goog.asserts.assert(!isNaN(result));
  return result;
};
gviz.canviz.AxisDefiner.prototype.calcNumericValueFromPosition = function(position) {
  if (!goog.isDefAndNotNull(position)) {
    return null;
  }
  var result = (position - this.startPos) * this.direction / this.numericValueToPixelsFactor + this.valueAtStartPos_;
  goog.asserts.assert(!isNaN(result));
  return result;
};
gviz.canviz.AxisDefiner.prototype.calcReversePosition = function(position) {
  if (!goog.isDefAndNotNull(position)) {
    return null;
  }
  this.direction = 1;
  var value = this.calcNumericValueFromPosition(position);
  this.direction = -1;
  var result = this.calcPositionForNumericValue(value);
  return result;
};
gviz.canviz.AxisDefiner.prototype.numberFromValue = function(value) {
  var numericValue = this.type == gviz.canviz.Options.AxisType.VALUE ? this.valueScale.valueToNumber(value) : value;
  return numericValue;
};
gviz.canviz.AxisDefiner.prototype.numberToValue = function(numericValue) {
  if (!goog.isDefAndNotNull(numericValue)) {
    return null;
  }
  var value = this.type == gviz.canviz.Options.AxisType.VALUE ? this.valueScale.numberToValue(numericValue) : numericValue;
  return value;
};
gviz.canviz.AxisDefiner.prototype.calcDataValueFromPosition = function(position) {
  var numericValue = this.calcNumericValueFromPosition(position);
  return goog.isDefAndNotNull(numericValue) ? this.numberToValue(numericValue) : null;
};
gviz.canviz.AxisDefiner.prototype.calcPositionFromDataValue = function(value) {
  return this.calcPositionForNumericValue(this.numberFromValue(value));
};
gviz.canviz.AxisDefiner.prototype.getMinNumericValue = function() {
  switch(this.type) {
    case gviz.canviz.Options.AxisType.VALUE:
    ;
    case gviz.canviz.Options.AxisType.CATEGORY_POINT:
      break;
    case gviz.canviz.Options.AxisType.CATEGORY:
      return this.viewWindow_.min - .5;
    default:
      goog.asserts.fail('Invalid axis type "' + this.type + '"');
  }
  return this.viewWindow_.min;
};
gviz.canviz.AxisDefiner.prototype.getMaxNumericValue = function() {
  switch(this.type) {
    case gviz.canviz.Options.AxisType.VALUE:
      break;
    case gviz.canviz.Options.AxisType.CATEGORY_POINT:
      return this.viewWindow_.max - 1;
    case gviz.canviz.Options.AxisType.CATEGORY:
      return this.viewWindow_.max - .5;
    default:
      goog.asserts.fail('Invalid axis type "' + this.type + '"');
  }
  return this.viewWindow_.max;
};
gviz.canviz.AxisDefiner.prototype.isValueInViewWindow = function(value) {
  return this.type == gviz.canviz.Options.AxisType.VALUE ? value >= this.viewWindow_.min && value <= this.viewWindow_.max : value >= Math.floor(this.viewWindow_.min) && value < Math.ceil(this.viewWindow_.max);
};
gviz.canviz.AxisDefiner.prototype.isPositionPastTheEnd = function(pos) {
  return pos * this.direction > this.endPos * this.direction;
};
gviz.canviz.AxisDefiner.prototype.isPositionBeforeTheStart = function(pos) {
  return pos * this.direction < this.startPos * this.direction;
};
gviz.canviz.AxisDefiner.prototype.isDatetimeValueScale_ = function() {
  return goog.isDefAndNotNull(this.valueScale) && (this.valueScale instanceof gviz.canviz.DatetimeValueScale || this.valueScale instanceof gviz.canviz.TimeofdayValueScale);
};
// INPUT (javascript/gviz/devel/canviz/tick-diluter.js)
gviz.canviz.TickDiluter = function(totalLength, ticks, firstTickIdx, maxLines, maxAltCount, forceSkip, skipMode, minSpacing, allowContainerBoundaryCufoff, calcTextLayout) {
  this.totalLength_ = totalLength;
  this.ticks_ = ticks;
  this.firstTickIdx_ = firstTickIdx;
  this.maxLines_ = maxLines;
  this.maxAltCount_ = maxAltCount;
  this.forceSkip_ = forceSkip;
  this.skipMode_ = skipMode;
  this.minSpacing_ = minSpacing;
  this.allowContainerBoundaryCufoff_ = allowContainerBoundaryCufoff;
  this.calcTextLayout_ = calcTextLayout;
};
gviz.canviz.TickDiluter.getFirstTickIdx = function(idx, numOfTicks, compositeSkip, skipMode) {
  switch(skipMode) {
    case gviz.canviz.Options.TextSkipMode.ATTACH_TO_END:
      return(numOfTicks - 1 - idx) % compositeSkip;
    default:
      return idx;
  }
};
gviz.canviz.TickDiluter.prototype.getEffectiveInterval_ = function(compositeSkip) {
  if (1 >= this.ticks_.length) {
    return this.totalLength_;
  }
  var interval = Math.abs(this.ticks_[1].coordinate - this.ticks_[0].coordinate);
  return interval * compositeSkip - this.minSpacing_;
};
gviz.canviz.TickDiluter.prototype.altSkipTooLarge_ = function(firstTickIdx, altCount, skip) {
  var numberOfDisplayedTicks = Math.ceil((this.ticks_.length - firstTickIdx) / (altCount * skip));
  return 2 > this.ticks_.length || 2 > numberOfDisplayedTicks;
};
gviz.canviz.TickDiluter.prototype.getTicksInfoForAlt_ = function(firstTickIdx, lineIdx, compositeSkip, numOfLines) {
  firstTickIdx = gviz.canviz.TickDiluter.getFirstTickIdx(firstTickIdx, this.ticks_.length, compositeSkip, this.skipMode_);
  for (var interval = this.getEffectiveInterval_(compositeSkip), result = [], i = firstTickIdx;i < this.ticks_.length;i += compositeSkip) {
    var tick = this.ticks_[i], width = tick.isVisible && !this.allowContainerBoundaryCufoff_ ? Math.min(interval, 2 * tick.coordinate, 2 * (this.totalLength_ - tick.coordinate)) : interval, layout = this.calcTextLayout_(tick.text, width, numOfLines), needTooltip = layout.needTooltip;
    if (width < interval) {
      var needTooltipLayout = this.calcTextLayout_(tick.text, interval, numOfLines), needTooltip = needTooltipLayout.needTooltip
    }
    result.push({dataValue:tick.dataValue, isVisible:tick.isVisible, coordinate:tick.coordinate, lineIdx:lineIdx, text:tick.text, width:layout.maxLineWidth, layout:layout, needTooltip:needTooltip});
  }
  return result;
};
gviz.canviz.TickDiluter.prototype.getTicksInfo_ = function(altCount, skip, numOfLines) {
  for (var compositeSkip = altCount * skip, numOfLinesPerAlt = 1 < altCount ? 1 : numOfLines, result = [], i = 0;i < altCount;i++) {
    var ticksInfo = this.getTicksInfoForAlt_(this.firstTickIdx_ + i * skip, i * numOfLinesPerAlt, compositeSkip, numOfLinesPerAlt);
    goog.array.extend(result, ticksInfo);
  }
  goog.array.sort(result, function(a, b) {
    return a.coordinate - b.coordinate;
  });
  return result;
};
gviz.canviz.TickDiluter.prototype.getDesiredTickLines_ = function(altCount, skip) {
  var ticksInfo = this.getTicksInfo_(altCount, skip, this.maxLines_), desiredLines = goog.array.reduce(ticksInfo, function(res, tickInfo) {
    var numOfLines = Math.max(res.numOfLines, tickInfo.layout.lines.length), needTooltip = res.needTooltip || tickInfo.needTooltip;
    return{numOfLines:numOfLines, needTooltip:needTooltip};
  }, {numOfLines:0, needTooltip:!1});
  return desiredLines;
};
gviz.canviz.TickDiluter.prototype.calcOptimisticTickArrangement = function() {
  for (var altCount = 1, skip = this.forceSkip_ || 1, desiredLines = this.getDesiredTickLines_(altCount, skip), safeAltCount = altCount;desiredLines.needTooltip && altCount < this.maxAltCount_;) {
    altCount++;
    if (this.altSkipTooLarge_(0, altCount, skip)) {
      break;
    }
    safeAltCount = altCount;
    desiredLines = this.getDesiredTickLines_(safeAltCount, skip);
  }
  var safeSkip = skip;
  if (!this.forceSkip_) {
    for (;desiredLines.needTooltip;) {
      skip++;
      if (this.altSkipTooLarge_(0, safeAltCount, skip)) {
        break;
      }
      safeSkip = skip;
      desiredLines = this.getDesiredTickLines_(safeAltCount, safeSkip);
    }
  }
  return{altCount:safeAltCount, skip:safeSkip, numOfLines:desiredLines.numOfLines * safeAltCount};
};
gviz.canviz.TickDiluter.prototype.getTicksInfoWithAcceptableFlag_ = function(altCount, skip, numOfLines, maxAcceptableRatio) {
  var ticksInfo = this.getTicksInfo_(altCount, skip, numOfLines), needTooltipCount = goog.array.reduce(ticksInfo, function(count, tickInfo) {
    var needTooltip = tickInfo.needTooltip ? 1 : 0;
    delete tickInfo.needTooltip;
    return count + needTooltip;
  }, 0), acceptable = needTooltipCount <= ticksInfo.length * maxAcceptableRatio;
  return{ticksInfo:ticksInfo, acceptable:acceptable};
};
gviz.canviz.TickDiluter.prototype.calcFinalTickArrangement = function(optimisticAltCount, optimisticSkip, numOfLines, maxAcceptableRatio) {
  for (var maxAltCount = Math.min(this.maxAltCount_, numOfLines), altCount = Math.min(optimisticAltCount, maxAltCount), skip = this.forceSkip_ || optimisticSkip, ticksInfoAcceptable = this.getTicksInfoWithAcceptableFlag_(altCount, skip, numOfLines, maxAcceptableRatio), safeAltCount = altCount;!ticksInfoAcceptable.acceptable && altCount < maxAltCount;) {
    altCount++;
    if (this.altSkipTooLarge_(0, altCount, skip)) {
      break;
    }
    safeAltCount = altCount;
    ticksInfoAcceptable = this.getTicksInfoWithAcceptableFlag_(safeAltCount, skip, numOfLines, maxAcceptableRatio);
  }
  var safeSkip = skip;
  if (!this.forceSkip_) {
    for (;!ticksInfoAcceptable.acceptable;) {
      skip++;
      if (this.altSkipTooLarge_(0, safeAltCount, skip)) {
        break;
      }
      safeSkip = skip;
      ticksInfoAcceptable = this.getTicksInfoWithAcceptableFlag_(safeAltCount, safeSkip, numOfLines, maxAcceptableRatio);
    }
  }
  return{altCount:safeAltCount, skip:safeSkip, ticksInfo:ticksInfoAcceptable.ticksInfo};
};
// INPUT (javascript/gviz/devel/canviz/horizontal-axis-definer.js)
gviz.canviz.HorizontalAxisDefiner = function(chartDef, options, optionsPath, index, defaultType, defaultViewWindowMode, opt_explicitTicks) {
  gviz.canviz.AxisDefiner.call(this, chartDef, options, goog.array.concat(["hAxes." + index, "hAxis"], optionsPath), index, defaultType, defaultViewWindowMode, opt_explicitTicks);
  this.slantedTickText = options.inferOptionalBooleanValue(this.getAbsoluteOptionsPath("slantedText"));
  var slantedTickTextAngleDegrees = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("slantedTextAngle"), 30);
  this.slantedTickTextAngleDegrees = slantedTickTextAngleDegrees = goog.math.modulo(slantedTickTextAngleDegrees, 360);
  this.slantedTickTextAngle = goog.math.toRadians(slantedTickTextAngleDegrees);
  this.axisMargin = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("margin"), .5 * this.tickTextStyle.fontSize);
  this.firstTickIdx = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("firstVisibleText"));
  this.maxTextLines = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("maxTextLines"), Infinity);
  this.maxAlternation = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("maxAlternation"), 2);
  this.forceSkip = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("showTextEvery"), 0);
  this.skipMode = options.inferEnumValue(this.getAbsoluteOptionsPath("showTextEveryMode"), gviz.canviz.Options.TextSkipMode, gviz.canviz.Options.TextSkipMode.ATTACH_TO_START);
  this.minTextSpacing = options.inferNonNegativeNumberValue(this.getAbsoluteOptionsPath("minTextSpacing"), this.tickTextStyle.fontSize);
  this.allowContainerBoundaryTextCufoff = options.inferBooleanValue(this.getAbsoluteOptionsPath("allowContainerBoundaryTextCufoff"), !1);
};
goog.inherits(gviz.canviz.HorizontalAxisDefiner, gviz.canviz.AxisDefiner);
gviz.canviz.HorizontalAxisDefiner.prototype.getAxisName = function() {
  return "hAxis#" + this.index;
};
gviz.canviz.HorizontalAxisDefiner.prototype.calcAxisDefinition = function(chartDef, legendDefiner, colorBarDefiner) {
  return this.calcCommonAxisDefinition(chartDef, chartDef.chartArea.width, 1 == this.direction ? chartDef.chartArea.left : chartDef.chartArea.right, legendDefiner, colorBarDefiner);
};
gviz.canviz.HorizontalAxisDefiner.prototype.calcOutsideTextLayout = function(chartDef, legendDefiner, colorBarDefiner, predefinedTickTextLayout) {
  if (0 == this.index) {
    var measureFunction = chartDef.textMeasureFunction, tickFontSize = this.tickTextStyle.fontSize, titleFontSize = this.title.textStyle.fontSize, legendFontSize = legendDefiner.getTextStyle().fontSize, titleText = chartDef.axisTitlesPosition == gviz.canviz.Options.InOutPosition.OUTSIDE ? this.title.text : "", that = this, tickDiluter = new gviz.canviz.TickDiluter(chartDef.width, this.ticks, this.firstTickIdx, this.maxTextLines, this.maxAlternation, this.forceSkip, this.skipMode, this.minTextSpacing, 
    this.allowContainerBoundaryTextCufoff, function(text, width, numOfLines) {
      return gviz.canviz.textutils.calcTextLayout(measureFunction, text, that.tickTextStyle, width, numOfLines);
    }), skipThreshold = this.forceSkip || 1, optimisticHorizontalTicks, optimisticSlantedTicks;
    if (this.tickTextPosition == gviz.canviz.Options.InOutPosition.OUTSIDE && !predefinedTickTextLayout) {
      if (goog.isDefAndNotNull(this.slantedTickText)) {
        this.slantedTickText ? optimisticSlantedTicks = this.calcOptimisticSlantedTicks_(measureFunction) : optimisticHorizontalTicks = tickDiluter.calcOptimisticTickArrangement();
      } else {
        if (this.ticks.length * tickFontSize / (this.maxAlternation * skipThreshold) <= chartDef.width) {
          if (optimisticHorizontalTicks = tickDiluter.calcOptimisticTickArrangement(), optimisticHorizontalTicks.skip > skipThreshold || 0 == optimisticHorizontalTicks.numOfLines) {
            optimisticSlantedTicks = this.calcOptimisticSlantedTicks_(measureFunction), optimisticHorizontalTicks = null;
          }
        } else {
          optimisticSlantedTicks = this.calcOptimisticSlantedTicks_(measureFunction);
        }
      }
    }
    var optimisticTitleLayout = gviz.canviz.textutils.calcTextLayout(measureFunction, titleText, this.title.textStyle, chartDef.chartArea.width, Infinity), minGap = this.minGap, gapAboveTicks = Math.max(minGap, Math.round(tickFontSize / gviz.canviz.Constants.GOLDEN_RATIO)), gapBetweenTickLines = Math.max(minGap, Math.round(tickFontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO))), getSlantedTicksItem = function() {
      return{key:"ticks", min:optimisticSlantedTicks.minHeight + minGap, max:optimisticSlantedTicks.maxHeight + minGap, extra:[gapAboveTicks - minGap]};
    }, items = [];
    items.push({key:"bottom-space", min:minGap, extra:[Infinity]});
    0 < optimisticTitleLayout.lines.length && items.push({key:"title", min:titleFontSize + minGap, extra:[Infinity]});
    legendDefiner.getPosition() == gviz.canviz.Options.LegendPosition.BOTTOM && items.push({key:"legend", min:legendFontSize + minGap, extra:[Infinity]});
    colorBarDefiner.getPosition() == gviz.canviz.Options.ColorBarPosition.BOTTOM && items.push({key:"colorBar", min:colorBarDefiner.getHeight() + minGap, extra:[Infinity]});
    var tickFirstLineIdx = items.length;
    predefinedTickTextLayout || optimisticHorizontalTicks && 0 < optimisticHorizontalTicks.numOfLines ? items.push({key:"ticks", min:tickFontSize + minGap, extra:[gapAboveTicks - minGap]}) : optimisticSlantedTicks && items.push(getSlantedTicksItem());
    var tickRestLinesBeginIdx = items.length;
    if (optimisticHorizontalTicks) {
      for (var i$$0 = 1;i$$0 < optimisticHorizontalTicks.numOfLines;i$$0++) {
        items.push({key:"ticks", min:tickFontSize + minGap, extra:[gapBetweenTickLines - minGap]});
      }
    }
    for (var tickRestLinesEndIdx = items.length, i$$0 = 1;i$$0 < optimisticTitleLayout.lines.length;i$$0++) {
      items.push({key:"title", min:titleFontSize + minGap, extra:[this.gapBetweenTitleLines - minGap]});
    }
    var allocatedHeights = gviz.canviz.util.distributeRealEstateWithKeys(items, chartDef.height - chartDef.chartArea.bottom), actualTickLines = allocatedHeights.ticks || [], finalHorizontalTicks;
    optimisticHorizontalTicks && (finalHorizontalTicks = tickDiluter.calcFinalTickArrangement(optimisticHorizontalTicks.altCount, optimisticHorizontalTicks.skip, actualTickLines.length, 0), !goog.isDefAndNotNull(this.slantedTickText) && finalHorizontalTicks.skip > skipThreshold && (finalHorizontalTicks = optimisticHorizontalTicks = null, optimisticSlantedTicks = this.calcOptimisticSlantedTicks_(measureFunction), items[tickFirstLineIdx] = getSlantedTicksItem(), items = gviz.canviz.util.arrayMultiSlice(items, 
    0, tickRestLinesBeginIdx, tickRestLinesEndIdx, void 0), allocatedHeights = gviz.canviz.util.distributeRealEstateWithKeys(items, chartDef.height - chartDef.chartArea.bottom)));
    var y = chartDef.chartArea.bottom, actualTickLines = allocatedHeights.ticks || [];
    if (0 < actualTickLines.length) {
      for (i$$0 = 1;i$$0 < actualTickLines.length;i$$0++) {
        actualTickLines[i$$0] += actualTickLines[i$$0 - 1];
      }
      if (predefinedTickTextLayout) {
        goog.asserts.assert(1 == actualTickLines.length);
        for (var singleLineY = y + actualTickLines[0], i$$0 = 0;i$$0 < predefinedTickTextLayout.length;i$$0++) {
          var textBlock = predefinedTickTextLayout[i$$0].textBlock;
          textBlock.anchor = textBlock.anchor || new gviz.math.Coordinate(0, 0);
          textBlock.anchor.y = singleLineY;
          goog.asserts.assert(1 == textBlock.lines.length);
        }
        this.tickTextLayout = predefinedTickTextLayout;
      } else {
        if (optimisticHorizontalTicks) {
          this.tickTextLayout = goog.array.map(finalHorizontalTicks.ticksInfo, function(tickInfo) {
            var lines = goog.array.map(tickInfo.layout.lines, function(line, i) {
              return{x:0, y:actualTickLines[tickInfo.lineIdx + i], length:tickInfo.width, text:line};
            }, this);
            return{dataValue:tickInfo.dataValue, isVisible:tickInfo.isVisible, textBlock:{text:tickInfo.text, textStyle:this.tickTextStyle, lines:lines, paralAlign:gviz.graphics.TextAlign.CENTER, perpenAlign:gviz.graphics.TextAlign.END, tooltip:tickInfo.layout.needTooltip ? tickInfo.text : "", anchor:new gviz.math.Coordinate(tickInfo.coordinate, y), angle:0}};
          }, this);
        } else {
          if (optimisticSlantedTicks) {
            var heightWithSpace = actualTickLines[0], height = Math.min(heightWithSpace - minGap, optimisticSlantedTicks.maxHeight), top = y + heightWithSpace - height;
            this.tickTextLayout = this.calcFinalSlantedTicks_(measureFunction, top, height, optimisticSlantedTicks.skip);
          }
        }
      }
      y += goog.array.peek(actualTickLines);
    }
    var actualTitleLines = allocatedHeights.title || [];
    if (0 < actualTitleLines.length) {
      var layout = gviz.canviz.textutils.calcTextLayout(measureFunction, titleText, this.title.textStyle, chartDef.chartArea.width, actualTitleLines.length);
      this.title.tooltip = layout.needTooltip ? titleText : "";
      for (i$$0 = 0;i$$0 < actualTitleLines.length;i$$0++) {
        y += actualTitleLines[i$$0], this.title.perpenAlign = gviz.graphics.TextAlign.END, this.title.lines.push({x:chartDef.chartArea.left + chartDef.chartArea.width / 2, y:y, length:chartDef.chartArea.width, text:layout.lines[i$$0]});
      }
    }
    var actualLegendLines = allocatedHeights.legend || [];
    if (0 < actualLegendLines.length) {
      var y = y + actualLegendLines[0], legendArea = new goog.math.Box(y - legendFontSize, chartDef.chartArea.right, y, chartDef.chartArea.left);
      legendDefiner.setArea(legendArea);
    }
    var actualColorBarLines = allocatedHeights.colorBar || [];
    if (0 < actualColorBarLines.length) {
      var y = y + actualColorBarLines[0], colorBarArea = new goog.math.Box(y - colorBarDefiner.getHeight(), chartDef.chartArea.right, y, chartDef.chartArea.left);
      colorBarDefiner.setArea(colorBarArea);
    }
  }
};
gviz.canviz.HorizontalAxisDefiner.prototype.calcOptimisticSlantedTicks_ = function(textMeasureFunction) {
  var tickTextStyle = this.tickTextStyle, tickFontSize = tickTextStyle.fontSize, sin = Math.sin(this.slantedTickTextAngle % Math.PI), cos = Math.cos(this.slantedTickTextAngle % Math.PI), getHeight = function(tick) {
    var textWidth = textMeasureFunction(tick.text, tickTextStyle).width, height = textWidth * sin + tickFontSize * cos;
    return Math.ceil(height);
  }, skip = this.forceSkip;
  if (!skip) {
    if (2 > this.ticks.length) {
      skip = 1;
    } else {
      var tickInterval = Math.abs(this.ticks[1].coordinate - this.ticks[0].coordinate), minWidth = (tickFontSize + this.minGap) / sin, skip = Math.ceil(minWidth / tickInterval)
    }
  }
  for (var maxHeight = 0, i = 0;i < this.ticks.length;i += skip) {
    maxHeight = Math.max(getHeight(this.ticks[i]), maxHeight);
  }
  var missingTextIndicatorHeight = getHeight({text:gviz.canviz.Messages.MSG_MISSING_TEXT_INDICATION}), minHeight = Math.min(maxHeight, missingTextIndicatorHeight);
  return{minHeight:minHeight, maxHeight:maxHeight, skip:skip};
};
gviz.canviz.HorizontalAxisDefiner.prototype.getMaximalTickTextWidth = function(chartDef) {
  var measureFunction = chartDef.textMeasureFunction;
  return goog.array.reduce(this.getApproximateTicks(chartDef), function(prev, curr) {
    return Math.max(prev, measureFunction(curr, this.tickTextStyle).width);
  }, 0, this);
};
gviz.canviz.HorizontalAxisDefiner.prototype.getMinimalTickTextWidth = function(chartDef) {
  var measureFunction = chartDef.textMeasureFunction, maximalTickTextWidth = this.getMaximalTickTextWidth(chartDef), missingItemsText = gviz.canviz.Messages.MSG_MISSING_TEXT_INDICATION, missingItemsTextWidth = measureFunction(missingItemsText, this.tickTextStyle).width;
  return Math.min(missingItemsTextWidth, maximalTickTextWidth);
};
gviz.canviz.HorizontalAxisDefiner.prototype.calcFinalSlantedTicks_ = function(textMeasureFunction, top, height, skip) {
  var tickFontSize = this.tickTextStyle.fontSize, sin = Math.sin(this.slantedTickTextAngle % Math.PI), cos = Math.cos(this.slantedTickTextAngle % Math.PI), firstTickIdx = gviz.canviz.TickDiluter.getFirstTickIdx(0, this.ticks.length, skip, this.skipMode), textWidth = (height - tickFontSize * cos) / sin, textWidth = Math.floor(textWidth), result = [];
  top += this.axisMargin;
  for (var i = firstTickIdx;i < this.ticks.length;i += skip) {
    var tick = this.ticks[i], textLayout = gviz.canviz.textutils.calcTextLayout(textMeasureFunction, tick.text, this.tickTextStyle, textWidth, 1), switchAlign = 180 < this.slantedTickTextAngleDegrees, textBlock = {text:tick.text, textStyle:this.tickTextStyle, lines:[], angle:-this.slantedTickTextAngleDegrees, paralAlign:switchAlign ? gviz.graphics.TextAlign.START : gviz.graphics.TextAlign.END, perpenAlign:gviz.graphics.TextAlign.CENTER, tooltip:textLayout.needTooltip ? tick.text : "", anchor:new gviz.math.Coordinate(tick.coordinate, 
    top)};
    0 < textLayout.lines.length && textBlock.lines.push({x:0, y:0, length:textWidth, text:textLayout.lines[0]});
    result.push({dataValue:tick.dataValue, isVisible:tick.isVisible, textBlock:textBlock});
  }
  return result;
};
gviz.canviz.HorizontalAxisDefiner.prototype.calcInsideTextLayout = function(chartDef) {
  if (0 == this.index) {
    var measureFunction = chartDef.textMeasureFunction, tickFontSize = this.tickTextStyle.fontSize, tickDiluter = new gviz.canviz.TickDiluter(chartDef.width, this.ticks, this.firstTickIdx, this.maxTextLines, this.maxAlternation, this.forceSkip, this.skipMode, this.minTextSpacing, this.allowContainerBoundaryTextCufoff, goog.bind(function(text, width, numOfLines) {
      return gviz.canviz.textutils.calcTextLayout(measureFunction, text, this.tickTextStyle, width, numOfLines);
    }, this)), optimisticHorizontalTicks, tickInTextPosition = this.tickInTextPosition;
    this.tickTextPosition == gviz.canviz.Options.InOutPosition.INSIDE && (optimisticHorizontalTicks = tickDiluter.calcOptimisticTickArrangement(), this.newTimeline && (tickInTextPosition = gviz.canviz.Options.HighLowPosition.HIGH));
    var minGap = this.minGap, gapFromValueAxis = Math.max(this.minGap, Math.round(tickFontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO))), gapFromCategoryAxis = Math.max(this.minGap, Math.round(tickFontSize / gviz.canviz.Constants.GOLDEN_RATIO)), gapBelowTicks = this.type == gviz.canviz.Options.AxisType.VALUE ? gapFromValueAxis : gapFromCategoryAxis, gapBetweenTickLines = Math.max(minGap, Math.round(tickFontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO))), paralAlign, horizontalOffset;
    this.type == gviz.canviz.Options.AxisType.VALUE ? tickInTextPosition === gviz.canviz.Options.HighLowPosition.HIGH ? (paralAlign = gviz.graphics.TextAlign.START, horizontalOffset = gapFromValueAxis) : (paralAlign = gviz.graphics.TextAlign.END, horizontalOffset = -gapFromValueAxis) : (paralAlign = gviz.graphics.TextAlign.CENTER, horizontalOffset = 0);
    var items = [];
    items.push({key:"top-space", min:minGap, extra:[Infinity]});
    if (optimisticHorizontalTicks) {
      for (var i$$0 = 0;i$$0 < optimisticHorizontalTicks.numOfLines;i$$0++) {
        var gap = 0 == i$$0 ? gapBelowTicks : gapBetweenTickLines;
        items.push({key:"ticks", min:tickFontSize + minGap, extra:[gap - minGap]});
      }
    }
    var availableRealEstate = Math.floor(chartDef.chartArea.height / 2), allocatedHeights = gviz.canviz.util.distributeRealEstateWithKeys(items, availableRealEstate), actualTickLines = allocatedHeights.ticks || [];
    if (0 < actualTickLines.length) {
      for (i$$0 = 1;i$$0 < actualTickLines.length;i$$0++) {
        actualTickLines[i$$0] += actualTickLines[i$$0 - 1];
      }
      var finalHorizontalTicks = tickDiluter.calcFinalTickArrangement(optimisticHorizontalTicks.altCount, optimisticHorizontalTicks.skip, actualTickLines.length, .5);
      this.tickTextLayout = goog.array.map(finalHorizontalTicks.ticksInfo, function(tickInfo) {
        var layoutLines = tickInfo.layout.lines;
        layoutLines.reverse();
        var lines = goog.array.map(layoutLines, function(line, i) {
          return{x:0, y:-actualTickLines[tickInfo.lineIdx + i], length:tickInfo.width, text:line};
        }, this);
        return{dataValue:tickInfo.dataValue, isVisible:tickInfo.isVisible, textBlock:{text:tickInfo.text, textStyle:this.tickTextStyle, lines:lines, paralAlign:paralAlign, perpenAlign:gviz.graphics.TextAlign.START, tooltip:tickInfo.layout.needTooltip ? tickInfo.text : "", anchor:new gviz.math.Coordinate(horizontalOffset + tickInfo.coordinate, chartDef.chartArea.bottom), angle:0}};
      }, this);
    }
  }
};
gviz.canviz.HorizontalAxisDefiner.prototype.getAxisDirectionalityParameters = function(chartDef) {
  var res = {};
  res.reversed = -1 == this.direction;
  res.screenStart = chartDef.chartArea.left;
  res.screenEnd = chartDef.chartArea.right;
  res.orientation = this.getOrientation();
  return res;
};
gviz.canviz.HorizontalAxisDefiner.prototype.getOrientation = function() {
  return gviz.canviz.axis.AxisTools.Orientation.HORIZONTAL;
};
gviz.canviz.HorizontalAxisDefiner.prototype.calcTicklinesOrigin = function(chartDef) {
  return 0 == this.index ? {coordinate:chartDef.chartArea.bottom, direction:-1} : {coordinate:chartDef.chartArea.top, direction:1};
};
// INPUT (javascript/gviz/devel/canviz/vector-utils.js)
gviz.canviz.vectorutils = {};
gviz.canviz.vectorutils.round = function(vec) {
  return new goog.math.Vec2(Math.round(vec.x), Math.round(vec.y));
};
gviz.canviz.vectorutils.sumAll = function(var_args) {
  return goog.array.reduce(arguments, goog.math.Vec2.sum, new goog.math.Vec2(0, 0));
};
gviz.canviz.vectorutils.sumOfSizes = function(var_args) {
  return goog.array.reduce(arguments, function(s1, s2) {
    return new goog.math.Size(s1.width + s2.width, s1.height + s2.height);
  }, new goog.math.Size(0, 0));
};
gviz.canviz.vectorutils.vectorInDirection = function(angle, magnitude) {
  return gviz.canviz.vectorutils.vectorOnEllipse(angle, magnitude, magnitude);
};
gviz.canviz.vectorutils.vectorOnEllipse = function(angle, radiusX, radiusY) {
  return new goog.math.Vec2(Math.cos(angle) * radiusX, Math.sin(angle) * radiusY);
};
gviz.canviz.vectorutils.pairToVector = function(pair) {
  return new goog.math.Vec2(pair[0], pair[1]);
};
gviz.canviz.vectorutils.pairsToVectors = function(pairs) {
  return goog.array.map(pairs, gviz.canviz.vectorutils.pairToVector);
};
gviz.canviz.vectorutils.rectangleDiagonal = function(rectangleSize) {
  return new goog.math.Vec2(rectangleSize.width, rectangleSize.height);
};
gviz.canviz.vectorutils.cornersOfRectangle = function(center, size) {
  return gviz.canviz.vectorutils.pairsToVectors([[center.x - size.width / 2, center.y - size.height / 2], [center.x + size.width / 2, center.y - size.height / 2], [center.x + size.width / 2, center.y + size.height / 2], [center.x - size.width / 2, center.y + size.height / 2]]);
};
gviz.canviz.vectorutils.centerOfRectangleAdjacentToPerpendicular = function(ray, rectangleSize, isInside) {
  var squaredMagnitude = ray.squaredMagnitude();
  if (0 == squaredMagnitude) {
    return new goog.math.Vec2(0, 0);
  }
  var candidates = gviz.canviz.vectorutils.cornersOfRectangle(ray, rectangleSize), scores = goog.array.map(candidates, function(candidate) {
    return goog.math.Vec2.dot(candidate, ray);
  }), f = function(a, b) {
    return isInside ? Math.min(a, b) : Math.max(a, b);
  }, winningScore = goog.array.reduce(scores, f, isInside ? Infinity : -Infinity);
  ray = ray.clone();
  ray.scale(winningScore / squaredMagnitude);
  return ray;
};
gviz.canviz.vectorutils.cornersToRectangle = function(x1, y1, x2, y2) {
  return new goog.math.Rect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
};
gviz.canviz.vectorutils.positionBoxInEllipticSlice = function(radiusX, radiusY, fromAngle, toAngle, boxSize, opt_paddingToSliceBoundries, opt_paddingToCenter) {
  var stretchedTextBoxSize = new goog.math.Size(boxSize.width / radiusX, boxSize.height / radiusY), stretchedPadding = new goog.math.Size((opt_paddingToSliceBoundries || 0) / radiusX, (opt_paddingToSliceBoundries || 0) / radiusY), stretchedTextBoxCenter = gviz.canviz.vectorutils.positionBoxInSliceOfAUnitCircle_(fromAngle, toAngle, stretchedTextBoxSize, stretchedPadding, opt_paddingToCenter || 0);
  return stretchedTextBoxCenter && new goog.math.Vec2(stretchedTextBoxCenter.x * radiusX, stretchedTextBoxCenter.y * radiusY);
};
gviz.canviz.vectorutils.positionBoxInSliceOfAUnitCircle_ = function(fromAngle, toAngle, boxSize, paddingToSliceBoundries, paddingToCenter) {
  var bisectionInverseAngle = (fromAngle + toAngle) / 2 + Math.PI, circleCenterDirection = gviz.canviz.vectorutils.vectorInDirection(bisectionInverseAngle, 1), zeroCenteredBoxCorners = gviz.canviz.vectorutils.cornersOfRectangle(new goog.math.Vec2(0, 0), boxSize), distanceToCircleCenter = gviz.canviz.vectorutils.circleAdjacentToConvexShape_(circleCenterDirection, zeroCenteredBoxCorners, !1);
  if (goog.isDefAndNotNull(paddingToCenter) && distanceToCircleCenter < paddingToCenter) {
    return null;
  }
  var boxCenter = circleCenterDirection.clone();
  boxCenter.scale(-distanceToCircleCenter);
  var sizeIncludingPadding = gviz.canviz.vectorutils.sumOfSizes(boxSize, paddingToSliceBoundries, paddingToSliceBoundries), inSlice = gviz.canviz.vectorutils.isConvexShapeInInfiniteSlice_(gviz.canviz.vectorutils.cornersOfRectangle(boxCenter, sizeIncludingPadding), fromAngle, toAngle);
  return inSlice ? boxCenter : null;
};
gviz.canviz.vectorutils.circleAdjacentToConvexShape_ = function(direction, vertices, isConvexOutsideCircle) {
  for (var distance = 1, reducer = isConvexOutsideCircle ? Math.max : Math.min, i = 0;i < vertices.length;++i) {
    var points = gviz.canviz.vectorutils.pointsOnLineOfDistanceOneToPoint_(direction, vertices[i]);
    if (goog.isNull(points) || 0 > points[1]) {
      return null;
    }
    distance = reducer(distance, points[1]);
  }
  return distance;
};
gviz.canviz.vectorutils.pointsOnLineOfDistanceOneToPoint_ = function(ray, point) {
  var squareNormP = point.squaredMagnitude(), rayDotPoint = goog.math.Vec2.dot(ray, point), dext = rayDotPoint * rayDotPoint + 1 - squareNormP;
  if (0 > dext) {
    return null;
  }
  var sqrtDext = Math.sqrt(dext);
  return[rayDotPoint - sqrtDext, rayDotPoint + sqrtDext];
};
gviz.canviz.vectorutils.isConvexShapeInInfiniteSlice_ = function(vertices, fromAngle, toAngle) {
  for (var range = goog.math.modulo(toAngle - fromAngle, 2 * Math.PI), max = 0, min = range, i = 0;i < vertices.length;++i) {
    var angle = Math.atan2(vertices[i].y, vertices[i].x), angleMinusFrom = goog.math.modulo(angle - fromAngle, 2 * Math.PI);
    if (angleMinusFrom >= range || 0 == angleMinusFrom) {
      return!1;
    }
    min = Math.min(angleMinusFrom, min);
    max = Math.max(angleMinusFrom, max);
  }
  return max - min < Math.PI;
};
// INPUT (javascript/gviz/devel/canviz/vertical-axis-definer.js)
gviz.canviz.VerticalAxisDefiner = function(chartDef, options, optionsPath, index, defaultType, defaultViewWindowMode, opt_explicitTicks) {
  gviz.canviz.AxisDefiner.call(this, chartDef, options, goog.array.concat(["vAxes." + index, "vAxis"], optionsPath), index, defaultType, defaultViewWindowMode, opt_explicitTicks);
  this.type == gviz.canviz.Options.AxisType.VALUE && (this.direction = -this.direction);
};
goog.inherits(gviz.canviz.VerticalAxisDefiner, gviz.canviz.AxisDefiner);
gviz.canviz.VerticalAxisDefiner.prototype.getAxisName = function() {
  return "vAxis#" + this.index;
};
gviz.canviz.VerticalAxisDefiner.prototype.calcAxisDefinition = function(chartDef, legendDefiner, colorBarDefiner) {
  return this.calcCommonAxisDefinition(chartDef, chartDef.chartArea.height, 1 == this.direction ? chartDef.chartArea.top : chartDef.chartArea.bottom, legendDefiner, colorBarDefiner);
};
gviz.canviz.VerticalAxisDefiner.prototype.getMaximalTickTextWidth = function(chartDef) {
  var measureFunction = chartDef.textMeasureFunction;
  return goog.array.reduce(this.getApproximateTicks(chartDef), function(prev, curr) {
    return Math.max(prev, measureFunction(curr, this.tickTextStyle).width);
  }, 0, this);
};
gviz.canviz.VerticalAxisDefiner.prototype.getMinimalTickTextWidth = function(chartDef) {
  var measureFunction = chartDef.textMeasureFunction, maximalTickTextWidth = this.getMaximalTickTextWidth(chartDef), missingItemsText = gviz.canviz.Messages.MSG_MISSING_TEXT_INDICATION, missingItemsTextWidth = measureFunction(missingItemsText, this.tickTextStyle).width;
  return Math.min(missingItemsTextWidth, maximalTickTextWidth);
};
gviz.canviz.VerticalAxisDefiner.prototype.calcOutsideTextLayout = function(chartDef) {
  var measureFunction = chartDef.textMeasureFunction, tickFontSize = this.tickTextStyle.fontSize, titleFontSize = this.title.textStyle.fontSize, titleText = chartDef.axisTitlesPosition == gviz.canviz.Options.InOutPosition.OUTSIDE ? this.title.text : "", optimisticTitleLayout = gviz.canviz.textutils.calcTextLayout(measureFunction, titleText, this.title.textStyle, chartDef.chartArea.height, Infinity), minGap = this.minGap, maximalTickTextWidth = this.getMaximalTickTextWidth(chartDef), minimalTickTextWidth = 
  this.getMinimalTickTextWidth(chartDef), items = [];
  this.tickTextPosition == gviz.canviz.Options.InOutPosition.OUTSIDE ? items.push({key:"right-space", min:minGap, extra:[tickFontSize - minGap]}) : items.push({key:"right-space", min:0, extra:[Infinity]});
  0 < optimisticTitleLayout.lines.length && items.push({key:"title", min:titleFontSize + minGap, extra:[Infinity]});
  this.tickTextPosition == gviz.canviz.Options.InOutPosition.OUTSIDE && items.push({key:"ticks", min:minimalTickTextWidth + minGap, max:maximalTickTextWidth + minGap, extra:[Infinity]});
  for (var i = 1;i < optimisticTitleLayout.lines.length;i++) {
    items.push({key:"title", min:titleFontSize + minGap, extra:[this.gapBetweenTitleLines - minGap]});
  }
  var allocatedWidths = gviz.canviz.util.distributeRealEstateWithKeys(items, 0 == this.index ? chartDef.chartArea.left : chartDef.width - chartDef.chartArea.right), x = 0 == this.index ? 0 : chartDef.width, actualTitleLines = allocatedWidths.title || [];
  if (0 < actualTitleLines.length) {
    var layout = gviz.canviz.textutils.calcTextLayout(measureFunction, titleText, this.title.textStyle, chartDef.chartArea.height, actualTitleLines.length);
    1 === this.index && layout.lines.reverse();
    this.title.tooltip = layout.needTooltip ? titleText : "";
    for (i = 0;i < actualTitleLines.length;i++) {
      x += actualTitleLines[i] * (0 == this.index ? 1 : -1), this.title.angle = -90, this.title.perpenAlign = 0 == this.index ? gviz.graphics.TextAlign.END : gviz.graphics.TextAlign.START, this.title.lines.push({x:x, y:chartDef.chartArea.top + chartDef.chartArea.height / 2, length:chartDef.chartArea.height, text:layout.lines[i]});
    }
  }
  if (this.tickTextPosition == gviz.canviz.Options.InOutPosition.OUTSIDE) {
    var tickWidth = allocatedWidths.ticks[0] || 0, x = x + tickWidth * (0 == this.index ? 1 : -1), tickTextWidth = Math.min(maximalTickTextWidth, tickWidth - minGap);
    this.tickTextLayout = tickTextWidth < minimalTickTextWidth ? [] : goog.array.map(this.ticks, function(tick, tickIndex) {
      var paralAlign = 0 == this.index ? gviz.graphics.TextAlign.END : gviz.graphics.TextAlign.START, perpenAlign = gviz.graphics.TextAlign.CENTER;
      this.tickOutTextPosition == gviz.canviz.Options.BoundUnboundPosition.BOUND && (0 == tickIndex && (perpenAlign = 1 == this.direction ? gviz.graphics.TextAlign.START : gviz.graphics.TextAlign.END), tickIndex == this.ticks.length - 1 && (perpenAlign = 1 == this.direction ? gviz.graphics.TextAlign.END : gviz.graphics.TextAlign.START));
      return this.getTickTextLayout_(chartDef, tick, x, tickTextWidth, paralAlign, perpenAlign, 0);
    }, this);
  }
};
gviz.canviz.VerticalAxisDefiner.prototype.calcInsideTextLayout = function(chartDef) {
  var measureFunction = chartDef.textMeasureFunction, tickFontSize = this.tickTextStyle.fontSize, minGap = this.minGap, gapFromValueAxis = Math.max(this.minGap, Math.round(tickFontSize / (2 * gviz.canviz.Constants.GOLDEN_RATIO))), gapFromCategoryAxis = Math.max(this.minGap, Math.round(tickFontSize / gviz.canviz.Constants.GOLDEN_RATIO)), horizontalOffset = this.type == gviz.canviz.Options.AxisType.VALUE ? gapFromValueAxis : gapFromCategoryAxis, perpenAlign, verticalOffset;
  this.type == gviz.canviz.Options.AxisType.VALUE ? this.tickInTextPosition == gviz.canviz.Options.HighLowPosition.HIGH ? (perpenAlign = gviz.graphics.TextAlign.END, verticalOffset = gapFromValueAxis) : (perpenAlign = gviz.graphics.TextAlign.START, verticalOffset = -gapFromValueAxis) : (perpenAlign = gviz.graphics.TextAlign.CENTER, verticalOffset = 0);
  var maximalTickTextWidth = goog.array.reduce(this.ticks, function(prev, curr) {
    return Math.max(prev, measureFunction(curr.text, this.tickTextStyle).width);
  }, 0, this), missingItemsText = gviz.canviz.Messages.MSG_MISSING_TEXT_INDICATION, missingItemsTextWidth = measureFunction(missingItemsText, this.tickTextStyle).width, minimalTickTextWidth = Math.min(missingItemsTextWidth, maximalTickTextWidth), items = [];
  items.push({key:"right-space", min:minGap, extra:[Infinity]});
  this.tickTextPosition == gviz.canviz.Options.InOutPosition.INSIDE && items.push({key:"ticks", min:minimalTickTextWidth + minGap, max:maximalTickTextWidth + horizontalOffset, extra:[]});
  var allocatedWidths = gviz.canviz.util.distributeRealEstateWithKeys(items, chartDef.chartArea.width / 2), x = 0 == this.index ? chartDef.chartArea.left : chartDef.chartArea.right;
  if (this.tickTextPosition == gviz.canviz.Options.InOutPosition.INSIDE) {
    var tickWidth = allocatedWidths.ticks[0] || 0, tickTextWidth = Math.min(maximalTickTextWidth, tickWidth - minGap), x = x + (tickWidth - tickTextWidth) * (0 == this.index ? 1 : -1);
    this.tickTextLayout = goog.array.map(this.ticks, function(tick) {
      var paralAlign = 0 == this.index ? gviz.graphics.TextAlign.START : gviz.graphics.TextAlign.END;
      return this.getTickTextLayout_(chartDef, tick, x, tickTextWidth, paralAlign, perpenAlign, verticalOffset);
    }, this);
  }
};
gviz.canviz.VerticalAxisDefiner.prototype.getTickTextLayout_ = function(chartDef, tick, x, tickTextWidth, paralAlign, perpenAlign, verticalOffset) {
  var layout = gviz.canviz.textutils.calcTextLayout(chartDef.textMeasureFunction, tick.text, this.tickTextStyle, tickTextWidth, 1), lines = goog.array.map(layout.lines, function(line) {
    return{x:0, y:0, length:tickTextWidth, text:line};
  }, this);
  return{dataValue:tick.dataValue, isVisible:tick.isVisible, textBlock:{text:tick.text, textStyle:this.tickTextStyle, boxStyle:null, lines:lines, paralAlign:paralAlign, perpenAlign:perpenAlign, tooltip:layout.needTooltip ? tick.text : "", anchor:new gviz.math.Coordinate(x, tick.coordinate - verticalOffset), angle:0}};
};
gviz.canviz.VerticalAxisDefiner.prototype.getAxisDirectionalityParameters = function(chartDef) {
  var res = {};
  res.reversed = -1 == this.direction;
  res.screenStart = chartDef.chartArea.top;
  res.screenEnd = chartDef.chartArea.bottom;
  res.orientation = this.getOrientation();
  return res;
};
gviz.canviz.VerticalAxisDefiner.prototype.getOrientation = function() {
  return gviz.canviz.axis.AxisTools.Orientation.VERTICAL;
};
gviz.canviz.VerticalAxisDefiner.prototype.calcTicklinesOrigin = function(chartDef) {
  return 0 == this.index ? {coordinate:chartDef.chartArea.left, direction:1} : {coordinate:chartDef.chartArea.right, direction:-1};
};
// INPUT (javascript/gviz/devel/canviz/axis-chart-definer.js)
gviz.canviz.AxisChartDefiner = function(dataTable, options, textMeasureFunction, width, height) {
  this.bubbleChartDefiner_ = this.targetAxisSerieTypeCount_ = this.targetAxisIndices_ = this.targetAxisDefiners_ = this.domainAxisDefiner_ = this.vAxisDefiners_ = this.hAxisDefiners_ = this.colors_ = null;
  this.numOfSubDivisions_ = 1;
  this.subDivisionDefinition_ = null;
  gviz.canviz.ChartDefiner.call(this, dataTable, options, textMeasureFunction, width, height);
};
goog.inherits(gviz.canviz.AxisChartDefiner, gviz.canviz.ChartDefiner);
gviz.canviz.AxisChartDefiner.prototype.init = function() {
  var options = this.options, tooltipTrigger = options.inferOptionalEnumValue("tooltip.trigger", gviz.Options.TooltipTrigger);
  this.isTooltipEnabled_ = tooltipTrigger != gviz.Options.TooltipTrigger.NONE;
  this.chartDef.focusTarget = options.inferEnumValue("focusTarget", gviz.canviz.Options.FocusTarget, gviz.canviz.Options.FocusTarget.DATUM);
  if (this.chartDef.focusTarget == gviz.canviz.Options.FocusTarget.CATEGORY && this.chartDef.chartType != gviz.canviz.Options.ChartType.FUNCTION) {
    throw Error("Focus target " + this.chartDef.focusTarget + " is not supported for the chosen chart type.");
  }
  this.chartDef.isDiff = this.options.inferBooleanValue("isDiff");
  this.chartDef.chartType == gviz.canviz.Options.ChartType.BUBBLE ? this.bubbleChartDefiner_ = new gviz.canviz.BubbleChartDefiner(this.dataView, this.options, this.textMeasureFunction, this.chartDef) : (this.colors_ = options.inferValue("colors", gviz.canviz.Options.DEFAULT_DISCRETE_COLORS), this.createSeriesAndCategoriesDrawingData_());
  var serieType = gviz.canviz.Options.SerieType, hasBarsOrArea = 0 < this.chartDef.serieTypeCount[serieType.BARS] || 0 < this.chartDef.serieTypeCount[serieType.AREA] || 0 < this.chartDef.serieTypeCount[serieType.STEPPED_AREA];
  this.chartDef.isStacked = this.options.inferBooleanValue("isStacked") && hasBarsOrArea;
  this.chartDef.showRemoveSerieButton = this.options.inferBooleanValue("showRemoveSeriesButton", !1);
  this.createAxes_();
  gviz.canviz.AxisChartDefiner.superClass_.init.call(this);
};
gviz.canviz.AxisChartDefiner.prototype.createSeriesAndCategoriesDrawingData_ = function() {
  var chartDef = this.chartDef, dataView = this.dataView, serieTypeExtractor = chartDef.chartType == gviz.canviz.Options.ChartType.SCATTER ? function() {
    return gviz.canviz.Options.SerieType.SCATTER;
  } : chartDef.chartType === gviz.canviz.Options.ChartType.HISTOGRAM ? function() {
    return gviz.canviz.Options.SerieType.BARS;
  } : goog.bind(function(serieIndex) {
    return this.options.inferEnumValue("series." + serieIndex + ".type", gviz.canviz.Options.SerieType, chartDef.defaultSerieType);
  }, this), columnStructure = chartDef.isDiff ? gviz.canviz.AxisChartDefiner.inferSerieAndCategoryStructuresForDiffChart_(dataView, serieTypeExtractor, chartDef.chartType) : gviz.canviz.AxisChartDefiner.inferSerieAndCategoryStructures_(dataView, serieTypeExtractor);
  chartDef.categories = [];
  chartDef.dataTableToCategoryMap = {};
  for (var domainsColumnStructure = columnStructure.domainsColumnStructure, i = 0;i < dataView.getNumberOfRows();i++) {
    var dataTableIdx = dataView.getTableRowIndex(i), data = dataView.getValue(i, 0), titles = goog.array.map(domainsColumnStructure, function(domainColumnsStructure) {
      var columnIndex = domainColumnsStructure.columns[gviz.canviz.ColumnRole.DOMAIN][0], title = dataView.getFormattedValue(i, columnIndex) || "";
      return title;
    }), category = {data:data, titles:titles, dataTableIdx:dataTableIdx}, domain = domainsColumnStructure[0], tooltipColumnIndices = domain.columns[gviz.canviz.ColumnRole.TOOLTIP];
    if (tooltipColumnIndices) {
      goog.asserts.assert(1 == tooltipColumnIndices.length);
      var tooltipColumnIndex = tooltipColumnIndices[0];
      category.tooltipText = this.getCustomTooltipText_(tooltipColumnIndex, i);
    }
    chartDef.categories.push(category);
    chartDef.dataTableToCategoryMap[dataTableIdx] = i;
  }
  chartDef.series = [];
  for (i = 0;i < columnStructure.seriesColumnStructure.length;i++) {
    var serieStructure = columnStructure.seriesColumnStructure[i], serieDefinition = this.createSerieDefinition_(i, serieStructure);
    chartDef.series.push(serieDefinition);
    goog.object.isEmpty(dataView.getColumnProperties(i)) || (chartDef.series[i].properties = dataView.getColumnProperties(i));
  }
  chartDef.dataTableColumnRoleInfo = columnStructure.columnRoleInfo;
  chartDef.domainsColumnStructure = columnStructure.domainsColumnStructure;
  chartDef.domainDataType = columnStructure.domainDataType;
  chartDef.targetAxisToDataType = {};
  chartDef.serieTypeCount = {};
  this.targetAxisIndices_ = new goog.structs.Set;
  this.targetAxisSerieTypeCount_ = [];
  for (i = 0;i < chartDef.series.length;++i) {
    var serie = chartDef.series[i];
    this.targetAxisIndices_.add(serie.targetAxisIndex);
    var targetAxisType = chartDef.targetAxisToDataType[serie.targetAxisIndex];
    if (!goog.isDefAndNotNull(targetAxisType)) {
      chartDef.targetAxisToDataType[serie.targetAxisIndex] = serie.dataType;
    } else {
      if (targetAxisType != serie.dataType) {
        throw Error("All series on a given axis must be of the same data type");
      }
    }
    chartDef.serieTypeCount[serie.type] = (chartDef.serieTypeCount[serie.type] || 0) + 1;
    var axisSTC = this.targetAxisSerieTypeCount_[serie.targetAxisIndex] || {};
    this.targetAxisSerieTypeCount_[serie.targetAxisIndex] = axisSTC;
    axisSTC[serie.type] = (axisSTC[serie.type] || 0) + 1;
  }
};
gviz.canviz.AxisChartDefiner.prototype.initLegend_ = function() {
  var addedIndices = {}, chartDef = this.chartDef;
  chartDef.legendEntries = [];
  var addLegendEntry = goog.bind(function(serieIndex) {
    var serieDef = chartDef.series[serieIndex];
    if (chartDef.isDiff && serieDef.type === gviz.canviz.Options.ChartType.SCATTER) {
      var alpha = [this.options.inferValue("diff.oldData.opacity", gviz.canviz.Options.DEFAULT_DIFF_OLD_DATA_OPACITY), this.options.inferValue("diff.newData.opacity", gviz.canviz.Options.DEFAULT_DIFF_NEW_DATA_OPACITY)], color = serieDef.color.color;
      chartDef.legendEntries.push({id:serieDef.id, text:serieDef.labelInLegend, brush:new gviz.graphics.Brush({gradient:{color1:color, color2:color, opacity1:alpha[0], opacity2:alpha[1], x1:"100%", y1:"0%", x2:"0%", y2:"0%", useObjectBoundingBoxUnits:!0, sharpTransition:!0}}), index:serieIndex, isVisible:serieDef.visibleInLegend});
    } else {
      var brush = new gviz.graphics.Brush({fill:serieDef.color.color});
      serieDef.colorOpacity && brush.setFillOpacity(serieDef.colorOpacity);
      chartDef.legendEntries.push({id:serieDef.id, text:serieDef.labelInLegend, brush:brush, index:serieIndex, isVisible:serieDef.visibleInLegend});
    }
    addedIndices[serieIndex] = !0;
  }, this);
  goog.array.forEach(chartDef.series, function(serieDef, serieIndex) {
    addedIndices[serieIndex] || (addLegendEntry(serieIndex), goog.isDefAndNotNull(serieDef.trendlineIndex) && addLegendEntry(serieDef.trendlineIndex));
  }, this);
  if (chartDef.isDiff) {
    var serieType = chartDef.series[0].type;
    serieType === gviz.canviz.Options.SerieType.BARS && chartDef.legendEntries.push({id:-1, text:"Previous data", brush:new gviz.graphics.Brush({fill:gviz.canviz.Options.DEFAULT_DIFF_SERIES_BACKGROUND_COLOR.color}), index:-1, isVisible:!0});
  }
};
gviz.canviz.AxisChartDefiner.prototype.initTrendlines_ = function(data) {
  for (var baseTime = (new Date(1900, 0, 1, 0, 0, 0)).getTime(), dateTransformDomain = function(numericValue) {
    numericValue -= baseTime;
    return numericValue /= 864E5;
  }, dateUntransformDomain = function(numericValue) {
    numericValue *= 864E5;
    return numericValue += baseTime;
  }, scientificFormat = new gviz.i18n.NumberFormat("0.###E0"), numberFormat = new gviz.i18n.NumberFormat("#.###"), stringRenderer = new gviz.math.expression.renderer.StringRenderer(function(n) {
    return 0 !== n && (1E5 < Math.abs(n) || .01 > Math.abs(n)) ? scientificFormat.format(n) : numberFormat.format(n);
  }), chartDef = this.chartDef, trendlineSeriesType = chartDef.chartType == gviz.canviz.Options.ChartType.SCATTER ? gviz.canviz.Options.SerieType.SCATTER : gviz.canviz.Options.SerieType.LINE, trendlineCount = 0, isVertical = chartDef.orientation === gviz.canviz.Options.Orientation.VERTICAL, seriesCount = chartDef.series.length, i$$0 = 0;i$$0 < seriesCount;i$$0++) {
    var series = chartDef.series[i$$0], optionPrefix = "trendlines." + i$$0 + ".", trendlineExists = null != this.options.inferWholeObjectValue("trendlines." + i$$0);
    if (trendlineExists) {
      trendlineCount++;
      var trendlineType = this.options.inferEnumValue(optionPrefix + "type", gviz.canviz.trendlines.TrendlineType, gviz.canviz.Options.DEFAULT_TRENDLINE_TYPE), rawColor = this.options.inferValue(optionPrefix + "color", "<default>"), isDefaultColor = "<default>" === rawColor;
      isDefaultColor && (rawColor = series.pointBrush.getFill());
      var opacity = this.options.inferRatioNumberValue([optionPrefix + "opacity", "opacity"], isDefaultColor ? .5 : 1), pointSize = this.options.inferNonNegativeNumberValue([optionPrefix + "pointSize", "pointSize"], 0), visiblePoints = 0 < pointSize;
      0 >= pointSize && (pointSize = gviz.canviz.Options.DEFAULT_POINT_SIZE_FOR_LINE);
      var pointRadius = pointSize / 2;
      0 < pointRadius && (pointRadius += 1);
      var trendlineColumns = {};
      goog.isDefAndNotNull(series.columns[gviz.canviz.ColumnRole.DATA]) && (trendlineColumns[gviz.canviz.ColumnRole.DATA] = series.columns[gviz.canviz.ColumnRole.DATA]);
      var lineWidth = this.options.inferNonNegativeNumberValue([optionPrefix + "lineWidth", "lineWidth"], gviz.canviz.Options.DEFAULT_LINE_WIDTH);
      this.options.inferEnumValue(optionPrefix + "curveType", gviz.canviz.Options.CurveType, gviz.canviz.Options.CurveType.NONE);
      this.options.inferBooleanValue(optionPrefix + "visibleInLegend", !1);
      var color = gviz.canviz.Theme.toStandardColor(rawColor), trendlineGenerator = gviz.canviz.trendlines.Trendline[trendlineType], domainAxisDefiners = isVertical ? this.vAxisDefiners_ : this.hAxisDefiners_, targetAxisDefiners = isVertical ? this.hAxisDefiners_ : this.vAxisDefiners_, domainAxisDefiner = domainAxisDefiners[0], targetAxisDefiner = targetAxisDefiners[series.targetAxisIndex];
      if (domainAxisDefiner.type === gviz.canviz.Options.AxisType.VALUE) {
        var domainAxisValueScale = domainAxisDefiner.valueScale, targetAxisValueScale = targetAxisDefiner.valueScale, domainColumn = 0, dataColumn = series.columns[gviz.canviz.ColumnRole.DATA][0], transformDomain = goog.functions.identity, untransformDomain = goog.functions.identity, isDomainDateLike = 0 < data.getNumberOfRows() && goog.isDateLike(data.getValue(0, domainColumn));
        isDomainDateLike && (transformDomain = dateTransformDomain, untransformDomain = dateUntransformDomain);
        var range = {min:transformDomain(domainAxisValueScale.numericMinValue), max:transformDomain(domainAxisValueScale.numericMaxValue)}, trendlineDefinition = trendlineGenerator(data.getNumberOfRows(), function(i) {
          var value = data.getValue(i, 0), number = domainAxisValueScale.valueToUnscaledNumber(value);
          return transformDomain(number);
        }, function(i) {
          return targetAxisValueScale.valueToUnscaledNumber(data.getValue(i, dataColumn));
        }, {range:range, degree:this.options.inferNumberValue(optionPrefix + "degree", 3)});
        if (!goog.isNull(trendlineDefinition)) {
          var title = this.options.inferStringValue(optionPrefix + "title", stringRenderer.render(trendlineDefinition.equation.compose()) || "Trendline " + trendlineCount), trendlineData = goog.array.map(trendlineDefinition.data, function(row) {
            var domainNumber = untransformDomain(row[0]), domainValue = domainAxisValueScale.unscaledNumberToValue(domainNumber);
            return[domainValue, targetAxisValueScale.unscaledNumberToValue(row[1])];
          });
          series.trendlineIndex = chartDef.series.length;
          var lineBrush = gviz.graphics.Brush.createStrokeBrush(color.color, lineWidth);
          lineBrush.setStrokeOpacity(opacity);
          var pointBrush = gviz.graphics.Brush.createFillBrush(color.color);
          pointBrush.setFillOpacity(opacity);
          var labelInLegend = this.options.inferStringValue(optionPrefix + "labelInLegend", title);
          this.options.inferBooleanValue(optionPrefix + "showR2", !1) && (labelInLegend += "\n" + stringRenderer.render((new gviz.math.expression.Eq([new gviz.math.expression.Pow([new gviz.math.expression.Variable("r"), new gviz.math.expression.Number(2)]), new gviz.math.expression.Number(trendlineDefinition.r2)])).compose()));
          var showTooltip = !1 !== this.options.inferValue(optionPrefix + "tooltip");
          chartDef.series.push({id:series.id + "_trendline", title:title, isVirtual:!0, data:trendlineData, dataType:series.dataType, enableInteractivity:this.options.inferBooleanValue([optionPrefix + "enableInteractivity", "enableInteractivity"], !0), showTooltip:showTooltip, isVisible:!0, dataTableIdx:0, columns:trendlineColumns, originalSeries:i$$0, domainIndex:series.domainIndex, intervals:null, color:color, colorOpacity:opacity, pointBrush:pointBrush, lineBrush:lineBrush, areaBrush:null, candlestick:null, 
          type:trendlineSeriesType, zOrder:this.options.inferNumberValue(optionPrefix + "zOrder", 0), lineWidth:lineWidth, pointRadius:pointRadius, pointSensitivityAreaRadius:gviz.canviz.Options.DEFAULT_POINT_SENSITIVITY_AREA_RADIUS, curveType:this.options.inferEnumValue(optionPrefix + "curveType", gviz.canviz.Options.CurveType, gviz.canviz.Options.CurveType.NONE), smoothingFactor:this.options.inferNonNegativeNumberValue([optionPrefix + "smoothingFactor", "smoothingFactor"], 1), visiblePoints:visiblePoints, 
          points:[], controlPoints:[], targetAxisIndex:series.targetAxisIndex, visibleInLegend:this.options.inferBooleanValue(optionPrefix + "visibleInLegend", !1), labelInLegend:labelInLegend});
        }
      }
    }
  }
};
gviz.canviz.AxisChartDefiner.inferSerieAndCategoryStructures_ = function(data, serieTypeInferenceFunction) {
  for (var seriesColumnStructure = [], domainsColumnStructure = [], currentUpdatedDescription = null, currentIndex = null, remainingDataColumns = 0, columnRoleInfo = [], i = 0;i < data.getNumberOfColumns();++i) {
    var columnType = data.getColumnType(i), columnRole = data.getColumnProperty(i, "role") || (0 == i ? gviz.canviz.ColumnRole.DOMAIN : gviz.canviz.ColumnRole.DATA);
    if (0 == i && columnRole !== gviz.canviz.ColumnRole.DOMAIN) {
      throw Error("First column must be a " + gviz.canviz.ColumnRole.DOMAIN + " column");
    }
    if (columnRole == gviz.canviz.ColumnRole.DOMAIN) {
      if (0 < remainingDataColumns) {
        throw Error("Unexpected " + gviz.canviz.ColumnRole.DOMAIN + " column (column #" + i + ")");
      }
      currentUpdatedDescription = {columns:{}, dataType:columnType};
      currentIndex = {serieIndex:null, domainIndex:domainsColumnStructure.length};
      domainsColumnStructure.push(currentUpdatedDescription);
    }
    if (0 == remainingDataColumns && columnRole === gviz.canviz.ColumnRole.DATA) {
      var newSerieIndex = seriesColumnStructure.length, serieType = serieTypeInferenceFunction(newSerieIndex), currentUpdatedDescription = {type:serieType, dataType:columnType, columns:{}}, currentIndex = {serieIndex:newSerieIndex, domainIndex:null};
      seriesColumnStructure.push(currentUpdatedDescription);
      remainingDataColumns = serieType === gviz.canviz.Options.SerieType.CANDLESTICKS ? 4 : 1;
    }
    if (columnRole === gviz.canviz.ColumnRole.DATA && (remainingDataColumns--, columnType !== currentUpdatedDescription.dataType)) {
      throw Error("All data columns of the same series must be of the same data type");
    }
    if (columnRole === gviz.canviz.ColumnRole.TOOLTIP && currentUpdatedDescription.columns[columnRole]) {
      throw Error("Only one data column with role 'tooltip' per series is allowed");
    }
    currentUpdatedDescription.columns[columnRole] = currentUpdatedDescription.columns[columnRole] || [];
    columnRoleInfo.push({serieIndex:currentIndex.serieIndex, domainIndex:currentIndex.domainIndex, role:columnRole, roleIndex:currentUpdatedDescription.columns[columnRole].length});
    currentUpdatedDescription.columns[columnRole].push(i);
  }
  if (0 < remainingDataColumns) {
    throw Error("Last domain does not have enough data columns (missing " + remainingDataColumns + ")");
  }
  for (var currentDomain = 0, domainDataType = domainsColumnStructure[0].dataType, i = 0;i < seriesColumnStructure.length;++i) {
    if (domainsColumnStructure.length <= currentDomain) {
      throw Error("Series #" + i + " does not have a " + gviz.canviz.ColumnRole.DOMAIN + " column.");
    }
    var nextColumnStructure = domainsColumnStructure[currentDomain + 1], dataColumns = seriesColumnStructure[i].columns[gviz.canviz.ColumnRole.DATA];
    if (nextColumnStructure && nextColumnStructure.columns[gviz.canviz.ColumnRole.DOMAIN][0] <= dataColumns[0] && (++currentDomain, domainDataType !== domainsColumnStructure[currentDomain].dataType)) {
      throw Error("All domains must be of the same data type");
    }
    seriesColumnStructure[i].domainIndex = currentDomain;
  }
  return{seriesColumnStructure:seriesColumnStructure, domainsColumnStructure:domainsColumnStructure, domainDataType:domainDataType, columnRoleInfo:columnRoleInfo};
};
gviz.canviz.AxisChartDefiner.validateColumnDataType_ = function(expectedColumnType, columnType) {
  if (expectedColumnType !== columnType) {
    throw Error("Column types must be consistent: equal for domain columns and for columns in the same serie.");
  }
};
gviz.canviz.AxisChartDefiner.inferSerieAndCategoryStructuresForDiffChart_ = function(data, serieTypeInferenceFunction, chartType) {
  var seriesColumnStructure = [], domainsColumnStructure = [], domainDataType = null, columnRoleInfo = [];
  if (chartType === gviz.canviz.Options.ChartType.SCATTER) {
    var numberOfDataColumns = data.getNumberOfColumns(), numberOfSeries = numberOfDataColumns - 2, validateColumnRole = function(columnRole) {
      if (columnRole !== gviz.canviz.ColumnRole.DATA && columnRole !== gviz.canviz.ColumnRole.DIFF_OLD_DATA) {
        throw Error("All columns must be either " + gviz.canviz.ColumnRole.DATA + " or " + gviz.canviz.ColumnRole.DIFF_OLD_DATA + " columns");
      }
    }, domainColumns = {};
    domainColumns[gviz.canviz.ColumnRole.DATA] = null;
    domainColumns[gviz.canviz.ColumnRole.DIFF_OLD_DATA] = null;
    for (var domainDataType = data.getColumnType(0), i = 0;2 > i;++i) {
      var columnType = data.getColumnType(i), columnRole$$0 = data.getColumnProperty(i, "role");
      validateColumnRole(columnRole$$0);
      gviz.canviz.AxisChartDefiner.validateColumnDataType_(domainDataType, columnType);
      var domainColumnStructure = {columns:{}, dataType:columnType};
      domainColumnStructure.columns[gviz.canviz.ColumnRole.DOMAIN] = [i];
      domainsColumnStructure.push(domainColumnStructure);
      domainColumns[columnRole$$0] = i;
      columnRoleInfo.push({domainIndex:i, role:gviz.canviz.ColumnRole.DOMAIN, roleIndex:0, serieIndex:null});
    }
    for (var serieIndex = 0;serieIndex < numberOfSeries;++serieIndex) {
      var columnIndex = 2 + serieIndex, columnType = data.getColumnType(serieIndex), columnRole$$0 = data.getColumnProperty(serieIndex, "role");
      validateColumnRole(columnRole$$0);
      if (serieIndex % 2) {
        var previousSerieDataType = seriesColumnStructure[serieIndex - 1].dataType;
        gviz.canviz.AxisChartDefiner.validateColumnDataType_(previousSerieDataType, columnType);
      }
      var domainColumnIndex = domainColumns[columnRole$$0], serieColumnStructure = {type:serieTypeInferenceFunction(serieIndex), dataType:columnType, domainIndex:domainColumnIndex, columns:{}};
      serieColumnStructure.columns[columnRole$$0] = [columnIndex];
      seriesColumnStructure.push(serieColumnStructure);
      columnRoleInfo.push({domainIndex:domainColumnIndex, role:columnRole$$0, roleIndex:0, serieIndex:serieIndex});
    }
  } else {
    if (chartType === gviz.canviz.Options.ChartType.FUNCTION) {
      for (var currentUpdatedDescription = null, currentIndex = null, remainingDataColumns = 0, i = 0;i < data.getNumberOfColumns();++i) {
        columnType = data.getColumnType(i);
        columnRole$$0 = data.getColumnProperty(i, "role") || (0 === i ? gviz.canviz.ColumnRole.DOMAIN : gviz.canviz.ColumnRole.DATA);
        if (0 === i && columnRole$$0 !== gviz.canviz.ColumnRole.DOMAIN) {
          throw Error("First column must be a " + gviz.canviz.ColumnRole.DOMAIN + " column");
        }
        if (columnRole$$0 === gviz.canviz.ColumnRole.DOMAIN) {
          if (0 < remainingDataColumns) {
            throw Error("Unexpected " + gviz.canviz.ColumnRole.DOMAIN + " column (column #" + i + ")");
          }
          currentUpdatedDescription = {columns:{}, dataType:columnType};
          currentIndex = {serieIndex:null, domainIndex:domainsColumnStructure.length};
          domainsColumnStructure.push(currentUpdatedDescription);
        }
        if (0 === remainingDataColumns && (columnRole$$0 === gviz.canviz.ColumnRole.DATA || columnRole$$0 === gviz.canviz.ColumnRole.DIFF_OLD_DATA)) {
          var newSerieIndex = seriesColumnStructure.length, serieType = serieTypeInferenceFunction(newSerieIndex), currentUpdatedDescription = {type:serieType, dataType:columnType, columns:{}}, currentIndex = {serieIndex:newSerieIndex, domainIndex:null};
          seriesColumnStructure.push(currentUpdatedDescription);
          remainingDataColumns = serieType === gviz.canviz.Options.SerieType.CANDLESTICKS ? 4 : columnRole$$0 === gviz.canviz.ColumnRole.DIFF_OLD_DATA ? 2 : 1;
        }
        if (columnRole$$0 === gviz.canviz.ColumnRole.DATA || columnRole$$0 === gviz.canviz.ColumnRole.DIFF_OLD_DATA) {
          if (remainingDataColumns--, columnType !== currentUpdatedDescription.dataType) {
            throw Error("All data columns of the same series must be of the same data type");
          }
        }
        if (columnRole$$0 === gviz.canviz.ColumnRole.TOOLTIP && currentUpdatedDescription.columns[columnRole$$0]) {
          throw Error("Only one data column with role 'tooltip' per series is allowed");
        }
        currentUpdatedDescription.columns[columnRole$$0] = currentUpdatedDescription.columns[columnRole$$0] || [];
        columnRoleInfo.push({serieIndex:currentIndex.serieIndex, domainIndex:currentIndex.domainIndex, role:columnRole$$0, roleIndex:currentUpdatedDescription.columns[columnRole$$0].length});
        currentUpdatedDescription.columns[columnRole$$0].push(i);
      }
      if (0 < remainingDataColumns) {
        throw Error("Last domain does not have enough data columns (missing " + remainingDataColumns + ")");
      }
      for (var currentDomain = 0, domainDataType = domainsColumnStructure[0].dataType, i = 0;i < seriesColumnStructure.length;++i) {
        if (domainsColumnStructure.length <= currentDomain) {
          throw Error("Series #" + i + " does not have a " + gviz.canviz.ColumnRole.DOMAIN + " column.");
        }
        var nextColumnStructure = domainsColumnStructure[currentDomain + 1], dataColumns = seriesColumnStructure[i].columns[gviz.canviz.ColumnRole.DIFF_OLD_DATA] || seriesColumnStructure[i].columns[gviz.canviz.ColumnRole.DATA];
        if (nextColumnStructure && nextColumnStructure.columns[gviz.canviz.ColumnRole.DOMAIN][0] <= dataColumns[0] && (++currentDomain, domainDataType !== domainsColumnStructure[currentDomain].dataType)) {
          throw Error("All domains must be of the same data type");
        }
        seriesColumnStructure[i].domainIndex = currentDomain;
      }
    }
  }
  return{seriesColumnStructure:seriesColumnStructure, domainsColumnStructure:domainsColumnStructure, domainDataType:domainDataType, columnRoleInfo:columnRoleInfo};
};
gviz.canviz.AxisChartDefiner.prototype.serieHasOldData_ = function(serieStructure) {
  var oldDataColumns = serieStructure.columns[gviz.canviz.ColumnRole.DIFF_OLD_DATA];
  return goog.isDefAndNotNull(oldDataColumns) && 0 < oldDataColumns.length;
};
gviz.canviz.AxisChartDefiner.prototype.createSerieDefinition_ = function(serieIndex, serieStructure) {
  var serieType = serieStructure.type, columns = serieStructure.columns, domainIndex = serieStructure.domainIndex, options = this.options, optionPrefix = "series." + serieIndex + ".", dataColumns = columns[gviz.canviz.ColumnRole.DATA] || columns[gviz.canviz.ColumnRole.DIFF_OLD_DATA], dataTableIdx = this.dataView.getTableColumnIndex(dataColumns[0]), title = this.dataView.getColumnLabel(dataColumns[0]) || "", defaultLineWidth = serieType == gviz.canviz.Options.SerieType.SCATTER ? 0 : gviz.canviz.Options.DEFAULT_LINE_WIDTH, 
  defaultPointSize = serieType == gviz.canviz.Options.SerieType.SCATTER ? gviz.canviz.Options.DEFAULT_POINT_SIZE_FOR_SCATTER : 0, pointSize = options.inferNonNegativeNumberValue([optionPrefix + "pointSize", "pointSize"], defaultPointSize), visiblePoints = serieType == gviz.canviz.Options.SerieType.LINE || serieType == gviz.canviz.Options.SerieType.AREA || serieType == gviz.canviz.Options.SerieType.SCATTER ? 0 < pointSize : !0;
  0 == pointSize && (pointSize = serieType == gviz.canviz.Options.SerieType.SCATTER ? gviz.canviz.Options.DEFAULT_POINT_SIZE_FOR_SCATTER : gviz.canviz.Options.DEFAULT_POINT_SIZE_FOR_LINE);
  var pointRadius = pointSize / 2;
  0 < pointRadius && (pointRadius += 1);
  var serieColorIndex;
  serieColorIndex = this.chartDef.isDiff && serieType == gviz.canviz.Options.SerieType.SCATTER ? Math.floor(serieIndex / 2) : serieIndex;
  var rawColor = options.inferValue(optionPrefix + "color", this.colors_[serieColorIndex % this.colors_.length]), color = gviz.canviz.Theme.toStandardColor(rawColor), areaBrush = null;
  if (serieType == gviz.canviz.Options.SerieType.AREA || serieType == gviz.canviz.Options.SerieType.STEPPED_AREA) {
    var areaOpacity = options.inferRatioNumberValue([optionPrefix + "areaOpacity", "areaOpacity"]), areaBrush = gviz.graphics.Brush.createFillBrush(color.color, areaOpacity)
  }
  var candlestick = null;
  if (serieType == gviz.canviz.Options.SerieType.CANDLESTICKS) {
    var filledBrush = new gviz.graphics.Brush({stroke:color.color, strokeWidth:2, fill:color.color}), hollowBrush = new gviz.graphics.Brush({stroke:color.color, strokeWidth:2, fill:"#fff"}), hollowIsRising = options.inferBooleanValue("candlestick.hollowIsRising"), defaultRisingBrush = hollowIsRising ? hollowBrush : filledBrush, defaultFallingBrush = hollowIsRising ? filledBrush : hollowBrush, candlestick = {risingBrush:options.inferBrushValue([optionPrefix + "candlestick.risingColor", "candlestick.risingColor"], 
    defaultRisingBrush), fallingBrush:options.inferBrushValue([optionPrefix + "candlestick.fallingColor", "candlestick.fallingColor"], defaultFallingBrush)}
  }
  var lineWidth = options.inferNonNegativeNumberValue([optionPrefix + "lineWidth", "lineWidth"], defaultLineWidth), lineBrush = gviz.graphics.Brush.createStrokeBrush(color.color, lineWidth), lineDashStyle = options.inferOptionalNumberArrayValue([optionPrefix + "lineDashStyle", "lineDashStyle"]);
  lineDashStyle && lineBrush.setStrokeDashStyle(lineDashStyle);
  var dataOpacity = options.inferNonNegativeNumberValue([optionPrefix + "dataOpacity", "dataOpacity"], 1), pointShape = null;
  if (serieType === gviz.canviz.Options.SerieType.SCATTER || serieType === gviz.canviz.Options.SerieType.LINE || serieType === gviz.canviz.Options.SerieType.AREA) {
    pointShape = options.inferWholeObjectValue([optionPrefix + "pointShape", "pointShape"], {type:"circle"}), goog.isString(pointShape) && (pointShape = {type:pointShape});
  }
  var visibleInLegend = null;
  if (this.chartDef.isDiff && serieType === gviz.canviz.Options.SerieType.SCATTER) {
    var isOldDataSerie = this.serieHasOldData_(serieStructure), dataOpacity = isOldDataSerie ? this.options.inferValue("diff.oldData.opacity", gviz.canviz.Options.DEFAULT_DIFF_OLD_DATA_OPACITY) : this.options.inferValue("diff.newData.opacity", gviz.canviz.Options.DEFAULT_DIFF_NEW_DATA_OPACITY);
    isOldDataSerie && (visibleInLegend = !1);
  }
  var pointBrush = serieType == gviz.canviz.Options.SerieType.STEPPED_AREA ? areaBrush : gviz.graphics.Brush.createFillBrush(color.color, dataOpacity);
  if (this.chartDef.isDiff) {
    if (serieType === gviz.canviz.Options.SerieType.BARS) {
      var diffBgRawColor = options.inferValue("diff.oldData.color", gviz.canviz.Options.DEFAULT_DIFF_SERIES_BACKGROUND_COLOR), diffBgColor = gviz.canviz.Theme.toStandardColor(diffBgRawColor), diff = {background:{pointBrush:gviz.graphics.Brush.createFillBrush(diffBgColor.color, dataOpacity)}}
    } else {
      serieType === gviz.canviz.Options.SerieType.SCATTER && this.serieHasOldData_(serieStructure) && (visiblePoints = !1);
    }
  }
  var intervals = this.getIntervalDefinitions_(columns, options, optionPrefix, color);
  return{id:this.dataView.getColumnId(dataColumns[0]), title:title, dataType:serieStructure.dataType, isVisible:!0, showTooltip:!0, dataTableIdx:dataTableIdx, columns:columns, domainIndex:domainIndex, enableInteractivity:options.inferBooleanValue([optionPrefix + "enableInteractivity", "enableInteractivity"], !0), intervals:intervals, color:color, colorOpacity:dataOpacity, pointBrush:pointBrush, lineBrush:lineBrush, pointShape:pointShape, diff:diff, areaBrush:areaBrush, candlestick:candlestick, type:serieType, 
  zOrder:options.inferNumberValue(optionPrefix + "zOrder", 0), lineWidth:lineWidth, pointRadius:pointRadius, pointSensitivityAreaRadius:gviz.canviz.Options.DEFAULT_POINT_SENSITIVITY_AREA_RADIUS, curveType:options.inferEnumValue([optionPrefix + "curveType", "curveType"], gviz.canviz.Options.CurveType, gviz.canviz.Options.CurveType.NONE), smoothingFactor:options.inferNonNegativeNumberValue([optionPrefix + "smoothingFactor", "smoothingFactor"], 1), visiblePoints:visiblePoints, points:[], controlPoints:[], 
  targetAxisIndex:options.inferNonNegativeNumberValue([optionPrefix + "targetAxisIndex", "targetAxisIndex"], 0), visibleInLegend:goog.isDefAndNotNull(visibleInLegend) ? visibleInLegend : options.inferBooleanValue(optionPrefix + "visibleInLegend", !0), labelInLegend:options.inferStringValue(optionPrefix + "labelInLegend", title)};
};
gviz.canviz.AxisChartDefiner.prototype.getIntervalDefinitions_ = function(columns, options, optionPrefix, color) {
  var intervalColumns = columns[gviz.canviz.ColumnRole.INTERVAL];
  if (!intervalColumns) {
    return null;
  }
  for (var intervals = {bars:[], sticks:[], boxes:[], points:[], areas:[], lines:[], settings:{}}, columnsOfInterval = {}, optionNamesOfIntervalOption = function(intervalName, optionName) {
    return[optionPrefix + "interval." + intervalName + "." + optionName, optionPrefix + "intervals." + optionName, "interval." + intervalName + "." + optionName, "intervals." + optionName];
  }, optionNamesOfIntervalOrGlobalOption = function(intervalName, optionName) {
    var names = optionNamesOfIntervalOption(intervalName, optionName);
    return names.concat([optionPrefix + optionName, optionName]);
  }, i = 0;i < intervalColumns.length;i++) {
    var columnIndex = intervalColumns[i], intervalName = this.dataView.getColumnId(columnIndex) || this.dataView.getColumnLabel(columnIndex) || "default", intervalStyle = options.inferOptionalEnumValue(optionNamesOfIntervalOption(intervalName, "style"), gviz.canviz.Options.IntervalStyle);
    switch(intervalStyle) {
      case gviz.canviz.Options.IntervalStyle.BARS:
        intervals.bars.push(columnIndex);
        break;
      case gviz.canviz.Options.IntervalStyle.STICKS:
        intervals.sticks.push(columnIndex);
        break;
      case gviz.canviz.Options.IntervalStyle.BOXES:
        intervals.boxes.push(columnIndex);
        break;
      case gviz.canviz.Options.IntervalStyle.POINTS:
        intervals.points.push(columnIndex);
        break;
      case gviz.canviz.Options.IntervalStyle.AREA:
        intervals.areas.push(columnIndex);
        break;
      case gviz.canviz.Options.IntervalStyle.LINE:
        intervals.lines.push(columnIndex);
        break;
      case gviz.canviz.Options.IntervalStyle.NONE:
        break;
      default:
        throw Error("Invalid interval style: " + intervalStyle);;
    }
    intervalName in columnsOfInterval ? columnsOfInterval[intervalName].push(columnIndex) : columnsOfInterval[intervalName] = [columnIndex];
  }
  1 < intervals.bars.length && 0 == intervals.sticks.length && (intervals.sticks = [intervals.bars[0], intervals.bars[intervals.bars.length - 1]]);
  if (0 != intervals.sticks.length % 2) {
    throw Error("Stick-intervals must be defined by an even number of columns");
  }
  if (0 != intervals.areas.length % 2) {
    throw Error("Area-intervals must be defined by an even number of columns");
  }
  for (intervalName in columnsOfInterval) {
    for (var intervalLineWidth = options.inferNonNegativeNumberValue(optionNamesOfIntervalOption(intervalName, "lineWidth")), intervalFillOpacity = options.inferRatioNumberValue(optionNamesOfIntervalOption(intervalName, "fillOpacity")), intervalColor = options.inferExtendedColorValue(optionNamesOfIntervalOption(intervalName, "color"), goog.object.getValues(gviz.canviz.Options.SeriesRelativeColor), ""), intervalColor = gviz.canviz.AxisChartDefiner.resolveSerieRelativeColor_(intervalColor, color), 
    intervalBrush = new gviz.graphics.Brush({stroke:intervalColor, fill:intervalColor, fillOpacity:intervalFillOpacity, strokeWidth:intervalLineWidth}), intervalBarWidth = options.inferNonNegativeNumberValue(optionNamesOfIntervalOption(intervalName, "barWidth")), intervalShortBarWidth = options.inferNonNegativeNumberValue(optionNamesOfIntervalOption(intervalName, "shortBarWidth")), intervalBoxWidth = options.inferNonNegativeNumberValue(optionNamesOfIntervalOption(intervalName, "boxWidth")), intervalPointSize = 
    options.inferNonNegativeNumberValue(optionNamesOfIntervalOption(intervalName, "pointSize")), intervalStyle = options.inferOptionalEnumValue(optionNamesOfIntervalOption(intervalName, "style"), gviz.canviz.Options.IntervalStyle), interpolateNulls = options.inferBooleanValue(optionNamesOfIntervalOrGlobalOption(intervalName, "interpolateNulls")), curveType = options.inferEnumValue(optionNamesOfIntervalOrGlobalOption(intervalName, "curveType"), gviz.canviz.Options.CurveType, gviz.canviz.Options.CurveType.NONE), 
    smoothingFactor = options.inferNonNegativeNumberValue(optionNamesOfIntervalOrGlobalOption(intervalName, "smoothingFactor"), 1), intervalSettings = {style:intervalStyle, brush:intervalBrush, barWidth:intervalBarWidth, shortBarWidth:intervalShortBarWidth, boxWidth:intervalBoxWidth, pointSize:intervalPointSize, interpolateNulls:interpolateNulls, curveType:curveType, smoothingFactor:smoothingFactor}, columnIndices = columnsOfInterval[intervalName], i = 0;i < columnIndices.length;++i) {
      columnIndex = columnIndices[i], intervals.settings[columnIndex] = intervalSettings;
    }
  }
  return intervals;
};
gviz.canviz.AxisChartDefiner.prototype.createAxes_ = function() {
  var chartDef = this.chartDef;
  switch(chartDef.chartType) {
    case gviz.canviz.Options.ChartType.FUNCTION:
    ;
    case gviz.canviz.Options.ChartType.HISTOGRAM:
      chartDef.orientation = this.options.inferEnumValue("orientation", gviz.canviz.Options.Orientation, "");
      if (!chartDef.orientation) {
        throw Error("Unspecified orientation.");
      }
      this.targetAxisDefiners_ = {};
      this.hAxisDefiners_ = {};
      this.vAxisDefiners_ = {};
      var targetAxisCtor, targetAxisChartDefField, domainAxisCtor, domainAxisChartDefField;
      switch(chartDef.orientation) {
        case gviz.canviz.Options.Orientation.HORIZONTAL:
          domainAxisCtor = gviz.canviz.HorizontalAxisDefiner;
          domainAxisChartDefField = this.hAxisDefiners_;
          targetAxisCtor = gviz.canviz.VerticalAxisDefiner;
          targetAxisChartDefField = this.vAxisDefiners_;
          break;
        case gviz.canviz.Options.Orientation.VERTICAL:
          domainAxisCtor = gviz.canviz.VerticalAxisDefiner, domainAxisChartDefField = this.vAxisDefiners_, targetAxisCtor = gviz.canviz.HorizontalAxisDefiner, targetAxisChartDefField = this.hAxisDefiners_;
      }
      for (var targetAxisIndices = this.targetAxisIndices_.getValues(), i = 0;i < targetAxisIndices.length;++i) {
        var targetAxisIndex = targetAxisIndices[i], targetAxisDefiner = new targetAxisCtor(chartDef, this.options, ["targetAxes." + targetAxisIndex, "targetAxis"], targetAxisIndex, gviz.canviz.Options.AxisType.VALUE, gviz.canviz.Options.ViewWindowMode.PRETTY);
        if (targetAxisDefiner.type != gviz.canviz.Options.AxisType.VALUE) {
          throw Error("Target-axis must be of type " + gviz.canviz.Options.AxisType.VALUE);
        }
        this.targetAxisDefiners_[targetAxisIndex] = targetAxisDefiner;
        targetAxisChartDefField[targetAxisIndex] = targetAxisDefiner;
      }
      var explicitTicks;
      chartDef.chartType === gviz.canviz.Options.ChartType.HISTOGRAM && (explicitTicks = chartDef.series[0].properties.histogramBuckets);
      this.domainAxisDefiner_ = new domainAxisCtor(chartDef, this.options, ["domainAxis"], 0, this.getDefaultDomainAxisType_(), gviz.canviz.Options.ViewWindowMode.MAXIMIZED, explicitTicks);
      domainAxisChartDefField[0] = this.domainAxisDefiner_;
      break;
    case gviz.canviz.Options.ChartType.SCATTER:
    ;
    case gviz.canviz.Options.ChartType.BUBBLE:
      this.hAxisDefiners_ = {0:new gviz.canviz.HorizontalAxisDefiner(chartDef, this.options, [], 0, gviz.canviz.Options.AxisType.VALUE, gviz.canviz.Options.ViewWindowMode.PRETTY)}, this.vAxisDefiners_ = {0:new gviz.canviz.VerticalAxisDefiner(chartDef, this.options, [], 0, gviz.canviz.Options.AxisType.VALUE, gviz.canviz.Options.ViewWindowMode.PRETTY)};
  }
  this.initScales_();
};
gviz.canviz.AxisChartDefiner.prototype.getDefaultDomainAxisType_ = function() {
  if ("string" == this.dataView.getColumnType(0)) {
    var dominantSerieType = this.findDominantSerieType_();
    return this.getRecommendedDomainAxisTypeForSerieType_(dominantSerieType);
  }
  return gviz.canviz.Options.AxisType.VALUE;
};
gviz.canviz.AxisChartDefiner.prototype.findDominantSerieType_ = function() {
  var serieTypeHierarchy = [gviz.canviz.Options.SerieType.LINE, gviz.canviz.Options.SerieType.AREA, gviz.canviz.Options.SerieType.STEPPED_AREA, gviz.canviz.Options.SerieType.BARS, gviz.canviz.Options.SerieType.CANDLESTICKS], serieTypePriorities = {};
  goog.array.forEach(serieTypeHierarchy, function(serieType, i) {
    serieTypePriorities[serieType] = i;
  });
  var highest = goog.array.reduce(this.chartDef.series, function(highest, serie) {
    return Math.max(highest, serieTypePriorities[serie.type]);
  }, 0);
  return serieTypeHierarchy[highest];
};
gviz.canviz.AxisChartDefiner.prototype.getRecommendedDomainAxisTypeForSerieType_ = function(serieType) {
  switch(serieType) {
    case gviz.canviz.Options.SerieType.AREA:
      return 1 < this.chartDef.categories.length ? gviz.canviz.Options.AxisType.CATEGORY_POINT : gviz.canviz.Options.AxisType.CATEGORY;
    case gviz.canviz.Options.SerieType.LINE:
    ;
    case gviz.canviz.Options.SerieType.BARS:
    ;
    case gviz.canviz.Options.SerieType.STEPPED_AREA:
    ;
    case gviz.canviz.Options.SerieType.CANDLESTICKS:
      return gviz.canviz.Options.AxisType.CATEGORY;
  }
  goog.asserts.fail('Invalid serie type "' + serieType + '"');
  return null;
};
gviz.canviz.AxisChartDefiner.prototype.initScales_ = function() {
  var chartDef = this.chartDef;
  switch(chartDef.chartType) {
    case gviz.canviz.Options.ChartType.SCATTER:
    ;
    case gviz.canviz.Options.ChartType.BUBBLE:
      if ("string" == chartDef.domainDataType) {
        throw Error("X values column cannot be of type string");
      }
      var targetDataType = chartDef.targetAxisToDataType[0];
      if ("string" == targetDataType) {
        throw Error("Data column(s) cannot be of type string");
      }
      var hAxis = this.hAxisDefiners_[0], vAxis = this.vAxisDefiners_[0];
      if (hAxis.type != gviz.canviz.Options.AxisType.VALUE) {
        throw Error("The x-axis must be of type " + gviz.canviz.Options.AxisType.VALUE);
      }
      hAxis.initScale(chartDef.domainDataType, this.options);
      if (vAxis.type != gviz.canviz.Options.AxisType.VALUE) {
        throw Error("The y-axis must be of type " + gviz.canviz.Options.AxisType.VALUE);
      }
      vAxis.initScale(targetDataType, this.options);
      break;
    case gviz.canviz.Options.ChartType.FUNCTION:
    ;
    case gviz.canviz.Options.ChartType.HISTOGRAM:
      var domainAxis = this.domainAxisDefiner_;
      if (domainAxis.type == gviz.canviz.Options.AxisType.VALUE) {
        if ("string" == chartDef.domainDataType) {
          throw Error("Domain column cannot be of type string, it should be the X values on a continuous domain axis");
        }
        domainAxis.initScale(chartDef.domainDataType, this.options);
      }
      goog.object.forEach(this.targetAxisDefiners_, function(axisDefiner, idx) {
        var dataType = chartDef.targetAxisToDataType[idx];
        if ("string" == dataType) {
          throw Error("Data column(s) for axis #" + idx + " cannot be of type string");
        }
        axisDefiner.initScale(dataType, this.options);
        var axisSTC = this.targetAxisSerieTypeCount_[idx], serieType = gviz.canviz.Options.SerieType;
        goog.isNull(axisDefiner.userBaseline) && (0 < axisSTC[serieType.BARS] || 0 < axisSTC[serieType.AREA] || 0 < axisSTC[serieType.STEPPED_AREA]) && (axisDefiner.userBaseline = 0);
      }, this);
  }
  goog.object.forEach(this.hAxisDefiners_, function(axisDefiner) {
    axisDefiner.validateHasScale();
  });
  goog.object.forEach(this.vAxisDefiners_, function(axisDefiner) {
    axisDefiner.validateHasScale();
  });
};
gviz.canviz.AxisChartDefiner.prototype.calcGaps_ = function() {
  var chartDef = this.chartDef, domainAxis = this.domainAxisDefiner_;
  goog.asserts.assert(chartDef.chartType == gviz.canviz.Options.ChartType.FUNCTION || chartDef.chartType == gviz.canviz.Options.ChartType.HISTOGRAM);
  goog.asserts.assert(domainAxis.type == gviz.canviz.Options.AxisType.VALUE);
  if (goog.isNull(this.findGapColumn_())) {
    return[];
  }
  var domainRelatedColumns = chartDef.domainsColumnStructure[0].columns, domainColumns = domainRelatedColumns[gviz.canviz.ColumnRole.DOMAIN] || [];
  goog.asserts.assert(!goog.array.isEmpty(domainColumns));
  for (var domainColumn = domainColumns[0], gaps = [], prevDomainValue = null, dataView = this.dataView, i = 0;i < dataView.getNumberOfRows();i++) {
    var domainValue = dataView.getValue(i, domainColumn), gapValue = this.calcGap_(i);
    if (!goog.isNull(prevDomainValue) && goog.isDefAndNotNull(gapValue)) {
      if (0 > gapValue) {
        throw Error("Invalid gap value (" + gapValue + ") in data row #" + i + ". Gap value must be non-negative.");
      }
      var gap = {startValue:prevDomainValue, endValue:domainValue, gapValue:gapValue};
      gaps.push(gap);
    }
    prevDomainValue = domainValue;
  }
  return gaps;
};
gviz.canviz.AxisChartDefiner.prototype.hasLeftAxis_ = function() {
  return goog.isDefAndNotNull(this.vAxisDefiners_[0]);
};
gviz.canviz.AxisChartDefiner.prototype.hasRightAxis_ = function() {
  return goog.isDefAndNotNull(this.vAxisDefiners_[1]);
};
gviz.canviz.AxisChartDefiner.prototype.getDefaultLegendPosition = function() {
  return this.bubbleChartDefiner_ && this.bubbleChartDefiner_.isContinuousColorMode() ? null : this.hasLeftAxis_() && this.hasRightAxis_() ? gviz.canviz.Options.LegendPosition.TOP : this.hasRightAxis_() ? gviz.canviz.Options.LegendPosition.LEFT : gviz.canviz.Options.LegendPosition.RIGHT;
};
gviz.canviz.AxisChartDefiner.prototype.getDefaultColorBarPosition = function() {
  return this.bubbleChartDefiner_ && this.bubbleChartDefiner_.isContinuousColorMode() ? gviz.canviz.Options.ColorBarPosition.TOP : null;
};
gviz.canviz.AxisChartDefiner.prototype.getFirstDataColumnIndex_ = function(serie) {
  var dataColumns = serie.columns[gviz.canviz.ColumnRole.DATA];
  if (dataColumns) {
    return dataColumns[0];
  }
  var oldDataColumns = serie.columns[gviz.canviz.ColumnRole.DIFF_OLD_DATA];
  goog.asserts.assert(oldDataColumns && 0 < oldDataColumns.length);
  return oldDataColumns[0];
};
gviz.canviz.AxisChartDefiner.prototype.findValuesClosestToZeroFunctionChart_ = function() {
  for (var chartDef = this.chartDef, dataView = this.dataView, domainAxis = this.domainAxisDefiner_, i = 0;i < chartDef.categories.length;i++) {
    for (var j = 0;j < chartDef.series.length;j++) {
      var serie = chartDef.series[j], targetAxisIndex = serie.targetAxisIndex, targetAxis = this.targetAxisDefiners_[targetAxisIndex], columnIdx = this.getFirstDataColumnIndex_(serie), targetValue = dataView.getValue(i, columnIdx), numericTargetValue = targetAxis.valueScale.valueToUnscaledNumber(targetValue);
      goog.isDefAndNotNull(numericTargetValue) && targetAxis.markClosestValueToZero(numericTargetValue);
    }
    if (domainAxis.type == gviz.canviz.Options.AxisType.VALUE) {
      var domainValue = dataView.getValue(i, 0), numericDomainValue = domainAxis.valueScale.valueToUnscaledNumber(domainValue);
      domainAxis.markClosestValueToZero(numericDomainValue);
    }
  }
};
gviz.canviz.AxisChartDefiner.prototype.findValuesClosestToZeroScatter_ = function() {
  for (var chartDef = this.chartDef, dataView = this.dataView, hAxis = this.hAxisDefiners_[0], vAxis = this.vAxisDefiners_[0], i = 0;i < dataView.getNumberOfRows();i++) {
    for (var j = 0;j < chartDef.series.length;j++) {
      var serie = chartDef.series[j], domainIndex = serie.domainIndex, columnIdxX = chartDef.domainsColumnStructure[domainIndex].columns[gviz.canviz.ColumnRole.DOMAIN][0], columnIdxY = this.getFirstDataColumnIndex_(serie), xValue = dataView.getValue(i, columnIdxX), yValue = dataView.getValue(i, columnIdxY), xNumeric = hAxis.valueScale.valueToUnscaledNumber(xValue), yNumeric = vAxis.valueScale.valueToUnscaledNumber(yValue);
      goog.isDefAndNotNull(xNumeric) && hAxis.markClosestValueToZero(xNumeric);
      goog.isDefAndNotNull(yNumeric) && vAxis.markClosestValueToZero(yNumeric);
    }
  }
};
gviz.canviz.AxisChartDefiner.prototype.calcLayout = function() {
  var chartDef = this.chartDef;
  this.calcTopAxisChartAreaLayout_();
  (chartDef.isStacked || chartDef.isDiff || chartDef.chartType === gviz.canviz.Options.ChartType.HISTOGRAM) && goog.object.forEach(this.targetAxisDefiners_, function(targetAxisDefiner) {
    targetAxisDefiner.extendRangeToIncludeNumber(0);
  });
  if (chartDef.chartType === gviz.canviz.Options.ChartType.FUNCTION || chartDef.chartType === gviz.canviz.Options.ChartType.HISTOGRAM) {
    this.findValuesClosestToZeroFunctionChart_(), this.domainAxisDefiner_.type == gviz.canviz.Options.AxisType.VALUE && this.domainAxisDefiner_.initPreCalculator(this.calcGaps_()), this.domainAxisDefiner_.initViewWindow(this.options), goog.object.forEach(this.targetAxisDefiners_, function(targetAxisDefiner) {
      targetAxisDefiner.initPreCalculator();
      targetAxisDefiner.initViewWindow(this.options);
    }, this);
  } else {
    var hAxisDefiner = this.hAxisDefiners_[0], vAxisDefiner = this.vAxisDefiners_[0];
    chartDef.chartType == gviz.canviz.Options.ChartType.BUBBLE ? this.bubbleChartDefiner_.findValuesClosestToZero(hAxisDefiner, vAxisDefiner) : chartDef.chartType == gviz.canviz.Options.ChartType.SCATTER && this.findValuesClosestToZeroScatter_();
    hAxisDefiner.initPreCalculator();
    hAxisDefiner.initViewWindow(this.options);
    vAxisDefiner.initPreCalculator();
    vAxisDefiner.initViewWindow(this.options);
  }
  chartDef.serieTypeCount[gviz.canviz.Options.SerieType.BARS] && this.calcBarLikeLayout_(gviz.canviz.Options.SerieType.BARS);
  if (chartDef.serieTypeCount[gviz.canviz.Options.SerieType.STEPPED_AREA]) {
    if (this.domainAxisDefiner_.type == gviz.canviz.Options.AxisType.VALUE) {
      throw Error("Stepped area series with value domain axis is not supported.");
    }
    this.calcBarLikeLayout_(gviz.canviz.Options.SerieType.STEPPED_AREA);
  }
  chartDef.serieTypeCount[gviz.canviz.Options.SerieType.CANDLESTICKS] && this.calcCandlesticksLayout_();
  chartDef.serieTypeCount[gviz.canviz.Options.SerieType.LINE] && (this.calcLinesLayout_(), this.calculateControlPoints_());
  chartDef.serieTypeCount[gviz.canviz.Options.SerieType.AREA] && this.calcAreaLayout_();
  chartDef.serieTypeCount[gviz.canviz.Options.SerieType.SCATTER] && (this.calcScatterLayout_(), this.calculateControlPoints_());
  chartDef.serieTypeCount[gviz.canviz.Options.SerieType.BUBBLES] && (goog.asserts.assert(goog.isDefAndNotNull(this.hAxisDefiners_) && this.hAxisDefiners_[0]), goog.asserts.assert(goog.isDefAndNotNull(this.vAxisDefiners_) && this.vAxisDefiners_[0]), goog.asserts.assert(this.bubbleChartDefiner_), this.bubbleChartDefiner_.calcBubblesLayout(this.hAxisDefiners_[0], this.vAxisDefiners_[0], this.colorBarDefiner));
  (chartDef.serieTypeCount[gviz.canviz.Options.SerieType.BARS] || chartDef.serieTypeCount[gviz.canviz.Options.SerieType.CANDLESTICKS]) && chartDef.chartType !== gviz.canviz.Options.ChartType.HISTOGRAM && this.domainAxisDefiner_ && this.domainAxisDefiner_.type == gviz.canviz.Options.AxisType.VALUE && this.expandMinMaxValuesForBarLikeCharts_();
  chartDef.hAxes = goog.object.map(this.hAxisDefiners_, function(definer) {
    return definer.calcAxisDefinition(this.chartDef, this.legendDefiner, this.colorBarDefiner);
  }, this);
  chartDef.vAxes = goog.object.map(this.vAxisDefiners_, function(definer) {
    return definer.calcAxisDefinition(this.chartDef, this.legendDefiner, this.colorBarDefiner);
  }, this);
  this.calcSubDivisionDefinition_();
  this.calcCategorySensitivityAreas_();
  this.positionNonScaledElements_();
  (chartDef.chartType === gviz.canviz.Options.ChartType.FUNCTION && chartDef.orientation === gviz.canviz.Options.Orientation.HORIZONTAL || chartDef.serieTypeCount[gviz.canviz.Options.SerieType.BARS]) && this.positionAnnotations_();
  var legendPosition = this.legendDefiner.getPosition(), sideMargin = this.legendDefiner.getTextStyle().fontSize, legendArea = null;
  legendPosition != gviz.canviz.Options.LegendPosition.RIGHT && legendPosition != gviz.canviz.Options.LegendPosition.LABELED || this.hasRightAxis_() || (legendArea = new goog.math.Box(chartDef.chartArea.top, chartDef.width - sideMargin, chartDef.chartArea.bottom, chartDef.chartArea.right + sideMargin));
  legendPosition != gviz.canviz.Options.LegendPosition.LEFT || this.hasLeftAxis_() || (legendArea = new goog.math.Box(chartDef.chartArea.top, chartDef.chartArea.left - sideMargin, chartDef.chartArea.bottom, sideMargin));
  legendArea && legendArea.right >= legendArea.left && this.legendDefiner.setArea(legendArea);
  this.resolveTextCollisions_();
  this.bubbleChartDefiner_ || (this.initTrendlines_(this.dataView), this.initLegend_(), this.calcTrendlinesLayout());
};
gviz.canviz.AxisChartDefiner.prototype.calcTopAxisChartAreaLayout_ = function() {
  var chartDef = this.chartDef, measureFunction = this.textMeasureFunction, titleFontSize = chartDef.title.textStyle.fontSize, axisTitleTextStyle = goog.object.getAnyValue(this.hAxisDefiners_).title.textStyle, axisTitleFontSize = axisTitleTextStyle.fontSize, maxTitleFontSize = Math.max(titleFontSize, axisTitleFontSize), legendFontSize = this.legendDefiner.getTextStyle().fontSize, legendPosition = this.legendDefiner.getPosition(), colorBarFontSize = this.colorBarDefiner.getTextStyle().fontSize, colorBarPosition = 
  this.colorBarDefiner.getPosition(), titleText = chartDef.titlePosition == gviz.canviz.Options.InOutPosition.INSIDE ? chartDef.title.text : "", firstAxisTitleText = "", secondAxisTitleText = "";
  if (chartDef.axisTitlesPosition == gviz.canviz.Options.InOutPosition.INSIDE) {
    var getJointAxesTitle = function(axisDefiners) {
      var axisIndices = goog.object.getKeys(axisDefiners);
      goog.array.sort(axisIndices);
      var titles = goog.array.map(axisIndices, function(idx) {
        var axisDefiner = axisDefiners[idx];
        return axisDefiner.title.text;
      }), nonEmptyTitles = goog.array.filter(titles, function(title) {
        return "" != title;
      });
      return nonEmptyTitles.join(", ");
    };
    switch(chartDef.chartType) {
      case gviz.canviz.Options.ChartType.SCATTER:
      ;
      case gviz.canviz.Options.ChartType.BUBBLE:
        firstAxisTitleText = getJointAxesTitle(this.hAxisDefiners_);
        secondAxisTitleText = getJointAxesTitle(this.vAxisDefiners_);
        break;
      case gviz.canviz.Options.ChartType.FUNCTION:
        firstAxisTitleText = getJointAxesTitle({0:this.domainAxisDefiner_}), secondAxisTitleText = getJointAxesTitle(this.targetAxisDefiners_);
    }
  }
  var axisTitleText;
  axisTitleText = firstAxisTitleText && secondAxisTitleText ? firstAxisTitleText + " / " + secondAxisTitleText : firstAxisTitleText ? firstAxisTitleText : secondAxisTitleText ? secondAxisTitleText : "";
  var gapAboveTitle = Math.max(2, Math.round(maxTitleFontSize / gviz.canviz.Constants.GOLDEN_RATIO)), gapBesidesTitle = gapAboveTitle, gapAboveLegend = Math.max(2, Math.round(legendFontSize / gviz.canviz.Constants.GOLDEN_RATIO)), gapAboveColorBar = Math.max(2, Math.round(colorBarFontSize / gviz.canviz.Constants.GOLDEN_RATIO)), availableTitleWidth = chartDef.chartArea.width - 2 * gapBesidesTitle, titleLayout = gviz.canviz.textutils.calcTextLayout(measureFunction, titleText, chartDef.title.textStyle, 
  availableTitleWidth, 1), displayedTitle = 0 < titleLayout.lines.length ? titleLayout.lines[0] : "", displayedTitleWidth = measureFunction(displayedTitle, chartDef.title.textStyle).width, gapBetweenTitles = Math.round(Math.max(2, maxTitleFontSize * gviz.canviz.Constants.GOLDEN_RATIO)), availableAxisTitleWidth = Math.max(availableTitleWidth - displayedTitleWidth - gapBetweenTitles, 0), axisTitleLayout = gviz.canviz.textutils.calcTextLayout(measureFunction, axisTitleText, axisTitleTextStyle, availableAxisTitleWidth, 
  1), displayedAxisTitle = 0 < axisTitleLayout.lines.length ? axisTitleLayout.lines[0] : "", items = [];
  items.push({key:"bottom-space", min:2, extra:[Infinity]});
  (displayedTitle || displayedAxisTitle) && items.push({key:"title", min:maxTitleFontSize + 2, extra:[gapAboveTitle - 2]});
  legendPosition == gviz.canviz.Options.LegendPosition.INSIDE && items.push({key:"legend", min:legendFontSize + 2, extra:[gapAboveLegend - 2]});
  colorBarPosition == gviz.canviz.Options.ColorBarPosition.INSIDE && items.push({key:"colorBar", min:this.colorBarDefiner.getHeight() + 2, extra:[gapAboveColorBar - 2]});
  var availableRealEstate = Math.floor(chartDef.chartArea.height / 2), allocatedHeights = gviz.canviz.util.distributeRealEstateWithKeys(items, availableRealEstate), y = chartDef.chartArea.top, actualTitleLines = allocatedHeights.title || [];
  0 < actualTitleLines.length && (y += actualTitleLines[0], displayedTitle && (chartDef.title.lines.push({text:displayedTitle, x:chartDef.chartArea.left + gapBesidesTitle, y:y, length:displayedTitleWidth}), chartDef.title.tooltip = titleLayout.needTooltip ? titleText : ""), displayedAxisTitle && (chartDef.innerAxisTitle = {text:axisTitleText, textStyle:axisTitleTextStyle, boxStyle:null, lines:[], paralAlign:gviz.graphics.TextAlign.END, perpenAlign:gviz.graphics.TextAlign.END, tooltip:axisTitleLayout.needTooltip ? 
  axisTitleText : "", anchor:null, angle:0}, chartDef.innerAxisTitle.lines.push({text:displayedAxisTitle, x:chartDef.chartArea.right - gapBesidesTitle, y:y, length:availableAxisTitleWidth})));
  var actualLegendLines = allocatedHeights.legend || [];
  if (0 < actualLegendLines.length) {
    var y = y + actualLegendLines[0], legendArea = new goog.math.Box(y - legendFontSize, chartDef.chartArea.right, y, chartDef.chartArea.left);
    this.legendDefiner.setArea(legendArea);
  }
  var actualColorBarLines = allocatedHeights.colorBar || [];
  if (0 < actualColorBarLines.length) {
    var y = y + actualColorBarLines[0], colorBarArea = new goog.math.Box(y - this.colorBarDefiner.getHeight(), chartDef.chartArea.right, y, chartDef.chartArea.left);
    this.colorBarDefiner.setArea(colorBarArea);
  }
};
gviz.canviz.AxisChartDefiner.prototype.calcBarLikeLayout_ = function(seriesType) {
  var chartDef = this.chartDef;
  chartDef.isDiff ? this.calcDiffBars_(seriesType) : this.calcBars_(seriesType, chartDef.isStacked);
};
gviz.canviz.AxisChartDefiner.prototype.expandMinMaxValuesForBarLikeCharts_ = function() {
  var domainAxis = this.domainAxisDefiner_, categories = goog.array.filter(this.chartDef.categories, function(category, i) {
    return 0 != this.calcGap_(i);
  }, this), minDistance = Infinity, previousValue;
  goog.array.forEach(categories, function(category) {
    var dataValue = category.data, numericValue = domainAxis.valueScale.valueToNumber(dataValue);
    goog.isDef(previousValue) && (minDistance = Math.min(minDistance, Math.abs(numericValue - previousValue)));
    previousValue = numericValue;
  }, this);
  if (goog.math.isFiniteNumber(minDistance)) {
    var halfBarWidthNumericValue = minDistance / 2;
    domainAxis.extendRangeToIncludeNumber(domainAxis.valueScale.numericMinValue - halfBarWidthNumericValue);
    domainAxis.extendRangeToIncludeNumber(domainAxis.valueScale.numericMaxValue + halfBarWidthNumericValue);
  }
};
gviz.canviz.AxisChartDefiner.prototype.calcBars_ = function(seriesType, isStacked$$0) {
  var chartDef = this.chartDef, dataView = this.dataView, domainAxis = this.domainAxisDefiner_, isHistogram = this.chartDef.chartType === gviz.canviz.Options.ChartType.HISTOGRAM, approxPixelRatio = (chartDef.chartArea.height - 1) / gviz.canviz.HistogramChartDefiner.getLargestStack(isStacked$$0, chartDef, dataView);
  this.chartDef.histogramAsColumnChart = isHistogram && gviz.canviz.HistogramChartDefiner.treatHistogramAsColumnChart(approxPixelRatio, this.options.inferBooleanValue("histogram.hideBucketItems"));
  for (var i = 0;i < chartDef.categories.length;i++) {
    for (var isCollapsed = 0 == this.calcGap_(i), accumulatedValues = goog.object.map(this.targetAxisDefiners_, function() {
      return[0, 0];
    }), correctedSeriesIndex = -1, j = 0;j < chartDef.series.length;j++) {
      var serie = chartDef.series[j];
      if (serie.type == seriesType) {
        correctedSeriesIndex++;
        0 == isStacked$$0 && (accumulatedValues[serie.targetAxisIndex] = [0, 0]);
        var points = serie.points;
        if (isCollapsed) {
          points.push(null);
        } else {
          var targetAxisIndex = serie.targetAxisIndex, targetAxis = this.targetAxisDefiners_[targetAxisIndex], columnIdx = serie.columns[gviz.canviz.ColumnRole.DATA][0], value = dataView.getValue(i, columnIdx), numericValue = targetAxis.valueScale.valueToNumber(value), numericDomainValue = this.getNumericDomainValue_(i);
          domainAxis.extendRangeToIncludeNumber(numericDomainValue);
          var idx = 0 < numericValue ? 0 : 1, accumulated = accumulatedValues[targetAxisIndex], shouldExtendTargetAxisRange = domainAxis.isValueInViewWindow(numericDomainValue);
          shouldExtendTargetAxisRange && (isStacked$$0 ? targetAxis.extendRangeToIncludeNumber(numericValue + accumulated[idx]) : targetAxis.extendRangeToIncludeNumber(numericValue));
          isStacked$$0 || this.allocateSubDivisions_(correctedSeriesIndex + 1);
          var addAndAccumulate = function(val, subdivision, fromVal, isStacked) {
            var point = {nonScaled:{division:i, subDivision:subdivision, from:fromVal, to:val + (isStacked || isHistogram ? accumulated[idx] : 0), d:numericDomainValue, intervalMarks:this.calcIntervalsLayout_(serie, i, accumulated[idx], !0)}};
            goog.isDefAndNotNull(val) || (point.isNull = !0);
            if (serie.type == gviz.canviz.Options.SerieType.STEPPED_AREA) {
              var len = points.length;
              point.nonScaled.previousTo = 0 != len && points[len - 1] ? points[len - 1].nonScaled.to : null;
            }
            this.addCommonPointProperties_(point, serie, j, i);
            points.push(point);
            accumulated[idx] += val;
          }, subdivision = isStacked$$0 ? 0 : correctedSeriesIndex, from = isStacked$$0 || isHistogram ? accumulated[idx] : null;
          if (isHistogram && !this.chartDef.histogramAsColumnChart) {
            for (var p = 0;p < numericValue;p++) {
              from = isStacked$$0 || isHistogram ? accumulated[idx] : null, addAndAccumulate.call(this, 1, subdivision, from, isStacked$$0);
            }
          } else {
            addAndAccumulate.call(this, numericValue, subdivision, from, isStacked$$0);
          }
        }
      }
    }
  }
  isStacked$$0 || goog.object.forEach(this.targetAxisDefiners_, function(targetAxisDefiner) {
    targetAxisDefiner.expandRangeABit();
  });
};
gviz.canviz.AxisChartDefiner.prototype.calcDiffBars_ = function(seriesType) {
  for (var chartDef = this.chartDef, dataView = this.dataView, domainAxis = this.domainAxisDefiner_, plottedSeries = goog.array.filter(chartDef.series, function(serie) {
    return serie.type == seriesType;
  }), catIndex = 0;catIndex < chartDef.categories.length;++catIndex) {
    var isCollapsed = 0 == this.calcGap_(catIndex), numericDomainValue = this.getNumericDomainValue_(catIndex);
    domainAxis.extendRangeToIncludeNumber(numericDomainValue);
    for (var shouldExtendTargetAxisRange = domainAxis.isValueInViewWindow(numericDomainValue), rolesToHandle = [gviz.canviz.ColumnRole.DIFF_OLD_DATA, gviz.canviz.ColumnRole.DATA], serieIndex = 0;serieIndex < plottedSeries.length;++serieIndex) {
      var serie$$0 = plottedSeries[serieIndex];
      if (isCollapsed) {
        serie$$0.points.push(null);
        return;
      }
      for (var targetAxisIndex = serie$$0.targetAxisIndex, targetAxis = this.targetAxisDefiners_[targetAxisIndex], valueScale = targetAxis.valueScale, roleIndex = 0;roleIndex < rolesToHandle.length;++roleIndex) {
        var role = rolesToHandle[roleIndex], columnIdx = serie$$0.columns[role][0], value = dataView.getValue(catIndex, columnIdx), numericValue = valueScale.valueToNumber(value);
        if (goog.isNull(numericValue)) {
          serie$$0.points.push(null);
          return;
        }
        shouldExtendTargetAxisRange && targetAxis.extendRangeToIncludeNumber(numericValue);
        this.allocateSubDivisions_(serieIndex + 1);
        var point = {brush:this.getDiffBarBrush_(serie$$0, role), nonScaled:{division:catIndex, subDivision:serieIndex, from:null, to:numericValue, d:numericDomainValue, isDiffForeground:role == gviz.canviz.ColumnRole.DATA, intervalMarks:this.calcIntervalsLayout_(serie$$0, catIndex, 0, !0)}};
        this.addCommonPointProperties_(point, serie$$0, serieIndex, catIndex);
        serie$$0.points.push(point);
      }
    }
  }
  goog.object.forEach(this.targetAxisDefiners_, function(targetAxisDefiner) {
    targetAxisDefiner.expandRangeABit();
  });
};
gviz.canviz.AxisChartDefiner.prototype.calcCandlesticksLayout_ = function() {
  var chartDef = this.chartDef, dataView = this.dataView, domainAxis = this.domainAxisDefiner_, plottedSeries = goog.array.filter(chartDef.series, function(serie) {
    return serie.type == gviz.canviz.Options.SerieType.CANDLESTICKS;
  });
  goog.array.forEach(chartDef.categories, function(category, i) {
    var isCollapsed = 0 == this.calcGap_(i);
    goog.array.forEach(plottedSeries, function(serie, j) {
      if (isCollapsed) {
        serie.points.push(null);
      } else {
        var dataColumns = serie.columns[gviz.canviz.ColumnRole.DATA], targetAxisIndex = serie.targetAxisIndex, targetAxis = this.targetAxisDefiners_[targetAxisIndex];
        this.allocateSubDivisions_(j + 1);
        var minValue = dataView.getValue(i, dataColumns[0]), openValue = dataView.getValue(i, dataColumns[1]), closeValue = dataView.getValue(i, dataColumns[2]), maxValue = dataView.getValue(i, dataColumns[3]), numericMinValue = targetAxis.valueScale.valueToNumber(minValue), numericOpenValue = targetAxis.valueScale.valueToNumber(openValue), numericCloseValue = targetAxis.valueScale.valueToNumber(closeValue), numericMaxValue = targetAxis.valueScale.valueToNumber(maxValue);
        if (goog.isNull(numericMinValue) || goog.isNull(numericMaxValue) || goog.isNull(numericOpenValue) || goog.isNull(numericCloseValue)) {
          serie.points.push(null);
        } else {
          var numericDomainValue = this.getNumericDomainValue_(i);
          domainAxis.extendRangeToIncludeNumber(numericDomainValue);
          var inverted = numericCloseValue < numericOpenValue, shouldExtendTargetAxisRange = domainAxis.isValueInViewWindow(numericDomainValue);
          shouldExtendTargetAxisRange && (targetAxis.extendRangeToIncludeNumber(numericMinValue), targetAxis.extendRangeToIncludeNumber(numericMaxValue));
          var barBrush = this.getCandleStickBrush_(inverted, serie), point = {barBrush:barBrush, lineBrush:gviz.graphics.Brush.createFillBrush(serie.color.color), nonScaled:{division:i, subDivision:j, lineFrom:numericMinValue, lineTo:numericMaxValue, rectFrom:inverted ? numericCloseValue : numericOpenValue, rectTo:inverted ? numericOpenValue : numericCloseValue, inverted:inverted, d:numericDomainValue}};
          this.addCommonPointProperties_(point, serie, j, i);
          serie.points.push(point);
        }
      }
    }, this);
  }, this);
};
gviz.canviz.AxisChartDefiner.prototype.calcLineSerieLayout_ = function(serieIndex) {
  var chartDef = this.chartDef, dataView = this.dataView, domainAxis = this.domainAxisDefiner_, serie = chartDef.series[serieIndex];
  if (serie.type == gviz.canviz.Options.SerieType.LINE) {
    for (var serieCategories = serie.isVirtual ? serie.data : chartDef.categories, i = 0;i < serieCategories.length;i++) {
      var targetAxisIndex = serie.targetAxisIndex, targetAxis = this.targetAxisDefiners_[targetAxisIndex], columnIdx = serie.columns[gviz.canviz.ColumnRole.DATA][0], targetValue = serie.isVirtual ? serie.data[i][1] : dataView.getValue(i, columnIdx), numericTargetValue = targetAxis.valueScale.valueToNumber(targetValue), shouldExtendTargetAxisRange, intervalMarks;
      if (goog.isDefAndNotNull(numericTargetValue)) {
        var numericDomainValue = this.getNumericDomainValue_(i, serie);
        domainAxis.extendRangeToIncludeNumber(numericDomainValue);
        (shouldExtendTargetAxisRange = domainAxis.isValueInViewWindow(numericDomainValue) && !serie.isVirtual) && targetAxis.extendRangeToIncludeNumber(numericTargetValue);
        intervalMarks = serie.isVirtual ? null : this.calcIntervalsLayout_(serie, i, 0, shouldExtendTargetAxisRange);
      } else {
        shouldExtendTargetAxisRange = !1, intervalMarks = null;
      }
      var point = {nonScaled:{division:i, subDivision:0, d:numericDomainValue, t:numericTargetValue, intervalMarks:intervalMarks}, shape:serie.pointShape, shouldExtendTargetAxisRange:shouldExtendTargetAxisRange};
      goog.isDefAndNotNull(numericTargetValue) || (point.isNull = !0);
      this.addCommonPointProperties_(point, serie, serieIndex, i);
      serie.points.push(point);
    }
  }
};
gviz.canviz.AxisChartDefiner.prototype.calcLinesLayout_ = function() {
  for (var chartDef = this.chartDef, j = 0;j < chartDef.series.length;j++) {
    this.calcLineSerieLayout_(j);
  }
  this.extendToIncludeLineValuesAtViewWindow_();
  this.adjustLineBrushProperties_();
};
gviz.canviz.AxisChartDefiner.prototype.extendToIncludeLineValuesAtViewWindow_ = function() {
  for (var domainAxis = this.domainAxisDefiner_, series = this.chartDef.series, i = 0;i < series.length;i++) {
    var serie = series[i];
    if ((serie.type == gviz.canviz.Options.SerieType.LINE || serie.type == gviz.canviz.Options.SerieType.AREA) && 0 != serie.lineWidth) {
      var targetAxis = this.targetAxisDefiners_[serie.targetAxisIndex], points = goog.array.map(serie.points, function(point) {
        return gviz.canviz.chartdefinitionutil.isDatumNull(point) ? null : new goog.math.Coordinate(point.nonScaled.d, point.nonScaled.t);
      }), interpolateNulls = this.chartDef.interpolateNulls, valueAtDomainMin = gviz.canviz.util.piecewiseLinearInterpolation(points, domainAxis.getMinNumericValue(), interpolateNulls), valueAtDomainMax = gviz.canviz.util.piecewiseLinearInterpolation(points, domainAxis.getMaxNumericValue(), interpolateNulls);
      targetAxis.extendRangeToIncludeNumber(valueAtDomainMin);
      targetAxis.extendRangeToIncludeNumber(valueAtDomainMax);
    }
  }
};
gviz.canviz.AxisChartDefiner.prototype.calcAreaLayout_ = function() {
  for (var chartDef = this.chartDef, dataView = this.dataView, domainAxis = this.domainAxisDefiner_, interpolateNulls = chartDef.interpolateNulls, i = 0;i < chartDef.categories.length;i++) {
    for (var lastValueTo = goog.object.map(this.targetAxisDefiners_, function() {
      return 0;
    }), lastValueFrom = goog.object.clone(lastValueTo), accumulatedValue = goog.object.clone(lastValueTo), j = 0;j < chartDef.series.length;j++) {
      var serie = chartDef.series[j];
      if (serie.type == gviz.canviz.Options.SerieType.AREA) {
        var targetAxisIndex = serie.targetAxisIndex, targetAxis = this.targetAxisDefiners_[targetAxisIndex], bottomTo = null, bottomFrom = null, columnIdx = serie.columns[gviz.canviz.ColumnRole.DATA][0], targetValue = dataView.getValue(i, columnIdx), numericTargetValue = targetAxis.valueScale.valueToNumber(targetValue), numericDomainValue = this.getNumericDomainValue_(i), nonScaledPoint, shouldExtendTargetAxisRange;
        if (goog.isDefAndNotNull(numericTargetValue) && !isNaN(numericTargetValue)) {
          var t, continueFrom, continueTo, prevValue = 0 < i ? dataView.getValue(i - 1, columnIdx) : null, nextValue = i < dataView.getNumberOfRows() - 1 ? dataView.getValue(i + 1, columnIdx) : null;
          chartDef.isStacked ? (t = numericTargetValue + accumulatedValue[targetAxisIndex], bottomTo = lastValueFrom[targetAxisIndex], bottomFrom = lastValueTo[targetAxisIndex], continueFrom = lastValueFrom[targetAxisIndex] + numericTargetValue, continueTo = lastValueTo[targetAxisIndex] + numericTargetValue, i == dataView.getNumberOfRows() - 1 || !goog.isNull(nextValue) && !isNaN(nextValue) ? lastValueFrom[targetAxisIndex] += numericTargetValue : continueFrom = lastValueFrom[targetAxisIndex], 0 == 
          i || !goog.isNull(prevValue) && !isNaN(prevValue) ? lastValueTo[targetAxisIndex] += numericTargetValue : continueTo = lastValueTo[targetAxisIndex]) : (continueFrom = continueTo = t = numericTargetValue, i == dataView.getNumberOfRows() - 1 || !goog.isNull(nextValue) && !isNaN(nextValue) ? continueFrom = t : interpolateNulls || (continueFrom = null), 0 == i || !goog.isNull(prevValue) && !isNaN(prevValue) ? continueTo = t : interpolateNulls || (continueTo = null));
          domainAxis.extendRangeToIncludeNumber(numericDomainValue);
          (shouldExtendTargetAxisRange = domainAxis.isValueInViewWindow(numericDomainValue)) && targetAxis.extendRangeToIncludeNumber(t);
          var intervalMarks = this.calcIntervalsLayout_(serie, i, accumulatedValue[targetAxisIndex], shouldExtendTargetAxisRange);
          chartDef.isStacked && (accumulatedValue[targetAxisIndex] = t);
          nonScaledPoint = {d:numericDomainValue, t:t, division:i, subDivision:0, continueToD:numericDomainValue, continueToT:continueTo, continueFromD:numericDomainValue, continueFromT:continueFrom, bottomToD:numericDomainValue, bottomToT:bottomTo, bottomFromD:numericDomainValue, bottomFromT:bottomFrom, intervalMarks:intervalMarks};
        } else {
          chartDef.isStacked && (bottomTo = lastValueFrom[targetAxisIndex], bottomFrom = lastValueTo[targetAxisIndex]), nonScaledPoint = {bottomToD:numericDomainValue, bottomToT:bottomTo, bottomFromD:numericDomainValue, bottomFromT:bottomFrom, continueToD:numericDomainValue, continueToT:bottomFrom, continueFromD:numericDomainValue, continueFromT:bottomTo}, shouldExtendTargetAxisRange = !1;
        }
        var point = {nonScaled:nonScaledPoint, shape:serie.pointShape, shouldExtendTargetAxisRange:shouldExtendTargetAxisRange};
        this.addCommonPointProperties_(point, serie, j, i);
        if (!goog.isDefAndNotNull(numericTargetValue) || isNaN(numericTargetValue)) {
          point.isNull = !0;
        }
        serie.points.push(point);
      }
    }
  }
  this.extendToIncludeLineValuesAtViewWindow_();
  this.adjustLineBrushProperties_();
};
gviz.canviz.AxisChartDefiner.prototype.calcTrendlinesLayout = function() {
  var chartDef = this.chartDef;
  goog.array.forEach(chartDef.series, function(serie, i) {
    serie.isVirtual && (serie.type === gviz.canviz.Options.SerieType.SCATTER ? this.calcScatterSerieLayout_(i) : serie.type === gviz.canviz.Options.SerieType.LINE && this.calcLineSerieLayout_(i), this.positionNonScaledElementsForSerie_(i));
  }, this);
};
gviz.canviz.AxisChartDefiner.prototype.calcScatterSerieLayout_ = function(serieIndex) {
  var chartDef = this.chartDef, dataView = this.dataView, hAxis = this.hAxisDefiners_[0], vAxis = this.vAxisDefiners_[0], serie = chartDef.series[serieIndex], domainIndex = serie.domainIndex;
  if (serie.type === gviz.canviz.Options.SerieType.SCATTER) {
    for (var dataLength = serie.isVirtual ? serie.data.length : dataView.getNumberOfRows(), i = 0;i < dataLength;i++) {
      var columnIdxX = chartDef.domainsColumnStructure[domainIndex].columns[gviz.canviz.ColumnRole.DOMAIN][0], columnIdxY = this.getFirstDataColumnIndex_(serie), xValue = serie.isVirtual ? serie.data[i][0] : dataView.getValue(i, columnIdxX), yValue = serie.isVirtual ? serie.data[i][1] : dataView.getValue(i, columnIdxY), xNumeric = hAxis.valueScale.valueToNumber(xValue), yNumeric = vAxis.valueScale.valueToNumber(yValue);
      if (goog.isNull(xNumeric) || goog.isNull(yNumeric)) {
        serie.points.push(null);
      } else {
        var shouldExtendAxesRange = hAxis.isValueInViewWindow(xNumeric) && vAxis.isValueInViewWindow(yNumeric);
        shouldExtendAxesRange && !serie.isVirtual && (hAxis.extendRangeToIncludeNumber(xNumeric), vAxis.extendRangeToIncludeNumber(yNumeric));
        var point = {nonScaled:{x:xNumeric, y:yNumeric}, shape:serie.pointShape, shouldExtendAxesRange:shouldExtendAxesRange};
        this.addCommonPointProperties_(point, serie, serieIndex, i);
        serie.points.push(point);
      }
    }
  }
};
gviz.canviz.AxisChartDefiner.prototype.calcScatterLayout_ = function() {
  for (var chartDef = this.chartDef, j = 0;j < chartDef.series.length;j++) {
    this.calcScatterSerieLayout_(j);
  }
  this.adjustLineBrushProperties_();
};
gviz.canviz.AxisChartDefiner.prototype.adjustLineBrushProperties_ = function() {
  for (var isNotNull = function(point) {
    return!gviz.canviz.chartdefinitionutil.isDatumNull(point);
  }, getProperties = goog.bind(function(point) {
    var division = goog.isDefAndNotNull(point.nonScaled) ? point.nonScaled.division : null;
    return{certainty:goog.isDefAndNotNull(point.certainty) ? point.certainty : 1, emphasis:goog.isDefAndNotNull(point.emphasis) ? point.emphasis : 1, scope:goog.isDefAndNotNull(point.scope) ? point.scope : !0, gap:goog.isDefAndNotNull(division) ? this.calcGap_(division) : null};
  }, this), noGaps = goog.isNull(this.findGapColumn_()), s = 0;s < this.chartDef.series.length;s++) {
    var serie = this.chartDef.series[s], areaBrush = serie.areaBrush, certaintyCols = serie.columns[gviz.canviz.ColumnRole.CERTAINTY] || [], emphasisCols = serie.columns[gviz.canviz.ColumnRole.EMPHASIS] || [], scopeCols = serie.columns[gviz.canviz.ColumnRole.SCOPE] || [];
    if (0 != certaintyCols.length || 0 != emphasisCols.length || 0 != scopeCols.length || !noGaps) {
      for (var prevPoint = goog.array.findRight(serie.points, isNotNull), prevProperties = getProperties(prevPoint || {}), p = 0;p < serie.points.length;p++) {
        var point$$0 = serie.points[p];
        if (isNotNull(point$$0)) {
          var properties = getProperties(point$$0), lineBrush = serie.lineBrush;
          properties.scope || prevProperties.scope || (serie.grayLineBrush = serie.grayLineBrush || lineBrush.grayOut(), lineBrush = serie.grayLineBrush, point$$0.incomingLineBrush = lineBrush, areaBrush && (serie.grayAreaBrush = serie.grayAreaBrush || areaBrush.grayOut(), point$$0.incomingAreaBrush = serie.grayAreaBrush));
          if (1 > properties.certainty || 1 > prevProperties.certainty) {
            lineBrush = this.createUncertainBrush_(lineBrush, !1), point$$0.incomingLineBrush = lineBrush;
          }
          if (1 != properties.emphasis && 1 != prevProperties.emphasis) {
            var actualEmphasis = Math.min(prevProperties.emphasis, properties.emphasis), lineBrush = this.createEmphasizedBrush_(lineBrush, actualEmphasis);
            point$$0.incomingLineBrush = lineBrush;
          }
          0 == properties.gap && isNotNull(prevPoint) && (point$$0.incomingLineBrush = null);
          prevProperties = properties;
        }
        prevPoint = point$$0;
      }
    }
  }
};
gviz.canviz.AxisChartDefiner.canonicalizeCssStyle_ = function(rules) {
  var style = {fill:{}, stroke:{}, shape:{}};
  goog.isDefAndNotNull(rules) && (goog.isDefAndNotNull(rules.visible) && (style.visible = rules.visible), goog.isDefAndNotNull(rules.size) && (style.size = rules.size), goog.isDefAndNotNull(rules.color) && (style.fill.color = style.stroke.color = rules.color), goog.isDefAndNotNull(rules.opacity) && (style.fill.opacity = style.stroke.opacity = rules.opacity), goog.isDefAndNotNull(rules.fillColor) && (style.fill.color = rules.fillColor), goog.isDefAndNotNull(rules.fillOpacity) && (style.fill.opacity = 
  rules.fillOpacity), goog.isDefAndNotNull(rules.strokeColor) && (style.stroke.color = rules.strokeColor), goog.isDefAndNotNull(rules.strokeOpacity) && (style.stroke.opacity = rules.strokeOpacity), goog.isDefAndNotNull(rules.strokeWidth) && (style.stroke.width = rules.strokeWidth), goog.isDefAndNotNull(rules.shapeType) && (style.shape.type = rules.shapeType), goog.isDefAndNotNull(rules.shapeSides) && (style.shape.sides = rules.shapeSides), goog.isDefAndNotNull(rules.shapeRotation) && (style.shape.rotation = 
  rules.shapeRotation), goog.isDefAndNotNull(rules.shapeDent) && (style.shape.dent = rules.shapeDent));
  return style;
};
gviz.canviz.AxisChartDefiner.processStyleString_ = function(style) {
  var customStyle;
  style = goog.string.trim(style);
  if (goog.color.isValidColor(style)) {
    customStyle = {fill:{color:style}, stroke:{color:style}};
  } else {
    if ("{" === style.charAt(0)) {
      try {
        var customPointStyle = goog.json.parse(style);
      } catch (e) {
      }
      goog.isDefAndNotNull(customPointStyle) && (customStyle = customPointStyle);
    }
  }
  if (!goog.isDefAndNotNull(customStyle)) {
    var canonicalizeCssStyle = gviz.canviz.AxisChartDefiner.canonicalizeCssStyle_;
    goog.string.contains(style, "{") ? (customStyle = goog.object.map(google.visualization.style.parseStyle(style), canonicalizeCssStyle), goog.object.containsKey(customStyle, "") && (goog.object.extend(customStyle, customStyle[""]), goog.object.remove(customStyle, "")), goog.object.containsKey(customStyle, "*") && (goog.object.extend(customStyle, customStyle["*"]), goog.object.remove(customStyle, "*"))) : customStyle = canonicalizeCssStyle(goog.style.parseStyleAttribute(style));
  }
  return customStyle;
};
gviz.canviz.AxisChartDefiner.prototype.getCustomPointStyle_ = function(serie, categoryIndex) {
  var customStyle = void 0, styleColumnIndex = goog.isDefAndNotNull(serie.columns[gviz.canviz.ColumnRole.STYLE]) ? serie.columns[gviz.canviz.ColumnRole.STYLE][0] : void 0;
  if (goog.isDefAndNotNull(styleColumnIndex) && "string" === this.dataView.getColumnType(styleColumnIndex)) {
    var customStyleString = this.dataView.getValue(categoryIndex, styleColumnIndex);
    goog.isDefAndNotNull(customStyleString) && (customStyle = gviz.canviz.AxisChartDefiner.processStyleString_(customStyleString));
  }
  if (goog.isDefAndNotNull(customStyle)) {
    return new gviz.Options([customStyle]);
  }
};
gviz.canviz.AxisChartDefiner.prototype.addCommonPointProperties_ = function(point, serie, serieIndex, categoryIndex) {
  this.isTooltipEnabled_ && (point.tooltipText = this.getTooltipText_(serie, serieIndex, categoryIndex));
  var customStyle = this.getCustomPointStyle_(serie, categoryIndex), certainty = this.calcCertainty_(serie, categoryIndex), emphasis = this.calcEmphasis_(serie, categoryIndex), scope = this.calcScope_(serie, categoryIndex), radius = gviz.canviz.chartdefinitionutil.getPointTotalRadius(point, serie), brush$$0 = serie.pointBrush;
  if (goog.isDefAndNotNull(customStyle)) {
    var brush$$0 = brush$$0.clone(), mutateBrush = function(brush, opt_subpath, opt_onlyFillOrStroke) {
      var subpath = opt_subpath || "";
      "stroke" !== opt_onlyFillOrStroke && (brush.setFill(customStyle.inferColorValue([subpath + "fill.color", subpath + "fill"], brush.getFill())), brush.setFillOpacity(customStyle.inferRatioNumberValue(subpath + "fill.opacity", brush.getFillOpacity())));
      "fill" !== opt_onlyFillOrStroke && (brush.setStroke(customStyle.inferColorValue([subpath + "stroke.color", subpath + "stroke"], brush.getStroke())), brush.setStrokeOpacity(customStyle.inferRatioNumberValue(subpath + "stroke.opacity", brush.getStrokeOpacity())), brush.setStrokeWidth(customStyle.inferNumberValue(subpath + "stroke.width", brush.getStrokeWidth())));
    };
    point.radius = radius = customStyle.inferNonNegativeNumberValue("point.size", radius);
    var customShape = customStyle.inferWholeObjectValue("point.shape");
    goog.isDefAndNotNull(customShape) && (point.shape = customShape);
    var pointVisible = customStyle.inferOptionalBooleanValue("point.visible");
    goog.isDefAndNotNull(pointVisible) && (point.visible = pointVisible);
    mutateBrush(brush$$0);
    switch(serie.type) {
      case gviz.canviz.Options.SerieType.LINE:
      ;
      case gviz.canviz.Options.SerieType.SCATTER:
      ;
      case gviz.canviz.Options.SerieType.AREA:
        mutateBrush(brush$$0, "point.");
        goog.isDefAndNotNull(serie.lineBrush) && (point.incomingLineBrush = (point.incomingLineBrush || point.lineBrush || serie.lineBrush).clone(), mutateBrush(point.incomingLineBrush, null, "stroke"), mutateBrush(point.incomingLineBrush, "line.", "stroke"));
        goog.isDefAndNotNull(serie.areaBrush) && (point.incomingAreaBrush = (point.incomingAreaBrush || point.lineBrush || serie.areaBrush).clone(), mutateBrush(point.incomingAreaBrush, null, "fill"), mutateBrush(point.incomingAreaBrush, "area.", "fill"));
        break;
      case gviz.canviz.Options.SerieType.STEPPED_AREA:
        mutateBrush(brush$$0, "area.", "fill"), goog.isDefAndNotNull(serie.lineBrush) && (point.lineBrush = (point.lineBrush || serie.lineBrush).clone(), mutateBrush(point.lineBrush, null, "stroke"), mutateBrush(point.lineBrush, "line.", "stroke"));
      case gviz.canviz.Options.SerieType.BARS:
        mutateBrush(brush$$0, "bar.");
        break;
      case gviz.canviz.Options.SerieType.CANDLESTICKS:
        point.barBrush = point.barBrush.clone(), mutateBrush(point.barBrush), mutateBrush(point.lineBrush), mutateBrush(point.barBrush, "bar."), mutateBrush(point.lineBrush, "line.");
    }
    point.brush = brush$$0;
  }
  scope || (point.scope = scope, serie.grayPointBrush = serie.grayPointBrush || brush$$0.grayOut(), brush$$0 = serie.grayPointBrush, point.brush = brush$$0);
  1 != emphasis && (point.emphasis = emphasis, serie.type == gviz.canviz.Options.SerieType.LINE || serie.type == gviz.canviz.Options.SerieType.AREA || serie.type == gviz.canviz.Options.SerieType.SCATTER) && (radius = Math.round(radius * Math.sqrt(emphasis) * 10) / 10, point.radius = radius);
  if (1 > certainty) {
    switch(point.certainty = certainty, serie.type) {
      case gviz.canviz.Options.SerieType.LINE:
      ;
      case gviz.canviz.Options.SerieType.AREA:
      ;
      case gviz.canviz.Options.SerieType.SCATTER:
        point.brush = this.createUncertainBrush_(brush$$0, !0);
        point.radius = gviz.canviz.util.calcCompensatedPointRadius(point.brush, radius);
        break;
      case gviz.canviz.Options.SerieType.BARS:
      ;
      case gviz.canviz.Options.SerieType.STEPPED_AREA:
        point.brush = this.createUncertainBrush_(brush$$0, !1);
    }
  }
};
gviz.canviz.AxisChartDefiner.prototype.getTooltipText_ = function(serie, serieIndex, categoryIndex) {
  var tooltipText = this.calcTooltipText_(serie, serieIndex, categoryIndex), tooltipColumnIndices = serie.columns[gviz.canviz.ColumnRole.TOOLTIP];
  if (tooltipColumnIndices && !serie.isVirtual) {
    goog.asserts.assert(1 == tooltipColumnIndices.length);
    var tooltipColumnIndex = tooltipColumnIndices[0], customTooltipText = this.getCustomTooltipText_(tooltipColumnIndex, categoryIndex);
    customTooltipText && goog.object.extend(tooltipText, customTooltipText);
  }
  tooltipText.hasHtmlContent = !!tooltipText.hasHtmlContent;
  return tooltipText;
};
gviz.canviz.AxisChartDefiner.prototype.getCustomTooltipText_ = function(tooltipColumnIndex, rowIndex) {
  var dataView = this.dataView, hasHtmlContent = this.chartDef.isHtmlTooltip && (dataView.getProperty(rowIndex, tooltipColumnIndex, "html") || dataView.getColumnProperty(tooltipColumnIndex, "html")), tooltipContent = dataView.getFormattedValue(rowIndex, tooltipColumnIndex);
  return{hasHtmlContent:!!hasHtmlContent, hasCustomContent:tooltipContent ? !0 : !1, content:tooltipContent};
};
gviz.canviz.AxisChartDefiner.prototype.calcTooltipText_ = function(serie, serieIndex, categoryIndex) {
  var chartType = this.chartDef.chartType;
  return chartType === gviz.canviz.Options.ChartType.SCATTER || serie.isVirtual ? this.calcScatterTooltipText_(serie, serieIndex, categoryIndex) : this.calcFunctionTooltipText_(serie, categoryIndex);
};
gviz.canviz.AxisChartDefiner.prototype.calcScatterTooltipText_ = function(serie, serieIndex, categoryIndex) {
  var dataView = this.dataView, chartDef = this.chartDef, valueX, valueY, content, categoryTitle;
  if (serie.isVirtual) {
    valueX = serie.data[categoryIndex][0], valueY = serie.data[categoryIndex][1], goog.isDefAndNotNull(valueX) && (valueX = google.visualization.datautils.getDefaultFormattedValue(valueX, dataView.getColumnType(serie.domainIndex))), goog.isDefAndNotNull(valueY) && (valueY = google.visualization.datautils.getDefaultFormattedValue(valueY, serie.dataType)), content = chartDef.focusTarget === gviz.canviz.Options.FocusTarget.CATEGORY ? valueY : valueX + ", " + valueY, categoryTitle = valueX;
  } else {
    if (this.chartDef.isDiff) {
      var hAxisTitle = this.hAxisDefiners_[0].title.text, vAxisTitle = this.vAxisDefiners_[0].title.text, valueXPrefixText = hAxisTitle || gviz.canviz.Options.DEFAULT_SCATTER_TOOLTIP_X_PREFIX_TEXT, valueYPrefixText = vAxisTitle || gviz.canviz.Options.DEFAULT_SCATTER_TOOLTIP_Y_PREFIX_TEXT, oldDataSerieIndex = serieIndex % 2 ? serieIndex - 1 : serieIndex, newDataSerieIndex = oldDataSerieIndex + 1, oldDataSerie = chartDef.series[oldDataSerieIndex], newDataSerie = chartDef.series[newDataSerieIndex], 
      columnIdxX, columnIdxY;
      columnIdxX = chartDef.domainsColumnStructure[newDataSerie.domainIndex].columns[gviz.canviz.ColumnRole.DOMAIN][0];
      columnIdxY = this.getFirstDataColumnIndex_(newDataSerie);
      valueX = dataView.getFormattedValue(categoryIndex, columnIdxX);
      valueY = dataView.getFormattedValue(categoryIndex, columnIdxY);
      content = valueXPrefixText + ": " + valueX + ", " + valueYPrefixText + ": " + valueY;
      columnIdxX = chartDef.domainsColumnStructure[oldDataSerie.domainIndex].columns[gviz.canviz.ColumnRole.DOMAIN][0];
      columnIdxY = this.getFirstDataColumnIndex_(oldDataSerie);
      valueX = dataView.getFormattedValue(categoryIndex, columnIdxX);
      valueY = dataView.getFormattedValue(categoryIndex, columnIdxY);
      content += "\n" + valueXPrefixText + ": " + valueX + ", " + valueYPrefixText + ": " + valueY;
    } else {
      columnIdxX = chartDef.domainsColumnStructure[serie.domainIndex].columns[gviz.canviz.ColumnRole.DOMAIN][0], columnIdxY = this.getFirstDataColumnIndex_(serie), valueX = dataView.getFormattedValue(categoryIndex, columnIdxX), valueY = dataView.getFormattedValue(categoryIndex, columnIdxY), content = valueX + ", " + valueY;
    }
  }
  return{hasCustomContent:!1, content:content, serieTitle:serie.title, categoryTitle:categoryTitle};
};
gviz.canviz.AxisChartDefiner.prototype.calcFunctionTooltipText_ = function(serie, categoryIndex) {
  var dataView = this.dataView, category = this.chartDef.categories[categoryIndex], categoryTitle = serie.isVirtual ? serie.data[categoryIndex][0].toString() : category.titles[serie.domainIndex], formattedDataValue;
  if (serie.type == gviz.canviz.Options.SerieType.CANDLESTICKS) {
    var dataColumns = serie.columns[gviz.canviz.ColumnRole.DATA];
    formattedDataValue = dataView.getFormattedValue(categoryIndex, dataColumns[0]) + " - " + dataView.getFormattedValue(categoryIndex, dataColumns[3]) + ", " + dataView.getFormattedValue(categoryIndex, dataColumns[1]) + " - " + dataView.getFormattedValue(categoryIndex, dataColumns[2]);
  } else {
    if (this.chartDef.isDiff) {
      var oldDataColumns = serie.columns[gviz.canviz.ColumnRole.DIFF_OLD_DATA], newDataColumns = serie.columns[gviz.canviz.ColumnRole.DATA], oldValue = this.dataView.getValue(categoryIndex, oldDataColumns[0]), newValue = this.dataView.getValue(categoryIndex, newDataColumns[0]), formattedOldDataValue = dataView.getFormattedValue(categoryIndex, oldDataColumns[0]), formattedNewDataValue = dataView.getFormattedValue(categoryIndex, newDataColumns[0]);
      if (goog.isNull(oldValue) && goog.string.isEmpty(formattedOldDataValue) && goog.isNull(newValue) && goog.string.isEmpty(formattedNewDataValue)) {
        return{hasCustomContent:!1, content:null};
      }
      formattedDataValue = formattedNewDataValue + "\n" + formattedOldDataValue;
    } else {
      var dataColumns = serie.columns[gviz.canviz.ColumnRole.DATA], value = serie.isVirtual ? serie.data[categoryIndex][1] : this.dataView.getValue(categoryIndex, dataColumns[0]);
      formattedDataValue = serie.isVirtual ? serie.data[categoryIndex][1].toString() : this.dataView.getFormattedValue(categoryIndex, dataColumns[0]);
      if (goog.isNull(value) && goog.string.isEmpty(formattedDataValue)) {
        return{hasCustomContent:!1, content:null};
      }
      var intervalColumns = serie.columns[gviz.canviz.ColumnRole.INTERVAL] || [];
      if (intervalColumns.length) {
        var values = goog.array.map(intervalColumns, function(columnIndex) {
          return dataView.getFormattedValue(categoryIndex, columnIndex);
        });
        formattedDataValue += " [" + values.join(", ") + "]";
      }
    }
  }
  return{hasCustomContent:!1, content:formattedDataValue, categoryTitle:categoryTitle, serieTitle:serie.title, hasHtmlContent:!1};
};
gviz.canviz.AxisChartDefiner.prototype.calculateControlPoints_ = function() {
  var chartDef = this.chartDef, domainAxis = this.domainAxisDefiner_, scatterNonScaledToVec = function(nonScaled) {
    return new goog.math.Vec2(nonScaled.x, nonScaled.y);
  }, scatterVecToNonScaled = function(vec) {
    return{x:vec.x, y:vec.y};
  }, scatterExtendRangeToIncludePoint = goog.bind(function(serie, point, nonScaled) {
    point.shouldExtendAxesRange && (this.hAxisDefiners_[0].extendRangeToIncludeNumber(nonScaled.x), this.vAxisDefiners_[0].extendRangeToIncludeNumber(nonScaled.y));
  }, this), functionNonScaledToVec = function(nonScaled) {
    return new goog.math.Vec2(nonScaled.d, nonScaled.t);
  }, functionVecToNonScaled = function(vec) {
    return{d:vec.x, t:vec.y};
  }, functionExtendRangeToIncludePoint = goog.bind(function(serie, point, nonScaled) {
    domainAxis.extendRangeToIncludeNumber(nonScaled.d);
    if (point.shouldExtendTargetAxisRange) {
      var targetAxis = this.targetAxisDefiners_[serie.targetAxisIndex];
      targetAxis.extendRangeToIncludeNumber(nonScaled.t);
    }
  }, this), nonScaledToVec, vecToNonScaled, extendRangeToIncludePoint;
  switch(chartDef.chartType) {
    case gviz.canviz.Options.ChartType.SCATTER:
      nonScaledToVec = scatterNonScaledToVec;
      vecToNonScaled = scatterVecToNonScaled;
      extendRangeToIncludePoint = scatterExtendRangeToIncludePoint;
      break;
    case gviz.canviz.Options.ChartType.FUNCTION:
      nonScaledToVec = functionNonScaledToVec, vecToNonScaled = functionVecToNonScaled, extendRangeToIncludePoint = functionExtendRangeToIncludePoint;
  }
  for (var j = 0;j < chartDef.series.length;j++) {
    var serie$$0 = chartDef.series[j];
    if (serie$$0.type == gviz.canviz.Options.SerieType.SCATTER || serie$$0.type == gviz.canviz.Options.SerieType.LINE) {
      if (goog.array.contains([gviz.canviz.Options.CurveType.FUNCTION, gviz.canviz.Options.CurveType.PHASE, gviz.canviz.Options.CurveType.CLOSED_PHASE], serie$$0.curveType)) {
        var isClosed = serie$$0.type == gviz.canviz.Options.SerieType.SCATTER && serie$$0.curveType == gviz.canviz.Options.CurveType.CLOSED_PHASE, isFunction = serie$$0.curveType == gviz.canviz.Options.CurveType.FUNCTION;
        serie$$0.isCurved = !0;
        serie$$0.isClosed = isClosed;
        for (var controlPoints = gviz.canviz.util.calculateControlPoints(goog.array.map(serie$$0.points, function(p) {
          return gviz.canviz.chartdefinitionutil.isDatumNull(p) ? null : nonScaledToVec(p.nonScaled);
        }), serie$$0.smoothingFactor, isFunction, isClosed, chartDef.interpolateNulls), i = 0;i < serie$$0.points.length;++i) {
          var point$$0 = serie$$0.points[i];
          if (controlPoints[i]) {
            var leftControlPoint = vecToNonScaled(controlPoints[i][0]), rightControlPoint = vecToNonScaled(controlPoints[i][1]);
            point$$0.nonScaledLeftControlPoint = leftControlPoint;
            point$$0.nonScaledRightControlPoint = rightControlPoint;
            extendRangeToIncludePoint(serie$$0, point$$0, leftControlPoint);
            extendRangeToIncludePoint(serie$$0, point$$0, rightControlPoint);
          }
        }
      } else {
        serie$$0.isCurved = !1;
      }
    }
  }
};
gviz.canviz.AxisChartDefiner.prototype.calcCategorySensitivityAreas_ = function() {
  if (this.chartDef.focusTarget == gviz.canviz.Options.FocusTarget.CATEGORY) {
    var categories = this.chartDef.categories, domainAxisDefiner = this.domainAxisDefiner_, categoryOrder = goog.array.range(categories.length);
    goog.array.stableSort(categoryOrder, goog.bind(function(a, b) {
      return goog.array.defaultCompare(this.calcCategoryPosition_(a), this.calcCategoryPosition_(b));
    }, this));
    var startPos = domainAxisDefiner.startPos;
    goog.asserts.assert(goog.isDefAndNotNull(startPos));
    var endPos = domainAxisDefiner.endPos;
    goog.asserts.assert(goog.isDefAndNotNull(endPos));
    if (startPos > endPos) {
      var t = startPos, startPos = endPos, endPos = t
    }
    for (var firstCategoryInViewWindow, currentCategoryPosition, i = 0;i < categoryOrder.length;i++) {
      var categoryIndex = categoryOrder[i];
      currentCategoryPosition = this.calcCategoryPosition_(categoryIndex);
      if (goog.isDefAndNotNull(currentCategoryPosition)) {
        if (domainAxisDefiner.isPositionPastTheEnd(currentCategoryPosition)) {
          return;
        }
        if (!domainAxisDefiner.isPositionBeforeTheStart(currentCategoryPosition)) {
          firstCategoryInViewWindow = i;
          break;
        }
      }
    }
    if (goog.isDef(firstCategoryInViewWindow)) {
      for (var sensitivityAreaStart, sensitivityAreaEnd = startPos, nextCategoryPosition, nextI = null, i = firstCategoryInViewWindow;i < categoryOrder.length;i++) {
        null != nextI && i < nextI && (i = nextI, nextI = null);
        categoryIndex = categoryOrder[i];
        sensitivityAreaStart = sensitivityAreaEnd;
        if (i == categoryOrder.length - 1) {
          this.setCategorySensitivityArea_(categoryIndex, sensitivityAreaStart, endPos);
          break;
        }
        nextCategoryPosition = this.calcCategoryPosition_(categoryOrder[i + 1]);
        if (!goog.isDefAndNotNull(nextCategoryPosition)) {
          for (var j = i + 2;j < categoryOrder.length;j++) {
            if (nextCategoryPosition = this.calcCategoryPosition_(categoryOrder[j]), null != nextCategoryPosition) {
              nextI = j;
              break;
            }
          }
          if (!goog.isDefAndNotNull(nextCategoryPosition)) {
            this.setCategorySensitivityArea_(categoryIndex, sensitivityAreaStart, endPos);
            break;
          }
        }
        if (domainAxisDefiner.isPositionPastTheEnd(nextCategoryPosition)) {
          this.setCategorySensitivityArea_(categoryIndex, sensitivityAreaStart, endPos);
          break;
        }
        goog.asserts.assert(goog.isDefAndNotNull(currentCategoryPosition));
        sensitivityAreaEnd = goog.math.average(currentCategoryPosition, nextCategoryPosition);
        this.setCategorySensitivityArea_(categoryIndex, sensitivityAreaStart, sensitivityAreaEnd);
        currentCategoryPosition = nextCategoryPosition;
      }
    }
  }
};
gviz.canviz.AxisChartDefiner.prototype.calcCategoryPosition_ = function(categoryIndex) {
  var categories = this.chartDef.categories, domainAxisDefiner = this.domainAxisDefiner_;
  return domainAxisDefiner.type == gviz.canviz.Options.AxisType.VALUE ? goog.isDefAndNotNull(categories[categoryIndex].data) ? domainAxisDefiner.calcPositionFromDataValue(categories[categoryIndex].data) : null : domainAxisDefiner.calcPositionForNumericValue(categoryIndex);
};
gviz.canviz.AxisChartDefiner.prototype.setCategorySensitivityArea_ = function(categoryIndex, sensitivityAreaStart, sensitivityAreaEnd) {
  var top = this.chartDef.chartArea.top, bottom = this.chartDef.chartArea.bottom, left = this.chartDef.chartArea.left, right = this.chartDef.chartArea.right, orientation = this.chartDef.orientation, direction = this.domainAxisDefiner_.direction, category = this.chartDef.categories[categoryIndex], swapSensitivityAreaStartAndEnd = function() {
    var t = sensitivityAreaStart;
    sensitivityAreaStart = sensitivityAreaEnd;
    sensitivityAreaEnd = t;
  };
  orientation == gviz.canviz.Options.Orientation.HORIZONTAL ? 1 == direction ? (sensitivityAreaEnd < sensitivityAreaStart && swapSensitivityAreaStartAndEnd(), category.sensitivityArea = new goog.math.Box(top, sensitivityAreaEnd, bottom, sensitivityAreaStart)) : (sensitivityAreaEnd > sensitivityAreaStart && swapSensitivityAreaStartAndEnd(), category.sensitivityArea = new goog.math.Box(top, sensitivityAreaStart, bottom, sensitivityAreaEnd)) : 1 == direction ? (sensitivityAreaEnd < sensitivityAreaStart && 
  swapSensitivityAreaStartAndEnd(), category.sensitivityArea = new goog.math.Box(sensitivityAreaStart, right, sensitivityAreaEnd, left)) : (sensitivityAreaEnd > sensitivityAreaStart && swapSensitivityAreaStartAndEnd(), category.sensitivityArea = new goog.math.Box(sensitivityAreaEnd, right, sensitivityAreaStart, left));
};
gviz.canviz.AxisChartDefiner.prototype.resolveTextCollisions_ = function() {
  this.resolveTicksWithChartCollisions_();
  this.resolveTicksWithTicksCollisions_();
};
gviz.canviz.AxisChartDefiner.prototype.resolveTicksWithChartCollisions_ = function() {
  var chartDef = this.chartDef;
  goog.object.forEach(chartDef.vAxes, function(vAxis, i) {
    this.filterAxisTicks_(this.vAxisDefiners_[i], chartDef.vAxes[i], this.isVerticalTickClearOfChartCollisions_);
  }, this);
  goog.object.forEach(chartDef.hAxes, function(hAxis, i) {
    this.filterAxisTicks_(this.hAxisDefiners_[i], chartDef.hAxes[i], this.isHorizontalTickClearOfChartCollisions_);
  }, this);
};
gviz.canviz.AxisChartDefiner.prototype.resolveTicksWithTicksCollisions_ = function() {
  var chartDef = this.chartDef;
  goog.object.forEach(chartDef.hAxes, function(hAxis, i) {
    this.filterAxisTicks_(this.hAxisDefiners_[i], chartDef.hAxes[i], this.isHorizontalTickClearOfTicksCollisions_);
  }, this);
};
gviz.canviz.AxisChartDefiner.prototype.filterAxisTicks_ = function(axisDefiner, axisDefinition, filterFunc) {
  axisDefinition.text && (axisDefinition.text = goog.array.filter(axisDefinition.text, goog.bind(filterFunc, this, axisDefiner)));
};
gviz.canviz.AxisChartDefiner.prototype.isHorizontalTickClearOfChartCollisions_ = function(hAxisDefiner, tickText) {
  var chartDef = this.chartDef, textBlock = tickText.textBlock;
  if (textBlock.angle) {
    return!0;
  }
  var boundingBox = gviz.canviz.TextBlockUtil.calcBoundingBox(textBlock);
  if (!boundingBox) {
    return!0;
  }
  if (hAxisDefiner.tickTextPosition == gviz.canviz.Options.InOutPosition.INSIDE) {
    var chartAreaBox = new goog.math.Box(chartDef.chartArea.top, chartDef.chartArea.right, chartDef.chartArea.bottom, chartDef.chartArea.left);
    if (!chartAreaBox.contains(boundingBox)) {
      return!1;
    }
  }
  return!0;
};
gviz.canviz.AxisChartDefiner.prototype.isHorizontalTickClearOfTicksCollisions_ = function(hAxisDefiner, tickText) {
  var chartDef = this.chartDef;
  if (hAxisDefiner.tickTextPosition != gviz.canviz.Options.InOutPosition.INSIDE) {
    return!0;
  }
  var textBlock = tickText.textBlock;
  if (textBlock.angle) {
    return!0;
  }
  var boundingBox = gviz.canviz.TextBlockUtil.calcBoundingBox(textBlock);
  if (!boundingBox) {
    return!0;
  }
  var margin = textBlock.textStyle.fontSize / 2, boundingBoxWithMargin = new goog.math.Box(boundingBox.top, boundingBox.right + margin, boundingBox.bottom, boundingBox.left - margin), idx;
  for (idx in chartDef.vAxes) {
    var i = Number(idx);
    if (this.vAxisDefiners_[i].tickTextPosition == gviz.canviz.Options.InOutPosition.INSIDE) {
      var numberOfVerticalTicks = chartDef.vAxes[i].text ? chartDef.vAxes[i].text.length : 0;
      if (!(1 > numberOfVerticalTicks)) {
        var firstVerticalTickBoundingBox = gviz.canviz.TextBlockUtil.calcBoundingBox(chartDef.vAxes[i].text[0].textBlock), lastVerticalTickBoundingBox = gviz.canviz.TextBlockUtil.calcBoundingBox(goog.array.peek(chartDef.vAxes[i].text).textBlock);
        if (firstVerticalTickBoundingBox || lastVerticalTickBoundingBox) {
          if (firstVerticalTickBoundingBox && goog.math.Box.intersects(boundingBoxWithMargin, firstVerticalTickBoundingBox) || lastVerticalTickBoundingBox && goog.math.Box.intersects(boundingBoxWithMargin, lastVerticalTickBoundingBox)) {
            return!1;
          }
          var verticalMinLeft, verticalMaxRight;
          firstVerticalTickBoundingBox ? lastVerticalTickBoundingBox ? (verticalMinLeft = Math.min(firstVerticalTickBoundingBox.left, lastVerticalTickBoundingBox.left), verticalMaxRight = Math.max(firstVerticalTickBoundingBox.right, lastVerticalTickBoundingBox.right)) : (verticalMinLeft = firstVerticalTickBoundingBox.left, verticalMaxRight = firstVerticalTickBoundingBox.right) : (verticalMinLeft = lastVerticalTickBoundingBox.left, verticalMaxRight = lastVerticalTickBoundingBox.right);
          if (Math.abs(boundingBox.left - verticalMinLeft) < margin || Math.abs(boundingBox.right - verticalMaxRight) < margin) {
            return!1;
          }
        }
      }
    }
  }
  return!0;
};
gviz.canviz.AxisChartDefiner.prototype.isVerticalTickClearOfChartCollisions_ = function(vAxisDefiner, tickText) {
  var chartDef = this.chartDef, chartAreaBox = new goog.math.Box(chartDef.chartArea.top, chartDef.chartArea.right, chartDef.chartArea.bottom, chartDef.chartArea.left), textBlock = tickText.textBlock, margin = textBlock.textStyle.fontSize / 2, boundingBox = gviz.canviz.TextBlockUtil.calcBoundingBox(textBlock);
  if (!boundingBox) {
    return!0;
  }
  if (vAxisDefiner.tickTextPosition == gviz.canviz.Options.InOutPosition.INSIDE && !chartAreaBox.contains(boundingBox)) {
    return!1;
  }
  var boundingBoxWithMargin = new goog.math.Box(boundingBox.top, boundingBox.right + margin, boundingBox.bottom, boundingBox.left - margin), titleBoundingBox = gviz.canviz.TextBlockUtil.calcBoundingBox(chartDef.title);
  if (titleBoundingBox && goog.math.Box.intersects(boundingBoxWithMargin, titleBoundingBox)) {
    return!1;
  }
  var axisTitlesBoundingBox = chartDef.innerAxisTitle ? gviz.canviz.TextBlockUtil.calcBoundingBox(chartDef.innerAxisTitle) : null;
  if (axisTitlesBoundingBox && goog.math.Box.intersects(boundingBoxWithMargin, axisTitlesBoundingBox)) {
    return!1;
  }
  var legendBoundingBox = this.legendDefiner.getArea();
  return legendBoundingBox && goog.math.Box.intersects(boundingBoxWithMargin, legendBoundingBox) ? !1 : !0;
};
gviz.canviz.AxisChartDefiner.prototype.positionAnnotations_ = function() {
  var chartDef = this.chartDef, domainAxis = this.domainAxisDefiner_, options = this.options, defaultTextStyle = {fontName:chartDef.defaultFontName, fontSize:chartDef.defaultFontSize, auraColor:chartDef.insideLabelsAuraColor}, domainAnnotationTextStyle = options.inferTextStyleValue(["annotations.domain.textStyle", "annotations.textStyle"], defaultTextStyle), domainAnnotationBoxStyle = options.inferBrushValue(["annotations.domain.boxStyle", "annotations.boxStyle"]), domainAnnotationStemColor = options.inferColorValue(["annotations.domain.stemColor", 
  "annotations.stemColor"], ""), domainAnnotationStemLength = options.inferNumberValue(["annotations.domain.stemLength", "annotations.stemLength"], 5), domainAnnotationStyle = options.inferEnumValue(["annotations.domain.style", "annotations.style"], gviz.canviz.Options.AnnotationStyle, gviz.canviz.Options.AnnotationStyle.LETTER);
  goog.array.forEach(this.chartDef.categories, function(category, categoryIndex) {
    var categoryLetterAnnotations = [], categoryLineAnnotations = [];
    goog.array.forEach(chartDef.domainsColumnStructure, function(domainsColumnStructure) {
      var annotations = this.extractAnnotations_(categoryIndex, domainsColumnStructure.columns, domainAnnotationStyle);
      goog.array.extend(categoryLetterAnnotations, annotations.letter);
      goog.array.extend(categoryLineAnnotations, annotations.line);
    }, this);
    if (categoryLetterAnnotations.length || categoryLineAnnotations.length) {
      var numericDomainValue = this.getNumericDomainValue_(categoryIndex), x = domainAxis.calcPositionForNumericValue(numericDomainValue);
      goog.asserts.assert(goog.isDefAndNotNull(x));
      var y = chartDef.chartArea.top + chartDef.chartArea.height;
      goog.asserts.assert(goog.isDefAndNotNull(this.chartDef.orientation));
      if (categoryLetterAnnotations.length) {
        var targetPoint = {x:x, y:y};
        category.annotation = this.positionLetterAnnotation_(targetPoint, gviz.canviz.Options.SerieType.NONE, "", !1, this.chartDef.orientation, categoryLetterAnnotations, domainAnnotationTextStyle, domainAnnotationBoxStyle, domainAnnotationStemLength, domainAnnotationStemColor);
      }
      categoryLineAnnotations.length && (targetPoint = {x:x, y:null}, category.annotation = this.positionLineAnnotation_(targetPoint, categoryLineAnnotations, domainAnnotationTextStyle, domainAnnotationStemColor));
    }
  }, this);
  var relativeColors = goog.object.getValues(gviz.canviz.Options.SeriesRelativeColor), globalUseHighContrast = options.inferBooleanValue(["annotations.datum.highContrast", "annotations.highContrast"], !0), globalOutsideOnly = options.inferBooleanValue(["annotations.datum.alwaysOutside", "annotations.alwaysOutside"], !1), defaultDatumAnnotationTextStyle = options.inferExtendedColorTextStyleValue(["annotations.datum.textStyle", "annotations.textStyle"], relativeColors, defaultTextStyle), defaultDatumAnnotationBoxStyle = 
  options.inferBrushValue(["annotations.datum.boxStyle", "annotations.boxStyle"]), defaultDatumAnnotationStemColor = options.inferExtendedColorValue(["annotations.datum.stemColor", "annotations.stemColor"], relativeColors, ""), defaultDatumAnnotationStemLength = options.inferNumberValue(["annotations.datum.stemLength", "annotations.stemLength"], 12), defaultDatumAnnotationStyle = options.inferEnumValue(["annotations.datum.style", "annotations.style"], gviz.canviz.Options.AnnotationStyle, gviz.canviz.Options.AnnotationStyle.LETTER);
  goog.array.forEach(this.chartDef.series, function(serie, serieIndex) {
    if (serie.type == gviz.canviz.Options.SerieType.AREA || serie.type == gviz.canviz.Options.SerieType.BARS || serie.type == gviz.canviz.Options.SerieType.LINE || serie.type == gviz.canviz.Options.SerieType.SCATTER) {
      var optionsPrefix = "series." + serieIndex + ".annotations.", useHighContrast = options.inferBooleanValue(optionsPrefix + "highContrast", globalUseHighContrast), alwaysOutside = options.inferBooleanValue(optionsPrefix + "alwaysOutside", globalOutsideOnly), serieAnnotationTextStyle = options.inferExtendedColorTextStyleValue(optionsPrefix + "textStyle", relativeColors, defaultDatumAnnotationTextStyle);
      serieAnnotationTextStyle.color = gviz.canviz.AxisChartDefiner.resolveSerieRelativeColor_(serieAnnotationTextStyle.color, serie.color);
      var serieAnnotationBoxStyle = options.inferBrushValue([optionsPrefix + "boxStyle"], defaultDatumAnnotationBoxStyle), serieAnnotationStemColor = options.inferExtendedColorValue(optionsPrefix + "stemColor", relativeColors, defaultDatumAnnotationStemColor), serieAnnotationStemLength = options.inferNumberValue(optionsPrefix + "stemLength", defaultDatumAnnotationStemLength), serieAnnotationStemColor = gviz.canviz.AxisChartDefiner.resolveSerieRelativeColor_(serieAnnotationStemColor, serie.color);
      options.inferEnumValue(optionsPrefix + "style", gviz.canviz.Options.AnnotationStyle, defaultDatumAnnotationStyle);
      for (var i = 0;i < serie.points.length;++i) {
        if (goog.isDefAndNotNull(serie.points[i]) && goog.isDefAndNotNull(serie.points[i].scaled)) {
          var point = serie.points[i], annotations = this.extractAnnotations_(i, serie.columns, defaultDatumAnnotationStyle), scaledPoint = point.scaled, seriesColor = serie.pointBrush.hasFill() ? serie.pointBrush.getFill() : useHighContrast ? "#fff" : "#000", datumColor = point.brush && point.brush.hasFill() ? point.brush.getFill() : seriesColor;
          if (datumColor !== seriesColor && useHighContrast) {
            var textStyle = goog.object.clone(serieAnnotationTextStyle), factors = [.1, .2, .3], rgbDatumColor = goog.color.hexToRgb(datumColor), bgColor = goog.color.hexToRgb(this.chartDef.backgroundBrush.getFill()), darkerDatumColors = goog.array.map(factors, goog.partial(goog.color.darken, rgbDatumColor)), lighterDatumColors = goog.array.map(factors, goog.partial(goog.color.lighten, rgbDatumColor)), datumColors = goog.array.concat([rgbDatumColor], darkerDatumColors, lighterDatumColors), candidateTextColor = 
            goog.color.rgbArrayToHex(goog.color.highContrast(bgColor, datumColors));
            textStyle.color = candidateTextColor;
          } else {
            textStyle = serieAnnotationTextStyle;
          }
          goog.asserts.assert(goog.isDefAndNotNull(this.chartDef.orientation));
          annotations.letter.length && (serie.points[i].annotation = this.positionLetterAnnotation_(scaledPoint, serie.type, datumColor, this.chartDef.isStacked, this.chartDef.orientation, annotations.letter, textStyle, serieAnnotationBoxStyle, serieAnnotationStemLength, serieAnnotationStemColor, useHighContrast, alwaysOutside));
          annotations.line.length && (serie.points[i].annotation = this.positionLineAnnotation_(scaledPoint, annotations.line, serieAnnotationTextStyle, serieAnnotationStemColor));
        }
      }
    }
  }, this);
};
gviz.canviz.AxisChartDefiner.prototype.extractAnnotations_ = function(rowNumber, roleToColumns, defaultStyle) {
  var dataView = this.dataView, annotationColumns = roleToColumns[gviz.canviz.ColumnRole.ANNOTATION], annotations = {line:[], letter:[]};
  if (!goog.isDefAndNotNull(annotationColumns)) {
    return annotations;
  }
  for (var tooltipColumns = roleToColumns[gviz.canviz.ColumnRole.ANNOTATION_TEXT] || [], i = 0;i < annotationColumns.length;++i) {
    var annotationColumn = annotationColumns[i], annotationTooltipColumn = annotationColumn + 1, hasAnnotationTooltipColumn = 0 <= goog.array.indexOf(tooltipColumns, annotationTooltipColumn);
    if (dataView.getValue(rowNumber, annotationColumn)) {
      var annotation = {text:dataView.getFormattedValue(rowNumber, annotationColumn), tooltipColumnIndex:hasAnnotationTooltipColumn ? annotationTooltipColumn : null, rowIndex:rowNumber}, optionPath = "annotation." + annotationColumn + ".style", style = this.options.inferEnumValue(optionPath, gviz.canviz.Options.AnnotationStyle, defaultStyle);
      style == gviz.canviz.Options.AnnotationStyle.LINE ? annotations.line.push(annotation) : annotations.letter.push(annotation);
    }
  }
  return annotations;
};
gviz.canviz.AxisChartDefiner.prototype.createAnnotationBundle_ = function(target, type, annotations, textStyle, x, y) {
  var bundle = null, collapsedText = annotations[0].text + " [+]", collapsedSize = this.textMeasureFunction(collapsedText, textStyle);
  if (type === gviz.canviz.Options.SerieType.BARS && collapsedSize.width > target.width) {
    var bundleLabelX = target.left, bundleParalAlign = gviz.graphics.TextAlign.START
  } else {
    bundleLabelX = x, bundleParalAlign = gviz.graphics.TextAlign.CENTER;
  }
  bundle = {isExpanded:!1, label:{text:collapsedText, textStyle:textStyle, lines:[{x:0, y:0, length:collapsedSize.width, text:collapsedText}], paralAlign:bundleParalAlign, perpenAlign:gviz.graphics.TextAlign.END, anchor:new gviz.math.Coordinate(bundleLabelX, y), angle:0}};
  this.isTooltipEnabled_ && (bundle.label.tooltip = "Click to expand annotations");
  return bundle;
};
gviz.canviz.AxisChartDefiner.prototype.positionLetterAnnotation_ = function(target, type, color, isStacked, orientation, annotations, textStyle, boxStyle, stemLength, stemColor, opt_useHighContrast, opt_alwaysOutside) {
  var annotationColors = [[64, 64, 64], [128, 128, 128], [255, 255, 255]], useHighContrast = null == opt_useHighContrast ? !0 : opt_useHighContrast, isBar = type === gviz.canviz.Options.SerieType.BARS, stemX, stemY;
  if (isBar) {
    var barRect = new goog.math.Rect(target.left, target.top, target.width, target.height), y = stemY = target.top, x = stemX = Math.floor(target.left + target.width / 2)
  } else {
    var x = stemX = target.x, y = stemY = target.y
  }
  var labelY = y - stemLength, bundleLabelY = labelY, actualStemLength = -stemLength, numOfAnnotations = annotations.length, totalHeight = stemLength + textStyle.fontSize * numOfAnnotations;
  y - totalHeight < this.chartDef.chartArea.top && y + totalHeight < this.chartDef.chartArea.bottom && (labelY = y + totalHeight, bundleLabelY = y + stemLength + textStyle.fontSize, actualStemLength = stemLength);
  var bundle = null;
  1 < numOfAnnotations && (bundle = this.createAnnotationBundle_(target, type, annotations, textStyle, x, bundleLabelY));
  for (var labels = [], i = 0;i < numOfAnnotations;i++) {
    var annotation = annotations[i], textSize = this.textMeasureFunction(annotation.text, textStyle), label = {}, anchor = new gviz.math.Coordinate(stemX, labelY), labelInBar = null;
    label.textStyle = gviz.json.clone(textStyle);
    if (isBar) {
      if (barRect && !opt_alwaysOutside) {
        var seriesColor = goog.color.hexToRgb(color), candidateLabelColor = goog.color.rgbArrayToHex(goog.color.highContrast(seriesColor, annotationColors)), position = orientation === gviz.canviz.Options.Orientation.HORIZONTAL ? gviz.common.text.TextBlock.Position.TOP : gviz.common.text.TextBlock.Position.RIGHT, newTextStyle = gviz.json.clone(textStyle);
        useHighContrast && (newTextStyle.auraColor = "none", newTextStyle.color = candidateLabelColor);
        labelInBar = gviz.common.text.TextBlock.createToFit(annotation.text, newTextStyle, position, barRect, this.textMeasureFunction, this.isTooltipEnabled_, 2, 2);
      }
      if (opt_alwaysOutside || !isStacked && (!labelInBar || 1 < labelInBar.lines.length || labelInBar.truncated)) {
        switch(orientation) {
          case gviz.canviz.Options.Orientation.HORIZONTAL:
            label.perpenAlign = gviz.graphics.TextAlign.END;
            target.width > textSize.width ? (anchor.x = stemX, label.paralAlign = gviz.graphics.TextAlign.CENTER) : (anchor.x = barRect.left, label.paralAlign = gviz.graphics.TextAlign.START);
            break;
          case gviz.canviz.Options.Orientation.VERTICAL:
            anchor.x = barRect.left + barRect.width + 2, label.paralAlign = gviz.graphics.TextAlign.START, label.perpenAlign = gviz.graphics.TextAlign.CENTER, anchor.y = barRect.getCenter().y;
        }
      }
    } else {
      anchor.x = x, label.paralAlign = gviz.graphics.TextAlign.CENTER, label.perpenAlign = gviz.graphics.TextAlign.END;
    }
    if (labelInBar && (isStacked || !isStacked && !labelInBar.truncated)) {
      labels.push(labelInBar);
      var noStem = !0;
    } else {
      switch(orientation) {
        case gviz.canviz.Options.Orientation.HORIZONTAL:
          label.paralAlign = gviz.graphics.TextAlign.CENTER;
          label.perpenAlign = gviz.graphics.TextAlign.END;
          break;
        case gviz.canviz.Options.Orientation.VERTICAL:
          label.paralAlign = gviz.graphics.TextAlign.START, label.perpenAlign = gviz.graphics.TextAlign.CENTER;
      }
      label.text = annotation.text;
      label.textStyle = textStyle;
      label.boxStyle = boxStyle;
      label.anchor = anchor;
      label.truncated = !1;
      label.lines = [{x:0, y:0, length:textSize.width, text:annotation.text}];
      label.angle = 0;
      var tooltipColumnIndex = annotation.tooltipColumnIndex;
      this.isTooltipEnabled_ && goog.isDefAndNotNull(tooltipColumnIndex) && (label.tooltipText = this.getCustomTooltipText_(tooltipColumnIndex, annotation.rowIndex));
      labels.push(label);
      labelY -= textStyle.fontSize;
    }
  }
  stemLength = noStem ? 0 : actualStemLength;
  var stemOrientation = gviz.canviz.Options.Orientation.VERTICAL;
  isBar && orientation === gviz.canviz.Options.Orientation.VERTICAL && (stemLength = 0, stemOrientation = gviz.canviz.Options.Orientation.HORIZONTAL, stemX = target.left + target.width, stemY = Math.floor(target.top + target.height / 2));
  return{stem:{x:stemX, y:stemY, length:stemLength, orientation:stemOrientation, color:stemColor}, labels:labels, bundle:bundle ? bundle : null};
};
gviz.canviz.AxisChartDefiner.prototype.positionLineAnnotation_ = function(point, annotations, textStyle, lineColor) {
  for (var x = point.x, y = point.y, margins = textStyle.fontSize, textLayouts = [], i = 0;i < annotations.length;i++) {
    var annotation = annotations[i], textLayout = gviz.canviz.textutils.calcTextLayout(this.chartDef.textMeasureFunction, annotation.text, textStyle, this.chartDef.chartArea.height - margins);
    textLayouts.push(textLayout);
  }
  var stemTop, stemBottom;
  if (goog.isDefAndNotNull(y)) {
    for (var maxAnnotationLength = 0, i = 0;i < textLayouts.length;i++) {
      textLayout = textLayouts[i], maxAnnotationLength = Math.max(maxAnnotationLength, textLayout.maxLineWidth);
    }
    var stemLength = maxAnnotationLength + margins;
    stemTop = Math.round(y - stemLength / 2);
    stemTop < this.chartDef.chartArea.top && (stemTop = this.chartDef.chartArea.top);
    stemBottom = stemTop + stemLength;
    stemBottom > this.chartDef.chartArea.bottom && (stemBottom = this.chartDef.chartArea.bottom, stemTop = stemBottom - stemLength);
  } else {
    stemTop = this.chartDef.chartArea.top, stemBottom = this.chartDef.chartArea.bottom;
  }
  for (var stemMiddle = Math.round((stemTop + stemBottom) / 2), labelX = x + 2, labels = [], i = 0;i < annotations.length;i++) {
    var annotation = annotations[i], textLayout = textLayouts[i], label = {text:annotation, textStyle:textStyle, lines:[{x:labelX, y:stemMiddle, length:textLayout.maxLineWidth, text:textLayout.lines[0]}], paralAlign:gviz.graphics.TextAlign.CENTER, perpenAlign:gviz.graphics.TextAlign.START, anchor:null, angle:270}, tooltipColumnIndex = annotation.tooltipColumnIndex;
    this.isTooltipEnabled_ && goog.isDefAndNotNull(tooltipColumnIndex) && (label.tooltipText = this.getCustomTooltipText_(tooltipColumnIndex, annotation.rowIndex));
    labels.push(label);
    labelX += textStyle.fontSize;
  }
  return{stem:{x:x, y:stemTop, length:stemBottom - stemTop, orientation:gviz.canviz.Options.Orientation.VERTICAL, color:lineColor}, labels:labels, bundle:null};
};
gviz.canviz.AxisChartDefiner.prototype.positionNonScaledElementsForSerie_ = function(serieIndex) {
  var chartDef = this.chartDef, serie = chartDef.series[serieIndex], scaleFunction = this.chooseScaleFunctionForSerie_(serie);
  serie.points && goog.array.forEach(serie.points, function(point) {
    goog.isDefAndNotNull(point) && (point.scaled = scaleFunction(point.nonScaled), goog.isDefAndNotNull(point.nonScaledLeftControlPoint) && (point.leftControlPoint = scaleFunction(point.nonScaledLeftControlPoint)), goog.isDefAndNotNull(point.nonScaledRightControlPoint) && (point.rightControlPoint = scaleFunction(point.nonScaledRightControlPoint)));
  });
  serie.intervals && (0 < serie.intervals.lines.length || 0 < serie.intervals.areas.length) && this.createPathIntervals_(serie);
};
gviz.canviz.AxisChartDefiner.prototype.positionNonScaledElements_ = function() {
  var chartDef = this.chartDef;
  goog.array.forEach(chartDef.series, function(serie, serieIndex) {
    this.positionNonScaledElementsForSerie_(serieIndex);
  }, this);
};
gviz.canviz.AxisChartDefiner.prototype.createPathIntervals_ = function(serie) {
  var paths = {}, settings = serie.intervals.settings;
  serie.intervals.paths = [];
  for (var intervalIsPathInterval = function(columnIndex) {
    var style = settings[columnIndex].style;
    return style == gviz.canviz.Options.IntervalStyle.AREA || style == gviz.canviz.Options.IntervalStyle.LINE;
  }, addPathVerticesFromIntervalRect = function(columnIndex, rect) {
    paths[columnIndex] || addIntervalPath(columnIndex);
    paths[columnIndex].line.push(new goog.math.Vec2(rect.left, rect.top));
    paths[columnIndex].bottom && paths[columnIndex].bottom.push(new goog.math.Vec2(rect.left + rect.width, rect.top + rect.height));
  }, addIntervalPath = function(columnIndex) {
    var brush = settings[columnIndex].brush.clone(), style = settings[columnIndex].style, path = {};
    path.columnIndex = columnIndex;
    path.line = [];
    style == gviz.canviz.Options.IntervalStyle.AREA ? (brush.setStrokeWidth(0), path.bottom = []) : brush.setFillOpacity(0);
    path.brush = brush;
    paths[columnIndex] = path;
  }, flushIntervalPath = function(columnIndex) {
    var path = paths[columnIndex];
    delete paths[columnIndex];
    if (path && 1 < path.line.length) {
      path.bottom && path.bottom.reverse();
      if (settings[columnIndex].curveType != gviz.canviz.Options.CurveType.NONE) {
        var isFunction = settings[columnIndex].curveType == gviz.canviz.Options.CurveType.FUNCTION, smoothingFactor = settings[columnIndex].smoothingFactor;
        path.controlPoints = gviz.canviz.util.calculateControlPoints(path.line, smoothingFactor, isFunction, !1, !1);
        path.bottom && (path.bottomControlPoints = gviz.canviz.util.calculateControlPoints(path.bottom, smoothingFactor, isFunction, !1, !1));
      }
      serie.intervals.paths.push(path);
    }
  }, i = 0;i < serie.points.length;i++) {
    var seenColumnIndices = {}, point = serie.points[i];
    if (point && point.scaled && point.scaled.intervalRects) {
      for (var intervalRects = point.scaled.intervalRects, rectIndex = 0;rectIndex < intervalRects.length;++rectIndex) {
        var columnIndex$$0 = intervalRects[rectIndex].columnIndex;
        intervalIsPathInterval(columnIndex$$0) && (seenColumnIndices[columnIndex$$0] = !0, addPathVerticesFromIntervalRect(columnIndex$$0, intervalRects[rectIndex].rect));
      }
    }
    for (columnIndex$$0 in paths) {
      seenColumnIndices[columnIndex$$0] || settings[columnIndex$$0].interpolateNulls || flushIntervalPath(columnIndex$$0);
    }
  }
  for (columnIndex$$0 in paths) {
    flushIntervalPath(columnIndex$$0);
  }
};
gviz.canviz.AxisChartDefiner.prototype.chooseScaleFunctionForSerie_ = function(serie) {
  switch(serie.type) {
    case gviz.canviz.Options.SerieType.SCATTER:
      return goog.bind(this.scaleScatterPoint_, this, serie);
    case gviz.canviz.Options.SerieType.BUBBLES:
      return goog.bind(this.scaleBubblePoint_, this, serie);
    case gviz.canviz.Options.SerieType.LINE:
      return goog.bind(this.scaleLinePoint_, this, serie);
    case gviz.canviz.Options.SerieType.BARS:
      return goog.bind(this.scaleBar_, this, serie);
    case gviz.canviz.Options.SerieType.STEPPED_AREA:
      return goog.bind(this.scaleSteppedArea_, this, serie);
    case gviz.canviz.Options.SerieType.CANDLESTICKS:
      return goog.bind(this.scaleCandlestick_, this, serie);
    case gviz.canviz.Options.SerieType.AREA:
      return goog.bind(this.scaleAreaPoint_, this, serie);
  }
  return null;
};
gviz.canviz.AxisChartDefiner.prototype.scaleScatterPoint_ = function(serie, nonScaledPoint) {
  goog.asserts.assert(goog.isDefAndNotNull(this.hAxisDefiners_) && this.hAxisDefiners_[0]);
  goog.asserts.assert(goog.isDefAndNotNull(this.vAxisDefiners_) && this.vAxisDefiners_[0]);
  var x = this.hAxisDefiners_[0].calcPositionForNumericValue(nonScaledPoint.x), y = this.vAxisDefiners_[0].calcPositionForNumericValue(nonScaledPoint.y);
  return{x:x, y:y};
};
gviz.canviz.AxisChartDefiner.prototype.scaleBubblePoint_ = function(serie, nonScaledPoint) {
  goog.asserts.assert(goog.isDefAndNotNull(this.hAxisDefiners_) && this.hAxisDefiners_[0]);
  goog.asserts.assert(goog.isDefAndNotNull(this.vAxisDefiners_) && this.vAxisDefiners_[0]);
  goog.asserts.assert(this.bubbleChartDefiner_);
  return this.bubbleChartDefiner_.scaleBubble(this.hAxisDefiners_[0], this.vAxisDefiners_[0], nonScaledPoint);
};
gviz.canviz.AxisChartDefiner.prototype.scaleLinePoint_ = function(serie, nonScaledPoint) {
  var scaled = this.getPhysicalPositionByFunctionValues_(serie.targetAxisIndex, nonScaledPoint.d, nonScaledPoint.t);
  scaled.intervalRects = this.scaleIntervals_(serie, nonScaledPoint);
  return scaled;
};
gviz.canviz.AxisChartDefiner.prototype.scaleBar_ = function(serie, nonScaledPoint) {
  var scaled = this.scaleBarlike_(serie, nonScaledPoint, nonScaledPoint.from, nonScaledPoint.to);
  return scaled ? {top:scaled.top, left:scaled.left, width:scaled.width, height:scaled.height, intervalRects:this.scaleIntervals_(serie, nonScaledPoint)} : null;
};
gviz.canviz.AxisChartDefiner.prototype.scaleCandlestick_ = function(serie, nonScaledPoint) {
  var rect = this.scaleBarlike_(serie, nonScaledPoint, nonScaledPoint.rectFrom, nonScaledPoint.rectTo), line = this.scaleBarlike_(serie, nonScaledPoint, nonScaledPoint.lineFrom, nonScaledPoint.lineTo);
  if (!rect || !line) {
    return null;
  }
  line.width = 2;
  var lineWidth = rect.width % 2 ? 3 : 2;
  line.left += (rect.width - lineWidth) / 2;
  var barBrush = this.getCandleStickBrush_(nonScaledPoint.inverted, serie);
  if (barBrush.hasStroke()) {
    var strokeCompensation = barBrush.getStrokeWidth() / 2;
    rect.height -= 2 * strokeCompensation;
    rect.width -= 2 * strokeCompensation;
    rect.left += strokeCompensation;
    rect.top += strokeCompensation;
  }
  rect.height = Math.max(rect.height, 2);
  rect.width = Math.max(rect.width, 1);
  return{rect:rect, line:line};
};
gviz.canviz.AxisChartDefiner.prototype.getCandleStickBrush_ = function(inverted, serie) {
  return inverted ? serie.candlestick.fallingBrush : serie.candlestick.risingBrush;
};
gviz.canviz.AxisChartDefiner.prototype.getDiffBarBrush_ = function(serie, columnRole) {
  return columnRole == gviz.canviz.ColumnRole.DIFF_OLD_DATA ? serie.diff.background.pointBrush : null;
};
gviz.canviz.AxisChartDefiner.prototype.scaleSteppedArea_ = function(serie, nonScaledPoint) {
  var targetAxis = this.targetAxisDefiners_[serie.targetAxisIndex];
  goog.isDefAndNotNull(nonScaledPoint.from) || (nonScaledPoint.from = targetAxis.valueScale.valueToNumber(targetAxis.baseline.dataValue));
  var domainAxis = this.domainAxisDefiner_, division = nonScaledPoint.division, divisionMiddle = domainAxis.ticks[division].coordinate, divisionWidth = domainAxis.numericValueToPixelsFactor, domainFrom = Math.floor(divisionMiddle - domainAxis.direction * divisionWidth / 2), domainTo = Math.floor(divisionMiddle + domainAxis.direction * divisionWidth / 2), targetFrom = targetAxis.calcPositionForNumericValue(nonScaledPoint.from), targetTo = targetAxis.calcPositionForNumericValue(nonScaledPoint.to), 
  corner1 = this.getPhysicalPositionByFunctionPositions_(domainFrom, targetFrom), corner3 = this.getPhysicalPositionByFunctionPositions_(domainFrom, targetTo), corner4 = this.getPhysicalPositionByFunctionPositions_(domainTo, targetTo), outline = [], connectSteps = this.options.inferBooleanValue("connectSteps", !0);
  if (connectSteps && goog.isDefAndNotNull(nonScaledPoint.previousTo)) {
    var previousDomainTo = domainFrom, previousTargetTo = targetAxis.calcPositionForNumericValue(nonScaledPoint.previousTo), previousCorner4 = this.getPhysicalPositionByFunctionPositions_(previousDomainTo, previousTargetTo);
    outline.push(previousCorner4);
  }
  outline.push(corner3);
  outline.push(corner4);
  return{bar:gviz.canviz.vectorutils.cornersToRectangle(corner1.x, corner1.y, corner4.x, corner4.y), outline:outline, intervalRects:this.scaleIntervals_(serie, nonScaledPoint)};
};
gviz.canviz.AxisChartDefiner.prototype.getBarScaledMin_ = function(targetAxis, from, to) {
  return Math.min(targetAxis.calcPositionForNumericValue(from), targetAxis.calcPositionForNumericValue(to));
};
gviz.canviz.AxisChartDefiner.prototype.getBarScaledMax_ = function(targetAxis, from, to) {
  return Math.max(targetAxis.calcPositionForNumericValue(from), targetAxis.calcPositionForNumericValue(to));
};
gviz.canviz.AxisChartDefiner.prototype.scaleBarlike_ = function(serie, nonScaledPoint, from, to) {
  var domainAxis = this.domainAxisDefiner_, targetAxis = this.targetAxisDefiners_[serie.targetAxisIndex], subDivisionDef = this.subDivisionDefinition_;
  goog.asserts.assert(subDivisionDef);
  if (!goog.isDefAndNotNull(from)) {
    var targetBaseline = targetAxis.valueScale.valueToNumber(targetAxis.baseline.dataValue);
    from = targetBaseline;
  }
  if (nonScaledPoint.subDivision >= subDivisionDef.actualNumOfSubDivisions || nonScaledPoint.division >= domainAxis.ticks.length && domainAxis.type != gviz.canviz.Options.AxisType.VALUE) {
    return null;
  }
  var scaledMin = this.getBarScaledMin_(targetAxis, from, to), scaledMax = this.getBarScaledMax_(targetAxis, from, to), histogram = this.chartDef.chartType === gviz.canviz.Options.ChartType.HISTOGRAM, margin;
  margin = histogram ? gviz.canviz.HistogramChartDefiner.treatHistogramAsColumnChart(targetAxis.numericValueToPixelsFactor, this.options.inferBooleanValue("histogram.hideBucketItems")) ? 0 : 1 : Math.min(1, .2 * (scaledMax - scaledMin));
  0 === margin || Math.floor(scaledMin + margin) < Math.floor(scaledMax) && Math.floor(scaledMin + margin) > Math.floor(scaledMin) ? (scaledMin = Math.floor(scaledMin + margin), scaledMax = Math.floor(scaledMax)) : scaledMin += margin;
  var newDataWidthScaleFactor = this.options.inferNumberValue("diff.newData.widthFactor", gviz.canviz.Options.DEFAULT_DIFF_NEW_DATA_WIDTH_FACTOR), widthScaleFactor = nonScaledPoint.isDiffForeground ? newDataWidthScaleFactor : 1, domainAxisCenter = this.getPointCenterAlongDomainAxis_(nonScaledPoint), domainAxisHalfWidth = widthScaleFactor * subDivisionDef.subDivisionWidth / 2, domainAxisFrom = (histogram ? Math.ceil : Math.floor)(domainAxisCenter - domainAxisHalfWidth), domainAxisTo = Math.floor(domainAxisCenter + 
  domainAxisHalfWidth), corner1 = this.getPhysicalPositionByFunctionPositions_(domainAxisFrom, scaledMin), corner2 = this.getPhysicalPositionByFunctionPositions_(domainAxisTo, scaledMax), rect = gviz.canviz.vectorutils.cornersToRectangle(corner1.x, corner1.y, corner2.x, corner2.y);
  return rect;
};
gviz.canviz.AxisChartDefiner.prototype.scaleAreaPoint_ = function(serie, nonScaledPoint) {
  var targetAxis = this.targetAxisDefiners_[serie.targetAxisIndex], targetBaseline = targetAxis.valueScale.valueToNumber(targetAxis.baseline.dataValue), applyBaseline = function(v) {
    return goog.isDefAndNotNull(v) ? v : targetBaseline;
  }, p = this.getPhysicalPositionByFunctionValues_(serie.targetAxisIndex, nonScaledPoint.d, nonScaledPoint.t), bottomFrom = this.getPhysicalPositionByFunctionValues_(serie.targetAxisIndex, nonScaledPoint.bottomFromD, applyBaseline(nonScaledPoint.bottomFromT)), bottomTo = this.getPhysicalPositionByFunctionValues_(serie.targetAxisIndex, nonScaledPoint.bottomToD, applyBaseline(nonScaledPoint.bottomToT)), continueFrom = this.getPhysicalPositionByFunctionValues_(serie.targetAxisIndex, nonScaledPoint.continueFromD, 
  applyBaseline(nonScaledPoint.continueFromT)), continueTo = this.getPhysicalPositionByFunctionValues_(serie.targetAxisIndex, nonScaledPoint.continueToD, applyBaseline(nonScaledPoint.continueToT)), intervalRects = this.scaleIntervals_(serie, nonScaledPoint);
  return{x:p.x, y:p.y, bottomFromX:bottomFrom.x, bottomFromY:bottomFrom.y, bottomToX:bottomTo.x, bottomToY:bottomTo.y, continueFromX:continueFrom.x, continueFromY:continueFrom.y, continueToX:continueTo.x, continueToY:continueTo.y, intervalRects:intervalRects};
};
gviz.canviz.AxisChartDefiner.prototype.scaleIntervals_ = function(serie, nonScaledPoint) {
  if (!nonScaledPoint.intervalMarks) {
    return[];
  }
  var domainAxis = this.domainAxisDefiner_, targetAxis = this.targetAxisDefiners_[serie.targetAxisIndex], subDivisionDef = this.subDivisionDefinition_;
  goog.asserts.assert(subDivisionDef);
  if (nonScaledPoint.subDivision >= subDivisionDef.actualNumOfSubDivisions || nonScaledPoint.division >= domainAxis.ticks.length && domainAxis.type != gviz.canviz.Options.AxisType.VALUE) {
    return[];
  }
  for (var domainCenter = this.getPointCenterAlongDomainAxis_(nonScaledPoint), intervalRects = [], i = 0, mark;mark = nonScaledPoint.intervalMarks[i];i++) {
    var highPosition = targetAxis.calcPositionForNumericValue(mark.highT), lowPosition = targetAxis.calcPositionForNumericValue(mark.lowT), domianSpacing;
    domianSpacing = domainAxis.type == gviz.canviz.Options.AxisType.VALUE ? domainAxis.ticks && 1 < domainAxis.ticks.length ? domainAxis.ticks[1].coordinate - domainAxis.ticks[0].coordinate : 0 : subDivisionDef.subDivisionWidth;
    var domainSize = domianSpacing * mark.spanD, targetSize = Math.abs(highPosition - lowPosition), leftTop = this.getPhysicalPositionByFunctionPositions_(domainCenter - domainSize / 2, Math.min(lowPosition, highPosition)), left = leftTop.x, top = leftTop.y, widthHeight = this.getPhysicalPositionByFunctionPositions_(domainSize, targetSize), width = widthHeight.x, height = widthHeight.y, boundingBox = new goog.math.Rect(left, top, width, height);
    intervalRects.push({rect:boundingBox, columnIndex:mark.columnIndex});
  }
  return intervalRects;
};
gviz.canviz.AxisChartDefiner.prototype.getPointCenterAlongDomainAxis_ = function(nonScaledPoint) {
  var domainAxis = this.domainAxisDefiner_, subDivisionDef = this.subDivisionDefinition_;
  goog.asserts.assert(subDivisionDef);
  var targetNumericValue;
  targetNumericValue = domainAxis.type == gviz.canviz.Options.AxisType.VALUE ? domainAxis.calcPositionForNumericValue(nonScaledPoint.d) : domainAxis.ticks[nonScaledPoint.division].coordinate;
  return targetNumericValue - subDivisionDef.divisionOffsetFromTick + (subDivisionDef.subDivisionWidth + 1) * nonScaledPoint.subDivision + subDivisionDef.subDivisionWidth / 2;
};
gviz.canviz.AxisChartDefiner.resolveSerieRelativeColor_ = function(colorString, serieColor) {
  switch(colorString) {
    case gviz.canviz.Options.SeriesRelativeColor.DARK:
      return serieColor.dark;
    case gviz.canviz.Options.SeriesRelativeColor.LIGHT:
      return serieColor.light;
    case gviz.canviz.Options.SeriesRelativeColor.COLOR:
      return serieColor.color;
    default:
      return colorString;
  }
};
gviz.canviz.AxisChartDefiner.prototype.getPhysicalPositionByFunctionPositions_ = function(domainPos, targetPos) {
  goog.asserts.assert(!isNaN(domainPos));
  goog.asserts.assert(!isNaN(targetPos));
  switch(this.chartDef.orientation) {
    case gviz.canviz.Options.Orientation.HORIZONTAL:
      return{x:domainPos, y:targetPos};
    case gviz.canviz.Options.Orientation.VERTICAL:
      return{x:targetPos, y:domainPos};
  }
  throw Error("Invalid orientation.");
};
gviz.canviz.AxisChartDefiner.prototype.getPhysicalPositionByFunctionValues_ = function(targetAxisIndex, domainValue, targetValue) {
  var domainAxisDefiner = this.domainAxisDefiner_, targetAxisDefiner = this.targetAxisDefiners_[targetAxisIndex], d = domainAxisDefiner.calcPositionForNumericValue(domainValue), t = targetAxisDefiner.calcPositionForNumericValue(targetValue), point = this.getPhysicalPositionByFunctionPositions_(d, t);
  return point;
};
gviz.canviz.AxisChartDefiner.prototype.createUncertainBrush_ = function(normalBrush, needStroking) {
  var brush = normalBrush.clone();
  brush.hasFill() && "#ffffff" != brush.getFill() ? (brush.setPattern(new gviz.graphics.Pattern(gviz.graphics.Pattern.Style.PRIMARY_DIAGONAL_STRIPES, brush.getFill())), !brush.hasStroke() && needStroking && (brush.setStroke(brush.getFill()), brush.setStrokeWidth(1))) : brush.hasStroke() && brush.setStrokeDashStyle(gviz.graphics.Brush.StrokeDashStyleType.DASH);
  return brush;
};
gviz.canviz.AxisChartDefiner.prototype.createEmphasizedBrush_ = function(normalBrush, emphasis) {
  var brush = normalBrush.clone();
  brush.setStrokeWidth(brush.getStrokeWidth() * emphasis);
  return brush;
};
gviz.canviz.AxisChartDefiner.prototype.calcCertainty_ = function(serie, categoryIndex) {
  var dataView = this.dataView, certaintyColumns = serie.columns[gviz.canviz.ColumnRole.CERTAINTY] || [];
  if (certaintyColumns.length) {
    var certainty = dataView.getValue(categoryIndex, certaintyColumns[0]);
    if (goog.isDefAndNotNull(certainty)) {
      return "boolean" == dataView.getColumnType(certaintyColumns[0]) ? certainty ? 1 : 0 : certainty;
    }
  }
  return 1;
};
gviz.canviz.AxisChartDefiner.prototype.calcScope_ = function(serie, categoryIndex) {
  var dataView = this.dataView, scopeColumns = serie.columns[gviz.canviz.ColumnRole.SCOPE] || [];
  if (scopeColumns.length) {
    var scope = dataView.getValue(categoryIndex, scopeColumns[0]);
    if (goog.isDefAndNotNull(scope)) {
      return!!scope;
    }
  }
  return!0;
};
gviz.canviz.AxisChartDefiner.prototype.calcEmphasis_ = function(serie, categoryIndex) {
  var dataView = this.dataView, emphasisColumns = serie.columns[gviz.canviz.ColumnRole.EMPHASIS] || [];
  if (emphasisColumns.length) {
    var emphasis = dataView.getValue(categoryIndex, emphasisColumns[0]);
    if (goog.isDefAndNotNull(emphasis)) {
      return "boolean" == dataView.getColumnType(emphasisColumns[0]) ? emphasis ? 2 : 1 : emphasis;
    }
  }
  return 1;
};
gviz.canviz.AxisChartDefiner.prototype.calcGap_ = function(categoryIndex) {
  var gapColumn = this.findGapColumn_();
  if (!goog.isNull(gapColumn)) {
    var gap = this.dataView.getValue(categoryIndex, gapColumn);
    return gap;
  }
  return null;
};
gviz.canviz.AxisChartDefiner.prototype.findGapColumn_ = function() {
  if (goog.isNull(this.domainAxisDefiner_) || this.domainAxisDefiner_.type != gviz.canviz.Options.AxisType.VALUE) {
    return null;
  }
  var domainRelatedColumns = this.chartDef.domainsColumnStructure[0].columns, gapColumns = domainRelatedColumns[gviz.canviz.ColumnRole.GAP] || [];
  return goog.array.isEmpty(gapColumns) ? null : gapColumns[0];
};
gviz.canviz.AxisChartDefiner.prototype.calcIntervalsLayout_ = function(serie, division, offset, shouldExtendTargetAxisRange) {
  var intervals = serie.intervals;
  if (!intervals) {
    return null;
  }
  for (var targetAxisIndex = serie.targetAxisIndex, targetAxis = this.targetAxisDefiners_[targetAxisIndex], dataView = this.dataView, intervalMarks = [], addIntervalRect = function(lowColumn, highColumn, span) {
    var lowValue = targetAxis.valueScale.valueToNumber(dataView.getValue(division, lowColumn)), highValue = targetAxis.valueScale.valueToNumber(dataView.getValue(division, highColumn));
    if (goog.isDefAndNotNull(lowValue) && goog.isDefAndNotNull(highValue)) {
      lowValue += offset;
      highValue += offset;
      shouldExtendTargetAxisRange && (targetAxis.extendRangeToIncludeNumber(lowValue), targetAxis.extendRangeToIncludeNumber(highValue));
      var mark = {lowT:lowValue, highT:highValue, spanD:span, columnIndex:lowColumn};
      intervalMarks.push(mark);
    }
  }, stickIndex = 0;stickIndex < intervals.sticks.length;stickIndex += 2) {
    addIntervalRect(intervals.sticks[stickIndex], intervals.sticks[stickIndex + 1], 0);
  }
  for (var boxLowIndex = 0, boxHighIndex = intervals.boxes.length - 1;boxLowIndex <= boxHighIndex;boxLowIndex++, boxHighIndex--) {
    var lowColumn = intervals.boxes[boxLowIndex], highColumn = intervals.boxes[boxHighIndex], boxWidth = intervals.settings[lowColumn].boxWidth;
    addIntervalRect(lowColumn, highColumn, boxWidth);
  }
  for (var pointIndex = 0;pointIndex < intervals.points.length;pointIndex++) {
    var column = intervals.points[pointIndex];
    addIntervalRect(column, column, 0);
  }
  for (var barIndex = 0;barIndex < intervals.bars.length;barIndex++) {
    var column = intervals.bars[barIndex], settings = intervals.settings[column], span$$0 = 0 == barIndex || barIndex == intervals.bars.length - 1 ? settings.barWidth : settings.shortBarWidth;
    addIntervalRect(column, column, span$$0);
  }
  for (var areaLowIndex = 0, areaHighIndex = intervals.areas.length - 1;areaLowIndex <= areaHighIndex;areaLowIndex++, areaHighIndex--) {
    lowColumn = intervals.areas[areaLowIndex], highColumn = intervals.areas[areaHighIndex], addIntervalRect(lowColumn, highColumn, 0);
  }
  for (var lineIndex = 0;lineIndex < intervals.lines.length;lineIndex++) {
    column = intervals.lines[lineIndex], addIntervalRect(column, column, 0);
  }
  return intervalMarks.length ? intervalMarks : null;
};
gviz.canviz.AxisChartDefiner.prototype.allocateSubDivisions_ = function(numOfSubDivisions) {
  this.numOfSubDivisions_ = Math.max(this.numOfSubDivisions_, numOfSubDivisions);
};
gviz.canviz.AxisChartDefiner.prototype.calcSubDivisionDefinition_ = function() {
  var chartDef = this.chartDef;
  if (chartDef.serieTypeCount[gviz.canviz.Options.SerieType.BARS] || chartDef.serieTypeCount[gviz.canviz.Options.SerieType.CANDLESTICKS] || !goog.isNull(goog.array.find(chartDef.series, function(serie) {
    return goog.isDefAndNotNull(serie.intervals);
  }))) {
    goog.asserts.assert(this.domainAxisDefiner_);
    var categories = goog.array.filter(chartDef.categories, function(category, i) {
      return 0 != this.calcGap_(i);
    }, this), minDistance = gviz.canviz.AxisChartDefiner.calcMinDistanceBetweenCategories_(this.domainAxisDefiner_, categories), divisionTotalWidth = Math.max(minDistance, 1), divisionWidth = this.options.inferAbsOrPercentageValue("bar.groupWidth", divisionTotalWidth), divisionWidth = Math.max(divisionWidth, 1), actualNumOfSubDivisions = Math.min(this.numOfSubDivisions_, Math.floor((divisionWidth + 1) / 2)), subDivisionWidth = (divisionWidth - actualNumOfSubDivisions + 1) / actualNumOfSubDivisions;
    divisionTotalWidth > divisionWidth && (subDivisionWidth = Math.floor(subDivisionWidth));
    var divisionOffsetFromTick = chartDef.chartType === gviz.canviz.Options.ChartType.HISTOGRAM ? 0 : ((subDivisionWidth + 1) * actualNumOfSubDivisions - 1) / 2;
    this.subDivisionDefinition_ = {actualNumOfSubDivisions:actualNumOfSubDivisions, subDivisionWidth:subDivisionWidth, divisionOffsetFromTick:divisionOffsetFromTick};
  }
};
gviz.canviz.AxisChartDefiner.calcMinDistanceBetweenCategories_ = function(domainAxisDefiner, categories) {
  if (goog.array.isEmpty(categories)) {
    return 0;
  }
  if (domainAxisDefiner.type == gviz.canviz.Options.AxisType.VALUE) {
    for (var minDistance = domainAxisDefiner.axisLength, prevPosition = null, i = 0;i < categories.length;i++) {
      var category = categories[i], dataValue = category.data, position = domainAxisDefiner.calcPositionFromDataValue(dataValue);
      if (goog.isDefAndNotNull(prevPosition)) {
        var distance = Math.abs(position - prevPosition), minDistance = Math.min(minDistance, distance)
      }
      prevPosition = position;
    }
    return minDistance;
  }
  return Math.abs(domainAxisDefiner.calcPositionFromDataValue(1) - domainAxisDefiner.calcPositionFromDataValue(0));
};
gviz.canviz.AxisChartDefiner.prototype.getNumericDomainValue_ = function(row, opt_serie) {
  var dataView = this.dataView, domainAxis = this.domainAxisDefiner_, numericDomainValue;
  if (domainAxis.type == gviz.canviz.Options.AxisType.VALUE) {
    var domainValue = opt_serie && opt_serie.isVirtual ? opt_serie.data[row][0] : dataView.getValue(row, 0);
    numericDomainValue = domainAxis.valueScale.valueToNumber(domainValue);
  } else {
    numericDomainValue = row;
  }
  return numericDomainValue;
};
// INPUT (javascript/gviz/devel/canviz/gesture-handler.js)
gviz.canviz.GestureHandler = function(interactionEventTarget) {
  this.interactionEventTarget_ = interactionEventTarget;
  this.mouseButtonsDown_ = [];
  this.isDragging_ = !1;
  this.dragInfo_ = {targetID:null, startX:0, startY:0, curX:0, curY:0};
};
gviz.canviz.GestureHandler.prototype.handleMouseDown = function(position, targetID, button) {
  this.mouseButtonsDown_[button] = !0;
  0 === button && (this.dragInfo_.targetID = targetID, this.dragInfo_.startX = position.x, this.dragInfo_.startY = position.y, this.dragInfo_.curX = position.x, this.dragInfo_.curY = position.y);
};
gviz.canviz.GestureHandler.prototype.handlePageMouseUp = function(position, button) {
  this.mouseButtonsDown_[button] = !1;
  0 === button && this.isDragging_ && (this.isDragging_ = !1, this.dragInfo_.curX = position.x, this.dragInfo_.curY = position.y, this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_DRAG_END, {targetID:this.dragInfo_.targetID, cursorPosition:{x:this.dragInfo_.curX, y:this.dragInfo_.curY}}));
};
gviz.canviz.GestureHandler.prototype.handlePageMouseMove = function(position) {
  this.mouseButtonsDown_[0] && (this.dragInfo_.curX = position.x, this.dragInfo_.curY = position.y, this.isDragging_ || this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_DRAG_START, {targetID:this.dragInfo_.targetID, cursorPosition:{x:this.dragInfo_.startX, y:this.dragInfo_.startY}}), this.isDragging_ = !0, this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_DRAG, {targetID:this.dragInfo_.targetID, cursorPosition:{x:this.dragInfo_.curX, y:this.dragInfo_.curY}}));
};
gviz.canviz.GestureHandler.prototype.dispatchEvent = function(type, data) {
  this.interactionEventTarget_.dispatchEvent({type:type, data:data});
};
// INPUT (javascript/gviz/devel/canviz/interaction-events.js)
gviz.canviz.interactionEvents = {};
gviz.canviz.interactionEvents.EventType = {CHART_HOVER_IN:"chartHoverIn", CHART_HOVER_OUT:"chartHoverOut", CHART_MOUSE_MOVE:"chartMouseMove", CHART_MOUSE_UP:"chartMouseUp", CHART_MOUSE_DOWN:"chartMouseDown", CHART_CLICK:"chartClick", CHART_RIGHT_CLICK:"chartRightClick", CHART_DBL_CLICK:"chartDblClick", CHART_SCROLL:"chartScroll", CHART_DRAG_START:"chartDragStart", CHART_DRAG:"chartDrag", CHART_DRAG_END:"chartDragEnd", CHART_PINCH_START:"chartPinchStart", CHART_PINCH:"chartPinch", CHART_PINCH_END:"chartPinchEnd", 
LEGEND_HOVER_IN:"legendHoverIn", LEGEND_HOVER_OUT:"legendHoverOut", LEGEND_CLICK:"legendClick", LEGEND_RIGHT_CLICK:"legendRightClick", LEGEND_ENTRY_HOVER_IN:"legendEntryHoverIn", LEGEND_ENTRY_HOVER_OUT:"legendEntryHoverOut", LEGEND_ENTRY_CLICK:"legendEntryClick", LEGEND_ENTRY_RIGHT_CLICK:"legendEntryRightClick", LEGEND_SCROLL_BUTTON_HOVER_IN:"legendScrollButtonHoverIn", LEGEND_SCROLL_BUTTON_HOVER_OUT:"legendScrollButtonHoverOut", LEGEND_SCROLL_BUTTON_CLICK:"legendScrollButtonClick", LEGEND_SCROLL_BUTTON_RIGHT_CLICK:"legendScrollButtonRightClick", 
SERIE_HOVER_IN:"serieHoverIn", SERIE_HOVER_OUT:"serieHoverOut", SERIE_CLICK:"serieClick", SERIE_RIGHT_CLICK:"serieRightClick", CATEGORY_HOVER_IN:"categoryHoverIn", CATEGORY_HOVER_OUT:"categoryHoverOut", CATEGORY_CLICK:"categoryClick", CATEGORY_RIGHT_CLICK:"categoryRightClick", DATUM_HOVER_IN:"datumHoverIn", DATUM_HOVER_OUT:"datumHoverOut", DATUM_CLICK:"datumClick", DATUM_RIGHT_CLICK:"datumRightClick", ANNOTATION_HOVER_IN:"annotationHoverIn", ANNOTATION_HOVER_OUT:"annotationHoverOut", ANNOTATION_CLICK:"annotationClick", 
ANNOTATION_RIGHT_CLICK:"annotationRightClick", TOOLTIP_HOVER_IN:"tooltipHoverIn", TOOLTIP_HOVER_OUT:"tooltipHoverOut", TOOLTIP_CLICK:"tooltipClick", TOOLTIP_RIGHT_CLICK:"tooltipRightClick", ACTIONS_MENU_ENTRY_HOVER_IN:"actionsMenuEntryHoverIn", ACTIONS_MENU_ENTRY_HOVER_OUT:"actionsMenuEntryHoverOut", ACTIONS_MENU_ENTRY_CLICK:"actionsMenuEntryClick", ACTIONS_MENU_ENTRY_RIGHT_CLICK:"actionsMenuEntryRightClick", REMOVE_SERIE_BUTTON_HOVER_IN:"removeSerieButtonHoverIn", REMOVE_SERIE_BUTTON_HOVER_OUT:"removeSerieButtonHoverOut", 
REMOVE_SERIE_BUTTON_CLICK:"removeSerieButtonClick", REMOVE_SERIE_BUTTON_RIGHT_CLICK:"removeSerieButtonRightClick"};
gviz.canviz.interactionEvents.TargetType = {CHART:"chart", LEGEND:"legend", LEGEND_ENTRY:"legendEntry", LEGEND_SCROLL_BUTTON:"legendScrollButton", SERIE:"serie", CATEGORY:"category", DATUM:"datum", ANNOTATION:"annotation", TOOLTIP:"tooltip", ACTIONS_MENU_ENTRY:"actionsMenuEntry", REMOVE_SERIE_BUTTON:"removeSerieButton"};
gviz.canviz.interactionEvents.OperationType = {HOVER_IN:"HoverIn", HOVER_OUT:"HoverOut", MOUSE_UP:"MouseUp", MOUSE_DOWN:"MouseDown", CLICK:"Click", RIGHT_CLICK:"RightClick", DBL_CLICK:"DblClick", SCROLL:"Scroll", DRAG_START:"DragStart", DRAG:"Drag", DRAG_END:"DragEnd"};
gviz.canviz.interactionEvents.generateEventType = function(targetType, operationType) {
  return targetType + operationType;
};
// INPUT (javascript/gviz/devel/canviz/chart-event-handler.js)
gviz.canviz.ChartEventHandler = function(interactionEventTarget, renderer, overlayArea, chartType) {
  goog.Disposable.call(this);
  this.interactionEventTarget_ = interactionEventTarget;
  this.renderer = renderer;
  this.overlayArea = overlayArea;
  this.chartType_ = chartType;
  this.hoveredElementID_ = null;
  this.gestureHandler_ = new gviz.canviz.GestureHandler(interactionEventTarget);
  this.scrollHandler_ = null;
};
goog.inherits(gviz.canviz.ChartEventHandler, goog.Disposable);
gviz.canviz.ChartEventHandler.prototype.disposeInternal = function() {
  this.renderer.clear();
  this.overlayArea.clear();
  goog.dispose(this.scrollHandler_);
  gviz.canviz.ChartEventHandler.superClass_.disposeInternal.call(this);
};
gviz.canviz.ChartEventHandler.prototype.listenToAllRendererEvents = function() {
  var canvas = this.renderer.getCanvas();
  goog.asserts.assert(canvas);
  this.listenToAllEvents_(goog.bind(function(eventType, listener) {
    this.renderer.setEventHandler(canvas, eventType, listener);
  }, this));
  goog.dispose(this.scrollHandler_);
  this.scrollHandler_ = new goog.events.MouseWheelHandler(this.renderer.getContainer());
  goog.events.listen(this.scrollHandler_, goog.events.MouseWheelHandler.EventType.MOUSEWHEEL, goog.bind(this.handleScrollEvent_, this));
};
gviz.canviz.ChartEventHandler.prototype.listenToAllOverlayAreaEvents = function() {
  var container = this.overlayArea.getContainer();
  this.listenToAllEvents_(goog.bind(function(eventType, listener) {
    this.overlayArea.setEventHandler(container, eventType, listener);
  }, this));
};
gviz.canviz.ChartEventHandler.prototype.listenToAllPageEvents = function() {
  var container = goog.dom.getDocument();
  this.listenToPageEvents_(goog.bind(function(eventType, listener) {
    this.overlayArea.setEventHandler(container, eventType, listener);
  }, this));
};
gviz.canviz.ChartEventHandler.prototype.listenToPageEvents_ = function(setEventHandler) {
  setEventHandler(goog.events.EventType.MOUSEMOVE, goog.bind(this.handlePageMouseMove_, this));
  setEventHandler(goog.events.EventType.MOUSEUP, goog.bind(this.handlePageMouseUp_, this));
};
gviz.canviz.ChartEventHandler.prototype.listenToAllEvents_ = function(setEventHandler) {
  setEventHandler(goog.events.EventType.MOUSEOVER, goog.bind(this.handleMouseoverAndMousemoveEvent_, this));
  setEventHandler(goog.events.EventType.MOUSEOUT, goog.bind(this.handleMouseoutEvent_, this));
  setEventHandler(goog.events.EventType.MOUSEMOVE, goog.bind(this.handleMouseoverAndMousemoveEvent_, this));
  setEventHandler(goog.events.EventType.MOUSEUP, goog.bind(this.handleMouseUpEvent_, this));
  setEventHandler(goog.events.EventType.MOUSEDOWN, goog.bind(this.handleMouseDownEvent_, this));
  setEventHandler(goog.events.EventType.CLICK, goog.bind(this.handleClickEvent_, this));
  setEventHandler(goog.events.EventType.CONTEXTMENU, goog.bind(this.handleRightClickEvent_, this));
  setEventHandler(goog.events.EventType.DBLCLICK, goog.bind(this.handleDblClickEvent_, this));
};
gviz.canviz.ChartEventHandler.prototype.handlePageMouseMove_ = function(event) {
  var positionInPage = goog.style.getClientPosition(this.renderer.getContainer()), position = goog.style.getClientPosition(event);
  position.x -= positionInPage.x;
  position.y -= positionInPage.y;
  this.gestureHandler_.handlePageMouseMove(position);
};
gviz.canviz.ChartEventHandler.prototype.handlePageMouseUp_ = function(event) {
  var positionInPage = goog.style.getClientPosition(this.renderer.getContainer()), position = goog.style.getClientPosition(event);
  position.x -= positionInPage.x;
  position.y -= positionInPage.y;
  this.gestureHandler_.handlePageMouseUp(position, event.button);
};
gviz.canviz.ChartEventHandler.prototype.handleMouseoverAndMousemoveEvent_ = function(event) {
  var cursorPosition = this.renderer.getCursorPosition(event), targetElementID = this.detectTargetElement(event);
  event.type == goog.events.EventType.MOUSEMOVE && this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_MOUSE_MOVE, {cursorPosition:cursorPosition, targetID:targetElementID});
  targetElementID != this.hoveredElementID_ && (goog.isDefAndNotNull(this.hoveredElementID_) && this.dispatchOutEvents_(this.hoveredElementID_), this.dispatchInEvents_(targetElementID, cursorPosition), this.hoveredElementID_ = targetElementID);
};
gviz.canviz.ChartEventHandler.prototype.handleMouseoutEvent_ = function(event) {
  var targetElementID = this.detectTargetElement(event);
  targetElementID == this.hoveredElementID_ && (this.dispatchOutEvents_(targetElementID), this.hoveredElementID_ = null);
};
gviz.canviz.ChartEventHandler.prototype.dispatchOutEvents_ = function(targetElementID) {
  this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_HOVER_OUT, null);
  this.dispatchInteractionEvent_(gviz.canviz.interactionEvents.OperationType.HOVER_OUT, targetElementID);
};
gviz.canviz.ChartEventHandler.prototype.dispatchInEvents_ = function(targetElementID, cursorPosition) {
  this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_HOVER_IN, {cursorPosition:cursorPosition});
  this.dispatchInteractionEvent_(gviz.canviz.interactionEvents.OperationType.HOVER_IN, targetElementID);
};
gviz.canviz.ChartEventHandler.prototype.handleMouseUpEvent_ = function(event) {
  var cursorPosition = this.renderer.getCursorPosition(event), targetElementID = this.detectTargetElement(event);
  this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_MOUSE_UP, {cursorPosition:cursorPosition, targetID:targetElementID});
  this.dispatchInteractionEvent_(gviz.canviz.interactionEvents.OperationType.MOUSE_UP, targetElementID);
};
gviz.canviz.ChartEventHandler.prototype.handleMouseDownEvent_ = function(event) {
  var cursorPosition = this.renderer.getCursorPosition(event), targetElementID = this.detectTargetElement(event);
  this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_MOUSE_DOWN, {cursorPosition:cursorPosition, targetID:targetElementID, preventDefault:goog.bind(event.preventDefault, event)});
  this.dispatchInteractionEvent_(gviz.canviz.interactionEvents.OperationType.MOUSE_DOWN, targetElementID);
  this.gestureHandler_.handleMouseDown(cursorPosition, targetElementID, event.button);
};
gviz.canviz.ChartEventHandler.prototype.handleClickEvent_ = function(event) {
  var cursorPosition = this.renderer.getCursorPosition(event), targetElementID = this.detectTargetElement(event);
  this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_CLICK, {cursorPosition:cursorPosition, targetID:targetElementID});
  this.dispatchInteractionEvent_(gviz.canviz.interactionEvents.OperationType.CLICK, targetElementID);
};
gviz.canviz.ChartEventHandler.prototype.handleRightClickEvent_ = function(event) {
  var cursorPosition = this.renderer.getCursorPosition(event), targetElementID = this.detectTargetElement(event);
  this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_RIGHT_CLICK, {cursorPosition:cursorPosition, targetID:targetElementID});
  this.dispatchInteractionEvent_(gviz.canviz.interactionEvents.OperationType.RIGHT_CLICK, targetElementID);
  goog.events.Event.preventDefault(event);
};
gviz.canviz.ChartEventHandler.prototype.handleDblClickEvent_ = function(event) {
  var cursorPosition = this.renderer.getCursorPosition(event), targetElementID = this.detectTargetElement(event);
  this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_DBL_CLICK, {cursorPosition:cursorPosition, targetID:targetElementID});
  this.dispatchInteractionEvent_(gviz.canviz.interactionEvents.OperationType.DBL_CLICK, targetElementID);
};
gviz.canviz.ChartEventHandler.prototype.handleScrollEvent_ = function(event) {
  var cursorPosition = this.renderer.getCursorPosition(event), targetElementID = this.detectTargetElement(event);
  this.dispatchEvent(gviz.canviz.interactionEvents.EventType.CHART_SCROLL, {cursorPosition:cursorPosition, targetID:targetElementID, wheelDelta:event.detail, preventDefault:goog.bind(event.preventDefault, event)});
  this.dispatchInteractionEvent_(gviz.canviz.interactionEvents.OperationType.SCROLL, targetElementID);
};
gviz.canviz.ChartEventHandler.prototype.dispatchInteractionEvent_ = function(interactionEventOperationType, targetElementID) {
  var targetElementTokens = targetElementID.split(gviz.canviz.idutils.TOKEN_SEPARATOR), targetElementType = targetElementTokens[0];
  switch(targetElementType) {
    case gviz.canviz.idutils.Token.TOOLTIP:
      var serieIndex = null, datumIndex = null, annotationIndex = null;
      this.chartType_ == gviz.canviz.Options.ChartType.PIE ? serieIndex = Number(targetElementTokens[1]) : 4 == targetElementTokens.length ? (serieIndex = targetElementTokens[1] ? Number(targetElementTokens[1]) : null, datumIndex = Number(targetElementTokens[2]), annotationIndex = Number(targetElementTokens[3])) : 3 == targetElementTokens.length ? (serieIndex = Number(targetElementTokens[1]), datumIndex = Number(targetElementTokens[2])) : datumIndex = Number(targetElementTokens[1]);
      var interactionEventType = gviz.canviz.interactionEvents.generateEventType(gviz.canviz.interactionEvents.TargetType.TOOLTIP, interactionEventOperationType), interactionEventData = {serieIndex:serieIndex, datumIndex:datumIndex, annotationIndex:annotationIndex};
      this.dispatchEvent(interactionEventType, interactionEventData);
      break;
    case gviz.canviz.idutils.Token.ACTIONS_MENU_ENTRY:
      var interactionEventType = gviz.canviz.interactionEvents.generateEventType(gviz.canviz.interactionEvents.TargetType.ACTIONS_MENU_ENTRY, interactionEventOperationType), entryID = targetElementTokens[1], interactionEventData = {entryID:entryID};
      this.dispatchEvent(interactionEventType, interactionEventData);
      break;
    case gviz.canviz.idutils.Token.LEGEND_ENTRY:
      var legendEntryIndex = Number(targetElementTokens[1]);
      if (0 > legendEntryIndex) {
        break;
      }
      interactionEventType = gviz.canviz.interactionEvents.generateEventType(gviz.canviz.interactionEvents.TargetType.LEGEND_ENTRY, interactionEventOperationType);
      interactionEventData = {legendEntryIndex:legendEntryIndex};
      this.dispatchEvent(interactionEventType, interactionEventData);
      break;
    case gviz.canviz.idutils.Token.LEGEND_SCROLL_BUTTON:
      var interactionEventType = gviz.canviz.interactionEvents.generateEventType(gviz.canviz.interactionEvents.TargetType.LEGEND_SCROLL_BUTTON, interactionEventOperationType), scrollStep = Number(targetElementTokens[1]), interactionEventData = {scrollStep:scrollStep};
      this.dispatchEvent(interactionEventType, interactionEventData);
      break;
    case gviz.canviz.idutils.Token.REMOVE_SERIE_BUTTON:
      interactionEventType = gviz.canviz.interactionEvents.generateEventType(gviz.canviz.interactionEvents.TargetType.REMOVE_SERIE_BUTTON, interactionEventOperationType);
      legendEntryIndex = Number(targetElementTokens[1]);
      interactionEventData = {legendEntryIndex:legendEntryIndex};
      this.dispatchEvent(interactionEventType, interactionEventData);
      break;
    default:
      this.dispatchInteractionEventForContent(interactionEventOperationType, targetElementID);
  }
};
gviz.canviz.ChartEventHandler.prototype.dispatchEvent = function(type, data) {
  this.interactionEventTarget_.dispatchEvent({type:type, data:data});
};
gviz.canviz.ChartEventHandler.prototype.getHoveredElementID = function() {
  return this.hoveredElementID_;
};
// INPUT (javascript/gviz/devel/canviz/axis-chart-event-handler.js)
gviz.canviz.AxisChartEventHandler = function(interactionEventTarget, renderer, overlayArea, chartDefinition) {
  gviz.canviz.ChartEventHandler.call(this, interactionEventTarget, renderer, overlayArea, chartDefinition.chartType);
  this.chartDefinition_ = chartDefinition;
  this.pointSensitivityAreas_ = this.createPointSensitivityAreas_();
};
goog.inherits(gviz.canviz.AxisChartEventHandler, gviz.canviz.ChartEventHandler);
gviz.canviz.AxisChartEventHandler.prototype.updateChartDefinition = function(chartDefinition) {
  this.chartDefinition_ = chartDefinition;
  this.pointSensitivityAreas_ = this.createPointSensitivityAreas_();
};
gviz.canviz.AxisChartEventHandler.prototype.createPointSensitivityAreas_ = function() {
  var chartDefinition = this.chartDefinition_;
  if (chartDefinition.chartType != gviz.canviz.Options.ChartType.FUNCTION && chartDefinition.chartType != gviz.canviz.Options.ChartType.SCATTER) {
    return{};
  }
  for (var pointSensitivityAreas = {}, series = chartDefinition.series, serieIndex = 0;serieIndex < series.length;serieIndex++) {
    var serie = series[serieIndex];
    if (gviz.canviz.chartdefinitionutil.isSeriePathBased(serie)) {
      for (var points = serie.points, pointIndex = 0;pointIndex < points.length;pointIndex++) {
        var point = points[pointIndex];
        if (point && point.scaled && !point.isNull) {
          var pointID = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.POINT, serieIndex, pointIndex]), pointSensitivityAreaRadius = gviz.canviz.chartdefinitionutil.getPointSensitivityAreaRadius(point, serie);
          goog.asserts.assert(goog.isDefAndNotNull(pointSensitivityAreaRadius));
          pointSensitivityAreas[pointID] = {center:point.scaled, radius:pointSensitivityAreaRadius, serieIndex:serieIndex, datumIndex:pointIndex};
        }
      }
    }
  }
  return pointSensitivityAreas;
};
gviz.canviz.AxisChartEventHandler.prototype.detectTargetElement = function(event) {
  var eventTarget = event.target, hoveredElement = this.renderer.getLogicalName(eventTarget);
  goog.asserts.assert(goog.isDefAndNotNull(hoveredElement));
  var cursorPosition = this.renderer.getCursorPosition(event), hoveredSensitivityArea = this.detectHoveredSensitivityArea_(cursorPosition);
  if (event.type == goog.events.EventType.MOUSEOUT) {
    var previouslyHoveredSensitivityArea = this.getHoveredElementID();
    if (!goog.isDefAndNotNull(previouslyHoveredSensitivityArea)) {
      return hoveredElement;
    }
    hoveredSensitivityArea = hoveredSensitivityArea == previouslyHoveredSensitivityArea ? null : previouslyHoveredSensitivityArea;
  }
  var targetElement;
  if (goog.isDefAndNotNull(hoveredSensitivityArea)) {
    var hoveredElementPrecedence = this.getElementPrecedence_(hoveredElement), hoveredSensitivityAreaPrecedence = this.getElementPrecedence_(hoveredSensitivityArea);
    targetElement = hoveredElementPrecedence > hoveredSensitivityAreaPrecedence ? hoveredElement : hoveredSensitivityArea;
  } else {
    targetElement = hoveredElement;
  }
  return this.validateDetectedTargetElement_(targetElement) ? targetElement : gviz.canviz.idutils.Token.CHART;
};
gviz.canviz.AxisChartEventHandler.prototype.detectHoveredSensitivityArea_ = function(cursorPosition) {
  var chartArea = new goog.math.Rect(this.chartDefinition_.chartArea.left + 1, this.chartDefinition_.chartArea.top + 1, this.chartDefinition_.chartArea.width - 2, this.chartDefinition_.chartArea.height - 2);
  if (!chartArea.contains(cursorPosition)) {
    return null;
  }
  var focusTarget = this.chartDefinition_.focusTarget;
  switch(focusTarget) {
    case gviz.canviz.Options.FocusTarget.DATUM:
      return this.detectHoveredPoint_(cursorPosition);
    case gviz.canviz.Options.FocusTarget.CATEGORY:
      return this.detectHoveredCategory_(cursorPosition);
    case gviz.canviz.Options.FocusTarget.SERIES:
      break;
    default:
      goog.asserts.fail('Invalid focus target "' + focusTarget + '"');
  }
  return null;
};
gviz.canviz.AxisChartEventHandler.prototype.detectHoveredCategory_ = function(cursorPosition) {
  for (var categories = this.chartDefinition_.categories, i = 0;i < categories.length;i++) {
    var sensitivityArea = categories[i].sensitivityArea;
    if (sensitivityArea && sensitivityArea.contains(cursorPosition)) {
      return gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.CATEGORY_SENSITIVITY_AREA, i]);
    }
  }
  return null;
};
gviz.canviz.AxisChartEventHandler.prototype.detectHoveredPoint_ = function(cursorPosition) {
  var x = cursorPosition.x, y = cursorPosition.y, hoveredPoint = null, minD2 = Infinity, pointID;
  for (pointID in this.pointSensitivityAreas_) {
    var circle = this.pointSensitivityAreas_[pointID], cx = circle.center.x, cy = circle.center.y, r = circle.radius;
    if (cx - x <= r && cx - x >= -r && cy - y <= r && cy - y >= -r) {
      var d2 = (cx - x) * (cx - x) + (cy - y) * (cy - y);
      d2 <= r * r && d2 <= minD2 && (hoveredPoint = gviz.canviz.idutils.generateId([gviz.canviz.idutils.Token.POINT_SENSITIVITY_AREA, circle.serieIndex, circle.datumIndex]), minD2 = d2);
    }
  }
  return hoveredPoint;
};
gviz.canviz.AxisChartEventHandler.prototype.validateDetectedTargetElement_ = function(targetElementID) {
  var focusTarget = this.chartDefinition_.focusTarget;
  if (focusTarget == gviz.canviz.Options.FocusTarget.CATEGORY) {
    var targetElementTokens = targetElementID.split(gviz.canviz.idutils.TOKEN_SEPARATOR), targetElementType = targetElementTokens[0];
    return targetElementType != gviz.canviz.idutils.Token.BAR && targetElementType != gviz.canviz.idutils.Token.BUBBLE && targetElementType != gviz.canviz.idutils.Token.CANDLESTICK && targetElementType != gviz.canviz.idutils.Token.POINT && targetElementType != gviz.canviz.idutils.Token.POINT_SENSITIVITY_AREA && targetElementType != gviz.canviz.idutils.Token.STEPPED_AREA_BAR;
  }
  return!0;
};
gviz.canviz.AxisChartEventHandler.prototype.getElementPrecedence_ = function(elementLogicalName) {
  var elementTokens = elementLogicalName.split(gviz.canviz.idutils.TOKEN_SEPARATOR);
  return goog.array.indexOf(gviz.canviz.idutils.TOKEN_PRECEDENCE, elementTokens[0]);
};
gviz.canviz.AxisChartEventHandler.prototype.dispatchInteractionEventForContent = function(interactionEventOperationType, targetElementID) {
  var targetElementTokens = targetElementID.split(gviz.canviz.idutils.TOKEN_SEPARATOR), targetElementType = targetElementTokens[0];
  switch(targetElementType) {
    case gviz.canviz.idutils.Token.BAR:
    ;
    case gviz.canviz.idutils.Token.BUBBLE:
    ;
    case gviz.canviz.idutils.Token.CANDLESTICK:
    ;
    case gviz.canviz.idutils.Token.POINT:
    ;
    case gviz.canviz.idutils.Token.POINT_SENSITIVITY_AREA:
    ;
    case gviz.canviz.idutils.Token.STEPPED_AREA_BAR:
      var serieIndex = Number(targetElementTokens[1]), datumIndex = Number(targetElementTokens[2]), interactionEventType = gviz.canviz.interactionEvents.generateEventType(gviz.canviz.interactionEvents.TargetType.DATUM, interactionEventOperationType), interactionEventData = {serieIndex:serieIndex, datumIndex:datumIndex};
      this.dispatchEvent(interactionEventType, interactionEventData);
      break;
    case gviz.canviz.idutils.Token.CATEGORY_SENSITIVITY_AREA:
      var categoryIndex = Number(targetElementTokens[1]), interactionEventType = gviz.canviz.interactionEvents.generateEventType(gviz.canviz.interactionEvents.TargetType.CATEGORY, interactionEventOperationType), interactionEventData = {serieIndex:null, datumIndex:categoryIndex};
      this.dispatchEvent(interactionEventType, interactionEventData);
      break;
    case gviz.canviz.idutils.Token.ANNOTATION_TEXT:
      this.dispatchAnnotationEvent_(interactionEventOperationType, targetElementTokens);
      break;
    case gviz.canviz.idutils.Token.LINE:
    ;
    case gviz.canviz.idutils.Token.AREA:
      serieIndex = Number(targetElementTokens[1]), interactionEventType = gviz.canviz.interactionEvents.generateEventType(gviz.canviz.interactionEvents.TargetType.SERIE, interactionEventOperationType), interactionEventData = {serieIndex:serieIndex, datumIndex:null}, this.dispatchEvent(interactionEventType, interactionEventData);
  }
};
gviz.canviz.AxisChartEventHandler.prototype.dispatchAnnotationEvent_ = function(operationType, targetElementTokens) {
  var interactionEventType = gviz.canviz.interactionEvents.generateEventType(gviz.canviz.interactionEvents.TargetType.ANNOTATION, operationType), annotationIndex = Number(goog.array.peek(targetElementTokens));
  if (3 == targetElementTokens.length) {
    var categoryIndex = Number(targetElementTokens[1]), interactionEventData = {serieIndex:null, datumIndex:categoryIndex, annotationIndex:annotationIndex}
  } else {
    var serieIndex = Number(targetElementTokens[1]), datumIndex = Number(targetElementTokens[2]), interactionEventData = {serieIndex:serieIndex, datumIndex:datumIndex, annotationIndex:annotationIndex}
  }
  this.dispatchEvent(interactionEventType, interactionEventData);
};
// INPUT (javascript/gviz/devel/canviz/actions-menu-definer.js)
gviz.canviz.ActionsMenuDefiner = function(chartOptions, chartTextStyle) {
  this.entries_ = {};
  this.actions_ = {};
  this.actionsMenu_ = [];
  this.updateOptions(chartOptions, chartTextStyle);
};
gviz.canviz.ActionsMenuDefiner.prototype.refreshActions_ = function() {
  goog.array.forEach(this.actionsMenu_, function(actionId) {
    this.setEntry(this.actions_[actionId]);
  }, this);
};
gviz.canviz.ActionsMenuDefiner.prototype.updateOptions = function(chartOptions, chartTextStyle) {
  this.textStyle_ = chartOptions.inferTextStyleValue("actionsMenu.textStyle", chartTextStyle);
  this.disabledTextStyle_ = chartOptions.inferTextStyleValue("actionsMenu.disabledTextStyle", chartTextStyle);
  this.refreshActions_();
};
gviz.canviz.ActionsMenuDefiner.prototype.createEntry_ = function(action, opt_disabled) {
  return gviz.util.tooltip.definer.createBodyTextLineEntry(action.text || "", opt_disabled ? this.disabledTextStyle_ : this.textStyle_, null, null, null, null, null, !1, opt_disabled ? null : action.id);
};
gviz.canviz.ActionsMenuDefiner.prototype.getEntries = function() {
  for (var entries = [], i = 0, len = this.actionsMenu_.length;i < len;i++) {
    var actionId = this.actionsMenu_[i], action = this.actions_[actionId];
    if (!action.visible || action.visible()) {
      var isDisabled = action.enabled && !action.enabled(), entry = null, entry = isDisabled ? this.createEntry_(action, !0) : goog.object.unsafeClone(this.entries_[actionId]);
      entries.push(entry);
    }
  }
  return entries;
};
gviz.canviz.ActionsMenuDefiner.prototype.setEntry = function(action) {
  if (!action.id) {
    throw Error("Missing mandatory ID for action.");
  }
  var existingAction = null;
  this.actions_[action.id] ? existingAction = this.actions_[action.id] : (existingAction = this.actions_[action.id] = {id:action.id, text:void 0, visible:void 0, enabled:void 0, action:void 0}, this.actionsMenu_.push(action.id));
  goog.object.extend(existingAction, action);
  this.entries_[action.id] = this.createEntry_(existingAction);
};
gviz.canviz.ActionsMenuDefiner.prototype.getAction = function(action) {
  var actionDefinition = this.actions_[action];
  actionDefinition && (actionDefinition = goog.object.unsafeClone(actionDefinition));
  return actionDefinition;
};
gviz.canviz.ActionsMenuDefiner.prototype.removeEntry = function(action) {
  action in this.entries_ && delete this.entries_[action];
  action in this.actions_ && delete this.actions_[action];
  var actionIndex = goog.array.indexOf(this.actionsMenu_, action);
  0 <= actionIndex && this.actionsMenu_.splice(actionIndex, 1);
};
gviz.canviz.ActionsMenuDefiner.prototype.createInteractiveEntry_ = function(interactivityLayer, entryIndex) {
  interactivityLayer.bodyLayout = interactivityLayer.bodyLayout || {};
  var bodyLayout = interactivityLayer.bodyLayout;
  bodyLayout.entries = bodyLayout.entries || {};
  var entriesLayout = bodyLayout.entries;
  entriesLayout[entryIndex] = entriesLayout[entryIndex] || {};
  var entryLayout = entriesLayout[entryIndex];
  entryLayout.entry = entryLayout.entry || {};
  return entryLayout.entry;
};
gviz.canviz.ActionsMenuDefiner.ENTRY_GLOW_COLOR = "#DDD";
gviz.canviz.ActionsMenuDefiner.prototype.extendInteractivityLayer = function(tooltipDefinition, actionsMenuState, tooltipInteractivityLayer) {
  if (!tooltipDefinition.html) {
    var entryID = actionsMenuState.focused.entryID;
    if (goog.isDefAndNotNull(entryID)) {
      var entryIndex = goog.array.findIndex(tooltipDefinition.bodyLayout.entries, function(entryLayout) {
        return entryLayout.entry.data.id == entryID;
      });
      if (-1 !== entryIndex) {
        var interactiveEntry = this.createInteractiveEntry_(tooltipInteractivityLayer, entryIndex);
        interactiveEntry.data = interactiveEntry.data || {};
        interactiveEntry.data.background = interactiveEntry.data.background || {};
        var background = interactiveEntry.data.background;
        background.brush = gviz.graphics.Brush.createFillBrush(gviz.canviz.ActionsMenuDefiner.ENTRY_GLOW_COLOR);
      }
    }
  }
};
// INPUT (javascript/gviz/devel/canviz/aggregator.js)
gviz.canviz.Tooltip = {};
gviz.canviz.Tooltip.Aggregator = function(chartDefinition) {
  this.chartDefinition = chartDefinition;
};
gviz.canviz.Tooltip.Aggregator.prototype.aggregate = function(data) {
  var aggregate = {index:{}, order:[], titles:{}};
  goog.array.forEach(data, function(datum) {
    var key = this.getKey(datum);
    if (null != key) {
      if (!aggregate.titles.hasOwnProperty(key)) {
        var title = this.getTitle(datum);
        title && (aggregate.titles[key] = title);
      }
      aggregate.index.hasOwnProperty(key) || (aggregate.index[key] = [], aggregate.order.push(key));
      aggregate.index[key].push(datum);
    }
  }, this);
  return aggregate;
};
gviz.canviz.Tooltip.Aggregator.prototype.getCategoryTitle = function(datum) {
  return this.chartDefinition.getCategoryTitleForDatum(datum);
};
gviz.canviz.Tooltip.Aggregator.prototype.getSeriesTitle = function(datum) {
  return this.chartDefinition.getSeriesTitleForDatum(datum);
};
// INPUT (javascript/gviz/devel/canviz/category-aggregator.js)
gviz.canviz.Tooltip.CategoryAggregator = function(chartDefinition) {
  gviz.canviz.Tooltip.Aggregator.call(this, chartDefinition);
};
goog.inherits(gviz.canviz.Tooltip.CategoryAggregator, gviz.canviz.Tooltip.Aggregator);
gviz.canviz.Tooltip.CategoryAggregator.prototype.getKey = function(datum) {
  return this.chartDefinition.getCategoryIndexForDatum(datum);
};
gviz.canviz.Tooltip.CategoryAggregator.prototype.getTitle = function(datum) {
  return this.getCategoryTitle(datum);
};
gviz.canviz.Tooltip.CategoryAggregator.prototype.getContent = function(bodyCreator, text, datum) {
  var title = this.getSeriesTitle(datum);
  return bodyCreator.getSerieLines(title, text.content || "", !0, bodyCreator.showColorCodeForAggregate, this.chartDefinition.series[datum.serie]);
};
// INPUT (javascript/gviz/devel/canviz/series-aggregator.js)
gviz.canviz.Tooltip.SeriesAggregator = function(chartDefinition) {
  gviz.canviz.Tooltip.Aggregator.call(this, chartDefinition);
};
goog.inherits(gviz.canviz.Tooltip.SeriesAggregator, gviz.canviz.Tooltip.Aggregator);
gviz.canviz.Tooltip.SeriesAggregator.prototype.getKey = function(datum) {
  return this.chartDefinition.getSeriesIndexForDatum(datum);
};
gviz.canviz.Tooltip.SeriesAggregator.prototype.getTitle = function(datum) {
  return this.getSeriesTitle(datum);
};
gviz.canviz.Tooltip.SeriesAggregator.prototype.getContent = function(bodyCreator, text, datum) {
  var title = this.getCategoryTitle(datum) || "";
  return[bodyCreator.getKeyValueLine(title, text.content || "")];
};
// INPUT (javascript/gviz/devel/canviz/tooltip-body-creator.js)
gviz.canviz.TooltipBodyCreator = function(chartOptions, chartTextStyle, focusTarget, opt_actionsMenuDefiner) {
  var tooltipTextStyle = chartOptions.inferTextStyleValue("tooltip.textStyle", {fontName:chartTextStyle.fontName, fontSize:chartTextStyle.fontSize});
  this.showColorCode = chartOptions.inferBooleanValue("tooltip.showColorCode", focusTarget == gviz.canviz.Options.FocusTarget.CATEGORY);
  this.showColorCodeForAggregate = chartOptions.inferBooleanValue("tooltip.showColorCode", !0);
  this.showEmpty_ = chartOptions.inferBooleanValue("tooltip.showEmpty", !0);
  this.textStyle_ = tooltipTextStyle;
  this.boldTextStyle_ = gviz.graphics.util.createBoldTextStyle(tooltipTextStyle, !0);
  this.actionsMenuDefiner = opt_actionsMenuDefiner || null;
  this.diffTooltipNewDataPrefix_ = chartOptions.inferStringValue("diff.newData.tooltip.prefix", gviz.canviz.Options.DEFAULT_DIFF_NEW_DATA_PREFIX_TEXT);
  this.diffTooltipOldDataPrefix_ = chartOptions.inferStringValue("diff.oldData.tooltip.prefix", gviz.canviz.Options.DEFAULT_DIFF_OLD_DATA_PREFIX_TEXT);
};
gviz.canviz.TooltipBodyCreator.prototype.embedActionsMenu = function() {
};
gviz.canviz.TooltipBodyCreator.prototype.createDatumAnnotationBody = function(interactionState, seriesIndex, categoryIndex, annotationIndex) {
  var series = interactionState.chartDefinition.series[seriesIndex], datum = series.points[categoryIndex], annotation = datum.annotation.labels[annotationIndex], body = {entries:[gviz.util.tooltip.definer.createBodyTextLineEntry(annotation.tooltipText.content, this.getTextStyle())]};
  this.embedActionsMenu(body, interactionState.actionsMenuEntries);
  return body;
};
gviz.canviz.TooltipBodyCreator.prototype.createCategoryAnnotationBody = function(interactionState, categoryIndex, annotationIndex) {
  var category = interactionState.chartDefinition.categories[categoryIndex], annotation = category.annotation.labels[annotationIndex], body = {entries:[gviz.util.tooltip.definer.createBodyTextLineEntry(annotation.tooltipText.content, this.getTextStyle())]};
  0 < interactionState.actionsMenuEntries.length && this.embedActionsMenu(body, interactionState.actionsMenuEntries);
  return body;
};
gviz.canviz.TooltipBodyCreator.prototype.getTextStyle = function() {
  return this.textStyle_;
};
gviz.canviz.TooltipBodyCreator.prototype.getBoldTextStyle = function() {
  return this.boldTextStyle_;
};
gviz.canviz.TooltipBodyCreator.prototype.hasActionsMenu = function() {
  return goog.isDefAndNotNull(this.actionsMenuDefiner) && 0 < this.actionsMenuDefiner.getEntries().length;
};
gviz.canviz.DefaultTooltipBodyCreator = function(chartOptions, chartTextStyle, focusTarget, opt_actionsMenuDefiner) {
  gviz.canviz.TooltipBodyCreator.call(this, chartOptions, chartTextStyle, focusTarget, opt_actionsMenuDefiner);
};
goog.inherits(gviz.canviz.DefaultTooltipBodyCreator, gviz.canviz.TooltipBodyCreator);
gviz.canviz.DefaultTooltipBodyCreator.prototype.createDatumBody = function(interactionState, seriesIndex, categoryIndex) {
  var chartDef = interactionState.chartDefinition, series = chartDef.series[seriesIndex], tooltipText = chartDef.getTooltipText(seriesIndex, categoryIndex), isTitleInSeparateLine = !1, linesColor = null, prefixText = null, alignColumns = goog.isDefAndNotNull(chartDef.isDiff) && chartDef.isDiff;
  if (chartDef.isDiff) {
    var isTitleInSeparateLine = !0, prefixText = [this.diffTooltipNewDataPrefix_, this.diffTooltipOldDataPrefix_], serieType = series.type;
    if (serieType === gviz.canviz.Options.SerieType.BARS) {
      linesColor = [{color:series.pointBrush.getFill(), alpha:series.pointBrush.getFillOpacity()}, {color:series.diff.background.pointBrush.getFill(), alpha:series.diff.background.pointBrush.getFillOpacity()}];
    } else {
      if (serieType === gviz.canviz.Options.SerieType.SCATTER) {
        var oldDataSerieIndex = seriesIndex % 2 ? seriesIndex - 1 : seriesIndex, newDataSerieIndex = oldDataSerieIndex + 1, oldDataSerie = interactionState.chartDefinition.series[oldDataSerieIndex], newDataSerie = interactionState.chartDefinition.series[newDataSerieIndex], linesColor = [{color:newDataSerie.pointBrush.getFill(), alpha:newDataSerie.pointBrush.getFillOpacity()}, {color:oldDataSerie.pointBrush.getFill(), alpha:oldDataSerie.pointBrush.getFillOpacity()}]
      } else {
        throw Error("Diff chart not supported for the chosen chart type.");
      }
    }
  }
  var body = {entries:[]};
  if (tooltipText.lines) {
    tooltipText.title && this.addTitleLine_(body, tooltipText.title);
    for (var i = 0;i < tooltipText.lines.length;i++) {
      var line = tooltipText.lines[i];
      this.addKeyValueLine_(body, line.title, line.value);
    }
  } else {
    tooltipText.categoryTitle && !tooltipText.hasCustomContent ? (this.addTitleLine_(body, tooltipText.categoryTitle), this.addSerieLine_(body, tooltipText.serieTitle, tooltipText.content, !0, this.showColorCode, series, isTitleInSeparateLine, linesColor, prefixText, alignColumns)) : tooltipText.serieTitle && !tooltipText.hasCustomContent ? (isTitleInSeparateLine = !0, this.addSerieLine_(body, tooltipText.serieTitle, tooltipText.content, !0, this.showColorCode, series, isTitleInSeparateLine, linesColor, 
    prefixText, alignColumns)) : goog.isDefAndNotNull(tooltipText.content) ? this.addSerieLine_(body, null, tooltipText.content, !1, this.showColorCode, series) : goog.asserts.fail("Cannot create tooltip for datum.");
  }
  this.embedActionsMenu(body, interactionState.actionsMenuEntries);
  return body;
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.createAggregateDataBody = function(interactionState, data, aggregationTarget) {
  var chartDefinition = interactionState.chartDefinition, categoryAggregator = new gviz.canviz.Tooltip.CategoryAggregator(chartDefinition), seriesAggregator = new gviz.canviz.Tooltip.SeriesAggregator(chartDefinition), aggregator = null;
  aggregationTarget == gviz.canviz.Options.AggregationTarget.CATEGORY ? aggregator = categoryAggregator : aggregationTarget == gviz.canviz.Options.AggregationTarget.SERIES && (aggregator = seriesAggregator);
  var aggregate;
  if (aggregator) {
    aggregate = aggregator.aggregate(data);
  } else {
    var categoryAggregate = categoryAggregator.aggregate(data), seriesAggregate = seriesAggregator.aggregate(data), aggregator = seriesAggregator;
    aggregate = seriesAggregate;
    1 == categoryAggregate.order.length && 1 < seriesAggregate.order.length && (aggregator = categoryAggregator, aggregate = categoryAggregate);
  }
  var body = {entries:[]};
  goog.array.forEach(aggregate.order, function(key) {
    var title = aggregate.titles[key];
    this.addTitleLine_(body, title.toString());
    goog.array.forEach(aggregate.index[key], function(datum) {
      var tooltipText = chartDefinition.getTooltipText(datum.serie, datum.category);
      if (tooltipText.hasCustomContent) {
        var series = chartDefinition.series[datum.serie];
        this.addSerieLine_(body, null, tooltipText.content, !1, this.showColorCode, series);
      } else {
        body.entries.push.apply(body.entries, aggregator.getContent(this, tooltipText, datum));
      }
    }, this);
  }, this);
  this.embedActionsMenu(body, interactionState.actionsMenuEntries, 0 < data.length);
  return body;
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.createSeriesBody = function(interactionState, seriesIndex) {
  var chartDef = interactionState.chartDefinition, series = chartDef.series[seriesIndex], text = series.tooltipText, linesColor = null, prefixText = null, alignColumns = goog.isDefAndNotNull(chartDef.isDiff) && chartDef.isDiff;
  if (chartDef.isDiff) {
    var seriesCount = chartDef.series.length, seriesInEachLayer = seriesCount / chartDef.pie.layers.length, twinIndex = (seriesIndex + seriesInEachLayer) % seriesCount, twinSeries = chartDef.series[twinIndex], seriesColor = {color:series.brush.getFill(), alpha:series.brush.getFillOpacity()}, twinColor = {color:twinSeries.brush.getFill(), alpha:twinSeries.brush.getFillOpacity()}, linesColor = seriesIndex > twinIndex ? [seriesColor, twinColor] : [twinColor, seriesColor], prefixText = [this.diffTooltipNewDataPrefix_, 
    this.diffTooltipOldDataPrefix_]
  }
  var body = {entries:[]};
  text.serieTitle ? this.addSerieLine_(body, text.serieTitle, text.content, !0, this.showColorCode, series, !0, linesColor, prefixText, alignColumns) : this.addSerieLine_(body, null, text.content, !1, this.showColorCode, series);
  this.embedActionsMenu(body, interactionState.actionsMenuEntries);
  return body;
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.createAggregateSeriesBody = function(interactionState, seriesIndices) {
  var chartDefinition = interactionState.chartDefinition, body = {entries:[]};
  goog.array.forEach(seriesIndices, goog.bind(function(seriesIndex) {
    var series = chartDefinition.series[seriesIndex], text = series.tooltipText;
    text.serieTitle ? this.addSerieLine_(body, text.serieTitle, text.content, !0, this.showColorCode, series, !0) : this.addSerieLine_(body, null, text.content, !1, this.showColorCode, series);
  }, this));
  this.embedActionsMenu(body, interactionState.actionsMenuEntries);
  return body;
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.createCategoryBody = function(interactionState, categoryIndex) {
  var chartDefinition = interactionState.chartDefinition, category = chartDefinition.categories[categoryIndex], text = category.tooltipText, hasData = !1, body = {entries:[]};
  if (text && text.content) {
    this.addSerieLine_(body, null, text.content, !1, !1);
  } else {
    var seriesIndex = 0, direction = 1, lastIndex = chartDefinition.series.length;
    gviz.canviz.chartdefinitionutil.reverseSeriesLabelsVertically(chartDefinition) && (seriesIndex = chartDefinition.series.length - 1, lastIndex = direction = -1);
    for (var domainIndex = null;seriesIndex != lastIndex;seriesIndex += direction) {
      var series = chartDefinition.series[seriesIndex];
      if (series.showTooltip) {
        var actualCategoryIndex = gviz.canviz.chartdefinitionutil.getCanonicalCategoryIndex(chartDefinition, seriesIndex, categoryIndex);
        if (domainIndex != series.domainIndex) {
          var domainIndex = series.domainIndex, domainTitle = chartDefinition.categories[categoryIndex].titles[domainIndex];
          goog.string.isEmptySafe(domainTitle) || this.addTitleLine_(body, domainTitle);
        }
        series.points[actualCategoryIndex] && series.points[actualCategoryIndex].tooltipText && series.points[actualCategoryIndex].tooltipText.content && (text = series.points[actualCategoryIndex].tooltipText, this.addSerieLine_(body, text.serieTitle, text.content, !0, this.showColorCode, series, void 0, void 0, void 0, void 0, text.hasCustomContent && text.hasHtmlContent), hasData = !0);
      }
    }
  }
  goog.isDefAndNotNull(interactionState.actionsMenuEntries) && 0 < interactionState.actionsMenuEntries.length && (hasData = !0);
  this.embedActionsMenu(body, interactionState.actionsMenuEntries);
  return hasData || this.showEmpty_ ? body : null;
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.addTitleLine_ = function(body, title) {
  var lineEntry = gviz.util.tooltip.definer.createBodyTextLineEntry(title, this.getBoldTextStyle());
  body.entries.push(lineEntry);
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.getSerieLines = function(serieTitle, text, isTextBold, showColorCode, opt_serie, opt_isTitleInSeparateLine, opt_linesColor, opt_prefixText, opt_alignColumns, opt_isHtml) {
  var isTitleInSeparateLine = goog.isDefAndNotNull(opt_isTitleInSeparateLine) ? opt_isTitleInSeparateLine : !1, textStyle = isTextBold ? this.getBoldTextStyle() : this.getTextStyle(), textLines = text.split("\n");
  goog.asserts.assert(!goog.isDefAndNotNull(opt_linesColor) || opt_linesColor.length == textLines.length);
  var color = showColorCode ? opt_serie.color.color : null, lineEntry;
  lineEntry = isTitleInSeparateLine && goog.isDefAndNotNull(serieTitle) ? gviz.util.tooltip.definer.createBodyTextLineEntry(serieTitle, this.getTextStyle(), null, null, color, opt_serie && opt_serie.colorOpacity) : gviz.util.tooltip.definer.createBodyTextLineEntry(textLines[0], textStyle, serieTitle, this.getTextStyle(), color, opt_serie && opt_serie.colorOpacity, null, opt_isHtml);
  for (var entries = [lineEntry], i = isTitleInSeparateLine ? 0 : 1;i < textLines.length;i++) {
    var color = goog.isDefAndNotNull(opt_linesColor) ? opt_linesColor[i].color : showColorCode ? gviz.graphics.util.NO_COLOR : null, alpha = goog.isDefAndNotNull(opt_linesColor) ? opt_linesColor[i].alpha : null, prefixText = goog.isDefAndNotNull(opt_prefixText) ? opt_prefixText[i] : null;
    lineEntry = gviz.util.tooltip.definer.createBodyTextLineEntry(textLines[i], textStyle, null, null, color, alpha, prefixText, opt_isHtml);
    lineEntry.alignColumns = opt_alignColumns;
    entries.push(lineEntry);
  }
  return entries;
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.addSerieLine_ = function(body, serieTitle, text, isTextBold, showColorCode, opt_serie, opt_isTitleInSeparateLine, opt_linesColor, opt_prefixText, opt_alignColumns, opt_isHtml) {
  body.entries.push.apply(body.entries, this.getSerieLines(serieTitle, text, isTextBold, showColorCode, opt_serie, opt_isTitleInSeparateLine, opt_linesColor, opt_prefixText, opt_alignColumns, opt_isHtml));
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.getKeyValueLine = function(key, value) {
  return key ? gviz.util.tooltip.definer.createBodyTextLineEntry(value, this.getBoldTextStyle(), key, this.getTextStyle()) : null;
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.addKeyValueLine_ = function(body, key, value) {
  var line = this.getKeyValueLine(key, value);
  null != line && body.entries.push(line);
};
gviz.canviz.DefaultTooltipBodyCreator.prototype.embedActionsMenu = function(body, actionsMenuEntries, opt_addSeparator) {
  actionsMenuEntries && 0 !== actionsMenuEntries.length && ((void 0 == opt_addSeparator || opt_addSeparator) && body.entries.push(gviz.util.tooltip.definer.createBodySeparatorEntry()), goog.array.extend(body.entries, actionsMenuEntries));
};
// INPUT (javascript/gviz/devel/canviz/dive-tooltip-body-creator.js)
gviz.canviz.DiveTooltipBodyCreator = function(chartOptions, chartTextStyle, focusTarget) {
  gviz.canviz.TooltipBodyCreator.call(this, chartOptions, chartTextStyle, focusTarget);
  this.valueStyle_ = this.getBoldTextStyle();
  this.timeStyle_ = goog.object.clone(this.getTextStyle());
  this.timeStyle_.color = "#666666";
  this.timeStyle_.fontSize -= 2;
};
goog.inherits(gviz.canviz.DiveTooltipBodyCreator, gviz.canviz.TooltipBodyCreator);
gviz.canviz.DiveTooltipBodyCreator.prototype.createDatumBody = function(interactionState, seriesIndex, categoryIndex) {
  var chartDefinition = interactionState.chartDefinition, series = chartDefinition.series[seriesIndex], text = series.points[categoryIndex].tooltipText, content = [];
  if (!series.visibleInLegend) {
    var entityName = gviz.util.tooltip.definer.createBodyTextLineEntry(series.title, this.valueStyle_);
    content.push(entityName);
  }
  var value = gviz.util.tooltip.definer.createBodyTextLineEntry(text.content, this.valueStyle_);
  content.push(value);
  var time = gviz.util.tooltip.definer.createBodyTextLineEntry(text.categoryTitle, this.timeStyle_);
  content.push(time);
  return{entries:content};
};
gviz.canviz.DiveTooltipBodyCreator.prototype.createSeriesBody = function() {
  return{entries:[]};
};
gviz.canviz.DiveTooltipBodyCreator.prototype.createCategoryBody = function() {
  return{entries:[]};
};
// INPUT (javascript/gviz/devel/canviz/tooltip-definer.js)
gviz.canviz.TooltipDefiner = function(chartOptions, bodyCreator, chartDimensions) {
  this.bodyCreator_ = bodyCreator;
  this.boundaries_ = chartOptions.inferBooleanValue("tooltip.ignoreBounds", !1) ? new goog.math.Box(-Infinity, Infinity, Infinity, -Infinity) : new goog.math.Box(0, chartDimensions.width, chartDimensions.height, 0);
  this.customPivot_ = null;
  var customPivotX = chartOptions.inferOptionalNumberValue("tooltip.pivot.x"), customPivotY = chartOptions.inferOptionalNumberValue("tooltip.pivot.y");
  goog.isDefAndNotNull(customPivotX) && goog.isNumber(customPivotX) && goog.math.isFiniteNumber(customPivotX) && goog.isDefAndNotNull(customPivotY) && goog.isNumber(customPivotY) && goog.math.isFiniteNumber(customPivotY) && (this.customPivot_ = new goog.math.Coordinate(customPivotX, customPivotY));
  var defaultTooltipTrigger = bodyCreator.hasActionsMenu() ? gviz.Options.TooltipTrigger.BOTH : gviz.Options.TooltipTrigger.FOCUS;
  this.trigger_ = chartOptions.inferEnumValue("tooltip.trigger", gviz.Options.TooltipTrigger, defaultTooltipTrigger);
};
gviz.canviz.TooltipDefiner.prototype.getTrigger = function() {
  return this.trigger_;
};
gviz.canviz.TooltipDefiner.prototype.calcChartOrigin_ = function(chartDefinition) {
  if (chartDefinition.chartType == gviz.canviz.Options.ChartType.PIE) {
    var center = chartDefinition.pie.center;
    return new goog.math.Coordinate(center.x, center.y);
  }
  var hAxis = goog.object.getAnyValue(chartDefinition.hAxes), x = goog.isDefAndNotNull(hAxis.baseline) ? hAxis.baseline.coordinate : Math.min(hAxis.startPos, hAxis.endPos), vAxis = goog.object.getAnyValue(chartDefinition.vAxes), y = goog.isDefAndNotNull(vAxis.baseline) ? vAxis.baseline.coordinate : Math.max(vAxis.startPos, vAxis.endPos);
  return new goog.math.Coordinate(x, y);
};
gviz.canviz.TooltipDefiner.prototype.setBoundaries = function(boundaries) {
  this.boundaries_ = boundaries;
};
gviz.canviz.TooltipDefiner.prototype.calcPointTooltipAnchor_ = function(chartDefinition, pointData, serie) {
  var scaledPoint = pointData.scaled, pointRadius = gviz.canviz.chartdefinitionutil.getPointTotalRadius(pointData, serie), origin = this.calcChartOrigin_(chartDefinition), delta = 1 + Math.ceil(pointRadius / Math.sqrt(2)), x = scaledPoint.x + (scaledPoint.x >= origin.x ? delta : -delta), y = scaledPoint.y + (scaledPoint.y <= origin.y ? -delta : delta);
  return new goog.math.Coordinate(x, y);
};
gviz.canviz.TooltipDefiner.prototype.calcBubbleTooltipAnchor_ = function(chartDefinition, bubbleData, serie) {
  var scaledBubble = bubbleData.scaled, anchor = this.calcPointTooltipAnchor_(chartDefinition, bubbleData, serie);
  if (anchor.x < chartDefinition.chartArea.left || anchor.x > chartDefinition.chartArea.right) {
    anchor.x += 2 * (scaledBubble.x - anchor.x);
  }
  if (anchor.y < chartDefinition.chartArea.top || anchor.y > chartDefinition.chartArea.bottom) {
    anchor.y += 2 * (scaledBubble.y - anchor.y);
  }
  return anchor;
};
gviz.canviz.TooltipDefiner.prototype.calcBarTooltipAnchor_ = function(chartDefinition, barData) {
  var scaledBar = barData.scaled.bar || barData.scaled, origin = this.calcChartOrigin_(chartDefinition), x = scaledBar.left + (scaledBar.left < origin.x ? 0 : scaledBar.width), y = scaledBar.top + (scaledBar.top < origin.y ? 0 : scaledBar.height), anchor = new goog.math.Coordinate(x, y);
  this.clampAnchorToChartArea_(chartDefinition, anchor);
  return anchor;
};
gviz.canviz.TooltipDefiner.prototype.calcCandlestickTooltipAnchor_ = function(chartDefinition, candlestickData) {
  var scaledRect = candlestickData.scaled.rect, origin = this.calcChartOrigin_(chartDefinition), x = scaledRect.left + scaledRect.width > origin.x ? scaledRect.left + scaledRect.width : scaledRect.left, y = scaledRect.top < origin.y ? scaledRect.top : scaledRect.top + scaledRect.height, anchor = new goog.math.Coordinate(x, y);
  this.clampAnchorToChartArea_(chartDefinition, anchor);
  return anchor;
};
gviz.canviz.TooltipDefiner.prototype.calcSliceTooltipAnchor_ = function(chartDefinition, slice) {
  var degrees = slice.isWholeCircle ? 45 : (slice.fromDegrees + slice.toDegrees) / 2, locationDxDy = gviz.canviz.vectorutils.vectorOnEllipse((degrees / 180 - .5) * Math.PI, chartDefinition.pie.radiusX, chartDefinition.pie.radiusY), location = goog.math.Vec2.sum(chartDefinition.pie.center, locationDxDy), anchor = new goog.math.Coordinate(location.x + slice.offset.x, location.y + slice.offset.y);
  this.clampAnchorToFrame_(chartDefinition, anchor);
  return anchor;
};
gviz.canviz.TooltipDefiner.prototype.calcAnnotationTooltipAnchor_ = function(chartDefinition, annotation) {
  goog.asserts.assert(0 < annotation.lines.length);
  var anchor = annotation.anchor ? annotation.anchor : new goog.math.Coordinate(0, 0), line = annotation.lines[0], fontSize = annotation.textStyle.fontSize;
  if (270 == annotation.angle) {
    return new goog.math.Coordinate(anchor.x + line.x + fontSize, anchor.y + line.y - line.length / 2);
  }
  goog.asserts.assert(!annotation.angle);
  return new goog.math.Coordinate(anchor.x + line.x + line.length / 2, anchor.y + line.y - fontSize);
};
gviz.canviz.TooltipDefiner.prototype.calcDatumTooltipAnchor_ = function(chartDefinition, seriesIndex, categoryIndex) {
  var series = chartDefinition.series[seriesIndex], seriesType = series.type;
  categoryIndex = gviz.canviz.chartdefinitionutil.getCanonicalCategoryIndex(chartDefinition, seriesIndex, categoryIndex);
  switch(chartDefinition.chartType) {
    case gviz.canviz.Options.ChartType.FUNCTION:
    ;
    case gviz.canviz.Options.ChartType.HISTOGRAM:
      switch(seriesType) {
        case gviz.canviz.Options.SerieType.BARS:
        ;
        case gviz.canviz.Options.SerieType.STEPPED_AREA:
          return this.calcBarTooltipAnchor_(chartDefinition, series.points[categoryIndex]);
        case gviz.canviz.Options.SerieType.LINE:
        ;
        case gviz.canviz.Options.SerieType.AREA:
          return this.calcPointTooltipAnchor_(chartDefinition, series.points[categoryIndex], series);
        case gviz.canviz.Options.SerieType.CANDLESTICKS:
          return this.calcCandlestickTooltipAnchor_(chartDefinition, series.points[categoryIndex]);
        default:
          goog.asserts.fail('Invalid series type "' + seriesType + '"');
      }
    ;
    case gviz.canviz.Options.ChartType.SCATTER:
      return this.calcPointTooltipAnchor_(chartDefinition, series.points[categoryIndex], series);
    case gviz.canviz.Options.ChartType.BUBBLE:
      return this.calcBubbleTooltipAnchor_(chartDefinition, series.points[categoryIndex], series);
  }
  return new goog.math.Coordinate(0, 0);
};
gviz.canviz.TooltipDefiner.prototype.clampAnchorToChartArea_ = function(chartDefinition, anchor) {
  var chartArea = chartDefinition.chartArea;
  anchor.x = goog.math.clamp(anchor.x, chartArea.left, chartArea.right);
  anchor.y = goog.math.clamp(anchor.y, chartArea.top, chartArea.bottom);
};
gviz.canviz.TooltipDefiner.prototype.clampAnchorToFrame_ = function(chartDefinition, anchor) {
  anchor.x = goog.math.clamp(anchor.x, 0, chartDefinition.width);
  anchor.y = goog.math.clamp(anchor.y, 0, chartDefinition.height);
};
gviz.canviz.TooltipDefiner.prototype.calcCategoryTooltipAnchor_ = function(chartDefinition, pivot, categoryIndex) {
  var x = null, y = null, hAxis = goog.object.getAnyValue(chartDefinition.hAxes), vAxis = goog.object.getAnyValue(chartDefinition.vAxes), hDirection = hAxis.dataDirection, vDirection = vAxis.dataDirection, value = categoryIndex;
  chartDefinition.orientation && chartDefinition.orientation !== gviz.canviz.Options.Orientation.HORIZONTAL ? (vDirection = -vDirection, vAxis.type === gviz.canviz.Options.AxisType.VALUE && (value = chartDefinition.categories[categoryIndex].data), y = vAxis.position.fromValue(value)) : (hAxis.type === gviz.canviz.Options.AxisType.VALUE && (value = chartDefinition.categories[categoryIndex].data), x = hAxis.position.fromValue(value));
  var fontSize = this.bodyCreator_.getTextStyle().fontSize;
  pivot.x = goog.isNull(x) ? pivot.x : x;
  pivot.y = goog.isNull(y) ? pivot.y : y;
  x = pivot.x - hDirection * fontSize;
  y = pivot.y + vDirection * fontSize;
  return new goog.math.Coordinate(x, y);
};
gviz.canviz.TooltipDefiner.prototype.calcBarTooltipPivot_ = function(chartDefinition, barData) {
  var left = barData.left, width = barData.width, right = left + width, top = barData.top, height = barData.height, bottom = top + height, origin = this.calcChartOrigin_(chartDefinition), orientation = chartDefinition.orientation;
  return orientation == gviz.canviz.Options.Orientation.HORIZONTAL ? bottom > origin.y ? new goog.math.Coordinate(left + width / 2, bottom - .1) : new goog.math.Coordinate(left + width / 2, top + .1) : left < origin.x ? new goog.math.Coordinate(left + .1, top + height / 2) : new goog.math.Coordinate(right - .1, top + height / 2);
};
gviz.canviz.TooltipDefiner.prototype.calcSliceTooltipPivot_ = function(chartDefinition, slice) {
  var degrees = slice.isWholeCircle ? 45 : (slice.fromDegrees + slice.toDegrees) / 2, locationDxDy = gviz.canviz.vectorutils.vectorOnEllipse((degrees / 180 - .5) * Math.PI, chartDefinition.pie.radiusX - .1, chartDefinition.pie.radiusY - .1), location = goog.math.Vec2.sum(chartDefinition.pie.center, locationDxDy);
  return new goog.math.Coordinate(location.x + slice.offset.x, location.y + slice.offset.y);
};
gviz.canviz.TooltipDefiner.prototype.calcAnnotationTooltipPivot_ = function(chartDefinition, annotation) {
  goog.asserts.assert(0 < annotation.lines.length);
  var anchor = annotation.anchor ? annotation.anchor : new goog.math.Coordinate(0, 0), line = annotation.lines[0], fontSize = annotation.textStyle.fontSize;
  if (270 == annotation.angle) {
    return new goog.math.Coordinate(anchor.x + line.x + fontSize / 2, anchor.y + line.y);
  }
  goog.asserts.assert(!annotation.angle);
  return new goog.math.Coordinate(anchor.x + line.x, anchor.y + line.y - fontSize / 2);
};
gviz.canviz.TooltipDefiner.prototype.calcDatumTooltipPivot_ = function(chartDefinition, seriesIndex, categoryIndex) {
  categoryIndex = gviz.canviz.chartdefinitionutil.getCanonicalCategoryIndex(chartDefinition, seriesIndex, categoryIndex);
  var series = chartDefinition.series[seriesIndex], seriesType = series.type, scaledDatum = series.points[categoryIndex].scaled;
  if (seriesType == gviz.canviz.Options.SerieType.BARS || seriesType == gviz.canviz.Options.SerieType.STEPPED_AREA || seriesType == gviz.canviz.Options.SerieType.CANDLESTICKS) {
    var barData = scaledDatum.bar || scaledDatum.rect || scaledDatum;
    return this.calcBarTooltipPivot_(chartDefinition, barData);
  }
  return new goog.math.Coordinate(scaledDatum.x, scaledDatum.y);
};
gviz.canviz.TooltipDefiner.prototype.createTooltip = function(interactionState, seriesIndex, categoryIndex, annotationIndex, opt_cursorPosition) {
  goog.asserts.assert(!goog.isNull(seriesIndex) || !goog.isNull(categoryIndex));
  return goog.isNull(seriesIndex) || goog.isNull(categoryIndex) || goog.isNull(annotationIndex) ? goog.isNull(seriesIndex) || goog.isNull(categoryIndex) ? !goog.isNull(seriesIndex) && goog.isNull(categoryIndex) ? this.createSeriesTooltip_(interactionState, seriesIndex) : !goog.isNull(seriesIndex) || goog.isNull(categoryIndex) || goog.isNull(annotationIndex) ? goog.isNull(seriesIndex) && !goog.isNull(categoryIndex) ? (goog.asserts.assert(goog.isDef(opt_cursorPosition)), this.createCategoryTooltip_(interactionState, 
  categoryIndex, opt_cursorPosition)) : null : this.createCategoryAnnotationTooltip_(interactionState, categoryIndex, annotationIndex) : this.createDatumTooltip_(interactionState, seriesIndex, categoryIndex) : this.createDatumAnnotationTooltip_(interactionState, seriesIndex, categoryIndex, annotationIndex);
};
gviz.canviz.TooltipDefiner.prototype.createAggregateTooltip = function(interactionState, data, positionDatum, aggregationTarget) {
  return this.createAggregateDataTooltip(interactionState, data, positionDatum, aggregationTarget);
};
gviz.canviz.TooltipDefiner.prototype.createDatumTooltip_ = function(interactionState, seriesIndex, categoryIndex) {
  var chartDefinition = interactionState.chartDefinition;
  if (!chartDefinition.series[seriesIndex].showTooltip) {
    return null;
  }
  var anchor = this.calcDatumTooltipAnchor_(chartDefinition, seriesIndex, categoryIndex), pivot = this.customPivot_ ? goog.math.Coordinate.sum(anchor, this.customPivot_) : this.calcDatumTooltipPivot_(chartDefinition, seriesIndex, categoryIndex), tooltipText = chartDefinition.series[seriesIndex].points[categoryIndex].tooltipText;
  if (tooltipText.hasHtmlContent && tooltipText.hasCustomContent) {
    return this.createHTMLTooltipWithCustomContent_(tooltipText.content, pivot);
  }
  var body = this.bodyCreator_.createDatumBody(interactionState, seriesIndex, categoryIndex);
  return gviz.util.tooltip.definer.createTooltipDefinition(body, chartDefinition.textMeasureFunction, !0, anchor, this.boundaries_, pivot, void 0, chartDefinition.isHtmlTooltip, chartDefinition.isRtl);
};
gviz.canviz.TooltipDefiner.prototype.createAggregateSeriesTooltip = function(interactionState, seriesIndices, positionSeriesIndex) {
  var chartDefinition = interactionState.chartDefinition;
  goog.asserts.assert(chartDefinition.chartType == gviz.canviz.Options.ChartType.PIE);
  var positionSlice = interactionState.chartDefinition.series[positionSeriesIndex], anchor = this.calcSliceTooltipAnchor_(chartDefinition, positionSlice), pivot = this.calcSliceTooltipPivot_(chartDefinition, positionSlice), tooltipText$$0 = goog.array.map(seriesIndices, function(seriesIndex) {
    return chartDefinition.series[seriesIndex].tooltipText;
  });
  goog.array.some(tooltipText$$0, function(tooltipText) {
    return tooltipText.hasHtmlContent && tooltipText.hasCustomContent;
  });
  var body = this.bodyCreator_.createAggregateSeriesBody(interactionState, seriesIndices);
  return gviz.util.tooltip.definer.createTooltipDefinition(body, chartDefinition.textMeasureFunction, !0, anchor, this.boundaries_, pivot, void 0, chartDefinition.isHtmlTooltip, chartDefinition.isRtl);
};
gviz.canviz.TooltipDefiner.prototype.createAggregateDataTooltip = function(interactionState, data, positionDatum, aggregateTarget) {
  var chartDefinition = interactionState.chartDefinition, anchor = this.calcDatumTooltipAnchor_(chartDefinition, positionDatum.serie, positionDatum.category), pivot = this.calcDatumTooltipPivot_(chartDefinition, positionDatum.serie, positionDatum.category), tooltipText$$0 = goog.array.map(data, function(datum) {
    var categoryIndex = gviz.canviz.chartdefinitionutil.getCanonicalCategoryIndex(chartDefinition, datum.serie, datum.category);
    return chartDefinition.series[datum.serie].points[categoryIndex].tooltipText;
  });
  goog.array.some(tooltipText$$0, function(tooltipText) {
    return tooltipText.hasHtmlContent && tooltipText.hasCustomContent;
  });
  var body = this.bodyCreator_.createAggregateDataBody(interactionState, data, aggregateTarget);
  return gviz.util.tooltip.definer.createTooltipDefinition(body, chartDefinition.textMeasureFunction, !0, anchor, this.boundaries_, pivot, void 0, chartDefinition.isHtmlTooltip, chartDefinition.isRtl);
};
gviz.canviz.TooltipDefiner.prototype.createAggregateCategoryTooltip = function(interactionState, categoryIndices, cursorPosition, aggregateTarget) {
  var chartDefinition = interactionState.chartDefinition, pivot = cursorPosition.clone(), anchor = this.calcCategoryTooltipAnchor_(chartDefinition, pivot, categoryIndices[categoryIndices.length - 1]), pivot = this.customPivot_ ? goog.math.Coordinate.sum(anchor, this.customPivot_) : pivot, tooltipText$$0 = goog.array.map(categoryIndices, function(categoryIndex) {
    return chartDefinition.categories[categoryIndex].tooltipText;
  });
  goog.array.some(tooltipText$$0, function(tooltipText) {
    return tooltipText && tooltipText.hasHtmlContent && tooltipText.hasCustomContent;
  });
  var data = [];
  goog.array.forEach(categoryIndices, function(categoryIndex) {
    goog.array.forEach(chartDefinition.series, function(series, seriesIndex) {
      data.push({serie:seriesIndex, category:categoryIndex});
    });
  });
  var body = this.bodyCreator_.createAggregateDataBody(interactionState, data, aggregateTarget);
  return goog.isNull(body) ? null : gviz.util.tooltip.definer.createTooltipDefinition(body, chartDefinition.textMeasureFunction, !1, anchor, this.boundaries_, pivot, void 0, chartDefinition.isHtmlTooltip, chartDefinition.isRtl);
};
gviz.canviz.TooltipDefiner.prototype.createSeriesTooltip_ = function(interactionState, seriesIndex) {
  var chartDefinition = interactionState.chartDefinition;
  goog.asserts.assert(chartDefinition.chartType == gviz.canviz.Options.ChartType.PIE);
  var slice = chartDefinition.series[seriesIndex], anchor = this.calcSliceTooltipAnchor_(chartDefinition, slice), pivot = this.calcSliceTooltipPivot_(chartDefinition, slice), tooltipText = chartDefinition.series[seriesIndex].tooltipText;
  if (tooltipText.hasHtmlContent && tooltipText.hasCustomContent) {
    return this.createHTMLTooltipWithCustomContent_(tooltipText.content, pivot);
  }
  var body = this.bodyCreator_.createSeriesBody(interactionState, seriesIndex);
  return gviz.util.tooltip.definer.createTooltipDefinition(body, chartDefinition.textMeasureFunction, !0, anchor, this.boundaries_, pivot, void 0, chartDefinition.isHtmlTooltip, chartDefinition.isRtl);
};
gviz.canviz.TooltipDefiner.prototype.createDatumAnnotationTooltip_ = function(interactionState, seriesIndex, categoryIndex, annotationIndex) {
  var chartDefinition = interactionState.chartDefinition, series = chartDefinition.series[seriesIndex], datum = series.points[categoryIndex], annotation = datum.annotation.labels[annotationIndex], tooltipText = annotation.tooltipText;
  if (!tooltipText) {
    return null;
  }
  var anchor = this.calcAnnotationTooltipAnchor_(chartDefinition, annotation), pivot = this.calcAnnotationTooltipPivot_(chartDefinition, annotation);
  if (tooltipText.hasHtmlContent && tooltipText.hasCustomContent) {
    return this.createHTMLTooltipWithCustomContent_(tooltipText.content, pivot);
  }
  var body = this.bodyCreator_.createDatumAnnotationBody(interactionState, seriesIndex, categoryIndex, annotationIndex);
  return gviz.util.tooltip.definer.createTooltipDefinition(body, chartDefinition.textMeasureFunction, !1, anchor, this.boundaries_, pivot, void 0, chartDefinition.isHtmlTooltip, chartDefinition.isRtl);
};
gviz.canviz.TooltipDefiner.prototype.createCategoryTooltip_ = function(interactionState, categoryIndex, cursorPosition) {
  var chartDefinition = interactionState.chartDefinition, pivot = cursorPosition.clone(), anchor = this.calcCategoryTooltipAnchor_(chartDefinition, pivot, categoryIndex), pivot = this.customPivot_ ? goog.math.Coordinate.sum(anchor, this.customPivot_) : pivot, tooltipText = chartDefinition.categories[categoryIndex].tooltipText;
  if (tooltipText && tooltipText.hasHtmlContent && tooltipText.hasCustomContent) {
    return this.createHTMLTooltipWithCustomContent_(tooltipText.content, pivot);
  }
  var body = this.bodyCreator_.createCategoryBody(interactionState, categoryIndex);
  return goog.isNull(body) ? null : gviz.util.tooltip.definer.createTooltipDefinition(body, chartDefinition.textMeasureFunction, !1, anchor, this.boundaries_, pivot, void 0, chartDefinition.isHtmlTooltip, chartDefinition.isRtl);
};
gviz.canviz.TooltipDefiner.prototype.createHTMLTooltipWithCustomContent_ = function(content, pivot) {
  return{html:{content:content, properties:{className:"google-visualization-tooltip"}}, customHtml:!0, pivot:pivot, anchor:pivot, boundaries:this.boundaries_, spacing:gviz.util.tooltip.htmldefiner.SPACING, margin:gviz.util.tooltip.definer.DEFAULT_MARGINS};
};
gviz.canviz.TooltipDefiner.prototype.createCategoryAnnotationTooltip_ = function(interactionState, categoryIndex, annotationIndex) {
  var chartDefinition = interactionState.chartDefinition, category = chartDefinition.categories[categoryIndex], annotation = category.annotation.labels[annotationIndex], tooltipText = annotation.tooltipText;
  if (!tooltipText) {
    return null;
  }
  var anchor = this.calcAnnotationTooltipAnchor_(chartDefinition, annotation), pivot = this.calcAnnotationTooltipPivot_(chartDefinition, annotation);
  if (tooltipText.hasHtmlContent && tooltipText.hasCustomContent) {
    return this.createHTMLTooltipWithCustomContent_(tooltipText.content, pivot);
  }
  var body = this.bodyCreator_.createCategoryAnnotationBody(interactionState, categoryIndex, annotationIndex);
  return gviz.util.tooltip.definer.createTooltipDefinition(body, chartDefinition.textMeasureFunction, !1, anchor, this.boundaries_, pivot, void 0, chartDefinition.isHtmlTooltip, chartDefinition.isRtl);
};
// INPUT (javascript/gviz/devel/canviz/chart-interactivity-definer.js)
gviz.canviz.ChartInteractivityDefiner = function(chartOptions, chartDimensions, chartTextStyle, interactivityModel, focusTarget, opt_actionsMenuDefiner) {
  this.actionsMenuDefiner = opt_actionsMenuDefiner;
  interactivityModel == gviz.canviz.Options.InteractivityModel.DIVE || this.actionsMenuDefiner ? goog.isDefAndNotNull(this.actionsMenuDefiner) && this.actionsMenuDefiner.updateOptions(chartOptions, chartTextStyle) : this.actionsMenuDefiner = new gviz.canviz.ActionsMenuDefiner(chartOptions, chartTextStyle);
  var tooltipBodyCreator = this.createTooltipBodyCreator_(chartOptions, chartTextStyle, interactivityModel, focusTarget);
  this.tooltipDefiner = new gviz.canviz.TooltipDefiner(chartOptions, tooltipBodyCreator, chartDimensions);
};
gviz.canviz.ChartInteractivityDefiner.prototype.getActionsMenuDefiner = function() {
  return this.actionsMenuDefiner;
};
gviz.canviz.ChartInteractivityDefiner.prototype.generateInteractivityLayer = function(chartDefinition, chartState) {
  var interactivityLayer = {};
  goog.isDefAndNotNull(chartState.legend.currentPageIndex) && this.calcLegendScrolling_(chartDefinition, chartState, interactivityLayer);
  this.extendInteractivityLayer(chartDefinition, chartState, interactivityLayer);
  return interactivityLayer;
};
gviz.canviz.ChartInteractivityDefiner.prototype.setAction = function(action) {
  this.actionsMenuDefiner && this.actionsMenuDefiner.setEntry(action);
};
gviz.canviz.ChartInteractivityDefiner.prototype.getAction = function(action) {
  if (this.actionsMenuDefiner) {
    return this.actionsMenuDefiner.getAction(action);
  }
};
gviz.canviz.ChartInteractivityDefiner.prototype.removeAction = function(action) {
  this.actionsMenuDefiner && this.actionsMenuDefiner.removeEntry(action);
};
gviz.canviz.ChartInteractivityDefiner.prototype.createTooltipBodyCreator_ = function(chartOptions, chartTextStyle, interactivityModel, focusTarget) {
  return interactivityModel == gviz.canviz.Options.InteractivityModel.DIVE ? new gviz.canviz.DiveTooltipBodyCreator(chartOptions, chartTextStyle, focusTarget) : new gviz.canviz.DefaultTooltipBodyCreator(chartOptions, chartTextStyle, focusTarget, this.actionsMenuDefiner);
};
gviz.canviz.ChartInteractivityDefiner.prototype.calcLegendScrolling_ = function(chartDefinition, chartState, interactivityLayer) {
  interactivityLayer.legend = interactivityLayer.legend || {};
  var legendDefinition = chartDefinition.legend, currentPageIndex = chartState.legend.currentPageIndex;
  interactivityLayer.legend.currentPage = legendDefinition.pages[currentPageIndex];
  var interactivePageIndexText = currentPageIndex + 1 + "/" + legendDefinition.pages.length, interactivePageIndexTextBlock = {text:interactivePageIndexText, lines:{0:{text:interactivePageIndexText}}}, previousButton = legendDefinition.scrollItems.previousButton, hasPrevious = 0 < currentPageIndex, interactivePreviousButton = {brush:hasPrevious ? previousButton.brushes.active : previousButton.brushes.inactive, active:hasPrevious}, nextButton = legendDefinition.scrollItems.nextButton, hasNext = currentPageIndex < 
  chartDefinition.legend.pages.length - 1, interactiveNextButton = {brush:hasNext ? nextButton.brushes.active : nextButton.brushes.inactive, active:hasNext};
  interactivityLayer.legend.scrollItems = {previousButton:interactivePreviousButton, nextButton:interactiveNextButton, pageIndexTextBlock:interactivePageIndexTextBlock};
};
// INPUT (javascript/gviz/devel/canviz/chart-state.js)
gviz.canviz.ChartState = function(opt_state) {
  this.selected = new gviz.util.Selection;
  this.focused = {serie:null, datum:null, category:null};
  this.annotations = {focused:null, expanded:null};
  this.legend = {focused:{entry:null}, currentPageIndex:null};
  this.actionsMenu = {focused:{entryID:null}};
  this.cursor = {position:null, positionAtLastClick:null};
  this.overlayBox = this.nextFrameOptions = null;
  opt_state && (this.selected.setSelection(opt_state.selected), opt_state.focused && (this.focused = gviz.canviz.ChartState.compact_(this.focused, opt_state.focused)), opt_state.annotations && (this.annotations = gviz.canviz.ChartState.compact_(this.annotations, opt_state.annotations)), opt_state.legend && (this.legend = gviz.canviz.ChartState.compact_(this.legend, opt_state.legend)), opt_state.actionsMenu && (this.actionsMenu = gviz.canviz.ChartState.compact_(this.actionsMenu, opt_state.actionsMenu)), 
  opt_state.nextFrameOptions && (this.nextFrameOptions = gviz.canviz.ChartState.compact_(this.nextFrameOptions, opt_state.nextFrameOptions)), opt_state.overlayBox && gviz.canviz.ChartState.compact_(this.overlayBox, opt_state.overlayBox));
};
gviz.canviz.ChartState.prototype.clone = function() {
  var cloned = new gviz.canviz.ChartState;
  cloned.selected = this.selected.clone();
  cloned.focused = gviz.object.unsafeClone(this.focused);
  cloned.annotations = gviz.object.unsafeClone(this.annotations);
  cloned.legend = gviz.object.unsafeClone(this.legend);
  cloned.actionsMenu = gviz.object.unsafeClone(this.actionsMenu);
  cloned.cursor = gviz.object.unsafeClone(this.cursor);
  cloned.nextFrameOptions = gviz.object.unsafeClone(this.nextFrameOptions);
  cloned.overlayBox = gviz.object.unsafeClone(this.overlayBox);
  return cloned;
};
gviz.canviz.ChartState.prototype.equals = function(other, opt_ignoreCursor) {
  var ignoreCursor = goog.isDef(opt_ignoreCursor) ? opt_ignoreCursor : !1;
  return this.selected.equals(other.selected) && gviz.object.unsafeEquals(this.focused, other.focused) && gviz.object.unsafeEquals(this.annotations, other.annotations) && gviz.object.unsafeEquals(this.legend, other.legend) && gviz.object.unsafeEquals(this.actionsMenu, other.actionsMenu) && (ignoreCursor || gviz.object.unsafeEquals(this.cursor, other.cursor)) && gviz.object.unsafeEquals(this.nextFrameOptions, other.nextFrameOptions) && gviz.object.unsafeEquals(this.overlayBox, other.overlayBox);
};
gviz.canviz.ChartState.compact_ = function(layer1, layer2) {
  var layeredObj = new gviz.util.LayeredObject(2);
  layeredObj.setLayer(0, layer1);
  layeredObj.setLayer(1, layer2);
  return layeredObj.compact();
};
// INPUT (javascript/gviz/devel/canviz/histogram-chart-definition.js)
gviz.canviz.HistogramChartDefinition = function() {
};
goog.inherits(gviz.canviz.HistogramChartDefinition, gviz.canviz.ChartDefinition);
gviz.canviz.HistogramChartDefinition.prototype.getCategoryTitleForDatum = function(datum) {
  var seriesIndex = datum.serie, categoryIndex = datum.category;
  if (this.histogramAsColumnChart) {
    return gviz.canviz.HistogramChartDefinition.superClass_.getCategoryTitleForDatum.call(this, datum);
  }
  var mapping = this.series[seriesIndex].properties.histogramBucketItems[categoryIndex];
  return mapping.label.categoryTitle;
};
gviz.canviz.HistogramChartDefinition.prototype.getCategoryIndexForDatum = function(datum) {
  if (this.histogramAsColumnChart) {
    return gviz.canviz.HistogramChartDefinition.superClass_.getCategoryIndexForDatum.call(this, datum);
  }
  var mapping = this.series[datum.serie].properties.histogramBucketItems[datum.category];
  return mapping.row;
};
gviz.canviz.HistogramChartDefinition.prototype.getCellRefForDatum = function(datum) {
  if (this.histogramAsColumnChart) {
    return gviz.canviz.HistogramChartDefinition.superClass_.getCellRefForDatum.call(this, datum);
  }
  var mapping = this.series[datum.serie].properties.histogramBucketItems[datum.category];
  return{row:mapping.row, column:mapping.column};
};
gviz.canviz.HistogramChartDefinition.prototype.getDatumForCellRef = function(cell) {
  var columnInfo = this.dataTableColumnRoleInfo[cell.column], serieIndex = columnInfo.serieIndex;
  if (!goog.isDefAndNotNull(serieIndex)) {
    return null;
  }
  if (this.histogramAsColumnChart) {
    return gviz.canviz.HistogramChartDefinition.superClass_.getDatumForCellRef.call(this, cell);
  }
  var datum = {serie:serieIndex, category:this.series[serieIndex].properties.histogramElementIndexes[cell.row]};
  return datum;
};
gviz.canviz.HistogramChartDefinition.prototype.getTooltipText = function(seriesIndex, categoryIndex) {
  var series = this.series[seriesIndex], point = series.points[categoryIndex], tooltipText;
  if (this.histogramAsColumnChart) {
    tooltipText = {lines:[{title:"Items", value:point.nonScaled.to - point.nonScaled.from}]};
  } else {
    var mapping = series.properties.histogramBucketItems[categoryIndex];
    tooltipText = mapping.label;
  }
  return tooltipText;
};
// INPUT (javascript/gviz/devel/canviz/histogram-chart-definer.js)
$jscomp.scope.MIN_PIXELS_PER_BUCKET = 5;
$jscomp.scope.BUCKET_SIZE_PRECISION = 1;
gviz.canviz.HistogramChartDefiner = function(dataTable, options, textMeasureFunction, width, height) {
  gviz.canviz.AxisChartDefiner.call(this, dataTable, options, textMeasureFunction, width, height);
};
goog.inherits(gviz.canviz.HistogramChartDefiner, gviz.canviz.AxisChartDefiner);
gviz.canviz.HistogramChartDefiner.prototype.constructChartDefinition = function() {
  return new gviz.canviz.HistogramChartDefinition;
};
gviz.canviz.HistogramChartDefiner.prototype.calcDataView = function() {
  for (var dataTable = this.dataTable, firstColIsLabel = "string" === dataTable.getColumnType(0), colStart = firstColIsLabel ? 1 : 0, vals = [], numRows = dataTable.getNumberOfRows(), numCols = dataTable.getNumberOfColumns(), min = Infinity, max = -Infinity, i = 0;i < numRows;i++) {
    for (var j = colStart;j < numCols;j++) {
      var val = dataTable.getValue(i, j);
      goog.isNumber(val) && !isFinite(val) || null === val && !this.chartDef.interpolateNulls || (val = val || 0, vals.push(val), min = Math.min(min, val), max = Math.max(max, val));
    }
  }
  var bucketSize = this.options.inferNumberValue("histogram.bucketSize"), percentile = this.options.inferNumberValue("histogram.lastBucketPercentile"), minNumBuckets = this.options.inferNumberValue("histogram.minNumBuckets"), maxNumBuckets = this.options.inferNumberValue("histogram.maxNumBuckets"), sortBucketItems = this.options.inferBooleanValue("histogram.sortBucketItems");
  0 < maxNumBuckets && (minNumBuckets = Math.min(minNumBuckets, maxNumBuckets - 1));
  if (0 < bucketSize) {
    var range = max - min, maxNumBuckets = Math.max(minNumBuckets, Math.min(maxNumBuckets, this.chartDef.width / $jscomp.scope.MIN_PIXELS_PER_BUCKET)), rawBucketSize = range / maxNumBuckets, niceBucketSize = (rawBucketSize + rawBucketSize / 2).toPrecision($jscomp.scope.BUCKET_SIZE_PRECISION), bucketSize = Math.max(bucketSize, niceBucketSize)
  }
  var buckets = new autovis.ColumnBuckets;
  buckets.create(vals, percentile, bucketSize, minNumBuckets, maxNumBuckets);
  var bucketSize = bucketSize || buckets.getBucketSize(), bucketItems = [], labels = buckets.getBucketLabels(), table = new google.visualization.DataTable;
  table.addColumn("number", "label");
  for (i = colStart;i < numCols;i++) {
    var MSG_HISTOGRAM_LABEL = dataTable.getColumnLabel(i) + " (count)";
    table.addColumn("number", MSG_HISTOGRAM_LABEL);
    bucketItems[i - colStart] = [];
    for (j = 0;j < labels.length;j++) {
      bucketItems[i - colStart].push([]);
    }
  }
  for (var values = buckets.getBucketValues(), i = 0;i < labels.length;i++) {
    table.addRow(), table.setValue(i, 0, values[i]);
  }
  for (i = 0;i < numRows;i++) {
    for (var title = firstColIsLabel ? this.dataTable.getValue(i, 0) : "", j = colStart;j < numCols;j++) {
      if (val = this.dataTable.getValue(i, j), !(goog.isNumber(val) && !isFinite(val) || null === val && !this.chartDef.interpolateNulls)) {
        var b$$0 = buckets.getBucketIndexByValue(val), c = j + 1 - colStart;
        table.setValue(b$$0, c, (table.getValue(b$$0, c) || 0) + 1);
        var serieTitle = this.dataTable.getColumnLabel(j) || "Value", categoryTitle = title, bucketItem = {row:i, column:j, label:{title:title, categoryTitle:categoryTitle, serieTitle:serieTitle, content:val.toString(), lines:[{title:serieTitle, value:val || 0}]}}, bucket = bucketItems[j - colStart][b$$0];
        bucket.push(bucketItem);
      }
    }
  }
  for (var elementIndexes = [], j = colStart;j < numCols;j++) {
    elementIndexes[j] = [];
  }
  for (j = colStart;j < numCols;j++) {
    var elementIndexToBucketItems = goog.array.flatten(bucketItems[j - colStart]);
    sortBucketItems && elementIndexToBucketItems.sort(function(a, b) {
      var valueA = a.label.lines[0].value, valueB = b.label.lines[0].value;
      return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
    });
    table.setColumnProperty(j - colStart, "histogramBucketItems", elementIndexToBucketItems);
    goog.array.forEach(elementIndexToBucketItems, function(bucketItem, index) {
      elementIndexes[bucketItem.column][bucketItem.row] = index;
    });
  }
  for (j = colStart;j < numCols;j++) {
    table.setColumnProperty(j - colStart, "histogramElementIndexes", elementIndexes[j]);
  }
  var bucketValues = buckets.getBucketValues();
  table.setColumnProperty(0, "histogramBuckets", bucketValues);
  this.dataView = new google.visualization.DataView(table);
};
gviz.canviz.HistogramChartDefiner.treatHistogramAsColumnChart = function(numericValueToPixelsFactor, hideBucketItems) {
  return 4 > numericValueToPixelsFactor || hideBucketItems;
};
gviz.canviz.HistogramChartDefiner.getLargestStack = function(isStacked, chartDef, dataView) {
  for (var totals = [], i = 0;i < chartDef.categories.length;i++) {
    totals[i] = [];
    for (var j = 0;j < chartDef.series.length;j++) {
      var serie = chartDef.series[j];
      if (serie.type == gviz.canviz.Options.SerieType.BARS) {
        var target = isStacked ? 0 : j;
        totals[i][target] = (totals[i][target] || 0) + dataView.getValue(i, serie.columns[gviz.canviz.ColumnRole.DATA][0]);
      }
    }
  }
  for (var max = 0, i = 0;i < totals.length;i++) {
    for (j = 0;j < totals[i].length;j++) {
      max = Math.max(totals[i][j], max);
    }
  }
  return max;
};
// INPUT (javascript/gviz/devel/canviz/axis-chart-interactivity-definer.js)
gviz.canviz.AxisChartInteractivityDefiner = function(chartOptions, chartDimensions, chartTextStyle, interactivityModel, focusTarget, numberOfSeries, opt_actionsMenuDefiner) {
  gviz.canviz.ChartInteractivityDefiner.call(this, chartOptions, chartDimensions, chartTextStyle, interactivityModel, focusTarget, opt_actionsMenuDefiner);
  this.crosshairTrigger_ = chartOptions.inferOptionalEnumValue("crosshair.trigger", gviz.Options.CrosshairTrigger);
  this.crosshairSelectedOrientation_ = chartOptions.inferEnumValue(["crosshair.selected.orientation", "crosshair.orientation"], gviz.Options.CrosshairOrientation, gviz.Options.CrosshairOrientation.BOTH);
  this.crosshairFocusedOrientation_ = chartOptions.inferEnumValue(["crosshair.focused.orientation", "crosshair.orientation"], gviz.Options.CrosshairOrientation, gviz.Options.CrosshairOrientation.BOTH);
  this.crosshairSelectedColor_ = chartOptions.inferOptionalColorValue(["crosshair.selected.color", "crosshair.color"]);
  this.crosshairFocusedColor_ = chartOptions.inferOptionalColorValue(["crosshair.focused.color", "crosshair.color"]);
  this.crosshairSelectedOpacity_ = chartOptions.inferRatioNumberValue(["crosshair.selected.opacity", "crosshair.opacity"], 1);
  this.crosshairFocusedOpacity_ = chartOptions.inferRatioNumberValue(["crosshair.focused.opacity", "crosshair.opacity"], 1);
  this.aggregationTarget_ = chartOptions.inferEnumValue("aggregationTarget", gviz.canviz.Options.AggregationTarget, gviz.canviz.Options.AggregationTarget.NONE);
  this.ignoreCursorInChartStateComparison_ = !0;
};
goog.inherits(gviz.canviz.AxisChartInteractivityDefiner, gviz.canviz.ChartInteractivityDefiner);
gviz.canviz.AxisChartInteractivityDefiner.prototype.extendInteractivityLayer = function(chartDefinition, chartState, interactivityLayer) {
  this.ignoreCursorInChartStateComparison_ = !0;
  switch(chartDefinition.interactivityModel) {
    case gviz.canviz.Options.InteractivityModel.DEFAULT:
      this.defaultInteractivityModel(chartDefinition, chartState, interactivityLayer);
      break;
    case gviz.canviz.Options.InteractivityModel.DIVE:
      this.diveInteractivityModel(chartDefinition, chartState, interactivityLayer);
      break;
    default:
      goog.asserts.fail('Invalid interactivity model "' + chartDefinition.interactivityModel + '"');
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.equalChartStates = function(chartState1, chartState2) {
  return chartState1.equals(chartState2, this.ignoreCursorInChartStateComparison_);
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.isSerieInteractive_ = function(chartDef, serieIndex) {
  return chartDef.series[serieIndex].enableInteractivity;
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.isAnySeriesInteractive_ = function(chartDef) {
  return goog.array.some(chartDef.series, function(series) {
    return series.enableInteractivity;
  });
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.isAnnotationInteractive_ = function(chartDef, serieIndex) {
  return goog.isDefAndNotNull(serieIndex) ? this.isSerieInteractive_(chartDef, serieIndex) : chartDef.enableInteractivity;
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.createInteractiveDatum_ = function(interactivityLayer, serieIndex, datumIndex) {
  interactivityLayer.series = interactivityLayer.series || {};
  var series = interactivityLayer.series;
  series[serieIndex] = series[serieIndex] || {};
  var serie = series[serieIndex];
  serie.points = serie.points || {};
  var points = serie.points;
  points[datumIndex] = points[datumIndex] || {};
  return points[datumIndex];
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.createInteractiveAnnotation_ = function(interactivityLayer, serieIndex, datumOrCategoryIndex) {
  if (goog.isDefAndNotNull(serieIndex)) {
    var datum = this.createInteractiveDatum_(interactivityLayer, serieIndex, datumOrCategoryIndex);
    datum.annotation = datum.annotation || {};
    return datum.annotation;
  }
  var category = this.createInteractiveCategory_(interactivityLayer, datumOrCategoryIndex);
  category.annotation = category.annotation || {};
  return category.annotation;
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.createInteractiveSerie_ = function(interactivityLayer, serieIndex) {
  interactivityLayer.series = interactivityLayer.series || {};
  var series = interactivityLayer.series;
  series[serieIndex] = series[serieIndex] || {};
  return series[serieIndex];
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.createInteractiveCategory_ = function(interactivityLayer, categoryIndex) {
  interactivityLayer.categories = interactivityLayer.categories || {};
  var categories = interactivityLayer.categories;
  categories[categoryIndex] = categories[categoryIndex] || {};
  return categories[categoryIndex];
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.createInteractiveLegendEntry_ = function(interactivityLayer, legendEntryIndex) {
  interactivityLayer.legend = interactivityLayer.legend || {};
  var legend = interactivityLayer.legend;
  legend.currentPage = legend.currentPage || {};
  var currentPage = legend.currentPage;
  currentPage[legendEntryIndex] = currentPage[legendEntryIndex] || {};
  return currentPage[legendEntryIndex];
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.defaultInteractivityModel = function(chartDefinition, chartState, interactivityLayer) {
  var interactionState = {chartDefinition:chartDefinition, actionsMenuEntries:this.actionsMenuDefiner.getEntries(), interactivityLayer:interactivityLayer, actionsMenuState:chartState.actionsMenu}, focusedActionId = chartState.actionsMenu.focused.entryID;
  null != focusedActionId && (chartState.actionsMenu.focused.action = this.actionsMenuDefiner.getAction(focusedActionId).action);
  for (var tooltipTrigger = this.tooltipDefiner.getTrigger(), selectionTriggersTooltip = gviz.canviz.chartdefinitionutil.isTooltipTriggeredBySelection(tooltipTrigger), focusTriggersTooltip = gviz.canviz.chartdefinitionutil.isTooltipTriggeredByFocus(tooltipTrigger, chartState.selected), shouldAggregate = this.aggregationTarget_ != gviz.canviz.Options.AggregationTarget.NONE, showActionsMenu = this.actionsMenuDefiner && 0 < interactionState.actionsMenuEntries.length, selectedCells = chartState.selected.getCells(), 
  showAggregateTooltip = 1 < selectedCells.length && (shouldAggregate || showActionsMenu), i = 0;i < selectedCells.length;++i) {
    var selectedCell = selectedCells[i], selectedColumn = selectedCell.column, selectedRow = selectedCell.row, selectedColumnInfo = chartDefinition.dataTableColumnRoleInfo[selectedColumn], selectedSerieIndex = selectedColumnInfo.serieIndex, selectedDatum = chartDefinition.getDatumForCellRef({column:selectedColumn, row:selectedRow});
    if (selectedDatum) {
      switch(selectedColumnInfo.role) {
        case gviz.canviz.ColumnRole.DATA:
          goog.asserts.assert(goog.isDefAndNotNull(selectedSerieIndex));
          this.ringDatum_(chartDefinition, selectedDatum.serie, selectedDatum.category, interactivityLayer);
          selectionTriggersTooltip && !showAggregateTooltip && this.addTooltipToDatum_(interactionState, selectedDatum.serie, selectedDatum.category);
          break;
        case gviz.canviz.ColumnRole.ANNOTATION:
          if (!this.isAnnotationInteractive_(chartDefinition, selectedSerieIndex)) {
            break;
          }
          var selectedAnnotationIndex = selectedColumnInfo.roleIndex;
          this.makeAnnotationBold_(chartDefinition, selectedDatum.serie, selectedDatum.category, selectedAnnotationIndex, interactivityLayer);
          selectionTriggersTooltip && this.addTooltipToAnnotation_(interactionState, selectedDatum.serie, selectedDatum.category, selectedAnnotationIndex);
      }
    }
  }
  if (selectionTriggersTooltip && showAggregateTooltip && !chartDefinition.histogramAsColumnChart) {
    var data = goog.array.filter(goog.array.map(selectedCells, function(cell) {
      return chartDefinition.getDatumForCellRef({column:cell.column, row:cell.row});
    }), goog.isDefAndNotNull);
    0 < data.length && this.addAggregateTooltipToData_(interactionState, shouldAggregate ? data : [], data[data.length - 1]);
  }
  for (var selectedColumns = chartState.selected.getColumnIndexes(), i = 0;i < selectedColumns.length;++i) {
    selectedColumn = selectedColumns[i], selectedColumnInfo = chartDefinition.dataTableColumnRoleInfo[selectedColumn], goog.isDefAndNotNull(selectedColumnInfo) && (selectedSerieIndex = selectedColumnInfo.serieIndex, goog.isDefAndNotNull(selectedSerieIndex) && this.ringSerie_(chartDefinition, selectedSerieIndex, interactivityLayer));
  }
  for (var isBubbleChart = chartDefinition.chartType === gviz.canviz.Options.ChartType.BUBBLE, selectedRows = chartState.selected.getRowIndexes(), showAggregateTooltipRows = 1 < selectedRows.length && (shouldAggregate || showActionsMenu), i = 0;i < selectedRows.length;++i) {
    var selectedRow = selectedRows[i], selectedCategoryIndex = chartDefinition.dataTableToCategoryMap[selectedRow];
    isBubbleChart ? (selectedSerieIndex = 0, this.ringDatum_(chartDefinition, selectedSerieIndex, selectedCategoryIndex, interactivityLayer), selectionTriggersTooltip && !showAggregateTooltipRows && this.addTooltipToDatum_(interactionState, selectedSerieIndex, selectedCategoryIndex)) : (this.ringCategory_(chartDefinition, selectedCategoryIndex, interactivityLayer), selectionTriggersTooltip && !showAggregateTooltipRows && this.addTooltipToCategory_(interactionState, chartState.cursor.positionAtLastClick, 
    selectedCategoryIndex));
  }
  if (showAggregateTooltipRows) {
    if (isBubbleChart) {
      var lastSelectedRow = selectedRows[selectedRows.length - 1];
      this.addTooltipToDatum_(interactionState, 0, chartDefinition.dataTableToCategoryMap[lastSelectedRow]);
    } else {
      if (selectionTriggersTooltip) {
        var categories = goog.array.map(selectedRows, function(row) {
          return chartDefinition.dataTableToCategoryMap[row];
        });
        0 < categories.length && this.addAggregateTooltipToCategory_(interactionState, chartState.cursor.positionAtLastClick, categories);
      }
    }
  }
  var focusedSerieIndex = chartState.focused.serie, focusedDatumIndex = chartState.focused.datum;
  goog.isDefAndNotNull(focusedDatumIndex) && goog.asserts.assert(goog.isDefAndNotNull(focusedSerieIndex));
  goog.isDefAndNotNull(focusedDatumIndex) ? this.isSerieInteractive_(chartDefinition, focusedSerieIndex) && (this.glowDatum_(chartDefinition, focusedSerieIndex, focusedDatumIndex, interactivityLayer), focusTriggersTooltip && this.addTooltipToDatum_(interactionState, focusedSerieIndex, focusedDatumIndex), this.markDatumInColorBar_(chartDefinition, focusedSerieIndex, focusedDatumIndex, interactivityLayer)) : goog.isDefAndNotNull(focusedSerieIndex) && this.isSerieInteractive_(chartDefinition, focusedSerieIndex) && 
  this.glowSerie_(chartDefinition, focusedSerieIndex, interactivityLayer);
  var focusedLegendEntryIndex = chartState.legend.focused.entry;
  goog.isDefAndNotNull(focusedLegendEntryIndex) && this.isSerieInteractive_(chartDefinition, focusedLegendEntryIndex) && this.glowSerie_(chartDefinition, focusedLegendEntryIndex, interactivityLayer);
  var focusedCategoryIndex = chartState.focused.category;
  goog.isDefAndNotNull(focusedCategoryIndex) && chartDefinition.categories[focusedCategoryIndex] && (this.glowCategory_(chartDefinition, focusedCategoryIndex, interactivityLayer), focusTriggersTooltip && this.isAnySeriesInteractive_(interactionState.chartDefinition) && (this.addTooltipToCategory_(interactionState, chartState.cursor.position, focusedCategoryIndex), this.ignoreCursorInChartStateComparison_ = !1));
  var expandedAnnotation = chartState.annotations.expanded;
  if (expandedAnnotation) {
    var interactiveAnnotation = this.createInteractiveAnnotation_(interactivityLayer, expandedAnnotation.serieIndex, expandedAnnotation.datumOrCategoryIndex);
    interactiveAnnotation.bundle = interactiveAnnotation.bundle || {};
    interactiveAnnotation.bundle.isExpanded = !0;
  }
  var focusedAnnotation = chartState.annotations.focused;
  if (focusedAnnotation && focusTriggersTooltip) {
    var annotationColumn = focusedAnnotation.column, annotationRow = focusedAnnotation.row, annotationColumnInfo = chartDefinition.dataTableColumnRoleInfo[annotationColumn], annotationSerieIndex = annotationColumnInfo.serieIndex, annotationCategoryIndex = chartDefinition.dataTableToCategoryMap[annotationRow], annotationLabelIndex = annotationColumnInfo.roleIndex;
    this.isAnnotationInteractive_(chartDefinition, annotationSerieIndex) && this.addTooltipToAnnotation_(interactionState, annotationSerieIndex, annotationCategoryIndex, annotationLabelIndex);
  }
  var overlayBox = chartState.overlayBox;
  overlayBox && (interactivityLayer.overlayBox = overlayBox);
};
gviz.canviz.AxisChartInteractivityDefiner.GLOW_COLOR = "black";
gviz.canviz.AxisChartInteractivityDefiner.GLOW_OPACITY_LEVELS_FOR_POINTS = [.25, .1, .05];
gviz.canviz.AxisChartInteractivityDefiner.GLOW_OPACITY_LEVELS_FOR_LINES = [.3, .1, .05];
gviz.canviz.AxisChartInteractivityDefiner.GLOW_OPACITY_LEVELS_FOR_BARS = [.3, .15, .05];
gviz.canviz.AxisChartInteractivityDefiner.POINT_RING_DISTANCE = 1.5;
gviz.canviz.AxisChartInteractivityDefiner.LINE_RING_DISTANCE = 2;
gviz.canviz.AxisChartInteractivityDefiner.BAR_RING_DISTANCE = 1.5;
gviz.canviz.AxisChartInteractivityDefiner.prototype.glowDatum_ = function(chartDefinition, serieIndex, datumIndex, interactivityLayer) {
  var serie = chartDefinition.series[serieIndex], datum = serie.points[datumIndex];
  if (!gviz.canviz.chartdefinitionutil.isDatumNull(datum) && datum.scaled && (!gviz.canviz.chartdefinitionutil.isSeriePathBased(serie) || 0 != serie.lineWidth || gviz.canviz.chartdefinitionutil.isDatumVisible(datum, serie))) {
    var GLOW_OPACITY_LEVELS = serie.type == gviz.canviz.Options.SerieType.BARS ? gviz.canviz.AxisChartInteractivityDefiner.GLOW_OPACITY_LEVELS_FOR_BARS : gviz.canviz.AxisChartInteractivityDefiner.GLOW_OPACITY_LEVELS_FOR_POINTS, interactiveDatum = this.createInteractiveDatum_(interactivityLayer, serieIndex, datumIndex);
    interactiveDatum.glow = {};
    var interactiveGlow = interactiveDatum.glow;
    interactiveGlow.levels = [];
    for (var i = 0;i < GLOW_OPACITY_LEVELS.length;i++) {
      var glowBrush = new gviz.graphics.Brush({fill:"none", stroke:gviz.canviz.AxisChartInteractivityDefiner.GLOW_COLOR, strokeOpacity:GLOW_OPACITY_LEVELS[i], strokeWidth:1});
      interactiveGlow.levels.push({brush:glowBrush});
    }
    switch(serie.type) {
      case gviz.canviz.Options.SerieType.BARS:
      ;
      case gviz.canviz.Options.SerieType.STEPPED_AREA:
      ;
      case gviz.canviz.Options.SerieType.CANDLESTICKS:
        for (var scaledBar = datum.scaled.bar || datum.scaled.rect || datum.scaled, rect = new goog.math.Rect(scaledBar.left, scaledBar.top, scaledBar.width, scaledBar.height), i = 0;i < GLOW_OPACITY_LEVELS.length;i++) {
          var glowStrokeWidth = interactiveGlow.levels[i].brush.getStrokeWidth();
          interactiveGlow.levels[i].rect = new goog.math.Rect(rect.left - glowStrokeWidth / 2, rect.top - glowStrokeWidth / 2, rect.width + glowStrokeWidth, rect.height + glowStrokeWidth);
          rect.left -= glowStrokeWidth;
          rect.top -= glowStrokeWidth;
          rect.width += 2 * glowStrokeWidth;
          rect.height += 2 * glowStrokeWidth;
        }
        break;
      case gviz.canviz.Options.SerieType.LINE:
      ;
      case gviz.canviz.Options.SerieType.AREA:
      ;
      case gviz.canviz.Options.SerieType.SCATTER:
      ;
      case gviz.canviz.Options.SerieType.BUBBLES:
        interactiveDatum.visible = !0;
        interactiveGlow.x = datum.scaled.x;
        interactiveGlow.y = datum.scaled.y;
        if (this.crosshairTrigger_ === gviz.Options.CrosshairTrigger.BOTH || this.crosshairTrigger_ === gviz.Options.CrosshairTrigger.FOCUS) {
          var datumBrush = gviz.canviz.chartdefinitionutil.getDatumBrush(datum, serie), crosshairBrush = gviz.graphics.Brush.createStrokeBrush(this.crosshairFocusedColor_ || datumBrush.getFill(), 1, !1, this.crosshairFocusedOpacity_);
          this.drawCrosshair_(chartDefinition, datum, interactiveDatum, crosshairBrush, this.crosshairFocusedOrientation_);
        }
        var radius;
        if (interactiveDatum.ring) {
          var ring = interactiveDatum.ring;
          radius = ring.radius + ring.brush.getStrokeWidth() / 2;
        } else {
          radius = gviz.canviz.chartdefinitionutil.getPointTotalRadius(datum, serie);
        }
        for (i = 0;i < GLOW_OPACITY_LEVELS.length;i++) {
          glowStrokeWidth = interactiveGlow.levels[i].brush.getStrokeWidth(), interactiveGlow.levels[i].radius = radius + glowStrokeWidth / 2, radius += glowStrokeWidth;
        }
      ;
    }
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.glowSerie_ = function(chartDefinition, serieIndex, interactivityLayer) {
  var serie = chartDefinition.series[serieIndex], interactiveSerie;
  if (gviz.canviz.chartdefinitionutil.isSeriePathBased(serie) && 0 < serie.lineWidth) {
    var GLOW_OPACITY_LEVELS = gviz.canviz.AxisChartInteractivityDefiner.GLOW_OPACITY_LEVELS_FOR_LINES;
    interactiveSerie = this.createInteractiveSerie_(interactivityLayer, serieIndex);
    interactiveSerie.glow = {};
    var interactiveGlow = interactiveSerie.glow;
    interactiveGlow.levels = [];
    var pathSegments;
    pathSegments = serie.type == gviz.canviz.Options.SerieType.AREA ? chartDefinition.isStacked ? gviz.canviz.chartdefinitionutil.createPathSegmentsForStackedArea(serie) : gviz.canviz.chartdefinitionutil.createPathSegments(serie, !1) : gviz.canviz.chartdefinitionutil.createPathSegments(serie, chartDefinition.interpolateNulls);
    pathSegments = pathSegments.toSingleBrush();
    for (var glowOffset = serie.lineBrush.getStrokeWidth() / 2, i = 0;i < GLOW_OPACITY_LEVELS.length;i++) {
      var glowBrush = new gviz.graphics.Brush({fill:"none", stroke:gviz.canviz.AxisChartInteractivityDefiner.GLOW_COLOR, strokeOpacity:GLOW_OPACITY_LEVELS[i], strokeWidth:1}), glowPath = gviz.graphics.pathsegmentsutil.calcParallelPath(pathSegments, glowOffset + glowBrush.getStrokeWidth() / 2);
      interactiveGlow.levels.push({brush:glowBrush, path:glowPath});
      glowOffset += glowBrush.getStrokeWidth();
    }
  }
  for (var interactiveSeries = interactivityLayer.series, interactivePoints = (interactiveSerie = interactiveSeries && interactiveSeries[serieIndex]) && interactiveSerie.points, datumIndex = 0;datumIndex < serie.points.length;++datumIndex) {
    var datum = serie.points[datumIndex];
    gviz.canviz.chartdefinitionutil.isDatumNull(datum) || (gviz.canviz.chartdefinitionutil.isDatumVisible(datum, serie) || interactivePoints && interactivePoints[datumIndex] && interactivePoints[datumIndex].visible) && this.glowDatum_(chartDefinition, serieIndex, datumIndex, interactivityLayer);
  }
  chartDefinition.isDiff && serie.type === gviz.canviz.Options.SerieType.SCATTER && !this.serieHasOldData_(serie.columns) && this.glowSerie_(chartDefinition, serieIndex - 1, interactivityLayer);
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.serieHasOldData_ = function(serieColumns) {
  var oldDataColumns = serieColumns[gviz.canviz.ColumnRole.DIFF_OLD_DATA];
  return goog.isDefAndNotNull(oldDataColumns) && 0 < oldDataColumns.length;
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.glowCategory_ = function(chartDefinition, categoryIndex, interactivityLayer) {
  for (var series = chartDefinition.series, serieIndex = 0;serieIndex < series.length;++serieIndex) {
    var actualCategoryIndex = gviz.canviz.chartdefinitionutil.getCanonicalCategoryIndex(chartDefinition, serieIndex, categoryIndex);
    this.isSerieInteractive_(chartDefinition, serieIndex) && goog.isDefAndNotNull(actualCategoryIndex) && this.glowDatum_(chartDefinition, serieIndex, actualCategoryIndex, interactivityLayer);
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.ringDatum_ = function(chartDefinition, serieIndex, datumIndex, interactivityLayer) {
  var serie = chartDefinition.series[serieIndex], datum = serie.points[datumIndex];
  if (!gviz.canviz.chartdefinitionutil.isDatumNull(datum) && datum.scaled && (!gviz.canviz.chartdefinitionutil.isSeriePathBased(serie) || 0 != serie.lineWidth || gviz.canviz.chartdefinitionutil.isDatumVisible(datum, serie))) {
    var datumBrush = gviz.canviz.chartdefinitionutil.getDatumBrush(datum, serie), interactiveDatum = this.createInteractiveDatum_(interactivityLayer, serieIndex, datumIndex);
    interactiveDatum.ring = {};
    var interactiveRing = interactiveDatum.ring, backgroundColor = chartDefinition.actualChartAreaBackgoundColor, ringOpacity = 1;
    goog.isDefAndNotNull(backgroundColor) || (backgroundColor = "white", ringOpacity = 0);
    switch(serie.type) {
      case gviz.canviz.Options.SerieType.BARS:
      ;
      case gviz.canviz.Options.SerieType.STEPPED_AREA:
      ;
      case gviz.canviz.Options.SerieType.CANDLESTICKS:
        ringOpacity = 1;
        interactiveRing.brush = gviz.graphics.Brush.TRANSPARENT_BRUSH.clone();
        interactiveRing.brush.setStroke(backgroundColor);
        if (serie.type == gviz.canviz.Options.SerieType.CANDLESTICKS) {
          var rgbDatumFillColor = goog.color.hexToRgb(goog.color.parse(datumBrush.getFill()).hex), rgbBackgroundColor = goog.color.hexToRgb(goog.color.parse(backgroundColor).hex), rgbBarFillColor = goog.color.hexToRgb(goog.color.parse(datum.barBrush.getFill()).hex);
          interactiveRing.brush.setStroke(goog.color.rgbArrayToHex(goog.color.highContrast(rgbBarFillColor, [rgbDatumFillColor, rgbBackgroundColor])));
        }
        interactiveRing.brush.setStrokeOpacity(ringOpacity);
        interactiveRing.brush.setStrokeWidth(1);
        var BAR_RING_DISTANCE = gviz.canviz.AxisChartInteractivityDefiner.BAR_RING_DISTANCE, scaledBar = datum.scaled.bar || datum.scaled.rect || datum.scaled, barStrokeWidth = datumBrush.getStrokeWidth(), ringStrokeWidth = interactiveRing.brush.getStrokeWidth();
        interactiveRing.rect = new goog.math.Rect(scaledBar.left + barStrokeWidth / 2 + BAR_RING_DISTANCE + ringStrokeWidth / 2, scaledBar.top + barStrokeWidth / 2 + BAR_RING_DISTANCE + ringStrokeWidth / 2, scaledBar.width - (barStrokeWidth + 2 * BAR_RING_DISTANCE + ringStrokeWidth), scaledBar.height - (barStrokeWidth + 2 * BAR_RING_DISTANCE + ringStrokeWidth));
        (0 >= interactiveRing.rect.width || 0 >= interactiveRing.rect.height) && delete interactiveDatum.ring;
        break;
      case gviz.canviz.Options.SerieType.LINE:
      ;
      case gviz.canviz.Options.SerieType.AREA:
      ;
      case gviz.canviz.Options.SerieType.SCATTER:
      ;
      case gviz.canviz.Options.SerieType.BUBBLES:
        interactiveDatum.visible = !0;
        interactiveRing.x = datum.scaled.x;
        interactiveRing.y = datum.scaled.y;
        if (this.crosshairTrigger_ === gviz.Options.CrosshairTrigger.BOTH || this.crosshairTrigger_ === gviz.Options.CrosshairTrigger.SELECTION) {
          var crosshairBrush = gviz.graphics.Brush.createStrokeBrush(this.crosshairSelectedColor_ || datumBrush.getFill(), 1, !1, this.crosshairSelectedOpacity_);
          this.drawCrosshair_(chartDefinition, datum, interactiveDatum, crosshairBrush, this.crosshairSelectedOrientation_);
        }
        interactiveRing.brush = new gviz.graphics.Brush({fill:backgroundColor, fillOpacity:ringOpacity, stroke:datumBrush.getFill(), strokeWidth:1});
        interactiveRing.radius = gviz.canviz.chartdefinitionutil.getPointTotalRadius(datum, serie) + gviz.canviz.AxisChartInteractivityDefiner.POINT_RING_DISTANCE + interactiveRing.brush.getStrokeWidth() / 2;
    }
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.drawCrosshair_ = function(chartDefinition, datum, interactiveDatum, brush, orientation) {
  var crosshair = interactiveDatum.crosshair || (interactiveDatum.crosshair = {});
  crosshair.x = datum.scaled.x;
  crosshair.y = datum.scaled.y;
  crosshair.brush = brush;
  var left = new goog.math.Coordinate(chartDefinition.chartArea.left, crosshair.y), right = new goog.math.Coordinate(chartDefinition.chartArea.right, crosshair.y), top = new goog.math.Coordinate(crosshair.x, chartDefinition.chartArea.top), bottom = new goog.math.Coordinate(crosshair.x, chartDefinition.chartArea.bottom);
  crosshair.path = crosshair.path || new gviz.graphics.PathSegments;
  if (orientation === gviz.Options.CrosshairOrientation.BOTH || orientation === gviz.Options.CrosshairOrientation.VERTICAL) {
    for (var vertPath = gviz.graphics.PathSegments.fromVertices([top, bottom]), i = 0;i < vertPath.segments.length - 1;i++) {
      crosshair.path.addSegment(vertPath.segments[i]);
    }
  }
  if (orientation === gviz.Options.CrosshairOrientation.BOTH || orientation === gviz.Options.CrosshairOrientation.HORIZONTAL) {
    for (var horizPath = gviz.graphics.PathSegments.fromVertices([left, right]), i = 0;i < horizPath.segments.length - 1;i++) {
      crosshair.path.addSegment(horizPath.segments[i]);
    }
  }
  crosshair.path.close();
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.ringSerie_ = function(chartDefinition, serieIndex, interactivityLayer) {
  var serie = chartDefinition.series[serieIndex];
  if ((serie.type == gviz.canviz.Options.SerieType.LINE || serie.type == gviz.canviz.Options.SerieType.AREA || serie.type == gviz.canviz.Options.SerieType.SCATTER) && 0 < serie.lineWidth) {
    var interactiveSerie = this.createInteractiveSerie_(interactivityLayer, serieIndex);
    interactiveSerie.ring = {};
    var interactiveRing = interactiveSerie.ring, pathSegments;
    pathSegments = serie.type == gviz.canviz.Options.SerieType.AREA ? chartDefinition.isStacked ? gviz.canviz.chartdefinitionutil.createPathSegmentsForStackedArea(serie) : gviz.canviz.chartdefinitionutil.createPathSegments(serie, !1) : gviz.canviz.chartdefinitionutil.createPathSegments(serie, chartDefinition.interpolateNulls);
    pathSegments = pathSegments.toSingleBrush();
    interactiveRing.brush = new gviz.graphics.Brush({stroke:serie.lineBrush.getStroke(), strokeWidth:Math.min(1, serie.lineBrush.getStrokeWidth() / 2)});
    var ringOffset = serie.lineBrush.getStrokeWidth() / 2 + gviz.canviz.AxisChartInteractivityDefiner.LINE_RING_DISTANCE + interactiveRing.brush.getStrokeWidth() / 2;
    interactiveRing.path = gviz.graphics.pathsegmentsutil.calcParallelPath(pathSegments, -ringOffset);
  }
  for (var datumIndex = 0;datumIndex < serie.points.length;++datumIndex) {
    var datum = serie.points[datumIndex];
    gviz.canviz.chartdefinitionutil.isDatumNull(datum) || (gviz.canviz.chartdefinitionutil.isDatumVisible(datum, serie) || gviz.canviz.chartdefinitionutil.isLonelyPoint(serie, datumIndex) && !chartDefinition.interpolateNulls) && this.ringDatum_(chartDefinition, serieIndex, datumIndex, interactivityLayer);
  }
  chartDefinition.isDiff && serie.type === gviz.canviz.Options.SerieType.SCATTER && !this.serieHasOldData_(serie.columns) && this.ringSerie_(chartDefinition, serieIndex - 1, interactivityLayer);
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.ringCategory_ = function(chartDefinition, categoryIndex, interactivityLayer) {
  for (var series = chartDefinition.series, serieIndex = 0;serieIndex < series.length;++serieIndex) {
    var actualCategoryIndex = gviz.canviz.chartdefinitionutil.getCanonicalCategoryIndex(chartDefinition, serieIndex, categoryIndex);
    goog.isDefAndNotNull(actualCategoryIndex) && this.ringDatum_(chartDefinition, serieIndex, actualCategoryIndex, interactivityLayer);
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.setTooltipOnDatum_ = function(interactionState, datum, tooltipDefinition) {
  var interactiveDatum = this.createInteractiveDatum_(interactionState.interactivityLayer, datum.serie, datum.category), embedActionsMenu = goog.isDefAndNotNull(interactionState.actionsMenuState);
  goog.asserts.assert(tooltipDefinition);
  interactiveDatum.tooltip = tooltipDefinition;
  if (embedActionsMenu) {
    goog.asserts.assert(this.actionsMenuDefiner);
    var actionsMenuState = interactionState.actionsMenuState;
    this.actionsMenuDefiner.extendInteractivityLayer(tooltipDefinition, actionsMenuState, interactiveDatum.tooltip);
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.setTooltipOnCategory_ = function(interactionState, categoryIndex, tooltipDefinition) {
  var interactiveCategory = this.createInteractiveCategory_(interactionState.interactivityLayer, categoryIndex), embedActionsMenu = goog.isDefAndNotNull(interactionState.actionsMenuState);
  goog.asserts.assert(tooltipDefinition);
  interactiveCategory.tooltip = tooltipDefinition;
  if (embedActionsMenu) {
    goog.asserts.assert(this.actionsMenuDefiner);
    var actionsMenuState = interactionState.actionsMenuState;
    this.actionsMenuDefiner.extendInteractivityLayer(tooltipDefinition, actionsMenuState, interactiveCategory.tooltip);
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.addTooltipToDatum_ = function(interactionState, serieIndex, datumIndex) {
  var tooltipDefinition = this.tooltipDefiner.createTooltip(interactionState, serieIndex, datumIndex, null);
  goog.isDefAndNotNull(tooltipDefinition) && this.setTooltipOnDatum_(interactionState, {serie:serieIndex, category:datumIndex}, tooltipDefinition);
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.addAggregateTooltipToData_ = function(interactionState, data, positionDatum) {
  var tooltipDefinition = this.tooltipDefiner.createAggregateTooltip(interactionState, data, positionDatum, this.aggregationTarget_);
  this.setTooltipOnDatum_(interactionState, positionDatum, tooltipDefinition);
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.addAggregateTooltipToCategory_ = function(interactionState, cursorPosition, categoryIndices) {
  if (cursorPosition) {
    var tooltipDefinition = this.tooltipDefiner.createAggregateCategoryTooltip(interactionState, categoryIndices, cursorPosition, this.aggregationTarget_);
    this.setTooltipOnCategory_(interactionState, categoryIndices[categoryIndices.length - 1], tooltipDefinition);
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.addTooltipToCategory_ = function(interactionState, cursorPosition, categoryIndex) {
  if (cursorPosition) {
    var interactiveCategory = this.createInteractiveCategory_(interactionState.interactivityLayer, categoryIndex), embedActionsMenu = goog.isDefAndNotNull(interactionState.actionsMenuState), tooltipDefinition = this.tooltipDefiner.createTooltip(interactionState, null, categoryIndex, null, cursorPosition);
    if (!goog.isNull(tooltipDefinition) && (interactiveCategory.tooltip = tooltipDefinition, embedActionsMenu)) {
      goog.asserts.assert(this.actionsMenuDefiner);
      var actionsMenuState = interactionState.actionsMenuState;
      this.actionsMenuDefiner.extendInteractivityLayer(tooltipDefinition, actionsMenuState, interactiveCategory.tooltip);
    }
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.addTooltipToAnnotation_ = function(interactionState, serieIndex, datumIndex, annotationIndex) {
  var interactiveAnnotation = this.createInteractiveAnnotation_(interactionState.interactivityLayer, serieIndex, datumIndex);
  interactiveAnnotation.labels = interactiveAnnotation.labels || {};
  var interactiveLabels = interactiveAnnotation.labels;
  interactiveLabels[annotationIndex] = interactiveLabels[annotationIndex] || {};
  var interactiveLabel = interactiveLabels[annotationIndex], embedActionsMenu = goog.isDefAndNotNull(interactionState.actionsMenuState), tooltipDefinition = this.tooltipDefiner.createTooltip(interactionState, serieIndex, datumIndex, annotationIndex);
  interactiveLabel.tooltip_ = tooltipDefinition;
  if (embedActionsMenu && tooltipDefinition) {
    goog.asserts.assert(interactiveLabel.tooltip_);
    goog.asserts.assert(this.actionsMenuDefiner);
    var actionsMenuState = interactionState.actionsMenuState;
    this.actionsMenuDefiner.extendInteractivityLayer(tooltipDefinition, actionsMenuState, interactiveLabel.tooltip_);
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.markDatumInColorBar_ = function(chartDefinition, serieIndex, datumIndex, interactivityLayer) {
  if (chartDefinition.colorBar) {
    var colorBar = chartDefinition.colorBar, point = chartDefinition.series[serieIndex].points[datumIndex], marker = {value:point.nonScaled.color}, definition = gviz.colorbar.definer.define(colorBar.scale, colorBar.drawingOptions, [marker], chartDefinition.textMeasureFunction);
    interactivityLayer.colorBar = {definition:definition};
  }
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.makeAnnotationBold_ = function(chartDefinition, serieIndex, datumOrCategoryIndex, annotationIndex, interactivityLayer) {
  var interactiveAnnotation = this.createInteractiveAnnotation_(interactivityLayer, serieIndex, datumOrCategoryIndex);
  interactiveAnnotation.labels = interactiveAnnotation.labels || {};
  var labels = interactiveAnnotation.labels;
  labels[annotationIndex] = labels[annotationIndex] || {};
  var label = labels[annotationIndex];
  label.textStyle = label.textStyle || {};
  var textStyle = label.textStyle;
  textStyle.bold = !0;
};
gviz.canviz.AxisChartInteractivityDefiner.prototype.diveInteractivityModel = function(chartDefinition, chartState, interactivityLayer) {
  var interactionState = {chartDefinition:chartDefinition, actionsMenuEntries:[], interactivityLayer:interactivityLayer, actionsMenuState:null}, focusedSerieIndex = chartState.focused.serie, focusedDatumIndex = chartState.focused.datum;
  goog.isDefAndNotNull(focusedDatumIndex) && goog.asserts.assert(goog.isDefAndNotNull(focusedSerieIndex));
  if (chartDefinition.legend) {
    var tooltipBoundaries = new goog.math.Box(0, chartDefinition.legend.area.left, chartDefinition.height, 0);
    this.tooltipDefiner.setBoundaries(tooltipBoundaries);
  }
  var tooltipTrigger = this.tooltipDefiner.getTrigger();
  if (goog.isDefAndNotNull(focusedSerieIndex) && !goog.isDefAndNotNull(focusedDatumIndex)) {
    for (var cursorX = chartState.cursor.position.x, allPoints = chartDefinition.series[focusedSerieIndex].points, concretePoints = goog.array.filter(allPoints, function(element) {
      return goog.isDefAndNotNull(element);
    }), i = 0;i < concretePoints.length && concretePoints[i].scaled.x < cursorX;) {
      i++;
    }
    if (0 == i) {
      focusedDatumIndex = 0;
    } else {
      if (i == concretePoints.length) {
        focusedDatumIndex = concretePoints.length - 1;
      } else {
        var prevX = concretePoints[i - 1].scaled.x, nextX = concretePoints[i].scaled.x, nearestDataPoint = cursorX < goog.math.average(prevX, nextX) ? i - 1 : i, focusedDatumIndex = goog.array.indexOf(allPoints, concretePoints[nearestDataPoint])
      }
    }
    this.ignoreCursorInChartStateComparison_ = !1;
  }
  var interactiveDatum = null;
  if (goog.isDefAndNotNull(focusedDatumIndex)) {
    interactiveDatum = this.createInteractiveDatum_(interactivityLayer, focusedSerieIndex, focusedDatumIndex);
    interactiveDatum.visible = !0;
    tooltipTrigger == gviz.Options.TooltipTrigger.FOCUS && this.addTooltipToDatum_(interactionState, focusedSerieIndex, focusedDatumIndex);
    if (chartDefinition.legend) {
      var interactiveLegendEntry = this.createInteractiveLegendEntry_(interactivityLayer, focusedSerieIndex);
      interactiveLegendEntry.removeSerieButton = {isVisible:chartDefinition.showRemoveSerieButton};
    }
    for (var serieIndex = 0;serieIndex < chartDefinition.series.length;serieIndex++) {
      if (serieIndex != focusedSerieIndex) {
        if (chartDefinition.legend) {
          var unfocusedInteractiveLegendEntry = this.createInteractiveLegendEntry_(interactivityLayer, serieIndex);
          unfocusedInteractiveLegendEntry.textBlock = {textStyle:{color:"#CCCCCC"}};
        }
        var unfocusedInteractiveSerie = this.createInteractiveSerie_(interactivityLayer, serieIndex), unfocusedSerie = chartDefinition.series[serieIndex];
        unfocusedInteractiveSerie.lineBrush = unfocusedSerie.lineBrush.clone();
        unfocusedInteractiveSerie.lineBrush.setStrokeOpacity(.3);
      }
    }
  }
  var expandedAnnotation = chartState.annotations.expanded;
  if (expandedAnnotation) {
    var interactiveAnnotation = this.createInteractiveAnnotation_(interactivityLayer, expandedAnnotation.serieIndex, expandedAnnotation.datumOrCategoryIndex);
    interactiveAnnotation.bundle = interactiveAnnotation.bundle || {};
    interactiveAnnotation.bundle.isExpanded = !0;
  }
  var focusedAnnotation = chartState.annotations.focused;
  if (focusedAnnotation) {
    var annotationColumn = focusedAnnotation.column, annotationRow = focusedAnnotation.row, annotationColumnInfo = chartDefinition.dataTableColumnRoleInfo[annotationColumn], annotationSerieIndex = annotationColumnInfo.serieIndex, annotationCategoryIndex = chartDefinition.dataTableToCategoryMap[annotationRow], annotationLabelIndex = annotationColumnInfo.roleIndex;
    this.isAnnotationInteractive_(chartDefinition, annotationSerieIndex) && this.addTooltipToAnnotation_(interactionState, annotationSerieIndex, annotationCategoryIndex, annotationLabelIndex);
  }
  var labeledLegendPosition = gviz.canviz.Options.LegendPosition.LABELED;
  if (chartDefinition.legend && chartDefinition.legend.position == labeledLegendPosition && goog.isDefAndNotNull(chartState.legend.focused.entry)) {
    var focusedLegendEntryIndex = chartState.legend.focused.entry, interactiveLegendEntry = this.createInteractiveLegendEntry_(interactivityLayer, focusedLegendEntryIndex);
    interactiveLegendEntry.removeSerieButton = {isVisible:chartDefinition.showRemoveSerieButton};
    for (var points = chartDefinition.series[focusedLegendEntryIndex].points, lastDatumIndex, datumIndex = points.length - 1;0 <= datumIndex;datumIndex--) {
      var datum = points[datumIndex];
      if (!gviz.canviz.chartdefinitionutil.isDatumNull(datum) && datum.scaled) {
        var chartArea = new goog.math.Box(chartDefinition.chartArea.top, chartDefinition.chartArea.right, chartDefinition.chartArea.bottom, chartDefinition.chartArea.left), coordinate = new goog.math.Coordinate(datum.scaled.x, datum.scaled.y);
        if (chartArea.contains(coordinate)) {
          lastDatumIndex = datumIndex;
          break;
        }
      }
    }
    goog.isDefAndNotNull(lastDatumIndex) && (interactiveDatum = this.createInteractiveDatum_(interactivityLayer, focusedLegendEntryIndex, lastDatumIndex), interactiveDatum.visible = !0, tooltipTrigger == gviz.Options.TooltipTrigger.FOCUS && this.addTooltipToDatum_(interactionState, focusedLegendEntryIndex, lastDatumIndex));
    for (serieIndex = 0;serieIndex < chartDefinition.series.length;serieIndex++) {
      serieIndex != focusedLegendEntryIndex && (unfocusedInteractiveLegendEntry = this.createInteractiveLegendEntry_(interactivityLayer, serieIndex), unfocusedInteractiveLegendEntry.textBlock = {textStyle:{color:"#CCCCCC"}}, unfocusedInteractiveSerie = this.createInteractiveSerie_(interactivityLayer, serieIndex), unfocusedSerie = chartDefinition.series[serieIndex], unfocusedInteractiveSerie.lineBrush = unfocusedSerie.lineBrush.clone(), unfocusedInteractiveSerie.lineBrush.setStrokeOpacity(.3));
    }
  }
};
// INPUT (javascript/gviz/devel/canviz/chart-definition-interpolator.js)
gviz.canviz.ChartDefinitionInterpolator = function(chartDef1, chartDef2) {
  this.chartDef1_ = chartDef1;
  this.chartDef2_ = chartDef2;
  this.interpolated_ = goog.object.clone(chartDef1);
  var changedSize = chartDef1.width != chartDef2.width || chartDef1.height != chartDef2.height;
  !changedSize && chartDef1.chartArea && chartDef2.chartArea && (changedSize = chartDef1.chartArea.width != chartDef2.chartArea.width || chartDef1.chartArea.height != chartDef2.chartArea.height || chartDef1.chartArea.left != chartDef2.chartArea.left || chartDef1.chartArea.top != chartDef2.chartArea.top);
  this.interpolated_.title && changedSize && (this.interpolated_.title.textStyle.opacity = 0);
  this.interpolated_.hAxes && (this.interpolated_.hAxes = goog.object.map(this.interpolated_.hAxes, goog.object.clone), this.hAxesSubstitute_ = goog.object.map(chartDef1.hAxes, function(hAxis, i) {
    return gviz.canviz.ChartDefinitionInterpolator.prepareAxis_(chartDef1.hAxes[i], chartDef2.hAxes[i], this.interpolated_.hAxes[i], !0, !1, changedSize);
  }, this));
  this.interpolated_.vAxes && (this.interpolated_.vAxes = goog.object.map(this.interpolated_.vAxes, goog.object.clone), this.vAxesSubstitute_ = goog.object.map(chartDef1.vAxes, function(vAxis, i) {
    return gviz.canviz.ChartDefinitionInterpolator.prepareAxis_(chartDef1.vAxes[i], chartDef2.vAxes[i], this.interpolated_.vAxes[i], !1, !0, changedSize);
  }, this));
  this.series2_ = this.series1_ = null;
  this.prepareSeries_();
  this.legendEntries2_ = this.legendEntries1_ = null;
  this.prepareLegend_();
};
gviz.canviz.ChartDefinitionInterpolator.prepareAxis_ = function(axis1, axis2, interpolated, rescaleTextX, rescaleTextY, changedSize) {
  if (!axis1 || !axis2) {
    return null;
  }
  var axis1Substitute = goog.object.clone(axis1), axis2Substitute = goog.object.clone(axis1);
  axis2Substitute.ticklinesOrigin = axis2.ticklinesOrigin;
  axis2Substitute.startPos = axis2.startPos;
  axis2Substitute.endPos = axis2.endPos;
  interpolated.title && changedSize && (interpolated.title.textStyle.opacity = 0);
  if (axis1.type == gviz.canviz.Options.AxisType.VALUE && axis2.type == gviz.canviz.Options.AxisType.VALUE && axis1.dataType === axis2.dataType) {
    axis1.baseline && axis2.baseline && (axis2Substitute.baseline = axis2.baseline, interpolated.baseline = goog.object.clone(interpolated.baseline));
    axis2Substitute.number = goog.object.clone(axis2Substitute.number);
    axis2Substitute.position = goog.object.clone(axis2Substitute.position);
    interpolated.number = goog.object.clone(interpolated.number);
    interpolated.position = goog.object.clone(interpolated.position);
    axis2Substitute.position.fromValue = axis2.position.fromValue;
    if (axis1.gridlines && axis2.gridlines) {
      axis2Substitute.gridlines = goog.array.clone(axis2Substitute.gridlines);
      interpolated.gridlines = goog.array.clone(interpolated.gridlines);
      for (var substituteGridlines = axis2Substitute.gridlines, interpolatedGridlines = interpolated.gridlines, i$$0 = 0;i$$0 < substituteGridlines.length;i$$0++) {
        substituteGridlines[i$$0] = goog.object.clone(substituteGridlines[i$$0]);
        interpolatedGridlines[i$$0] = goog.object.clone(interpolatedGridlines[i$$0]);
        var substituteGridline = substituteGridlines[i$$0], substituteNumber = axis1.number.fromValue(substituteGridline.dataValue), substituteValue = axis2.number.toValue(substituteNumber);
        substituteGridline.coordinate = axis2.position.fromValue(substituteValue);
      }
    }
    if (axis1.ticklines && axis2.ticklines) {
      axis2Substitute.ticklines = goog.array.clone(axis2Substitute.ticklines);
      interpolated.ticklines = goog.array.clone(interpolated.ticklines);
      for (var substituteTicklines = axis2Substitute.ticklines, interpolatedTicklines = interpolated.ticklines, i$$0 = 0;i$$0 < substituteTicklines.length;i$$0++) {
        substituteTicklines[i$$0] = goog.object.clone(substituteTicklines[i$$0]);
        interpolatedTicklines[i$$0] = goog.object.clone(interpolatedTicklines[i$$0]);
        var substituteTickline = substituteTicklines[i$$0], substituteNumber = axis1.number.fromValue(substituteTickline.dataValue), substituteValue = axis2.number.toValue(substituteNumber);
        substituteTickline.coordinate = axis2.position.fromValue(substituteValue);
      }
    }
    if (axis1.text && axis2.text) {
      axis2Substitute.text = goog.array.clone(axis2Substitute.text);
      interpolated.text = goog.array.clone(interpolated.text);
      var substituteText = axis2Substitute.text, interpolatedText = interpolated.text;
      gviz.canviz.ChartDefinitionInterpolator.cloneAxisText_(substituteText);
      gviz.canviz.ChartDefinitionInterpolator.cloneAxisText_(interpolatedText);
      for (i$$0 = 0;i$$0 < substituteText.length;i$$0++) {
        var substituteTextItem = substituteText[i$$0];
        gviz.canviz.ChartDefinitionInterpolator.prepareTextItem_(axis1, axis2, axis1.text[i$$0], axis2.text[i$$0], substituteTextItem, rescaleTextX, rescaleTextY);
      }
    }
  } else {
    if (axis1.text && axis2.text) {
      var textEditDistance = gviz.canviz.util.calcEditDistance(axis1.text, axis2.text, function(item1, item2) {
        return item1.dataValue == item2.dataValue;
      });
      axis1Substitute.text = goog.array.filter(axis1.text, function(item, i) {
        return goog.isDefAndNotNull(textEditDistance.map1[i]);
      });
      axis2Substitute.text = goog.array.filter(axis2.text, function(item, i) {
        return goog.isDefAndNotNull(textEditDistance.map2[i]);
      });
      interpolated.text = goog.array.clone(axis1Substitute.text);
      gviz.canviz.ChartDefinitionInterpolator.cloneAxisText_(axis1Substitute.text);
      gviz.canviz.ChartDefinitionInterpolator.cloneAxisText_(axis2Substitute.text);
      gviz.canviz.ChartDefinitionInterpolator.cloneAxisText_(interpolated.text);
    }
  }
  return[axis1Substitute, axis2Substitute];
};
gviz.canviz.ChartDefinitionInterpolator.prepareTextItem_ = function(axis1, axis2, axis1text, axis2text, substituteTextItem, rescaleX, rescaleY) {
  var substituteTextBlock = substituteTextItem.textBlock, substituteNumber = axis1.number.fromValue(substituteTextItem.dataValue), substituteValue = axis2.number.toValue(substituteNumber), scaled1 = axis1.position.fromValue(substituteTextItem.dataValue), scaled2 = axis2.position.fromValue(substituteValue);
  if (rescaleX) {
    var offset = axis1text.textBlock.anchor.x - scaled1;
    substituteTextBlock.anchor.x = scaled2 + offset;
    axis2text && (substituteTextBlock.anchor.y = axis2text.textBlock.anchor.y);
  }
  rescaleY && (offset = axis1text.textBlock.anchor.y - scaled1, substituteTextBlock.anchor.y = scaled2 + offset, axis2text && (substituteTextBlock.anchor.x = axis2text.textBlock.anchor.x));
};
gviz.canviz.ChartDefinitionInterpolator.cloneAxisText_ = function(text) {
  goog.array.forEach(text, function(textItem, i) {
    text[i] = goog.object.clone(text[i]);
    textItem = text[i];
    textItem.textBlock = goog.object.clone(textItem.textBlock);
    var textBlock = textItem.textBlock;
    textBlock.anchor && (textBlock.anchor = gviz.math.Coordinate.clone(textBlock.anchor));
  });
};
gviz.canviz.ChartDefinitionInterpolator.prototype.prepareSeries_ = function() {
  var chartDef1 = this.chartDef1_, chartDef2 = this.chartDef2_;
  if (chartDef1.series && chartDef2.series) {
    var seriesEditDistance = gviz.canviz.util.calcEditDistance(chartDef1.series, chartDef2.series, function(serie1, serie2) {
      return serie1.id == serie2.id;
    });
    this.series1_ = goog.array.filter(chartDef1.series, function(serie, i) {
      return goog.isDefAndNotNull(seriesEditDistance.map1[i]);
    });
    this.series2_ = goog.array.filter(chartDef2.series, function(serie, i) {
      return goog.isDefAndNotNull(seriesEditDistance.map2[i]);
    });
    goog.asserts.assert(this.series1_.length == this.series2_.length);
    if (chartDef1.chartType == gviz.canviz.Options.ChartType.FUNCTION || chartDef1.chartType == gviz.canviz.Options.ChartType.SCATTER) {
      var domain1Axis = chartDef1.orientation == gviz.canviz.Options.Orientation.HORIZONTAL ? chartDef1.hAxes[0] : chartDef1.vAxes[0], domain2Axis = chartDef2.orientation == gviz.canviz.Options.Orientation.HORIZONTAL ? chartDef2.hAxes[0] : chartDef2.vAxes[0];
      domain1Axis.type == gviz.canviz.Options.AxisType.VALUE && domain2Axis.type == gviz.canviz.Options.AxisType.VALUE && domain1Axis.dataType === domain2Axis.dataType ? this.preparePointsForContinuousDomain_(domain1Axis.number.fromValue, domain1Axis.number.toValue) : this.preparePointsForDiscreteDomain_();
    } else {
      chartDef1.chartType == gviz.canviz.Options.ChartType.BUBBLE && this.preparePointsForBubbleChart_();
    }
  }
};
gviz.canviz.ChartDefinitionInterpolator.prototype.preparePointsForDiscreteDomain_ = function() {
  var categories1 = this.chartDef1_.categories, categories2 = this.chartDef2_.categories;
  if (categories1 && categories2) {
    var map1 = {}, map2 = {}, categories1Indices = {}, categories2Indices = {};
    goog.array.forEach(categories1, function(category, index) {
      goog.isDefAndNotNull(category.data) && (categories1Indices[category.data] = index);
    });
    goog.array.forEach(categories2, function(category, index) {
      goog.isDefAndNotNull(category.data) && (categories2Indices[category.data] = index);
    });
    goog.array.forEach(categories1, function(category, index) {
      if (goog.isDefAndNotNull(category.data)) {
        var value = categories2Indices[category.data];
        map1[index] = value;
      }
    });
    goog.array.forEach(categories2, function(category, index) {
      if (goog.isDefAndNotNull(category.data)) {
        var value = categories1Indices[category.data];
        map1[value] !== index && (value = null);
        map2[index] = value;
      }
    });
    goog.array.forEach(categories1, function(category, index) {
      if (goog.isDefAndNotNull(category.data)) {
        var value = categories2Indices[category.data];
        map2[value] !== index && (map1[index] = null);
      }
    });
    for (var idx1 = 0, idx2 = 0, interpolatedCategories = [], categoryMapping = [];idx1 < categories1.length || idx2 < categories2.length;) {
      idx1 < categories1.length && !goog.isDefAndNotNull(map1[idx1]) ? (categoryMapping.push({c1:{idx:idx1, existsInOriginal:!0}, c2:{idx:idx2, existsInOriginal:!1}}), interpolatedCategories.push({data:categories1[idx1].data}), idx1++) : (idx2 < categories2.length && !goog.isDefAndNotNull(map2[idx2]) ? (categoryMapping.push({c1:{idx:idx1, existsInOriginal:!1}, c2:{idx:idx2, existsInOriginal:!0}}), interpolatedCategories.push({data:categories2[idx2].data})) : (goog.asserts.assert(idx1 < categories1.length), 
      goog.asserts.assert(idx2 < categories2.length), goog.asserts.assert(map1[idx1] == idx2), goog.asserts.assert(map2[idx2] == idx1), categoryMapping.push({c1:{idx:idx1, existsInOriginal:!0}, c2:{idx:idx2, existsInOriginal:!0}}), interpolatedCategories.push({data:categories1[idx1].data}), idx1++), idx2++);
    }
    this.interpolated_.categories = interpolatedCategories;
    var interpolateAdjacentPoints = function(points, idx) {
      return 0 == idx ? points[0] : idx >= points.length ? goog.array.peek(points) : gviz.canviz.ChartDefinitionInterpolator.interpolatePoint_(points[idx - 1], points[idx], .5);
    };
    this.chartDef1_.isDiff ? this.makeNewDiffPoints_(categoryMapping, function(points, mapping, pointsPerCategory, k) {
      return mapping.existsInOriginal ? points[mapping.idx * pointsPerCategory + k] : interpolateAdjacentPoints(points, mapping.idx * pointsPerCategory + k);
    }) : this.makeNewPoints_(categoryMapping, function(points, mapping) {
      return mapping.existsInOriginal ? points[mapping.idx] : interpolateAdjacentPoints(points, mapping.idx);
    });
  }
};
gviz.canviz.ChartDefinitionInterpolator.prototype.preparePointsForContinuousDomain_ = function(dataToNumber, numberToData) {
  var categories1 = this.chartDef1_.categories, categories2 = this.chartDef2_.categories;
  if (categories1 && categories2) {
    if (0 == categories1.length || 0 == categories2.length) {
      this.interpolated_.categories = [], this.makeNewPoints_([], function() {
        return null;
      });
    } else {
      var getCategoryDataAsNumber = function(category) {
        return dataToNumber(category.data);
      }, interpolatedCategories = [], categoryMapping = [];
      if (categories1.length === categories2.length) {
        for (var i = 0;i < categories1.length;i++) {
          categoryMapping.push({c1:i, c2:i}), interpolatedCategories.push({data:numberToData(goog.math.average(getCategoryDataAsNumber(categories1[i]), getCategoryDataAsNumber(categories2[i])))});
        }
      } else {
        var merged = gviz.canviz.util.mergeArrays(categories1, categories2, getCategoryDataAsNumber);
        goog.array.forEach(merged, function(item) {
          var ar1 = item.ar1, ar2 = item.ar2, data;
          null != categories1[ar1] && null != categories2[ar2] && (data = numberToData(goog.math.average(getCategoryDataAsNumber(categories1[ar1]), getCategoryDataAsNumber(categories2[ar2]))));
          null != data && (categoryMapping.push({c1:ar1, c2:ar2}), interpolatedCategories.push({data:data}));
        });
      }
      this.interpolated_.categories = interpolatedCategories;
      this.chartDef1_.isDiff ? this.makeNewDiffPoints_(categoryMapping, function(points, idx, pointsPerCategory, k) {
        return points[idx * pointsPerCategory + k];
      }) : this.makeNewPoints_(categoryMapping, function(points, idx) {
        return points[idx];
      });
    }
  }
};
gviz.canviz.ChartDefinitionInterpolator.prototype.preparePointsForBubbleChart_ = function() {
  var serie1 = this.series1_[0], serie2 = this.series2_[0], points1 = serie1.points, points2 = serie2.points, pointsToFadeOut = [], pointsToFadeIn = [], categoryMapping = [], points2Map = {};
  goog.array.forEach(points2, function(point, idx) {
    goog.isDefAndNotNull(point) && (goog.isDef(points2Map[point.id]) || (points2Map[point.id] = []), points2Map[point.id].push(idx));
  });
  goog.object.forEach(points1, function(point, idx1) {
    if (goog.isDefAndNotNull(point)) {
      var pointsIdx = point.id && points2Map[point.id], idx2 = pointsIdx && pointsIdx.shift();
      goog.isDef(idx2) ? categoryMapping.push({c1:idx1, c2:idx2}) : pointsToFadeOut.push(point);
    }
  });
  goog.object.forEach(points2Map, function(points) {
    goog.array.forEach(points, function(idx2) {
      var point = points2[idx2];
      pointsToFadeIn.push(point);
    });
  });
  this.makeNewPoints_(categoryMapping, function(points, idx) {
    return points[idx];
  });
  var cloneMissingPoint = function(point) {
    var newPoint = goog.object.clone(point);
    newPoint.scaled = goog.object.clone(newPoint.scaled);
    newPoint.scaled.brush = newPoint.scaled.brush.clone();
    newPoint.scaled.brush.setFillOpacity(0);
    newPoint.scaled.brush.setStrokeOpacity(0);
    newPoint.textStyle = goog.object.clone(newPoint.textStyle);
    newPoint.textStyle.opacity = 0;
    return newPoint;
  }, fadingOutPoints = goog.array.map(pointsToFadeOut, cloneMissingPoint), fadingInPoints = goog.array.map(pointsToFadeIn, cloneMissingPoint);
  this.series1_[0].extraPoints_ = goog.array.concat(pointsToFadeOut, fadingInPoints);
  this.series2_[0].extraPoints_ = goog.array.concat(fadingOutPoints, pointsToFadeIn);
};
gviz.canviz.ChartDefinitionInterpolator.prototype.makeNewPoints_ = function(domainMapping, getPoint) {
  for (var i = 0;i < this.series1_.length;i++) {
    var points1 = this.series1_[i].points, points2 = this.series2_[i].points, newPoints1 = [], newPoints2 = [];
    if (this.series1_[i].isVirtual) {
      newPoints1 = goog.array.clone(this.series1_[i].points), newPoints2 = goog.array.clone(this.series2_[i].points);
    } else {
      for (var j = 0;j < domainMapping.length;j++) {
        var mapping = domainMapping[j], point1 = getPoint(points1, mapping.c1), point2 = getPoint(points2, mapping.c2);
        point1 && !point1.isNull && point2 && !point2.isNull && (newPoints1.push(point1), newPoints2.push(point2));
      }
    }
    this.series1_[i] = gviz.canviz.ChartDefinitionInterpolator.cloneSerie_(this.series1_[i], newPoints1);
    this.series2_[i] = gviz.canviz.ChartDefinitionInterpolator.cloneSerie_(this.series2_[i], newPoints2);
  }
};
gviz.canviz.ChartDefinitionInterpolator.prototype.makeNewDiffPoints_ = function(domainMapping, getPoint) {
  for (var i = 0;i < this.series1_.length;i++) {
    var points1 = this.series1_[i].points, points2 = this.series2_[i].points, newPoints1 = [], newPoints2 = [];
    if (0 < domainMapping.length) {
      var points1PerCategory = Math.ceil(points1.length / domainMapping.length), points2PerCategory = Math.ceil(points2.length / domainMapping.length);
      this.chartDef1_.chartType == gviz.canviz.Options.ChartType.FUNCTION && (goog.asserts.assert(Math.floor(points1.length / points1PerCategory) === this.chartDef1_.categories.length), goog.asserts.assert(Math.floor(points2.length / points2PerCategory) === this.chartDef2_.categories.length));
      for (var j = 0;j < domainMapping.length;j++) {
        for (var mapping = domainMapping[j], k = 0;k < points1PerCategory;k++) {
          var point1 = getPoint(points1, mapping.c1, points1PerCategory, k);
          point1 && !point1.isNull && newPoints1.push(point1);
        }
        for (k = 0;k < points2PerCategory;k++) {
          var point2 = getPoint(points2, mapping.c2, points2PerCategory, k);
          point2 && !point2.isNull && newPoints2.push(point2);
        }
      }
    }
    this.series1_[i] = gviz.canviz.ChartDefinitionInterpolator.cloneSerie_(this.series1_[i], newPoints1);
    this.series2_[i] = gviz.canviz.ChartDefinitionInterpolator.cloneSerie_(this.series2_[i], newPoints2);
  }
};
gviz.canviz.ChartDefinitionInterpolator.cloneSerie_ = function(serie, newPoints) {
  var newSerie = goog.object.clone(serie);
  newSerie.points = newPoints;
  return newSerie;
};
gviz.canviz.ChartDefinitionInterpolator.prototype.prepareLegend_ = function() {
  var chartDef1 = this.chartDef1_, chartDef2 = this.chartDef2_;
  chartDef1.legend && chartDef1.legend.pages && chartDef2.legend && chartDef2.legend.pages && (this.interpolated_.legend = null);
};
gviz.canviz.ChartDefinitionInterpolator.interpolateValue_ = function(v1, v2, ratio) {
  return v1 === v2 ? v1 : v1 && v1.constructor == gviz.graphics.Brush && v2 && v2.constructor == gviz.graphics.Brush ? gviz.canviz.ChartDefinitionInterpolator.interpolateBrush_(v1, v2, ratio) : goog.isArray(v1) && goog.isArray(v2) ? gviz.canviz.ChartDefinitionInterpolator.interpolateArray_(v1, v2, ratio) : goog.isObject(v1) || goog.isObject(v2) ? gviz.canviz.ChartDefinitionInterpolator.interpolateObject_(v1, v2, ratio) : goog.isString(v1) || goog.isString(v2) ? v1 : goog.isNumber(v1) && goog.isNumber(v2) ? 
  v1 * (1 - ratio) + v2 * ratio : null;
};
gviz.canviz.ChartDefinitionInterpolator.interpolateBrush_ = function(brush1, brush2, ratio) {
  return new gviz.graphics.Brush({fill:gviz.util.blendHexColors(brush1.getFill(), brush2.getFill(), 1 - ratio), fillOpacity:gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(brush1.getFillOpacity(), brush2.getFillOpacity(), ratio), stroke:gviz.util.blendHexColors(brush1.getStroke(), brush2.getStroke(), 1 - ratio), strokeWidth:gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(brush1.getStrokeWidth(), brush2.getStrokeWidth(), ratio), strokeOpacity:gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(brush1.getStrokeOpacity(), 
  brush2.getStrokeOpacity(), ratio), strokeDashStyle:brush1.getStrokeDashStyle(), gradient:brush1.getGradient(), pattern:brush1.getPattern()});
};
gviz.canviz.ChartDefinitionInterpolator.interpolateArray_ = function(arr1, arr2, ratio) {
  if (!arr1) {
    return arr2;
  }
  if (!arr2) {
    return arr1;
  }
  for (var result = [], len = Math.min(arr1.length, arr2.length), i = 0;i < len;i++) {
    result.push(gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(arr1[i], arr2[i], ratio));
  }
  return result;
};
gviz.canviz.ChartDefinitionInterpolator.interpolateObject_ = function(obj1, obj2, ratio) {
  if (!obj1) {
    return obj2;
  }
  if (!obj2) {
    return obj1;
  }
  var result = {};
  goog.object.forEach(obj1, function(value, key) {
    goog.isDef(obj2[key]) && (result[key] = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(obj1[key], obj2[key], ratio));
  });
  return result;
};
gviz.canviz.ChartDefinitionInterpolator.isCoordinateInLimits_ = function(x, y, chartArea, limitByX, limitByY) {
  var inXLimits = !limitByX || (chartArea ? x >= chartArea.left && x <= chartArea.right : !1), inYLimits = !limitByY || (chartArea ? y >= chartArea.top && y <= chartArea.bottom : !1);
  return inXLimits && inYLimits;
};
gviz.canviz.ChartDefinitionInterpolator.interpolateTextBlock_ = function(textBlock1, textBlock2, interpolated, ratio) {
  interpolated && interpolated.anchor && (interpolated.anchor.x = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(textBlock1.anchor.x, textBlock2.anchor.x, ratio), interpolated.anchor.y = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(textBlock1.anchor.y, textBlock2.anchor.y, ratio));
};
gviz.canviz.ChartDefinitionInterpolator.interpolateTextItem_ = function(item1, item2, interpolated, isInLimits, ratio) {
  if (interpolated && (gviz.canviz.ChartDefinitionInterpolator.interpolateTextBlock_(item1.textBlock, item2.textBlock, interpolated.textBlock, ratio), interpolated.textBlock)) {
    var hasLines = 0 < interpolated.textBlock.lines.length, firstLineX = hasLines ? interpolated.textBlock.lines[0].x : 0, firstLineY = hasLines ? interpolated.textBlock.lines[0].y : 0;
    interpolated.isVisible = isInLimits(firstLineX + interpolated.textBlock.anchor.x, firstLineY + interpolated.textBlock.anchor.y);
  }
};
gviz.canviz.ChartDefinitionInterpolator.interpolateAxis_ = function(axis1, axis2, interpolated, isInLimits, ratio) {
  axis1.position && axis1.position.fromValue && axis2.position && axis2.position.fromValue && (interpolated.position.fromValue = function(v) {
    var p1 = axis1.position.fromValue(v), p2 = axis2.position.fromValue(v);
    return gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(p1, p2, ratio);
  });
  axis1.title && axis2.title && goog.array.forEach(interpolated.title.lines, function(line, i) {
    line.x = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(axis1.title.lines[i].x, axis2.title.lines[i].x, ratio);
    line.y = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(axis1.title.lines[i].y, axis2.title.lines[i].y, ratio);
  });
  if (axis1.baseline && axis2.baseline) {
    var baseline = interpolated.baseline;
    baseline.coordinate = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(axis1.baseline.coordinate, axis2.baseline.coordinate, ratio);
  }
  axis1.gridlines && axis2.gridlines && goog.array.forEach(interpolated.gridlines, function(gridline, i) {
    gridline.coordinate = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(axis1.gridlines[i].coordinate, axis2.gridlines[i].coordinate, ratio);
    gridline.isVisible = isInLimits(gridline.coordinate, gridline.coordinate);
  });
  axis1.ticklines && axis2.ticklines && goog.array.forEach(interpolated.ticklines, function(tickline, i) {
    tickline.coordinate = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(axis1.ticklines[i].coordinate, axis2.ticklines[i].coordinate, ratio);
    tickline.isVisible = isInLimits(tickline.coordinate, tickline.coordinate);
  });
  axis1.ticklinesOrigin && axis2.ticklinesOrigin && (interpolated.ticklinesOrigin = gviz.canviz.ChartDefinitionInterpolator.interpolateObject_(axis1.ticklinesOrigin, axis2.ticklinesOrigin, ratio));
  null != axis1.startPos && null != axis2.startPos && (interpolated.startPos = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(axis1.startPos, axis2.startPos, ratio));
  null != axis1.endPos && null != axis2.endPos && (interpolated.endPos = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(axis1.endPos, axis2.endPos, ratio));
  axis1.text && axis2.text && goog.array.forEach(interpolated.text, function(textItem, i) {
    gviz.canviz.ChartDefinitionInterpolator.interpolateTextItem_(axis1.text[i], axis2.text[i], textItem, isInLimits, ratio);
  });
};
gviz.canviz.ChartDefinitionInterpolator.interpolatePoint_ = function(point1, point2, ratio) {
  if (!point1 || !point2) {
    return null;
  }
  var result = goog.object.clone(point1), interpolateValue = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_;
  if (goog.isDef(point1.scaled) || goog.isDef(point2.scaled)) {
    result.scaled = interpolateValue(point1.scaled || {}, point2.scaled || {}, ratio), result.nonScaled = interpolateValue(point1.nonScaled || {}, point2.nonScaled || {}, ratio);
  }
  goog.isDef(point1.leftControlPoint) && goog.isDef(point2.leftControlPoint) && (result.leftControlPoint = interpolateValue(point1.leftControlPoint, point2.leftControlPoint, ratio));
  goog.isDef(point1.rightControlPoint) && goog.isDef(point2.rightControlPoint) && (result.rightControlPoint = interpolateValue(point1.rightControlPoint, point2.rightControlPoint, ratio));
  goog.isDef(point1.textStyle) && goog.isDef(point2.textStyle) && point1.textStyle !== point2.textStyle && (result.textStyle = goog.object.clone(point1.textStyle), result.textStyle.color = gviz.util.blendHexColors(point1.textStyle.color, point2.textStyle.color, 1 - ratio), result.textStyle.opacity = interpolateValue(goog.isDef(point1.textStyle.opacity) ? point1.textStyle.opacity : 1, goog.isDef(point2.textStyle.opacity) ? point2.textStyle.opacity : 1, ratio));
  goog.isDefAndNotNull(point1.annotation) && goog.isDefAndNotNull(point2.annotation) && point1.annotation.labels[0].text === point2.annotation.labels[0].text ? result.annotation = interpolateValue(point1.annotation, point2.annotation, ratio) : delete result.annotation;
  return result;
};
gviz.canviz.ChartDefinitionInterpolator.prototype.interpolate = function(ratio) {
  var interpolated = this.interpolated_;
  if (interpolated.hAxes) {
    var hIsInLimits = function(x, y) {
      return gviz.canviz.ChartDefinitionInterpolator.isCoordinateInLimits_(x, y, interpolated.chartArea, !0, !1);
    };
    goog.object.forEach(interpolated.hAxes, function(hAxis, i) {
      var substitute = this.hAxesSubstitute_[i];
      substitute && gviz.canviz.ChartDefinitionInterpolator.interpolateAxis_(substitute[0], substitute[1], hAxis, hIsInLimits, ratio);
    }, this);
  }
  if (interpolated.vAxes) {
    var vIsInLimits = function(x, y) {
      return gviz.canviz.ChartDefinitionInterpolator.isCoordinateInLimits_(x, y, interpolated.chartArea, !1, !0);
    };
    goog.object.forEach(interpolated.vAxes, function(vAxis, i) {
      var substitute = this.vAxesSubstitute_[i];
      substitute && gviz.canviz.ChartDefinitionInterpolator.interpolateAxis_(substitute[0], substitute[1], vAxis, vIsInLimits, ratio);
    }, this);
  }
  if (this.series1_ && this.series2_) {
    interpolated.series = [];
    for (var i$$0 = 0;i$$0 < this.series1_.length;++i$$0) {
      var serie1 = this.series1_[i$$0], serie2 = this.series2_[i$$0], interpolatedSerie = goog.object.clone(serie2);
      if (serie1 && serie2 && serie1.type == serie2.type) {
        if (serie1.points && serie2.points) {
          interpolatedSerie.points = [];
          for (var j = 0;j < serie1.points.length;j++) {
            interpolatedSerie.points[j] = gviz.canviz.ChartDefinitionInterpolator.interpolatePoint_(serie1.points[j], serie2.points[j], ratio);
          }
          if (serie1.extraPoints_ && serie2.extraPoints_) {
            for (j = 0;j < serie1.extraPoints_.length;j++) {
              interpolatedSerie.points.push(gviz.canviz.ChartDefinitionInterpolator.interpolatePoint_(serie1.extraPoints_[j], serie2.extraPoints_[j], ratio));
            }
          }
        }
        serie1.intervals && serie1.intervals.paths && serie2.intervals && serie2.intervals.paths && (interpolatedSerie.intervals = goog.object.clone(interpolatedSerie.intervals), interpolatedSerie.intervals.paths = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(serie1.intervals.paths, serie2.intervals.paths, ratio));
      }
      interpolated.series[i$$0] = interpolatedSerie;
    }
  }
  interpolated.height && (interpolated.height = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(this.chartDef1_.height, this.chartDef2_.height, ratio));
  interpolated.width && (interpolated.width = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(this.chartDef1_.width, this.chartDef2_.width, ratio));
  interpolated.chartArea && (interpolated.chartArea = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(this.chartDef1_.chartArea, this.chartDef2_.chartArea, ratio));
  if (this.legendEntries1_ && this.legendEntries2_ && interpolated.legend && interpolated.legend.currentPage) {
    for (i$$0 = 0;i$$0 < interpolated.legend.currentPage.length;i$$0++) {
      var interpolatedEntry = interpolated.legend.currentPage[i$$0], entry1 = this.legendEntries1_[i$$0], entry2 = this.legendEntries2_[i$$0];
      if (interpolatedEntry.textBlock && interpolatedEntry.textBlock.lines && entry1.textBlock && entry1.textBlock.lines && !goog.array.isEmpty(entry1.textBlock.lines) && entry2.textBlock && entry2.textBlock.lines) {
        for (var interpolatedLines = interpolatedEntry.textBlock.lines, lines1 = entry1.textBlock.lines, lines2 = entry2.textBlock.lines, lines1Len = lines1.length, j = 0;j < interpolatedLines.length;j++) {
          var pos1 = j < lines1Len ? lines1[j] : lines1[lines1Len - 1];
          interpolatedLines[j].x = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(pos1.x, lines2[j].x, ratio);
          interpolatedLines[j].y = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(pos1.y, lines2[j].y, ratio);
        }
      }
      if (interpolatedEntry.square && interpolatedEntry.square.coordinates && entry1.square && entry1.square.coordinates && entry2.square && entry2.square.coordinates) {
        var interpolatedCoordinates = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(entry1.square.coordinates, entry2.square.coordinates, ratio);
        interpolatedEntry.square.coordinates = new goog.math.Rect(interpolatedCoordinates.left, interpolatedCoordinates.top, interpolatedCoordinates.width, interpolatedCoordinates.height);
      }
      interpolatedEntry.removeSerieButton && interpolatedEntry.removeSerieButton.coordinates && entry1.removeSerieButton && entry1.removeSerieButton.coordinates && entry2.removeSerieButton && entry2.removeSerieButton.coordinates && (interpolatedEntry.removeSerieButton.coordinates = gviz.canviz.ChartDefinitionInterpolator.interpolateValue_(entry1.removeSerieButton.coordinates, entry2.removeSerieButton.coordinates, ratio));
    }
  }
  return interpolated;
};
// INPUT (javascript/gviz/devel/canviz/chart-event-dispatcher.js)
gviz.canviz.ChartEventDispatcher = function(eventSource) {
  this.eventSource_ = eventSource;
};
gviz.canviz.ChartEventDispatcher.prototype.dispatchByStateChange = function(previousChartState, currentChartState, chartType, series) {
  var events = [], currentFocus = currentChartState.focused, previousFocus = previousChartState.focused;
  if (currentFocus.serie != previousFocus.serie || currentFocus.datum != previousFocus.datum) {
    goog.isDefAndNotNull(previousFocus.serie) && events.push(this.createDatumEvent_(gviz.ChartEventType.FOCUS_OUT, previousFocus.serie, previousFocus.datum, chartType, series)), goog.isDefAndNotNull(currentFocus.serie) && events.push(this.createDatumEvent_(gviz.ChartEventType.FOCUS_IN, currentFocus.serie, currentFocus.datum, chartType, series));
  }
  if (currentFocus.category != previousFocus.category) {
    if (goog.isDefAndNotNull(previousFocus.category)) {
      var focusedCategory = previousFocus.category;
      events.push({type:gviz.ChartEventType.FOCUS_OUT, data:{row:focusedCategory, column:null}});
    }
    goog.isDefAndNotNull(currentFocus.category) && (focusedCategory = currentFocus.category, events.push({type:gviz.ChartEventType.FOCUS_IN, data:{row:focusedCategory, column:null}}));
  }
  currentFocus = currentChartState.annotations.focused;
  previousFocus = previousChartState.annotations.focused;
  !previousFocus || currentFocus && currentFocus.row == previousFocus.row && currentFocus.column == previousFocus.column || events.push({type:gviz.ChartEventType.FOCUS_OUT, data:{row:previousFocus.row, column:previousFocus.column}});
  !currentFocus || previousFocus && currentFocus.row == previousFocus.row && currentFocus.column == previousFocus.column || events.push({type:gviz.ChartEventType.FOCUS_IN, data:{row:currentFocus.row, column:currentFocus.column}});
  currentFocus = currentChartState.legend.focused;
  previousFocus = previousChartState.legend.focused;
  currentFocus.entry != previousFocus.entry && (goog.isDefAndNotNull(previousFocus.entry) && events.push(this.createDatumEvent_(gviz.ChartEventType.FOCUS_OUT, previousFocus.entry, null, chartType, series)), goog.isDefAndNotNull(currentFocus.entry) && events.push(this.createDatumEvent_(gviz.ChartEventType.FOCUS_IN, currentFocus.entry, null, chartType, series)));
  currentChartState.selected.equals(previousChartState.selected) || events.push({type:gviz.ChartEventType.SELECT});
  goog.array.forEach(events, goog.bind(function(event) {
    this.dispatchEvent(event.type, event.data);
  }, this));
};
gviz.canviz.ChartEventDispatcher.prototype.dispatchEvent = function(eventType, opt_eventData) {
  var eventData = opt_eventData || null;
  google.visualization.events.trigger(this.eventSource_, eventType, eventData);
};
gviz.canviz.ChartEventDispatcher.prototype.createDatumEvent_ = function(eventType, serieIndex, datumIndex, chartType, series) {
  var serie = series[serieIndex], row, column;
  chartType == gviz.canviz.Options.ChartType.PIE ? (row = serie.dataTableIdx, column = null) : (row = datumIndex, column = serie.dataTableIdx);
  return{type:eventType, data:{row:row, column:column}};
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/common.js)
gviz.ai = {};
gviz.ai.common = {};
gviz.ai.common.Options = {EXPLORER:"explorer", MAX_ZOOM:"maxZoomOut", MIN_ZOOM:"maxZoomIn", ZOOM_DELTA:"zoomDelta", KEEP_IN_BOUNDS:"keepInBounds", ACTIONS:"actions", DRAG_TO_PAN:"dragToPan", DRAG_TO_ZOOM:"dragToZoom", PINCH_TO_ZOOM:"pinchToZoom", RIGHT_CLICK_TO_RESET:"rightClickToReset", SCROLL_TO_ZOOM:"scrollToZoom"};
gviz.ai.common.Defaults = {MAX_ZOOM:4, MIN_ZOOM:.25, ZOOM_DELTA:1.5, KEEP_IN_BOUNDS:!1, OVERLAY_BOX_COLOR:"blue", OVERLAY_BOX_OPACITY:.2};
gviz.ai.common.isInChart = function(event, bounds) {
  return goog.math.clamp(event.x, bounds.left, bounds.left + bounds.width) === event.x && goog.math.clamp(event.y, bounds.top, bounds.top + bounds.height) === event.y ? !0 : !1;
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/enabled-axes.js)
gviz.ai.EnabledAxes = function(horizontal, vertical) {
  this.horizontal = horizontal;
  this.vertical = vertical;
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/viewport.js)
gviz.ai.Viewport = function(chartDefinition, layout, maxZoomOut, maxZoomIn, zoomDelta, keepInBounds) {
  var hAxisIndex = chartDefinition.hAxes[0] ? 0 : 1, vAxisIndex = chartDefinition.vAxes[0] ? 0 : 1, hAxis = chartDefinition.hAxes[hAxisIndex], vAxis = chartDefinition.vAxes[vAxisIndex], valueToNumberX = hAxis.dataType && gviz.canviz.valuenumberconverter.getByType(hAxis.dataType).toNumber, valueToNumberY = vAxis.dataType && gviz.canviz.valuenumberconverter.getByType(vAxis.dataType).toNumber;
  this.layout_ = layout;
  this.getHAxisValue = goog.bind(function(value) {
    return valueToNumberX ? valueToNumberX(this.layout_.getHAxisValue(value, hAxisIndex)) : value;
  }, this);
  this.getVAxisValue = goog.bind(function(value) {
    return valueToNumberY ? valueToNumberY(this.layout_.getVAxisValue(value, vAxisIndex)) : value;
  }, this);
  var chartAreaBounds = this.layout_.getChartAreaBoundingBox();
  this.minX = this.getHAxisValue(chartAreaBounds.left);
  this.minY = this.getVAxisValue(chartAreaBounds.top + chartAreaBounds.height);
  this.maxX = this.getHAxisValue(chartAreaBounds.left + chartAreaBounds.width);
  this.maxY = this.getVAxisValue(chartAreaBounds.top);
  this.origX = this.minX;
  this.origY = this.minY;
  this.origWidth = this.maxX - this.minX;
  this.origHeight = this.maxY - this.minY;
  this.scale = 1;
  this.maxZoomOut = maxZoomOut;
  this.maxZoomIn = maxZoomIn;
  this.zoomDelta = zoomDelta;
  this.keepInBounds = keepInBounds;
};
gviz.ai.Viewport.prototype.setLayout = function(layout) {
  this.layout_ = layout;
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/base-explorer-type.js)
gviz.ai.BaseExplorerType = function(chartState, getLayout, enabledAxes) {
  this.enabledAxes_ = enabledAxes;
  this.chartState_ = chartState;
  this.getLayout_ = getLayout;
  this.viewport_ = null;
};
gviz.ai.BaseExplorerType.prototype.getViewport = function() {
  return this.viewport_;
};
gviz.ai.BaseExplorerType.prototype.getLayout = function() {
  return this.getLayout_();
};
gviz.ai.BaseExplorerType.prototype.getEnabledAxes = function() {
  return this.enabledAxes_;
};
gviz.ai.BaseExplorerType.prototype.getState = function() {
  return this.chartState_;
};
gviz.ai.BaseExplorerType.prototype.handleReady = function(viewport) {
  this.viewport_ = viewport;
};
gviz.ai.BaseExplorerType.prototype.handleDragStart = function() {
};
gviz.ai.BaseExplorerType.prototype.handleDrag = function() {
};
gviz.ai.BaseExplorerType.prototype.handleDragEnd = function() {
};
gviz.ai.BaseExplorerType.prototype.handlePinchStart = function() {
};
gviz.ai.BaseExplorerType.prototype.handlePinch = function() {
};
gviz.ai.BaseExplorerType.prototype.handlePinchEnd = function() {
};
gviz.ai.BaseExplorerType.prototype.handleScroll = function() {
};
gviz.ai.BaseExplorerType.prototype.handleRightClick = function() {
};
gviz.ai.BaseExplorerType.prototype.handleMouseDown = function() {
};
gviz.ai.BaseExplorerType.prototype.updateOptions = function() {
  var options = {hAxis:{viewWindowMode:gviz.canviz.Options.ViewWindowMode.EXPLICIT, viewWindow:{}}, vAxis:{viewWindowMode:gviz.canviz.Options.ViewWindowMode.EXPLICIT, viewWindow:{}}};
  this.chartState_.nextFrameOptions = options;
  this.enabledAxes_.horizontal && (isNaN(this.viewport_.minX) || (options.hAxis.viewWindow.numericMin = this.viewport_.minX), isNaN(this.viewport_.maxX) || (options.hAxis.viewWindow.numericMax = this.viewport_.maxX));
  this.enabledAxes_.vertical && (isNaN(this.viewport_.minY) || (options.vAxis.viewWindow.numericMin = this.viewport_.minY), isNaN(this.viewport_.maxY) || (options.vAxis.viewWindow.numericMax = this.viewport_.maxY));
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/drag-to-pan.js)
gviz.ai.DragToPan = function(chartState, getLayout, enabledAxis) {
  gviz.ai.BaseExplorerType.call(this, chartState, getLayout, enabledAxis);
  this.event_ = null;
};
goog.inherits(gviz.ai.DragToPan, gviz.ai.BaseExplorerType);
gviz.ai.DragToPan.prototype.handleDragStart = function(event) {
  var chartBounds = this.getLayout().getChartAreaBoundingBox();
  gviz.ai.common.isInChart(event, chartBounds) && (this.event_ = {x:event.x, y:event.y, dx:0, dy:0});
};
gviz.ai.DragToPan.prototype.handleDrag = function(event) {
  if (this.event_) {
    var nextX = event.x, nextY = event.y;
    this.event_ = {dx:nextX - this.event_.x, dy:nextY - this.event_.y, x:nextX, y:nextY};
    this.updateBounds();
  }
};
gviz.ai.DragToPan.prototype.handleDragEnd = function() {
  this.event_ = null;
};
gviz.ai.DragToPan.prototype.handleMouseDown = function(event, preventDefault) {
  var chartBounds = this.getLayout().getChartAreaBoundingBox();
  gviz.ai.common.isInChart(event, chartBounds) && preventDefault();
};
gviz.ai.DragToPan.prototype.updateBounds = function() {
  var viewport = this.getViewport();
  if (viewport) {
    viewport.setLayout(this.getLayout());
    var enabledAxes = this.getEnabledAxes();
    if (enabledAxes.horizontal) {
      var nextx = this.event_.x - this.event_.dx, dx = viewport.getHAxisValue(this.event_.x) - viewport.getHAxisValue(nextx), minx = viewport.minX - dx, maxx = viewport.maxX - dx, minBound = Math.max(minx, viewport.origX), maxBound = Math.min(maxx, viewport.origX + viewport.origWidth);
      if (viewport.keepInBounds && (minBound === minx || 0 > dx) && (maxBound === maxx || 0 < dx) || !viewport.keepInBounds) {
        viewport.minX = minx, viewport.maxX = maxx;
      }
    }
    if (enabledAxes.vertical) {
      var nexty = this.event_.y - this.event_.dy, dy = viewport.getVAxisValue(this.event_.y) - viewport.getVAxisValue(nexty), miny = viewport.minY - dy, maxy = viewport.maxY - dy, minBound = Math.max(miny, viewport.origY), maxBound = Math.min(maxy, viewport.origY + viewport.origHeight);
      if (viewport.keepInBounds && (minBound === miny || 0 > dy) && (maxBound === maxy || 0 < dy) || !viewport.keepInBounds) {
        viewport.minY = miny, viewport.maxY = maxy;
      }
    }
    this.updateOptions();
  }
};
gviz.ai.DragToPan.isEnabled = function(options) {
  var actions = options.inferValue(gviz.ai.common.Options.EXPLORER + "." + gviz.ai.common.Options.ACTIONS);
  return!goog.isDefAndNotNull(actions) || goog.isArray(actions) && goog.array.contains(actions, gviz.ai.common.Options.DRAG_TO_PAN) ? !0 : !1;
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/drag-to-zoom.js)
gviz.ai.DragToZoom = function(chartState, getLayout, enabledAxis) {
  gviz.ai.BaseExplorerType.call(this, chartState, getLayout, enabledAxis);
  this.event_ = null;
};
goog.inherits(gviz.ai.DragToZoom, gviz.ai.BaseExplorerType);
gviz.ai.DragToZoom.prototype.handleDragStart = function(event) {
  var chartBounds = this.getLayout().getChartAreaBoundingBox();
  gviz.ai.common.isInChart(event, chartBounds) && (this.event_ = {startX:event.x, startY:event.y, endX:0, endY:0});
};
gviz.ai.DragToZoom.prototype.handleDrag = function(event) {
  if (this.event_) {
    var chartContainer = this.getLayout().getChartAreaBoundingBox(), enabledAxis = this.getEnabledAxes();
    this.pullToBounds(event, chartContainer);
    this.event_.endX = event.x;
    this.event_.endY = event.y;
    if (enabledAxis.horizontal) {
      var left = Math.min(this.event_.startX, this.event_.endX), width = Math.abs(this.event_.startX - this.event_.endX)
    } else {
      left = chartContainer.left, width = chartContainer.width;
    }
    if (enabledAxis.vertical) {
      var top = Math.min(this.event_.startY, this.event_.endY), height = Math.abs(this.event_.startY - this.event_.endY)
    } else {
      top = chartContainer.top, height = chartContainer.height;
    }
    this.getState().overlayBox = {left:left, top:top, width:width, height:height, color:gviz.ai.common.Defaults.OVERLAY_BOX_COLOR, opacity:gviz.ai.common.Defaults.OVERLAY_BOX_OPACITY};
  }
};
gviz.ai.DragToZoom.prototype.handleDragEnd = function() {
  this.event_ && (this.updateBounds(), this.event_ = null);
};
gviz.ai.DragToZoom.prototype.updateBounds = function() {
  var enabledAxes = this.getEnabledAxes(), viewport = this.getViewport();
  viewport.setLayout(this.getLayout());
  var overlayBox = this.getState().overlayBox, startX = viewport.getHAxisValue(overlayBox.left), endX = viewport.getHAxisValue(overlayBox.left + overlayBox.width), startY = viewport.getVAxisValue(overlayBox.top), endY = viewport.getVAxisValue(overlayBox.top + overlayBox.height);
  if (startX !== endX && startY !== endY) {
    var minWidth = viewport.origWidth * viewport.maxZoomIn;
    if (enabledAxes.horizontal) {
      var minx = Math.min(startX, endX), maxx = Math.max(startX, endX);
      if (maxx - minx < minWidth) {
        var center = (minx + maxx) / 2, minx = center - minWidth / 2, maxx = center + minWidth / 2
      }
      viewport.minX = minx;
      viewport.maxX = maxx;
    }
    var minHeight = viewport.origHeight * viewport.maxZoomIn;
    if (enabledAxes.vertical) {
      var miny = Math.min(startY, endY), maxy = Math.max(startY, endY);
      maxy - miny < minHeight && (center = (miny + maxy) / 2, miny = center - minHeight / 2, maxy = center + minHeight / 2);
      viewport.minY = miny;
      viewport.maxY = maxy;
    }
    this.updateOptions();
  }
};
gviz.ai.DragToZoom.prototype.pullToBounds = function(cursor, chartBounds) {
  cursor.x = goog.math.clamp(cursor.x, chartBounds.left, chartBounds.left + chartBounds.width);
  cursor.y = goog.math.clamp(cursor.y, chartBounds.top, chartBounds.top + chartBounds.height);
};
gviz.ai.DragToZoom.isEnabled = function(options) {
  var actions = options.inferValue(gviz.ai.common.Options.EXPLORER + "." + gviz.ai.common.Options.ACTIONS);
  return goog.isArray(actions) && goog.array.contains(actions, gviz.ai.common.Options.DRAG_TO_ZOOM) ? !0 : !1;
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/pinch-to-zoom.js)
gviz.ai.PinchToZoom = function(chartState, getLayout, enabledAxis) {
  gviz.ai.BaseExplorerType.call(this, chartState, getLayout, enabledAxis);
  this.event_ = null;
};
goog.inherits(gviz.ai.PinchToZoom, gviz.ai.BaseExplorerType);
gviz.ai.PinchToZoom.prototype.handlePinchStart = function(event) {
  var chartBounds = this.getLayout().getChartAreaBoundingBox();
  gviz.ai.common.isInChart(event, chartBounds) && (this.event_ = {x:event.x, y:event.y, scale:event.gesture.scale, oldScale:1});
};
gviz.ai.PinchToZoom.prototype.handlePinch = function(event) {
  if (this.event_) {
    var chartContainer = this.getLayout().getChartAreaBoundingBox();
    this.pullToBounds(event, chartContainer);
    this.event_.oldScale = this.event_.scale;
    this.event_.scale = event.gesture.scale;
    this.updateBounds();
  }
};
gviz.ai.PinchToZoom.prototype.handlePinchEnd = function() {
  this.event_ && (this.updateBounds(), this.event_ = null);
};
gviz.ai.PinchToZoom.prototype.updateBounds = function() {
  var viewport = this.getViewport();
  viewport.setLayout(this.getLayout());
  if (viewport) {
    var scale = 1 - (this.event_.oldScale - this.event_.scale), x = viewport.getHAxisValue(this.event_.x), minX = viewport.minX, maxX = viewport.maxX, dminX = x - minX, dmaxX = maxX - x;
    viewport.minX = x - dminX / scale;
    viewport.maxX = x + dmaxX / scale;
    var y = viewport.getVAxisValue(this.event_.y), minY = viewport.minY, maxY = viewport.maxY, dminY = y - minY, dmaxY = maxY - y;
    viewport.minY = y - dminY / scale;
    viewport.maxY = y + dmaxY / scale;
    this.updateOptions();
  }
};
gviz.ai.PinchToZoom.prototype.pullToBounds = function(cursor, chartBounds) {
  cursor.x = goog.math.clamp(cursor.x, chartBounds.left, chartBounds.left + chartBounds.width);
  cursor.y = goog.math.clamp(cursor.y, chartBounds.top, chartBounds.top + chartBounds.height);
};
gviz.ai.PinchToZoom.isEnabled = function(options) {
  var actions = options.inferValue(gviz.ai.common.Options.EXPLORER + "." + gviz.ai.common.Options.ACTIONS);
  goog.isArray(actions) && goog.array.contains(actions, gviz.ai.common.Options.PINCH_TO_ZOOM);
  return!1;
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/right-click-to-reset.js)
gviz.ai.RightClickToReset = function(chartState, getLayout, enabledAxis) {
  gviz.ai.BaseExplorerType.call(this, chartState, getLayout, enabledAxis);
};
goog.inherits(gviz.ai.RightClickToReset, gviz.ai.BaseExplorerType);
gviz.ai.RightClickToReset.prototype.handleRightClick = function() {
  var viewport = this.getViewport();
  viewport.scale = 1;
  viewport.minX = viewport.origX;
  viewport.maxX = viewport.origX + viewport.origWidth;
  viewport.minY = viewport.origY;
  viewport.maxY = viewport.origY + viewport.origHeight;
  this.updateOptions();
};
gviz.ai.RightClickToReset.isEnabled = function(options) {
  var actions = options.inferValue(gviz.ai.common.Options.EXPLORER + "." + gviz.ai.common.Options.ACTIONS);
  return!goog.isDefAndNotNull(actions) || goog.isArray(actions) && goog.array.contains(actions, gviz.ai.common.Options.RIGHT_CLICK_TO_RESET) ? !0 : !1;
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/scroll-to-zoom.js)
gviz.ai.ScrollToZoom = function(chartState, getLayout, enabledAxis) {
  gviz.ai.BaseExplorerType.call(this, chartState, getLayout, enabledAxis);
};
goog.inherits(gviz.ai.ScrollToZoom, gviz.ai.BaseExplorerType);
gviz.ai.ScrollToZoom.prototype.handleScroll = function(event, preventDefault) {
  var enabledAxes = this.getEnabledAxes(), chartBounds = this.getLayout().getChartAreaBoundingBox();
  if (gviz.ai.common.isInChart(event, chartBounds)) {
    preventDefault();
    var viewport = this.getViewport();
    if (0 > event.wheelDelta) {
      if (viewport.scale >= viewport.maxZoomOut) {
        return;
      }
      viewport.scale *= viewport.zoomDelta;
    } else {
      if (viewport.scale <= viewport.maxZoomIn) {
        return;
      }
      viewport.scale /= viewport.zoomDelta;
    }
    if (enabledAxes.horizontal) {
      var hMidpoint = (viewport.maxX + viewport.minX) / 2, hDistFromMid = viewport.origWidth * viewport.scale / 2;
      viewport.minX = hMidpoint - hDistFromMid;
      viewport.maxX = hMidpoint + hDistFromMid;
    }
    if (enabledAxes.vertical) {
      var vMidpoint = (viewport.maxY + viewport.minY) / 2, vDistFromMid = viewport.origHeight * viewport.scale / 2;
      viewport.minY = vMidpoint - vDistFromMid;
      viewport.maxY = vMidpoint + vDistFromMid;
    }
    this.updateOptions();
  }
};
gviz.ai.ScrollToZoom.isEnabled = function(options) {
  var actions = options.inferValue(gviz.ai.common.Options.EXPLORER + "." + gviz.ai.common.Options.ACTIONS);
  return!goog.isDefAndNotNull(actions) || goog.isArray(actions) && goog.array.contains(actions, gviz.ai.common.Options.SCROLL_TO_ZOOM) ? !0 : !1;
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/explorer-types.js)
gviz.ai.ExplorerTypes = [{isEnabled:gviz.ai.DragToPan.isEnabled, constructor:gviz.ai.DragToPan}, {isEnabled:gviz.ai.DragToZoom.isEnabled, constructor:gviz.ai.DragToZoom}, {isEnabled:gviz.ai.RightClickToReset.isEnabled, constructor:gviz.ai.RightClickToReset}, {isEnabled:gviz.ai.PinchToZoom.isEnabled, constructor:gviz.ai.PinchToZoom}, {isEnabled:gviz.ai.ScrollToZoom.isEnabled, constructor:gviz.ai.ScrollToZoom}];
// INPUT (javascript/gviz/devel/jsapi/packages/ai/explorer.js)
gviz.ai.Explorer = function(chartState, getLayout, options, chartDefinition) {
  this.checkValidChart(options, chartDefinition);
  this.options_ = options;
  this.chartState_ = chartState;
  this.enabledAxes_ = null;
  this.getLayout_ = getLayout;
  this.chartDefinition_ = chartDefinition;
  this.viewport_ = null;
  this.enabledExplorerTypes_ = [];
  this.initializeDetails(chartDefinition);
};
gviz.ai.Explorer.prototype.checkValidChart = function(options) {
  if (options.inferValue("type") === gviz.canviz.Options.ChartType.PIE) {
    throw Error("Cannot use explorer with a pie chart");
  }
};
gviz.ai.Explorer.prototype.handleReady = function() {
  var maxZoom = this.options_.inferNumberValue(gviz.ai.common.Options.EXPLORER + "." + gviz.ai.common.Options.MAX_ZOOM, gviz.ai.common.Defaults.MAX_ZOOM);
  1 > maxZoom && (maxZoom = 1 / maxZoom);
  var minZoom = this.options_.inferNumberValue(gviz.ai.common.Options.EXPLORER + "." + gviz.ai.common.Options.MIN_ZOOM, gviz.ai.common.Defaults.MIN_ZOOM);
  1 < minZoom && (minZoom = 1 / minZoom);
  var zoomDelta = this.options_.inferNumberValue(gviz.ai.common.Options.EXPLORER + "." + gviz.ai.common.Options.ZOOM_DELTA, gviz.ai.common.Defaults.ZOOM_DELTA), keepInBounds = this.options_.inferBooleanValue(gviz.ai.common.Options.EXPLORER + "." + gviz.ai.common.Options.KEEP_IN_BOUNDS, gviz.ai.common.Defaults.KEEP_IN_BOUNDS);
  this.viewport_ = new gviz.ai.Viewport(this.chartDefinition_, this.getLayout_(), maxZoom, minZoom, zoomDelta, keepInBounds);
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handleReady(this.viewport_);
  }, this);
};
gviz.ai.Explorer.prototype.initializeDetails = function() {
  var hAxisIndex = this.chartDefinition_.hAxes[0] ? 0 : 1, vAxisIndex = this.chartDefinition_.vAxes[0] ? 0 : 1, hAxis = this.chartDefinition_.hAxes[hAxisIndex], vAxis = this.chartDefinition_.vAxes[vAxisIndex], enableHorizontal = !this.chartDefinition_.hAxes[1 - hAxisIndex] && "value" === hAxis.type && !hAxis.logScale, enableVertical = !this.chartDefinition_.vAxes[1 - vAxisIndex] && "value" === vAxis.type && !vAxis.logScale, settings = this.options_.inferValue(gviz.ai.common.Options.EXPLORER), axis = 
  settings.axis;
  axis === gviz.canviz.Options.Orientation.HORIZONTAL ? enableVertical = !1 : axis === gviz.canviz.Options.Orientation.VERTICAL && (enableHorizontal = !1);
  this.enabledAxes_ = new gviz.ai.EnabledAxes(enableHorizontal, enableVertical);
  goog.array.forEach(gviz.ai.ExplorerTypes, function(explorer) {
    var curType = explorer;
    curType.isEnabled(this.options_) && this.enabledExplorerTypes_.push(new curType.constructor(this.chartState_, this.getLayout_, this.enabledAxes_));
  }, this);
};
gviz.ai.Explorer.prototype.handleDragStart = function(event) {
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handleDragStart(event);
  }, this);
};
gviz.ai.Explorer.prototype.handleDrag = function(event) {
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handleDrag(event);
  }, this);
};
gviz.ai.Explorer.prototype.handleDragEnd = function(event) {
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handleDragEnd(event);
  }, this);
};
gviz.ai.Explorer.prototype.handleRightClick = function(event) {
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handleRightClick(event);
  }, this);
};
gviz.ai.Explorer.prototype.handleScroll = function(event, preventDefault) {
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handleScroll(event, preventDefault);
  }, this);
};
gviz.ai.Explorer.prototype.handleMouseDown = function(event, preventDefault) {
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handleMouseDown(event, preventDefault);
  }, this);
};
gviz.ai.Explorer.prototype.handlePinchStart = function(event, preventDefault) {
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handlePinchStart(event, preventDefault);
  }, this);
};
gviz.ai.Explorer.prototype.handlePinch = function(event, preventDefault) {
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handlePinch(event, preventDefault);
  }, this);
};
gviz.ai.Explorer.prototype.handlePinchEnd = function(event, preventDefault) {
  goog.array.forEach(this.enabledExplorerTypes_, function(explorer) {
    explorer.handlePinchEnd(event, preventDefault);
  }, this);
};
gviz.ai.Explorer.isEnabled = function(options) {
  return options.inferValue(gviz.ai.common.Options.EXPLORER) ? !0 : !1;
};
// INPUT (javascript/gviz/devel/jsapi/packages/ai/subscriber-types.js)
gviz.ai.SubscriberTypes = [{isEnabled:gviz.ai.Explorer.isEnabled, constructor:gviz.ai.Explorer}];
// INPUT (javascript/gviz/devel/jsapi/packages/ai/publisher.js)
gviz.ai.Publisher = function(options, state, getLayout, chartDefinition) {
  this.options_ = options;
  this.state_ = state;
  this.getLayout_ = getLayout;
  this.chartDefinition_ = chartDefinition;
  this.enabledFeatures_ = [];
  this.scheduler_ = null;
  this.initializeFeatures();
};
gviz.ai.Publisher.prototype.initializeFeatures = function() {
  this.options_ && goog.array.forEach(gviz.ai.SubscriberTypes, function(feature) {
    feature.isEnabled && feature.isEnabled(this.options_) && this.enabledFeatures_.push(new feature.constructor(this.state_, this.getLayout_, this.options_, this.chartDefinition_));
  }, this);
};
gviz.ai.Publisher.prototype.setScheduler = function(scheduler) {
  this.scheduler_ = scheduler;
};
gviz.ai.Publisher.prototype.handleDragEnd = function(event) {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handleDragEnd(event);
  });
  this.scheduler_.updateCountdown(15);
};
gviz.ai.Publisher.prototype.handleDrag = function(event) {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handleDrag(event);
  });
  this.scheduler_.updateCountdown(5);
};
gviz.ai.Publisher.prototype.handleDragStart = function(event) {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handleDragStart(event);
  });
  this.scheduler_.updateCountdown(5);
};
gviz.ai.Publisher.prototype.handleScroll = function(event, preventDefault) {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handleScroll(event, preventDefault);
  });
  this.scheduler_.updateCountdown(5);
};
gviz.ai.Publisher.prototype.handleRightClick = function(event) {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handleRightClick(event);
  });
  this.scheduler_.updateCountdown(5);
};
gviz.ai.Publisher.prototype.handleMouseDown = function(event, preventDefault) {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handleMouseDown(event, preventDefault);
  });
};
gviz.ai.Publisher.prototype.handlePinchStart = function(event, preventDefault) {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handlePinchStart(event, preventDefault);
  });
};
gviz.ai.Publisher.prototype.handlePinch = function(event, preventDefault) {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handlePinch(event, preventDefault);
  });
  this.scheduler_.updateCountdown(5);
};
gviz.ai.Publisher.prototype.handlePinchEnd = function(event, preventDefault) {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handlePinchEnd(event, preventDefault);
  });
  this.scheduler_.updateCountdown(15);
};
gviz.ai.Publisher.prototype.handleReady = function() {
  goog.array.forEach(this.enabledFeatures_, function(feature) {
    feature.handleReady();
  });
};
// INPUT (javascript/gviz/devel/canviz/event-handler.js)
gviz.canviz.EventHandler = function(chartDefinition, chartState, interactionEventTarget, chartEventDispatcher, callback, aiPublisher) {
  goog.Disposable.call(this);
  this.chartDefinition_ = chartDefinition;
  this.chartState_ = chartState;
  this.interactionEventTarget_ = interactionEventTarget;
  this.chartEventDispatcher_ = chartEventDispatcher;
  this.scheduler_ = new gviz.canviz.Scheduler(callback);
  this.registerDisposable(this.scheduler_);
  this.aiPublisher_ = aiPublisher;
  this.aiPublisher_.setScheduler(this.scheduler_);
  this.registerEventHandlers_();
};
goog.inherits(gviz.canviz.EventHandler, goog.Disposable);
gviz.canviz.EventHandler.prototype.disposeInternal = function() {
  goog.events.removeAll(this.interactionEventTarget_);
  gviz.canviz.EventHandler.superClass_.disposeInternal.call(this);
};
gviz.canviz.EventHandler.prototype.setChartDefinition = function(chartDefinition) {
  this.chartDefinition_ = chartDefinition;
};
gviz.canviz.EventHandler.prototype.cancelPendingEvents = function() {
  this.scheduler_.stopCountdown();
};
gviz.canviz.EventHandler.prototype.handleChartHoverIn_ = function(event) {
  this.chartState_.cursor.position = event.data.cursorPosition;
  this.scheduler_.updateCountdown(5);
};
gviz.canviz.EventHandler.prototype.handleChartHoverOut_ = function() {
};
gviz.canviz.EventHandler.prototype.handleChartMouseMove_ = function(event) {
  this.chartState_.cursor.position = event.data.cursorPosition;
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.MOUSE_MOVE, {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y});
};
gviz.canviz.EventHandler.prototype.handleChartMouseUp_ = function(event) {
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.MOUSE_UP, {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y});
};
gviz.canviz.EventHandler.prototype.handleChartMouseDown_ = function(event) {
  var data = {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y};
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.MOUSE_DOWN, data);
  this.aiPublisher_.handleMouseDown(data, event.data.preventDefault);
};
gviz.canviz.EventHandler.prototype.handleChartClick_ = function(event) {
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.CLICK, {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y});
};
gviz.canviz.EventHandler.prototype.handleChartRightClick_ = function(event) {
  var data = {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y};
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.RIGHT_CLICK, data);
  this.aiPublisher_.handleRightClick(data);
};
gviz.canviz.EventHandler.prototype.handleChartDblClick_ = function(event) {
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.DBL_CLICK, {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y});
};
gviz.canviz.EventHandler.prototype.handleChartScroll_ = function(event) {
  var data = {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y, wheelDelta:event.data.wheelDelta};
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.SCROLL, data);
  this.aiPublisher_.handleScroll(data, event.data.preventDefault);
};
gviz.canviz.EventHandler.prototype.handleChartDragStart_ = function(event) {
  var data = {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y};
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.DRAG_START, data);
  this.aiPublisher_.handleDragStart(data);
};
gviz.canviz.EventHandler.prototype.handleChartDrag_ = function(event) {
  var data = {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y};
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.DRAG, data);
  this.aiPublisher_.handleDrag(data);
};
gviz.canviz.EventHandler.prototype.handleChartDragEnd_ = function(event) {
  var data = {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y};
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.DRAG_END, data);
  this.aiPublisher_.handleDragEnd(data);
};
gviz.canviz.EventHandler.prototype.handleChartPinchStart_ = function(event) {
  var data = {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y, gesture:event.data.gestureDetails};
  this.aiPublisher_.handlePinchStart(data, event.data.preventDefault);
};
gviz.canviz.EventHandler.prototype.handleChartPinch_ = function(event) {
  var data = {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y, gesture:event.data.gestureDetails};
  this.aiPublisher_.handlePinch(data, event.data.preventDefault);
};
gviz.canviz.EventHandler.prototype.handleChartPinchEnd_ = function(event) {
  var data = {targetID:event.data.targetID, x:event.data.cursorPosition.x, y:event.data.cursorPosition.y, gesture:event.data.gestureDetails};
  this.aiPublisher_.handlePinchEnd(data, event.data.preventDefault);
};
gviz.canviz.EventHandler.prototype.handleCategoryHoverIn_ = function(event) {
  var categoryIndex = event.data.datumIndex;
  this.chartState_.focused.category = categoryIndex;
  this.scheduler_.updateCountdown(50);
};
gviz.canviz.EventHandler.prototype.handleCategoryHoverOut_ = function() {
  this.unfocusCategory_();
  this.scheduler_.updateCountdown(50);
};
gviz.canviz.EventHandler.prototype.handleCategoryClick_ = function(event) {
  var chartDefinition = this.chartDefinition_;
  this.chartState_.cursor.positionAtLastClick = this.chartState_.cursor.position.clone();
  var categoryIndex = event.data.datumIndex, isAnySeriesInteractive = goog.array.some(chartDefinition.series, function(series) {
    return series.enableInteractivity;
  });
  if (isAnySeriesInteractive) {
    var rowIndex = chartDefinition.categories[categoryIndex].dataTableIdx, isSingle = chartDefinition.selectionMode == gviz.Options.SelectionMode.SINGLE;
    this.chartState_.selected.toggleRow(rowIndex, isSingle);
    this.scheduler_.updateCountdown(0);
  }
};
gviz.canviz.EventHandler.prototype.handleLegendEntryHoverIn_ = function(event) {
  this.chartDefinition_.chartType != gviz.canviz.Options.ChartType.BUBBLE && (this.chartState_.legend.focused.entry = event.data.legendEntryIndex, this.scheduler_.updateCountdown(50));
};
gviz.canviz.EventHandler.prototype.handleLegendEntryHoverOut_ = function() {
  this.chartDefinition_.chartType != gviz.canviz.Options.ChartType.BUBBLE && (this.chartState_.legend.focused.entry = null, this.scheduler_.updateCountdown(250));
};
gviz.canviz.EventHandler.prototype.handleLegendEntryClick_ = function(event) {
  this.chartDefinition_.chartType != gviz.canviz.Options.ChartType.BUBBLE && (this.toggleSerieSelection_(event.data.legendEntryIndex), this.scheduler_.updateCountdown(0));
};
gviz.canviz.EventHandler.prototype.handleLegendScrollButtonClick_ = function(event) {
  goog.isDefAndNotNull(this.chartState_.legend.currentPageIndex) || (this.chartState_.legend.currentPageIndex = 0);
  this.chartState_.legend.currentPageIndex += event.data.scrollStep;
  this.scheduler_.updateCountdown(0);
};
gviz.canviz.EventHandler.prototype.handleSerieHoverIn_ = function(event) {
  if (this.chartDefinition_.chartType != gviz.canviz.Options.ChartType.BUBBLE) {
    var focusTarget = this.chartDefinition_.focusTarget, interactivityModel = this.chartDefinition_.interactivityModel;
    if (focusTarget == gviz.canviz.Options.FocusTarget.SERIES || interactivityModel == gviz.canviz.Options.InteractivityModel.DIVE) {
      this.chartState_.focused.serie = event.data.serieIndex, this.scheduler_.updateCountdown(50);
    }
  }
};
gviz.canviz.EventHandler.prototype.handleSerieHoverOut_ = function() {
  if (this.chartDefinition_.chartType != gviz.canviz.Options.ChartType.BUBBLE) {
    var focusTarget = this.chartDefinition_.focusTarget, interactivityModel = this.chartDefinition_.interactivityModel;
    if (focusTarget == gviz.canviz.Options.FocusTarget.SERIES || interactivityModel == gviz.canviz.Options.InteractivityModel.DIVE) {
      this.unfocusSerie_(), this.scheduler_.updateCountdown(250);
    }
  }
};
gviz.canviz.EventHandler.prototype.handleSerieClick_ = function(event) {
  if (this.chartDefinition_.chartType != gviz.canviz.Options.ChartType.BUBBLE) {
    var focusTarget = this.chartDefinition_.focusTarget;
    focusTarget == gviz.canviz.Options.FocusTarget.SERIES && (this.toggleSerieSelection_(event.data.serieIndex), this.scheduler_.updateCountdown(0));
  }
};
gviz.canviz.EventHandler.prototype.handleRemoveSerieButtonHoverIn_ = function(event) {
  this.handleLegendEntryHoverIn_(event);
};
gviz.canviz.EventHandler.prototype.handleRemoveSerieButtonHoverOut_ = function(event) {
  this.handleLegendEntryHoverOut_(event);
};
gviz.canviz.EventHandler.prototype.handleRemoveSerieButtonClick_ = function(event) {
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.REMOVE_SERIE, {index:event.data.legendEntryIndex});
};
gviz.canviz.EventHandler.prototype.handleDatumHoverIn_ = function(event) {
  var focusTarget = this.chartDefinition_.focusTarget;
  focusTarget == gviz.canviz.Options.FocusTarget.SERIES ? this.handleSerieHoverIn_(event) : (this.chartState_.focused.serie = event.data.serieIndex, this.chartState_.focused.datum = event.data.datumIndex, this.scheduler_.updateCountdown(50));
};
gviz.canviz.EventHandler.prototype.handleDatumHoverOut_ = function(event) {
  var focusTarget = this.chartDefinition_.focusTarget;
  focusTarget == gviz.canviz.Options.FocusTarget.SERIES ? this.handleSerieHoverOut_(event) : (this.unfocusDatum_(), this.scheduler_.updateCountdown(250));
};
gviz.canviz.EventHandler.prototype.handleDatumClick_ = function(event) {
  var chartDefinition = this.chartDefinition_;
  if (chartDefinition.focusTarget == gviz.canviz.Options.FocusTarget.SERIES) {
    this.handleSerieClick_(event);
  } else {
    var isSingle = chartDefinition.selectionMode == gviz.Options.SelectionMode.SINGLE, datum = {category:event.data.datumIndex, serie:event.data.serieIndex}, serie = chartDefinition.series[datum.serie];
    if (serie.enableInteractivity) {
      if (chartDefinition.chartType == gviz.canviz.Options.ChartType.BUBBLE) {
        this.chartState_.selected.toggleRow(datum.category, isSingle);
      } else {
        if (!serie.isVirtual) {
          var cellRef = chartDefinition.getCellRefForDatum(datum), focusTarget = this.chartDefinition_.focusTarget;
          focusTarget == gviz.canviz.Options.FocusTarget.SERIES ? this.chartState_.selected.toggleColumn(cellRef.column, isSingle) : this.chartState_.selected.toggleCell(cellRef.row, cellRef.column, isSingle);
        }
      }
    }
    this.scheduler_.updateCountdown(0);
  }
};
gviz.canviz.EventHandler.prototype.handleAnnotationHoverIn_ = function(event) {
  var annotationIndex = event.data.annotationIndex;
  -1 != annotationIndex && (this.chartState_.annotations.focused = {row:event.data.datumIndex, column:this.getAnnotationColumn_(event.data.serieIndex, annotationIndex)}, this.unfocusDatum_(), this.scheduler_.updateCountdown(50));
};
gviz.canviz.EventHandler.prototype.handleAnnotationHoverOut_ = function(event) {
  -1 != event.data.annotationIndex && (this.chartState_.annotations.focused = null, this.scheduler_.updateCountdown(250));
};
gviz.canviz.EventHandler.prototype.handleAnnotationClick_ = function(event) {
  var chartDefinition = this.chartDefinition_, isSingle = chartDefinition.selectionMode == gviz.Options.SelectionMode.SINGLE, datumIndex = event.data.datumIndex, serieIndex = event.data.serieIndex, annotationIndex = event.data.annotationIndex;
  if (chartDefinition.series[serieIndex].enableInteractivity) {
    if (-1 == annotationIndex) {
      this.chartState_.annotations.expanded = {serieIndex:serieIndex, datumOrCategoryIndex:datumIndex};
    } else {
      var column = this.getAnnotationColumn_(serieIndex, annotationIndex);
      this.chartState_.selected.toggleCell(datumIndex, column, isSingle);
    }
  }
  this.scheduler_.updateCountdown(0);
};
gviz.canviz.EventHandler.prototype.handleTooltipHoverIn_ = function(event) {
  if (goog.isNull(event.data.annotationIndex)) {
    var focusTarget = this.chartDefinition_.focusTarget;
    switch(focusTarget) {
      case gviz.canviz.Options.FocusTarget.DATUM:
        this.chartState_.focused.datum = event.data.datumIndex;
        this.chartState_.focused.serie = event.data.serieIndex;
        break;
      case gviz.canviz.Options.FocusTarget.SERIES:
        this.chartState_.focused.serie = event.data.serieIndex;
        break;
      case gviz.canviz.Options.FocusTarget.CATEGORY:
        this.chartState_.focused.category = event.data.datumIndex;
        break;
      default:
        goog.asserts.fail('Illegal focus target "' + focusTarget + '"');
    }
    this.scheduler_.updateCountdown(50);
  } else {
    this.handleAnnotationHoverIn_(event);
  }
};
gviz.canviz.EventHandler.prototype.handleTooltipHoverOut_ = function(event) {
  if (goog.isNull(event.data.annotationIndex)) {
    var focusTarget = this.chartDefinition_.focusTarget;
    switch(focusTarget) {
      case gviz.canviz.Options.FocusTarget.DATUM:
        this.unfocusDatum_();
        break;
      case gviz.canviz.Options.FocusTarget.SERIES:
        this.unfocusSerie_();
        break;
      case gviz.canviz.Options.FocusTarget.CATEGORY:
        this.unfocusCategory_();
        break;
      default:
        goog.asserts.fail('Illegal focus target "' + focusTarget + '"');
    }
    this.scheduler_.updateCountdown(750);
  } else {
    this.handleAnnotationHoverOut_(event);
  }
};
gviz.canviz.EventHandler.prototype.handleActionsMenuEntryHoverIn_ = function(event) {
  this.chartState_.actionsMenu.focused.entryID = event.data.entryID;
  this.scheduler_.updateCountdown(50);
};
gviz.canviz.EventHandler.prototype.handleActionsMenuEntryHoverOut_ = function() {
  this.chartState_.actionsMenu.focused.entryID = null;
  this.scheduler_.updateCountdown(250);
};
gviz.canviz.EventHandler.prototype.handleActionsMenuEntryClick_ = function() {
  this.chartState_.actionsMenu.focused.action && this.chartState_.actionsMenu.focused.action();
  this.scheduler_.updateCountdown(250);
};
gviz.canviz.EventHandler.prototype.handleReady = function() {
  this.aiPublisher_.handleReady();
};
gviz.canviz.EventHandler.prototype.unfocusDatum_ = function() {
  this.chartState_.focused.serie = null;
  this.chartState_.focused.datum = null;
};
gviz.canviz.EventHandler.prototype.unfocusSerie_ = function() {
  this.chartState_.focused.serie = null;
};
gviz.canviz.EventHandler.prototype.unfocusCategory_ = function() {
  this.chartState_.cursor.position = null;
  this.chartState_.focused.category = null;
};
gviz.canviz.EventHandler.prototype.getAnnotationColumn_ = function(serieIndex, annotationIndex) {
  var chartDefinition = this.chartDefinition_, annotationColumns = null;
  if (goog.isDefAndNotNull(serieIndex)) {
    var serie = chartDefinition.series[serieIndex], annotationColumns = serie.columns[gviz.canviz.ColumnRole.ANNOTATION]
  } else {
    for (var i = 0;i < chartDefinition.domainsColumnStructure.length;++i) {
      var domainColumnStructure = chartDefinition.domainsColumnStructure[i], annotationColumns = domainColumnStructure.columns[gviz.canviz.ColumnRole.ANNOTATION]
    }
  }
  goog.asserts.assert(annotationIndex < annotationColumns.length);
  return annotationColumns[annotationIndex];
};
gviz.canviz.EventHandler.prototype.registerEventHandlers_ = function() {
  var setEventHandler = goog.bind(function(eventType, eventHandler) {
    goog.events.listen(this.interactionEventTarget_, eventType, goog.bind(eventHandler, this));
  }, this);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_HOVER_IN, this.handleChartHoverIn_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_HOVER_OUT, this.handleChartHoverOut_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_MOUSE_MOVE, this.handleChartMouseMove_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_MOUSE_UP, this.handleChartMouseUp_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_MOUSE_DOWN, this.handleChartMouseDown_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_CLICK, this.handleChartClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_RIGHT_CLICK, this.handleChartRightClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_DBL_CLICK, this.handleChartDblClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_SCROLL, this.handleChartScroll_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_DRAG_START, this.handleChartDragStart_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_DRAG, this.handleChartDrag_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_DRAG_END, this.handleChartDragEnd_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_PINCH_START, this.handleChartPinchStart_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_PINCH, this.handleChartPinch_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CHART_PINCH_END, this.handleChartPinchEnd_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CATEGORY_HOVER_IN, this.handleCategoryHoverIn_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CATEGORY_HOVER_OUT, this.handleCategoryHoverOut_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.CATEGORY_CLICK, this.handleCategoryClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.LEGEND_ENTRY_HOVER_IN, this.handleLegendEntryHoverIn_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.LEGEND_ENTRY_HOVER_OUT, this.handleLegendEntryHoverOut_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.LEGEND_ENTRY_CLICK, this.handleLegendEntryClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.LEGEND_SCROLL_BUTTON_CLICK, this.handleLegendScrollButtonClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.SERIE_HOVER_IN, this.handleSerieHoverIn_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.SERIE_HOVER_OUT, this.handleSerieHoverOut_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.SERIE_CLICK, this.handleSerieClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.REMOVE_SERIE_BUTTON_HOVER_IN, this.handleRemoveSerieButtonHoverIn_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.REMOVE_SERIE_BUTTON_HOVER_OUT, this.handleRemoveSerieButtonHoverOut_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.REMOVE_SERIE_BUTTON_CLICK, this.handleRemoveSerieButtonClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.DATUM_HOVER_IN, this.handleDatumHoverIn_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.DATUM_HOVER_OUT, this.handleDatumHoverOut_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.DATUM_CLICK, this.handleDatumClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.ANNOTATION_HOVER_IN, this.handleAnnotationHoverIn_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.ANNOTATION_HOVER_OUT, this.handleAnnotationHoverOut_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.ANNOTATION_CLICK, this.handleAnnotationClick_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.TOOLTIP_HOVER_IN, this.handleTooltipHoverIn_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.TOOLTIP_HOVER_OUT, this.handleTooltipHoverOut_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.ACTIONS_MENU_ENTRY_HOVER_IN, this.handleActionsMenuEntryHoverIn_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.ACTIONS_MENU_ENTRY_HOVER_OUT, this.handleActionsMenuEntryHoverOut_);
  setEventHandler(gviz.canviz.interactionEvents.EventType.ACTIONS_MENU_ENTRY_CLICK, this.handleActionsMenuEntryClick_);
};
gviz.canviz.EventHandler.prototype.toggleSerieSelection_ = function(serieIndex) {
  var chartDefinition = this.chartDefinition_;
  if (chartDefinition.series[serieIndex].enableInteractivity) {
    var isSingle = chartDefinition.selectionMode == gviz.Options.SelectionMode.SINGLE, dataTableIdx = chartDefinition.series[serieIndex].dataTableIdx;
    chartDefinition.chartType == gviz.canviz.Options.ChartType.PIE ? this.chartState_.selected.toggleRow(dataTableIdx, isSingle) : this.chartState_.selected.toggleColumn(dataTableIdx, isSingle);
  }
};
// INPUT (javascript/gviz/devel/jsapi/common/webfonts.js)
gviz.common.WebFontLoader = function(fonts, resolver) {
  this.fonts_ = fonts || [];
  this.loadFonts_(resolver);
};
gviz.common.WebFontLoader.FONT_FAMILIES = "Arial;Comic Sans MS;Courier New;Georgia;Impact;Times New Roman;Trebuchet MS;Verdana".split(";");
gviz.common.WebFontLoader.fontPredicate = function(fontName) {
  return function(v, k) {
    return k === fontName && !goog.array.contains(gviz.common.WebFontLoader.FONT_FAMILIES, v);
  };
};
gviz.common.WebFontLoader.prototype.loadFonts_ = function(resolver) {
  var webFont = goog.getObjectByName("WebFont");
  0 !== this.fonts_.length && webFont ? webFont.load({google:{families:this.fonts_}, active:function() {
    resolver.resolve();
  }, fontinactive:function() {
    resolver.reject("One or more fonts could not be loaded");
  }}) : resolver.resolve(null);
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/corechart/corechart.js)
google.visualization.CoreChart = function(container) {
  google.visualization.AbstractVisualization.call(this, container);
  this.logger_ = goog.log.getLogger("google.visualization.CoreChart");
  this.chartType_ = null;
  this.orientation_ = gviz.canviz.Options.Orientation.HORIZONTAL;
  this.interactivityDefiner_ = this.builder_ = this.options_ = this.chartDefinition_ = this.theme_ = null;
  this.actionsQueue_ = [];
  this.animation_ = this.drawingFrame_ = this.drawnChartState_ = this.chartState_ = null;
  this.interactionEventTarget_ = new goog.events.EventTarget;
  this.eventHandler_ = null;
  this.chartEventDispatcher_ = new gviz.canviz.ChartEventDispatcher(this);
  this.chartEventHandler_ = null;
};
goog.inherits(google.visualization.CoreChart, google.visualization.AbstractVisualization);
google.visualization.CoreChart.prototype.disposeInternal = function() {
  this.clearInternal();
  goog.dispose(this.interactionEventTarget_);
  google.visualization.CoreChart.superClass_.disposeInternal.call(this);
};
google.visualization.CoreChart.prototype.selection_ = null;
google.visualization.CoreChart.prototype.constructChartDefiner = function(dataTable, options, textMeasureFunction, width, height) {
  return this.chartType_ === gviz.canviz.Options.ChartType.HISTOGRAM ? new gviz.canviz.HistogramChartDefiner(dataTable, options, textMeasureFunction, width, height) : new gviz.canviz.AxisChartDefiner(dataTable, options, textMeasureFunction, width, height);
};
google.visualization.CoreChart.prototype.constructInteractivityDefiner = function(options, chartDimensions, chartTextStyle, interactivityModel, focusTarget, numberOfSeries, opt_actionsMenuDefiner) {
  return new gviz.canviz.AxisChartInteractivityDefiner(options, chartDimensions, chartTextStyle, interactivityModel, focusTarget, numberOfSeries, opt_actionsMenuDefiner);
};
google.visualization.CoreChart.prototype.constructEventHandler = function(interactionEventTarget, renderer, overlayArea, opt_chartDef) {
  goog.asserts.assert(void 0 !== opt_chartDef, "ChartDefinition cannot be undefined");
  return new gviz.canviz.AxisChartEventHandler(interactionEventTarget, renderer, overlayArea, opt_chartDef);
};
google.visualization.CoreChart.prototype.constructBuilder = function(overlayArea, renderer) {
  return new gviz.canviz.AxisChartBuilder(overlayArea, renderer);
};
google.visualization.CoreChart.prototype.setChartType = function(chartType, opt_defaultSerieType, opt_orientation, opt_theme) {
  this.chartType_ = chartType;
  goog.isDefAndNotNull(opt_defaultSerieType) && (this.defaultSerieType_ = opt_defaultSerieType);
  goog.isDefAndNotNull(opt_orientation) && (this.orientation_ = opt_orientation);
  goog.isDefAndNotNull(opt_theme) && (this.theme_ = opt_theme);
};
google.visualization.CoreChart.validateOptions_ = function(options) {
  if (options.isStacked && options.vAxis && options.vAxis.baseline) {
    throw Error("Cannot set a non-zero base-line for a stacked chart");
  }
};
google.visualization.CoreChart.prototype.drawInternal = function(asyncWrapper, dataTable, opt_options, opt_state) {
  //gviz.util.VisCommon.addCssToDom("/core/tooltip.css");
  var options = opt_options || {};//, options = gviz.json.deserialize(gviz.json.serialize(options));
  this.updateChartType_(options);
  this.updateDefaultSerieType_(options);
  options.orientation = options.orientation || this.orientation_;
  options.theme = options.theme || this.theme_;
  this.chartType_ != gviz.canviz.Options.ChartType.NONE && google.visualization.CoreChart.convertBrowserchartOptions_(options);
  if (this.chartType_ != gviz.canviz.Options.ChartType.PIE && gviz.Options.convertToBoolean(options.reverseCategories)) {
    var axisOption = options.orientation === gviz.canviz.Options.Orientation.VERTICAL ? "vAxis" : "hAxis";
    options[axisOption] = options[axisOption] || {};
    options[axisOption].direction = -1;
    delete options.reverseCategories;
  }
  google.visualization.CoreChart.convertDeprecatedOptions_(options);
  google.visualization.errors.removeAll(this.container);
  if (!dataTable) {
    throw Error("Data table is not defined");
  }
  var isDiffData = goog.array.some(goog.array.range(dataTable.getNumberOfColumns()), function(i) {
    return dataTable.getColumnRole(i) == gviz.canviz.ColumnRole.DIFF_OLD_DATA;
  });
  isDiffData && (options.isDiff = !0);
  var firstColIsLabels = "number" != dataTable.getColumnType(0);
  this.firstValueCol_ = firstColIsLabels ? 1 : 0;
  this.numberOfRows_ = dataTable.getNumberOfRows();
  this.clearInteractionEvents_();
  google.visualization.CoreChart.validateOptions_(options);
  var themes = options.theme || [];
  goog.isArray(themes) || (themes = [themes]);
  for (var optionsLayers = [options], i$$0 = 0;i$$0 < themes.length;++i$$0) {
    var theme;
    if (goog.isString(themes[i$$0])) {
      theme = gviz.canviz.Theme.getTheme(themes[i$$0]);
    } else {
      if (goog.isObject(themes[i$$0])) {
        theme = themes[i$$0];
      } else {
        throw Error("Theme should be a theme name or an options object.");
      }
    }
    optionsLayers.push(theme);
  }
  var chartType = options.type.toLowerCase();
  gviz.canviz.Options.CHART_SPECIFIC_DEFAULTS[chartType] && optionsLayers.push(gviz.canviz.Options.CHART_SPECIFIC_DEFAULTS[chartType]);
  optionsLayers.push(gviz.canviz.Options.DEFAULTS);
  var fontPredicate = gviz.common.WebFontLoader.fontPredicate("fontName"), fonts = [];
  goog.array.forEach(optionsLayers, function(obj) {
    fonts.push.apply(fonts, gviz.object.findValuesRecursive(obj, fontPredicate));
  });
  this.options_ = new gviz.Options(optionsLayers);
  this.chartType_ = this.options_.inferEnumValue("type", gviz.canviz.Options.ChartType, gviz.canviz.Options.ChartType.NONE);
  this.width_ = gviz.util.VisCommon.getWidth(this.container, this.options_);
  this.height_ = gviz.util.VisCommon.getHeight(this.container, this.options_);
  var dimensions = new goog.math.Size(this.width_, this.height_), forceIFrame = this.options_.inferBooleanValue("forceIFrame");
  if (!this.drawingFrame_ || this.drawingFrame_.isDisposed()) {
    try {
      this.drawingFrame_ = new gviz.graphics.DrawingFrame(this.container, dimensions, asyncWrapper, forceIFrame);
    } catch (e) {
      throw Error(gviz.canviz.Messages.MSG_NOT_SUPPORTED);
    }
  } else {
    this.drawingFrame_.update(dimensions, asyncWrapper);
  }
  this.chartState_ = new gviz.canviz.ChartState(opt_state);
  this.dataTable_ = dataTable;
  fonts.length && this.fontWaitResolver ? (this.fontWaitResolver.promise.then(function() {
    this.drawingFrame_.waitUntilReady(goog.bind(this.completeTheDraw_, this), asyncWrapper);
  }, null, this), this.fontWaitResolver.reject = goog.bind(function(message) {
    goog.log.warning(this.logger_, message);
    goog.log.warning(this.logger_, "Going to use fallback fonts.");
    this.drawingFrame_.waitUntilReady(goog.bind(this.completeTheDraw_, this), asyncWrapper);
  }, this), new gviz.common.WebFontLoader(fonts, this.fontWaitResolver)) : this.drawingFrame_.waitUntilReady(goog.bind(this.completeTheDraw_, this), asyncWrapper);
};
google.visualization.CoreChart.prototype.completeTheDraw_ = function() {
  var renderer = this.drawingFrame_.getRenderer();
  goog.asserts.assert(renderer);
  var overlayArea = this.drawingFrame_.getOverlayArea();
  goog.asserts.assert(overlayArea);
  var oldChartDef;
  this.animation_ ? (oldChartDef = this.animation_.prevFrameChartDef, this.stopAnimation_()) : oldChartDef = this.chartDefinition_;
  var options = this.options_, newChartDef = this.constructChartDefiner(this.dataTable_, options, goog.bind(renderer.getTextSize, renderer), this.width_, this.height_).getChartDefinition(), aiPublisher = new gviz.ai.Publisher(options, this.chartState_, goog.bind(this.getChartLayoutInterface, this), newChartDef);
  goog.dispose(this.eventHandler_);
  this.eventHandler_ = new gviz.canviz.EventHandler(newChartDef, this.chartState_, this.interactionEventTarget_, this.chartEventDispatcher_, goog.bind(this.refresh_, this, !0), aiPublisher);
  var chartDimensions = new goog.math.Size(this.width_, this.height_), chartTextStyle = {fontName:newChartDef.defaultFontName, fontSize:newChartDef.defaultFontSize}, interactivityModel = newChartDef.interactivityModel, focusTarget = newChartDef.focusTarget, numberOfSeries = newChartDef.series.length, oldActionsMenuDefiner = this.interactivityDefiner_ ? this.interactivityDefiner_.getActionsMenuDefiner() : void 0;
  this.interactivityDefiner_ = this.constructInteractivityDefiner(options, chartDimensions, chartTextStyle, interactivityModel, focusTarget, numberOfSeries, oldActionsMenuDefiner);
  goog.array.forEach(this.actionsQueue_, goog.bind(function(action) {
    goog.isString(action) ? this.removeAction(action) : this.setAction(action);
  }, this));
  this.actionsQueue_ = [];
  this.builder_ = this.constructBuilder(overlayArea, renderer);
  var chartDefsFitAnimation = function() {
    return oldChartDef.chartType == newChartDef.chartType;
  }, animationProps = gviz.animation.getProperties(options, 0, 30, gviz.animation.EasingType.LINEAR);
  if (animationProps && oldChartDef && chartDefsFitAnimation()) {
    this.chartDefinition_ = null;
    var now = goog.now();
    this.stopAnimation_();
    this.animation_ = {oldChartDef:oldChartDef, newChartDef:newChartDef, interpolator:new gviz.canviz.ChartDefinitionInterpolator(oldChartDef, newChartDef), prevFrameChartDef:oldChartDef, startTime:now, endTime:now + animationProps.duration, prevFrameTime:0, timer:new goog.Timer(10), easingFunction:animationProps.easing, maxFramesPerSecond:animationProps.maxFramesPerSecond, done:!1};
    this.handleAnimation_();
    goog.events.listen(this.animation_.timer, goog.Timer.TICK, goog.bind(this.handleAnimation_, this));
    this.animation_.timer.start();
    this.chartDefinition_ = newChartDef;
  } else {
    this.chartDefinition_ = newChartDef, this.drawStateInducedChartDefinition_(), this.listenToChartEvents_();
  }
  if (renderer.createAccessibilityContainer) {
    var aContainer = renderer.createAccessibilityContainer();
    aContainer && this.dataTable_ && (aContainer.innerHTML = gviz.a11y.createHtmlTableRep(this.dataTable_));
  }
  this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.READY);
  this.eventHandler_.handleReady();
};
google.visualization.CoreChart.prototype.computeDiffInternal = function(oldDataTable, newDataTable) {
  goog.asserts.assert(oldDataTable.getColumnType(0) == newDataTable.getColumnType(0));
  goog.asserts.assert(oldDataTable.getNumberOfRows() == newDataTable.getNumberOfRows());
  goog.asserts.assert(oldDataTable.getNumberOfColumns() == newDataTable.getNumberOfColumns());
  var oldData = oldDataTable, newData = newDataTable, diffDataTable = new google.visualization.DataTable, rowsCount = newData.getNumberOfRows(), colsCount = newData.getNumberOfColumns(), firstColIsLabels = "number" != oldData.getColumnType(0);
  firstColIsLabels && diffDataTable.addColumn(oldData.getColumnType(0), oldData.getColumnLabel(0));
  for (var firstValueCol = firstColIsLabels ? 1 : 0, colIndex = firstValueCol;colIndex < colsCount;++colIndex) {
    diffDataTable.addColumn({type:oldData.getColumnType(colIndex), label:oldData.getColumnLabel(colIndex), role:gviz.canviz.ColumnRole.DIFF_OLD_DATA}), diffDataTable.addColumn({type:newData.getColumnType(colIndex), label:newData.getColumnLabel(colIndex), role:gviz.canviz.ColumnRole.DATA});
  }
  diffDataTable.addRows(rowsCount);
  for (var rowIndex = 0;rowIndex < rowsCount;++rowIndex) {
    var label = null;
    firstColIsLabels && (label = newData.getValue(rowIndex, 0), diffDataTable.setCell(rowIndex, 0, label));
    for (var rowLength = firstValueCol, colIndex = firstValueCol;colIndex < colsCount;++colIndex) {
      var oldValue = oldData.getValue(rowIndex, colIndex);
      diffDataTable.setCell(rowIndex, rowLength, oldValue);
      var rowLength = rowLength + 1, newValue = newData.getValue(rowIndex, colIndex);
      diffDataTable.setCell(rowIndex, rowLength, newValue);
      rowLength += 1;
    }
  }
  return diffDataTable;
};
google.visualization.CoreChart.OldChartType = {LINE:"line", AREA:"area", COLUMNS:"columns", BARS:"bars", SCATTER:"scatter", PIE:"pie"};
google.visualization.CoreChart.prototype.updateChartType_ = function(options) {
  switch(options.type) {
    case google.visualization.CoreChart.OldChartType.LINE:
      this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.LINE, gviz.canviz.Options.Orientation.HORIZONTAL);
      options.type = null;
      break;
    case google.visualization.CoreChart.OldChartType.AREA:
      this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.AREA, gviz.canviz.Options.Orientation.HORIZONTAL);
      options.type = null;
      break;
    case google.visualization.CoreChart.OldChartType.COLUMNS:
      this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.BARS, gviz.canviz.Options.Orientation.HORIZONTAL);
      options.type = null;
      break;
    case google.visualization.CoreChart.OldChartType.BARS:
      this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.BARS, gviz.canviz.Options.Orientation.VERTICAL);
      options.type = null;
      break;
    case google.visualization.CoreChart.OldChartType.SCATTER:
      this.setChartType(gviz.canviz.Options.ChartType.SCATTER);
      options.type = null;
      break;
    case google.visualization.CoreChart.OldChartType.PIE:
      this.setChartType(gviz.canviz.Options.ChartType.PIE), options.type = null;
  }
  var chartTypeFromClass = this.chartType_;
  chartTypeFromClass == gviz.canviz.Options.ChartType.NONE && (chartTypeFromClass = null);
  var chartTypeFromOptions = options.type || gviz.canviz.Options.ChartType.NONE;
  chartTypeFromOptions == gviz.canviz.Options.ChartType.NONE && (chartTypeFromOptions = null);
  if (!chartTypeFromClass && !chartTypeFromOptions) {
    throw Error("Unspecified chart type.");
  }
  if (chartTypeFromClass && chartTypeFromOptions && chartTypeFromClass != chartTypeFromOptions) {
    throw Error("Incompatible chart types.");
  }
  options.type = chartTypeFromClass || chartTypeFromOptions;
};
google.visualization.CoreChart.prototype.updateDefaultSerieType_ = function(options) {
  if (options.type == gviz.canviz.Options.ChartType.FUNCTION) {
    var defaultSerieTypeFromClass = this.defaultSerieType_;
    defaultSerieTypeFromClass == gviz.canviz.Options.SerieType.NONE && (defaultSerieTypeFromClass = null);
    var defaultSerieTypeFromOptions = options.seriesType || gviz.canviz.Options.SerieType.NONE;
    defaultSerieTypeFromOptions == gviz.canviz.Options.SerieType.NONE && (defaultSerieTypeFromOptions = null);
    if (defaultSerieTypeFromClass && defaultSerieTypeFromOptions && defaultSerieTypeFromClass != defaultSerieTypeFromOptions) {
      throw Error("Incompatible default series types.");
    }
    options.seriesType = defaultSerieTypeFromClass || defaultSerieTypeFromOptions;
  }
};
google.visualization.CoreChart.convertBrowserchartOptions_ = function(options) {
  options.hAxis = options.hAxis || {};
  options.vAxis = options.vAxis || {};
  var hAxis = options.hAxis, vAxis = options.vAxis, targetAxis = null;
  switch(options.type) {
    case gviz.canviz.Options.ChartType.SCATTER:
      targetAxis = vAxis;
      break;
    case gviz.canviz.Options.ChartType.FUNCTION:
      options.targetAxis = options.targetAxis || {}, targetAxis = options.targetAxis;
  }
  targetAxis && (google.visualization.CoreChart.convertOption_(options, "min", targetAxis, "minValue"), google.visualization.CoreChart.convertOption_(options, "max", targetAxis, "maxValue"), google.visualization.CoreChart.convertOption_(options, "logScale", targetAxis, "logScale"));
  hAxis && (google.visualization.CoreChart.convertOption_(options, "logScaleX", hAxis, "logScale"), google.visualization.CoreChart.convertOption_(options, "titleX", hAxis, "title"));
  vAxis && google.visualization.CoreChart.convertOption_(options, "titleY", vAxis, "title");
  options.smoothLine && !goog.isDef(options.curveType) && (options.curveType = "function");
  google.visualization.CoreChart.convertOption_(options, "lineSize", options, "lineWidth");
  google.visualization.CoreChart.convertOption_(options, "reverseAxis", options, "reverseCategories");
  options.chartArea = options.chartArea || {};
  var chartArea = options.chartArea;
  google.visualization.CoreChart.convertOption_(options, "axisBackgroundColor", chartArea, "backgroundColor");
};
google.visualization.CoreChart.convertDeprecatedOptions_ = function(options) {
  google.visualization.CoreChart.convertTextStyleOptions_(options, "titleColor", "titleFontSize", "titleTextStyle");
  google.visualization.CoreChart.convertTextStyleOptions_(options, "legendTextColor", "legendFontSize", "legendTextStyle");
  google.visualization.CoreChart.convertDeprecatedAxisOptions_(options.hAxis);
  for (var i in options.hAxes) {
    google.visualization.CoreChart.convertDeprecatedAxisOptions_(options.hAxes[i]);
  }
  google.visualization.CoreChart.convertDeprecatedAxisOptions_(options.vAxis);
  for (i in options.vAxes) {
    google.visualization.CoreChart.convertDeprecatedAxisOptions_(options.vAxes[i]);
  }
  google.visualization.CoreChart.convertDeprecatedTooltipOptions_(options);
  google.visualization.CoreChart.convertDeprecatedLegendOptions_(options);
  google.visualization.CoreChart.convertDeprecatedAnimationOptions_(options);
};
google.visualization.CoreChart.convertDeprecatedAxisOptions_ = function(axisOptions) {
  goog.isDefAndNotNull(axisOptions) && (google.visualization.CoreChart.convertTextStyleOptions_(axisOptions, "textColor", "textFontSize", "textStyle"), google.visualization.CoreChart.convertTextStyleOptions_(axisOptions, "titleColor", "titleFontSize", "titleTextStyle"), google.visualization.CoreChart.convertDeprecatedGridlineOptions_(axisOptions));
};
google.visualization.CoreChart.convertDeprecatedTooltipOptions_ = function(options) {
  var tooltipOptions = options.tooltip;
  goog.isDefAndNotNull(tooltipOptions) || (tooltipOptions = {}, options.tooltip = tooltipOptions);
  google.visualization.CoreChart.convertTextStyleOptions_(options, "tooltipTextColor", "tooltipFontSize", "tooltipTextStyle");
  google.visualization.CoreChart.convertOption_(options, "tooltipTextStyle", tooltipOptions, "textStyle");
  google.visualization.CoreChart.convertOption_(options, "tooltipText", tooltipOptions, "text");
  google.visualization.CoreChart.convertOption_(options, "tooltipTrigger", tooltipOptions, "trigger");
  "hover" == tooltipOptions.trigger && (tooltipOptions.trigger = "focus");
};
google.visualization.CoreChart.convertDeprecatedLegendOptions_ = function(options) {
  var legendOptions = options.legend;
  if (!goog.isDefAndNotNull(legendOptions)) {
    legendOptions = {}, options.legend = legendOptions;
  } else {
    if ("string" == typeof legendOptions) {
      var position = legendOptions, legendOptions = {};
      options.legend = legendOptions;
      legendOptions.position = position;
    }
  }
  google.visualization.CoreChart.convertOption_(options, "legendTextStyle", legendOptions, "textStyle");
};
google.visualization.CoreChart.convertDeprecatedAnimationOptions_ = function(options) {
  var animationOptions = options.animation;
  if (!goog.isDefAndNotNull(animationOptions)) {
    animationOptions = {}, options.animation = animationOptions;
  } else {
    if ("number" == typeof animationOptions) {
      var duration = 1E3 * animationOptions, animationOptions = {};
      options.animation = animationOptions;
      animationOptions.duration = duration;
    }
  }
  google.visualization.CoreChart.convertOption_(options, "animationEasing", animationOptions, "easing");
};
google.visualization.CoreChart.convertDeprecatedGridlineOptions_ = function(axisOptions) {
  axisOptions.gridlines = axisOptions.gridlines || {};
  var gridlineOptions = axisOptions.gridlines, numberOfSections = axisOptions.numberOfSections;
  !goog.isDef(gridlineOptions.count) && goog.isDef(numberOfSections) && "number" == typeof numberOfSections && (gridlineOptions.count = numberOfSections + 1);
  var gridlineColor = axisOptions.gridlineColor;
  !goog.isDef(gridlineOptions.color) && goog.isDef(gridlineColor) && (gridlineOptions.color = gridlineColor);
};
google.visualization.CoreChart.convertTextStyleOptions_ = function(options, oldColorOption, oldFontSizeOption, newTextStyleOption) {
  options[newTextStyleOption] = options[newTextStyleOption] || {};
  var textStyle = options[newTextStyleOption];
  google.visualization.CoreChart.convertOption_(options, oldColorOption, textStyle, "color");
  google.visualization.CoreChart.convertOption_(options, oldFontSizeOption, textStyle, "fontSize");
};
google.visualization.CoreChart.convertOption_ = function(options, oldOption, targetOptions, newOption) {
  goog.isDef(options[oldOption]) && !goog.isDef(targetOptions[newOption]) && (targetOptions[newOption] = options[oldOption]);
};
google.visualization.CoreChart.prototype.clearInternal = function() {
  this.stopAnimation_();
  this.clearInteractionEvents_();
  goog.dispose(this.drawingFrame_);
  goog.events.removeAll(this);
};
google.visualization.CoreChart.prototype.clearInteractionEvents_ = function() {
  this.eventHandler_ && !this.eventHandler_.isDisposed() && this.eventHandler_.cancelPendingEvents();
  goog.dispose(this.eventHandler_);
  goog.dispose(this.chartEventHandler_);
  goog.events.removeAll(this.interactionEventTarget_);
};
google.visualization.CoreChart.prototype.setAction = function(action) {
  goog.isDefAndNotNull(this.interactivityDefiner_) ? this.interactivityDefiner_.setAction(action) : this.actionsQueue_.push(action);
};
google.visualization.CoreChart.prototype.validateSelection_ = function(selected) {
  var selection = new gviz.util.Selection;
  selection.setSelection(selected);
  for (var selectedCells = selection.getCells(), foundSelectedAnnotation = !1, i = 0;i < selectedCells.length;i++) {
    var selectedCell = selectedCells[i], columnIndex = selectedCell.column, rowIndex = selectedCell.row, columnInfo = this.chartDefinition_.dataTableColumnRoleInfo && this.chartDefinition_.dataTableColumnRoleInfo[columnIndex];
    if (!columnInfo) {
      return!1;
    }
    var serieIndex = columnInfo.serieIndex, datum, category;
    if (goog.isDefAndNotNull(serieIndex)) {
      var serie = this.chartDefinition_.series[serieIndex];
      datum = serie.points[rowIndex];
    } else {
      category = this.chartDefinition_.categories[rowIndex];
    }
    if (!datum && !category) {
      return!1;
    }
    if (columnInfo.role == gviz.canviz.ColumnRole.ANNOTATION) {
      if (foundSelectedAnnotation) {
        return!1;
      }
      var foundSelectedAnnotation = !0, annotation = (datum || category).annotation;
      if (!annotation) {
        return!1;
      }
    }
  }
  return!0;
};
google.visualization.CoreChart.prototype.setSelection = function(selected) {
  if (this.validateSelection_(selected)) {
    var selectedAnnotation = null;
    if (this.chartDefinition_.chartType != gviz.canviz.Options.ChartType.PIE) {
      var selection = new gviz.util.Selection;
      selection.setSelection(selected);
      for (var selectedCells = selection.getCells(), i = 0;i < selectedCells.length;i++) {
        var selectedCell = selectedCells[i], selectedColumn = selectedCell.column, selectedColumnInfo = this.chartDefinition_.dataTableColumnRoleInfo[selectedColumn];
        if (selectedColumnInfo.role == gviz.canviz.ColumnRole.ANNOTATION) {
          var serieIndex = selectedColumnInfo.serieIndex, selectedRow = selectedCell.row, selectedAnnotation = {serieIndex:serieIndex, datumOrCategoryIndex:selectedRow};
          break;
        }
      }
    }
    this.refresh_(!0);
    this.chartState_.selected.setSelection(selected);
    selectedAnnotation && (this.chartState_.annotations.expanded = selectedAnnotation);
    this.refresh_(!1);
  }
};
google.visualization.CoreChart.prototype.refresh_ = function(dispatchEvents) {
  goog.asserts.assert(this.chartDefinition_);
  goog.asserts.assert(this.chartState_);
  goog.asserts.assert(this.drawnChartState_);
  var previousChartState = this.drawnChartState_;
  if (!this.interactivityDefiner_.equalChartStates(this.chartState_, this.drawnChartState_)) {
    var nextFrameOptions = this.chartState_.nextFrameOptions, interactivityLayer;
    if (nextFrameOptions) {
      this.options_.mergeLayer(nextFrameOptions);
      var renderer = this.drawingFrame_.getRenderer(), newChartDef = this.constructChartDefiner(this.dataTable_, this.options_, goog.bind(renderer.getTextSize, renderer), this.width_, this.height_).getChartDefinition();
      this.eventHandler_.setChartDefinition(newChartDef);
      this.chartEventHandler_.updateChartDefinition && this.chartEventHandler_.updateChartDefinition(newChartDef);
      interactivityLayer = this.interactivityDefiner_.generateInteractivityLayer(newChartDef, this.chartState_);
      this.chartDefinition_ = newChartDef;
      this.builder_.revertChartContentChanges(this.chartDefinition_);
      this.builder_.redrawChart(this.chartDefinition_, interactivityLayer);
      this.chartState_.nextFrameOptions = null;
    } else {
      interactivityLayer = this.interactivityDefiner_.generateInteractivityLayer(this.chartDefinition_, this.chartState_), this.builder_.refreshChart(this.chartDefinition_, interactivityLayer);
    }
    this.drawnChartState_ = this.chartState_.clone();
  }
  dispatchEvents && this.chartEventDispatcher_.dispatchByStateChange(previousChartState, this.drawnChartState_, this.chartDefinition_.chartType, this.chartDefinition_.series);
};
google.visualization.CoreChart.prototype.getSelection = function() {
  return this.drawnChartState_ ? this.drawnChartState_.selected.getSelection() : [];
};
google.visualization.CoreChart.prototype.getAction = function(action) {
  return this.interactivityDefiner_ ? this.interactivityDefiner_.getAction(action) : void 0;
};
google.visualization.CoreChart.prototype.removeAction = function(action) {
  null != this.interactivityDefiner_ ? this.interactivityDefiner_.removeAction(action) : this.actionsQueue_.push(action);
};
google.visualization.CoreChart.prototype.dump = function() {
  var renderer = this.drawingFrame_.getRenderer();
  return renderer.getInternalSvg ? renderer.getInternalSvg() : "";
};
google.visualization.CoreChart.prototype.drawStateInducedChartDefinition_ = function() {
  goog.asserts.assert(this.chartDefinition_);
  goog.asserts.assert(this.chartState_);
  var interactivityLayer = this.interactivityDefiner_.generateInteractivityLayer(this.chartDefinition_, this.chartState_);
  this.builder_.drawChart(this.chartDefinition_, interactivityLayer);
  this.drawnChartState_ = this.chartState_.clone();
};
google.visualization.CoreChart.prototype.listenToChartEvents_ = function() {
  var renderer = this.drawingFrame_.getRenderer();
  goog.asserts.assert(renderer);
  var overlayArea = this.drawingFrame_.getOverlayArea();
  goog.asserts.assert(overlayArea);
  goog.dispose(this.chartEventHandler_);
  this.chartEventHandler_ = this.constructEventHandler(this.interactionEventTarget_, renderer, overlayArea, this.chartDefinition_);
  this.chartEventHandler_.listenToAllRendererEvents();
  this.chartEventHandler_.listenToAllOverlayAreaEvents();
  this.chartEventHandler_.listenToAllPageEvents();
};
google.visualization.CoreChart.prototype.handleAnimation_ = function() {
  var animation = this.animation_;
  this.chartDefinition_ = null;
  if (animation.done) {
    this.stopAnimation_(), this.chartDefinition_ = animation.newChartDef, this.drawStateInducedChartDefinition_(), this.listenToChartEvents_(), this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.ANIMATION_FINISH);
  } else {
    var now = goog.now(), nowInterval = now - animation.startTime, totalInterval = animation.endTime - animation.startTime, progress = nowInterval / totalInterval;
    if (1 > progress) {
      var maxFramesPerSec = this.animation_.maxFramesPerSecond;
      if (now - animation.prevFrameTime < 1E3 / maxFramesPerSec) {
        return;
      }
    } else {
      progress = 1, animation.done = !0;
    }
    var interpolatedChartDef = animation.interpolator.interpolate(animation.easingFunction(progress));
    animation.prevFrameChartDef = interpolatedChartDef;
    animation.prevFrameTime = now;
    this.builder_.drawChart(interpolatedChartDef, {});
    this.chartEventDispatcher_.dispatchEvent(gviz.ChartEventType.ANIMATION_FRAME_FINISH);
  }
  this.chartDefinition_ = animation.newChartDef;
};
google.visualization.CoreChart.prototype.stopAnimation_ = function() {
  this.animation_ && (goog.dispose(this.animation_.timer), this.animation_ = null);
};
google.visualization.CoreChart.prototype.getChartAreaBoundingBox = function() {
  var chartArea = this.chartDefinition_.chartArea;
  return{left:chartArea.left, top:chartArea.top, width:chartArea.width, height:chartArea.height};
};
google.visualization.CoreChart.prototype.getBoundingBox = function(elementId) {
  if (!goog.isDefAndNotNull(this.builder_)) {
    return null;
  }
  var box = this.builder_.getBoundingBox(elementId);
  return box ? {left:box.left, top:box.top, width:box.right - box.left, height:box.bottom - box.top} : null;
};
google.visualization.CoreChart.prototype.getChartLayoutInterface = function() {
  var chartDef = this.chartDefinition_;
  return{getChartAreaBoundingBox:goog.bind(this.getChartAreaBoundingBox, this), getBoundingBox:goog.bind(this.getBoundingBox, this), getXLocation:goog.bind(gviz.canviz.chartdefinitionutil.getXLocation, null, chartDef), getYLocation:goog.bind(gviz.canviz.chartdefinitionutil.getYLocation, null, chartDef), getHAxisValue:goog.bind(gviz.canviz.chartdefinitionutil.getHAxisValue, null, chartDef), getVAxisValue:goog.bind(gviz.canviz.chartdefinitionutil.getVAxisValue, null, chartDef), getPointDatum:goog.bind(gviz.canviz.chartdefinitionutil.getPointDatum, 
  null, chartDef)};
};
google.visualization.CoreChart.prototype.getDrawingFrame = function() {
  return this.drawingFrame_;
};
google.visualization.CoreChart.prototype.getChartDefinition = function() {
  return this.chartDefinition_;
};
google.visualization.CoreChart.prototype.getImageURI = function() {
  goog.asserts.assert(this.chartDefinition_);
  goog.asserts.assert(this.chartState_);
  if (!this.options_) {
    throw Error("Chart not drawn.");
  }
  var dimensions = new goog.math.Size(this.width_, this.height_), div = goog.dom.getDomHelper(this.container).createElement("div"), textDiv = gviz.graphics.DrawingFrame.createTextMeasurementDiv(div, dimensions), renderer = new gviz.graphics.CanvasRenderer(div, textDiv), overlayArea = new gviz.graphics.OverlayArea(div), builder = this.constructBuilder(overlayArea, renderer), interactivityLayer = this.interactivityDefiner_.generateInteractivityLayer(this.chartDefinition_, this.chartState_);
  builder.drawChart(this.chartDefinition_, interactivityLayer);
  var imageUrl = div.childNodes[0].toDataURL("image/png");
  return imageUrl;
};
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/corechart/corecharts.js)
google.visualization.AreaChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.AREA, gviz.canviz.Options.Orientation.HORIZONTAL);
};
goog.inherits(google.visualization.AreaChart, google.visualization.CoreChart);
google.visualization.SteppedAreaChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.STEPPED_AREA, gviz.canviz.Options.Orientation.HORIZONTAL);
};
goog.inherits(google.visualization.SteppedAreaChart, google.visualization.CoreChart);
google.visualization.SparklineChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.NONE, gviz.canviz.Options.Orientation.HORIZONTAL, "sparkline");
};
goog.inherits(google.visualization.SparklineChart, google.visualization.CoreChart);
google.visualization.LineChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.LINE, gviz.canviz.Options.Orientation.HORIZONTAL);
};
goog.inherits(google.visualization.LineChart, google.visualization.CoreChart);
google.visualization.ScatterChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.SCATTER);
};
goog.inherits(google.visualization.ScatterChart, google.visualization.CoreChart);
google.visualization.ScatterChart.prototype.computeDiff = function(oldDataTable, newDataTable) {
  return this.computeDiffInternal(oldDataTable, newDataTable);
};
goog.exportSymbol("google.visualization.ScatterChart.prototype.computeDiff", google.visualization.ScatterChart.prototype.computeDiff);
google.visualization.BubbleChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.BUBBLE);
};
goog.inherits(google.visualization.BubbleChart, google.visualization.CoreChart);
google.visualization.BarChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.BARS, gviz.canviz.Options.Orientation.VERTICAL);
};
goog.inherits(google.visualization.BarChart, google.visualization.CoreChart);
google.visualization.BarChart.prototype.computeDiff = function(oldDataTable, newDataTable) {
  return this.computeDiffInternal(oldDataTable, newDataTable);
};
goog.exportSymbol("google.visualization.BarChart.prototype.computeDiff", google.visualization.BarChart.prototype.computeDiff);
google.visualization.CandlestickChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.CANDLESTICKS, gviz.canviz.Options.Orientation.HORIZONTAL);
};
goog.inherits(google.visualization.CandlestickChart, google.visualization.CoreChart);
google.visualization.ColumnChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.BARS, gviz.canviz.Options.Orientation.HORIZONTAL);
};
goog.inherits(google.visualization.ColumnChart, google.visualization.CoreChart);
google.visualization.ColumnChart.prototype.computeDiff = function(oldDataTable, newDataTable) {
  return this.computeDiffInternal(oldDataTable, newDataTable);
};
goog.exportSymbol("google.visualization.ColumnChart.prototype.computeDiff", google.visualization.ColumnChart.prototype.computeDiff);
google.visualization.ComboChart = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.FUNCTION, gviz.canviz.Options.SerieType.NONE, gviz.canviz.Options.Orientation.HORIZONTAL);
};
goog.inherits(google.visualization.ComboChart, google.visualization.CoreChart);
google.visualization.Histogram = function(container) {
  google.visualization.CoreChart.call(this, container);
  this.setChartType(gviz.canviz.Options.ChartType.HISTOGRAM, gviz.canviz.Options.SerieType.BARS, gviz.canviz.Options.Orientation.HORIZONTAL);
};
goog.inherits(google.visualization.Histogram, google.visualization.CoreChart);
// INPUT (javascript/gviz/devel/jsapi/packages/visualization/corechart/rangeselector.js)
google.visualization.RangeSelector = function(container) {
  goog.events.EventTarget.call(this);
  this.idToElementMapping_ = {};
  this.chart_ = null;
  this.chartDrawContext_ = {alive:!1};
  this.eventFiringScheduler_ = this.refreshScheduler_ = this.eventHandler_ = this.renderer_ = this.axisDefinition_ = this.chartDefinition_ = this.valueNumberConverter_ = this.dataTable_ = null;
  this.container_ = container;
  this.rangeChangeEventFiringRate_ = google.visualization.RangeSelector.DEFAULT_RANGE_CHANGE_EVENT_FIRING_RATE_;
  this.minRangeSizeValue_ = google.visualization.RangeSelector.DEFAULT_MIN_RANGE_SIZE_VALUE_;
  this.minRangeSizePixel_ = google.visualization.RangeSelector.DEFAULT_MIN_RANGE_SIZE_PIXEL_;
  this.zoomAroundSelection_ = google.visualization.RangeSelector.DEFAULT_ZOOM_AROUND_SELECTION_;
  this.snapToData_ = google.visualization.RangeSelector.DEFAULT_SNAP_TO_DATA_;
  this.centerSelectionAroundData_ = google.visualization.RangeSelector.DEFAULT_CENTER_SELECTION_AROUND_DATA_;
  this.maxDomainDataValue_ = this.minDomainDataValue_ = this.fullScreenBrush_ = this.sideScreenBrush_ = null;
  this.isVertical_ = !1;
  this.chartOptions_ = null;
  this.state_ = {range:null, draggedPixel:null, inDrag:null};
  this.axisRange_ = {pixel:{min:0, max:0}, value:{min:0, max:0}};
  this.axisPixels_ = null;
  this.containerIsSelectorsAncestor_ = !1;
  this.autoPanningTimer_ = null;
};
goog.inherits(google.visualization.RangeSelector, goog.events.EventTarget);
google.visualization.RangeSelector.DragElement_ = {MIN:"min", MAX:"max", BOTH:"both"};
google.visualization.RangeSelector.ElementIds_ = {HANDLE_MIN:"rangeSelectorMinHandle", HANDLE_MAX:"rangeSelectorMaxHandle", SCREEN_MIN:"rangeSelectorMinScreen", SCREEN_MAX:"rangeSelectorMaxScreen"};
google.visualization.RangeSelector.ChartType = {LINE_CHART:"LineChart", AREA_CHART:"AreaChart", COMBO_CHART:"ComboChart", SCATTER_CHART:"ScatterChart"};
google.visualization.RangeSelector.DEFAULT_RANGE_CHANGE_EVENT_FIRING_RATE_ = 50;
google.visualization.RangeSelector.DEFAULT_MIN_RANGE_SIZE_VALUE_ = 0;
google.visualization.RangeSelector.DEFAULT_MIN_RANGE_SIZE_PIXEL_ = 1;
google.visualization.RangeSelector.DEFAULT_FIXED_RANGE_SIZE_ = !1;
google.visualization.RangeSelector.DEFAULT_ZOOM_AROUND_SELECTION_ = !1;
google.visualization.RangeSelector.DEFAULT_SNAP_TO_DATA_ = !1;
google.visualization.RangeSelector.DEFAULT_CENTER_SELECTION_AROUND_DATA_ = !1;
google.visualization.RangeSelector.DEFAULT_SIDE_SCREEN_COLOR_ = {fill:"#ccc", fillOpacity:.5};
google.visualization.RangeSelector.DefaultChartOptions_ = {HORIZONTAL:{chartArea:{top:"0", height:"100%"}, enableInteractivity:!1, legend:{position:"none"}, hAxis:{textPosition:"in"}, vAxis:{textPosition:"none", gridlines:{color:"none"}}}, VERTICAL:{chartArea:{left:"0", width:"100%"}, enableInteractivity:!1, legend:{position:"none"}, vAxis:{textPosition:"in"}, hAxis:{textPosition:"none", gridlines:{color:"none"}}}};
google.visualization.RangeSelector.HandleDefinition_ = {brush:new gviz.graphics.Brush({stroke:"#000", fill:"#fff"}), thumbSize:new goog.math.Size(10, 16), thumbCornerOffset:3};
google.visualization.RangeSelector.prototype.draw = function(dataTable, userOptions, opt_state) {
  this.clearChart();
  this.dataTable_ = dataTable;
  this.valueNumberConverter_ = gviz.canviz.valuenumberconverter.getByType(dataTable.getColumnType(0));
  this.idToElementMapping_ = {};
  this.createSchedulers_();
  var options = new gviz.Options([userOptions || {}]);
  this.parseOptions_(options);
  this.chartOptions_ = this.getChartOptions_(options);
  var state = opt_state || {};
  google.visualization.events.addListener(this.chart_, gviz.ChartEventType.READY, goog.bind(this.onChartReady_, this, state));
  this.zoomAroundSelection_ && this.initDomainViewWindow_(state);
  this.chart_.draw(dataTable, this.chartOptions_);
};
google.visualization.RangeSelector.prototype.initDomainViewWindow_ = function(state) {
  this.minDomainDataValue_ = this.dataTable_.getValue(0, 0);
  this.maxDomainDataValue_ = this.dataTable_.getValue(Math.max(0, this.dataTable_.getNumberOfRows() - 1), 0);
  var domainViewWindow = {min:this.minDomainDataValue_, max:this.maxDomainDataValue_};
  state.range && this.adjustZoomAroundSelection_(domainViewWindow, state.range);
  this.chartOptions_.domainAxis = this.chartOptions_.domainAxis || {};
  var domainAxis = this.chartOptions_.domainAxis;
  domainAxis.viewWindow = domainViewWindow;
};
google.visualization.RangeSelector.prototype.createSchedulers_ = function() {
  goog.isDefAndNotNull(this.refreshScheduler_) || (this.refreshScheduler_ = new gviz.canviz.Scheduler(goog.bind(this.updateUIAccordingToState_, this)));
  goog.isDefAndNotNull(this.eventFiringScheduler_) || (this.eventFiringScheduler_ = new gviz.canviz.Scheduler(goog.bind(this.triggerRangeChange_, this, !0)));
};
google.visualization.RangeSelector.prototype.parseOptions_ = function(options) {
  this.rangeChangeEventFiringRate_ = options.inferNonNegativeNumberValue("rangeChangeEventFiringRate", google.visualization.RangeSelector.DEFAULT_RANGE_CHANGE_EVENT_FIRING_RATE_);
  this.minRangeSizeValue_ = options.inferNonNegativeNumberValue("minRangeSize", google.visualization.RangeSelector.DEFAULT_MIN_RANGE_SIZE_VALUE_);
  this.fixedRangeSize_ = options.inferBooleanValue("fixedRangeSize", google.visualization.RangeSelector.DEFAULT_FIXED_RANGE_SIZE_);
  this.zoomAroundSelection_ = options.inferBooleanValue("zoomAroundSelection", google.visualization.RangeSelector.DEFAULT_ZOOM_AROUND_SELECTION_);
  this.snapToData_ = options.inferBooleanValue("snapToData", google.visualization.RangeSelector.DEFAULT_SNAP_TO_DATA_);
  this.centerSelectionAroundData_ = options.inferBooleanValue("centerSelectionAroundData", google.visualization.RangeSelector.DEFAULT_CENTER_SELECTION_AROUND_DATA_);
  this.sideScreenBrush_ = options.inferBrushValue("sideScreenColor", new gviz.graphics.Brush(google.visualization.RangeSelector.DEFAULT_SIDE_SCREEN_COLOR_));
  this.fullScreenBrush_ = gviz.graphics.Brush.TRANSPARENT_BRUSH.clone();
  this.clearChart();
  this.chart_ = this.getChartByType_(options);
  this.isVertical_ = this.isOrientationVertical_(options);
};
google.visualization.RangeSelector.prototype.isOrientationVertical_ = function(options) {
  var orientation = options.inferEnumValue("orientation", gviz.canviz.Options.Orientation, gviz.canviz.Options.Orientation.HORIZONTAL);
  return orientation == gviz.canviz.Options.Orientation.VERTICAL;
};
google.visualization.RangeSelector.prototype.getChartByType_ = function(options) {
  var chartType = options.inferEnumValue("chartType", google.visualization.RangeSelector.ChartType, google.visualization.RangeSelector.ChartType.COMBO_CHART), chart = null;
  switch(chartType) {
    case google.visualization.RangeSelector.ChartType.AREA_CHART:
      chart = new google.visualization.AreaChart(this.container_);
      break;
    case google.visualization.RangeSelector.ChartType.COMBO_CHART:
      chart = new google.visualization.ComboChart(this.container_);
      break;
    case google.visualization.RangeSelector.ChartType.SCATTER_CHART:
      chart = new google.visualization.ScatterChart(this.container_);
      break;
    case google.visualization.RangeSelector.ChartType.LINE_CHART:
      chart = new google.visualization.LineChart(this.container_);
      break;
    default:
      chart = new google.visualization.ComboChart(this.container_);
  }
  return chart;
};
google.visualization.RangeSelector.prototype.getChartOptions_ = function(options) {
  var chartOptions = gviz.object.unsafeClone(options.inferObjectValue("chartOptions"));
  chartOptions.theme = this.isVertical_ ? google.visualization.RangeSelector.DefaultChartOptions_.VERTICAL : google.visualization.RangeSelector.DefaultChartOptions_.HORIZONTAL;
  return chartOptions;
};
google.visualization.RangeSelector.prototype.dataValuesToPixels_ = function(dataTable, columnIndex, valueToPixelFn) {
  var columnValues = gviz.canviz.util.rangeMap(dataTable.getNumberOfRows(), function(rowIndex) {
    return dataTable.getValue(rowIndex, columnIndex);
  }), columnValues = goog.array.filter(columnValues, goog.isDefAndNotNull);
  return goog.array.map(columnValues, valueToPixelFn);
};
google.visualization.RangeSelector.prototype.getAxisPixels_ = function(dataTable) {
  var axisDefinition = this.axisDefinition_, pixels = this.dataValuesToPixels_(dataTable, 0, axisDefinition.position.fromValue);
  return this.isVertical_ ? 1 == axisDefinition.dataDirection ? pixels.reverse() : pixels : 1 == axisDefinition.dataDirection ? pixels : pixels.reverse();
};
google.visualization.RangeSelector.prototype.setMinRangePixel_ = function() {
  var minRangeValue = this.minRangeSizeValue_, defaultMinRangePixel = google.visualization.RangeSelector.DEFAULT_MIN_RANGE_SIZE_PIXEL_;
  if (0 >= minRangeValue) {
    this.minRangeSizePixel_ = defaultMinRangePixel;
  } else {
    var optionMinRangePixel = 0, pointPixel = this.axisRange_.pixel.min, pointValue = this.axisDefinition_.position.toValue(pointPixel), sumValue = null;
    goog.isDateLike(pointValue) ? (sumValue = new Date, sumValue.setTime(pointValue.getTime() + minRangeValue)) : sumValue = pointValue + minRangeValue;
    var optionMinRangePixel = Math.ceil(Math.abs(this.axisDefinition_.position.fromValue(sumValue) - pointPixel)), minRangePixel = Math.max(optionMinRangePixel, defaultMinRangePixel);
    this.minRangeSizePixel_ = minRangePixel < this.axisRange_.pixel.max - this.axisRange_.pixel.min ? minRangePixel : defaultMinRangePixel;
  }
};
google.visualization.RangeSelector.prototype.onChartReady_ = function(state) {
  google.visualization.events.removeAllListeners(this.chart_);
  this.chartDrawContext_ = {alive:!0};
  this.initializeGivenChartIsReady_(state);
  goog.dispose(this.renderer_);
  this.renderer_ = this.chart_.getDrawingFrame().getRenderer(1);
  goog.asserts.assert(this.renderer_);
  goog.dispose(this.eventHandler_);
  this.eventHandler_ = new goog.events.EventHandler;
  this.draw_();
};
google.visualization.RangeSelector.prototype.onChartReready_ = function(state) {
  google.visualization.events.removeAllListeners(this.chart_);
  this.initializeGivenChartIsReady_(state);
  this.updateUI_(google.visualization.RangeSelector.DragElement_.BOTH);
};
google.visualization.RangeSelector.prototype.initializeGivenChartIsReady_ = function(state) {
  this.chartDefinition_ = this.chart_.getChartDefinition();
  this.axisDefinition_ = this.getRangeAxisDefinition_();
  goog.asserts.assert(this.axisDefinition_.position);
  goog.asserts.assert(this.axisDefinition_.type == gviz.canviz.Options.AxisType.VALUE);
  this.axisRange_.pixel = this.getAxisPixelRange_();
  this.axisRange_.value = this.getAxisValueBound_();
  this.setMinRangePixel_();
  if (this.snapToData_ || this.centerSelectionAroundData_) {
    this.axisPixels_ = this.getAxisPixels_(this.dataTable_);
  }
  if (state) {
    var rangeValues = state.range, startValue = goog.isObject(rangeValues) ? rangeValues.start : null, endValue = goog.isObject(rangeValues) ? rangeValues.end : null;
    this.state_.range = this.getValidPixelRange_(startValue, endValue);
  }
};
google.visualization.RangeSelector.prototype.getRangeAxisDefinition_ = function() {
  return this.isVertical_ ? this.chartDefinition_.vAxes[0] : this.chartDefinition_.hAxes[0];
};
google.visualization.RangeSelector.prototype.getAxisPixelRange_ = function() {
  return{min:Math.min(this.axisDefinition_.startPos, this.axisDefinition_.endPos), max:Math.max(this.axisDefinition_.startPos, this.axisDefinition_.endPos)};
};
google.visualization.RangeSelector.prototype.getAxisValueBound_ = function() {
  var axisStartValue = this.axisDefinition_.position.toValue(this.axisDefinition_.startPos), axisEndValue = this.axisDefinition_.position.toValue(this.axisDefinition_.endPos);
  return{min:Math.min(axisStartValue, axisEndValue), max:Math.max(axisStartValue, axisEndValue)};
};
google.visualization.RangeSelector.prototype.draw_ = function() {
  var renderer = this.renderer_, chartDef = this.chartDefinition_, mainDrawingGroup = renderer.createCanvas(chartDef.width, chartDef.height), rangeSelectorDrawingGroup = renderer.createGroup(!1);
  renderer.appendChild(mainDrawingGroup, rangeSelectorDrawingGroup);
  var handleDef = google.visualization.RangeSelector.HandleDefinition_, ids = google.visualization.RangeSelector.ElementIds_, chartArea = chartDef.chartArea;
  goog.asserts.assert(this.fullScreenBrush_);
  goog.asserts.assert(this.sideScreenBrush_);
  renderer.drawRect(0, 0, chartDef.width, chartDef.height, this.fullScreenBrush_, rangeSelectorDrawingGroup);
  var fullScreen = renderer.drawRect(chartArea.left, chartArea.top, chartArea.width, chartArea.height, this.fullScreenBrush_, rangeSelectorDrawingGroup), minRect = this.getMinScreenRect_(), minScreen = renderer.drawRect(minRect.left, minRect.top, minRect.width, minRect.height, this.sideScreenBrush_, rangeSelectorDrawingGroup);
  this.idToElementMapping_[ids.SCREEN_MIN] = minScreen;
  var maxRect = this.getMaxScreenRect_(), maxScreen = renderer.drawRect(maxRect.left, maxRect.top, maxRect.width, maxRect.height, this.sideScreenBrush_, rangeSelectorDrawingGroup);
  this.idToElementMapping_[ids.SCREEN_MAX] = maxScreen;
  var minHandle = this.drawHandle_(this.state_.range.minPixel, chartArea, handleDef.thumbSize, handleDef.thumbCornerOffset, renderer, handleDef.brush, rangeSelectorDrawingGroup);
  this.idToElementMapping_[ids.HANDLE_MIN] = minHandle;
  var maxHandle = this.drawHandle_(this.state_.range.maxPixel, chartArea, handleDef.thumbSize, handleDef.thumbCornerOffset, renderer, handleDef.brush, rangeSelectorDrawingGroup);
  this.idToElementMapping_[ids.HANDLE_MAX] = maxHandle;
  var document = goog.dom.getOwnerDocument(this.container_);
  this.eventHandler_.listen(document.body, goog.events.EventType.MOUSEMOVE, goog.bind(this.handleDocumentMouseMove_, this, this.chartDrawContext_));
  this.eventHandler_.listen(document.body, goog.events.EventType.MOUSEUP, goog.bind(this.handleMouseUp_, this, this.chartDrawContext_));
  var rangeSelectorElement = rangeSelectorDrawingGroup.getElement();
  this.eventHandler_.listen(rangeSelectorElement, goog.events.EventType.MOUSEMOVE, goog.bind(this.handleSelectorMouseMove_, this, this.chartDrawContext_));
  this.eventHandler_.listen(rangeSelectorElement, goog.events.EventType.MOUSEOUT, goog.bind(this.handleMouseHover_, this, this.chartDrawContext_, {type:"screen", isOver:!1}));
  (this.containerIsSelectorsAncestor_ = goog.dom.getAncestor(rangeSelectorElement, function(e) {
    return e == document.body;
  })) || this.eventHandler_.listen(rangeSelectorElement, goog.events.EventType.MOUSEUP, goog.bind(this.handleMouseUp_, this, this.chartDrawContext_));
  this.fixedRangeSize_ || (this.addEventsForHandle_(minHandle, "min", google.visualization.RangeSelector.DragElement_.MIN), this.addEventsForHandle_(maxHandle, "max", google.visualization.RangeSelector.DragElement_.MAX));
  this.eventHandler_.listen(fullScreen, goog.events.EventType.MOUSEDOWN, goog.bind(this.handleMouseDown_, this, this.chartDrawContext_, {inDrag:google.visualization.RangeSelector.DragElement_.BOTH}));
  this.eventHandler_.listen(fullScreen, goog.events.EventType.MOUSEOVER, goog.bind(this.handleMouseHover_, this, this.chartDrawContext_, {type:"screen", isOver:!0}));
  this.eventHandler_.listen(fullScreen, goog.events.EventType.MOUSEOUT, goog.bind(this.handleMouseHover_, this, this.chartDrawContext_, {type:"screen", isOver:!1}));
  google.visualization.events.trigger(this, gviz.ChartEventType.READY, null);
};
google.visualization.RangeSelector.prototype.addEventsForHandle_ = function(handle, type, dragState) {
  this.eventHandler_.listen(handle, goog.events.EventType.MOUSEDOWN, goog.bind(this.handleMouseDown_, this, this.chartDrawContext_, {inDrag:dragState}));
  this.eventHandler_.listen(handle, goog.events.EventType.MOUSEOVER, goog.bind(this.handleMouseHover_, this, this.chartDrawContext_, {type:type, isOver:!0}));
  this.eventHandler_.listen(handle, goog.events.EventType.MOUSEOUT, goog.bind(this.handleMouseHover_, this, this.chartDrawContext_, {type:type, isOver:!1}));
};
google.visualization.RangeSelector.prototype.drawHandle_ = function(handlePixel, chartArea, thumbSize, thumbCornerOffset, renderer, brush, parentDrawingGroup) {
  var drawingGroup = renderer.createGroup(!1);
  renderer.appendChild(parentDrawingGroup, drawingGroup);
  var halfThumbWidth = .5 * thumbSize.width, offsetLeft = this.isVertical_ ? chartArea.left : this.adjustToHalfPixel_(handlePixel - halfThumbWidth), offsetTop = this.isVertical_ ? this.adjustToHalfPixel_(handlePixel - halfThumbWidth) : chartArea.top;
  renderer.setOffset(drawingGroup.getElement(), offsetLeft, offsetTop);
  this.isVertical_ ? (this.drawHandleLine_(0, Math.round(halfThumbWidth), chartArea.height, chartArea.width, renderer, brush, drawingGroup), this.fixedRangeSize_ || this.drawHandleThumb_(.5 * (chartArea.width - thumbSize.height), 0, thumbSize.height, thumbSize.width, thumbCornerOffset, renderer, brush, drawingGroup)) : (this.drawHandleLine_(Math.round(halfThumbWidth), 0, chartArea.height, chartArea.width, renderer, brush, drawingGroup), this.fixedRangeSize_ || this.drawHandleThumb_(0, .5 * (chartArea.height - 
  thumbSize.height), thumbSize.width, thumbSize.height, thumbCornerOffset, renderer, brush, drawingGroup));
  return drawingGroup.getElement();
};
google.visualization.RangeSelector.prototype.drawHandleLine_ = function(left, top, height, width, renderer, brush, drawingGroup) {
  var barPath;
  barPath = this.isVertical_ ? [{x:left, y:top}, {x:left + width, y:top}] : [{x:left, y:top}, {x:left, y:top + height}];
  var pathSegments = gviz.graphics.PathSegments.fromVertices(barPath);
  renderer.drawPath(pathSegments, brush, drawingGroup);
};
google.visualization.RangeSelector.prototype.drawHandleThumb_ = function(left, top, thumbWidth, thumbHeight, thumbCornerOffset, renderer, brush, drawingGroup) {
  var right = left + thumbWidth, bottom = top + thumbHeight, outlinePath = [{x:left + thumbCornerOffset, y:top}, {x:right - thumbCornerOffset, y:top}, {x:right, y:top + thumbCornerOffset}, {x:right, y:bottom - thumbCornerOffset}, {x:right - thumbCornerOffset, y:bottom}, {x:left + thumbCornerOffset, y:bottom}, {x:left, y:bottom - thumbCornerOffset}, {x:left, y:top + thumbCornerOffset}], pathSegments = gviz.graphics.PathSegments.fromVertices(outlinePath, !1);
  renderer.drawPath(pathSegments, brush, drawingGroup);
  var strokeOffset = thumbCornerOffset + 1, path1, path2;
  this.isVertical_ ? (path1 = gviz.graphics.PathSegments.fromVertices([{x:left + strokeOffset, y:top + strokeOffset}, {x:right - strokeOffset, y:top + strokeOffset}]), path2 = gviz.graphics.PathSegments.fromVertices([{x:left + strokeOffset, y:bottom - strokeOffset}, {x:right - strokeOffset, y:bottom - strokeOffset}])) : (path1 = gviz.graphics.PathSegments.fromVertices([{x:left + strokeOffset, y:top + strokeOffset}, {x:left + strokeOffset, y:bottom - strokeOffset}]), path2 = gviz.graphics.PathSegments.fromVertices([{x:right - 
  strokeOffset, y:top + strokeOffset}, {x:right - strokeOffset, y:bottom - strokeOffset}]));
  renderer.drawPath(path1, brush, drawingGroup);
  renderer.drawPath(path2, brush, drawingGroup);
};
google.visualization.RangeSelector.prototype.getMinScreenRect_ = function() {
  var chartArea = this.chartDefinition_.chartArea, min = this.state_.range.minPixel;
  return this.isVertical_ ? new goog.math.Rect(chartArea.left, chartArea.top, chartArea.width, min - chartArea.top) : new goog.math.Rect(chartArea.left, chartArea.top, min - chartArea.left, chartArea.height);
};
google.visualization.RangeSelector.prototype.getMaxScreenRect_ = function() {
  var chartArea = this.chartDefinition_.chartArea, max = this.state_.range.maxPixel;
  return this.isVertical_ ? new goog.math.Rect(chartArea.left, max, chartArea.width, chartArea.bottom - max) : new goog.math.Rect(max, chartArea.top, chartArea.right - max, chartArea.height);
};
google.visualization.RangeSelector.prototype.getValidPixelRange_ = function(startValue, endValue) {
  var minPixel = this.axisRange_.pixel.min, maxPixel = this.axisRange_.pixel.max, startIsMin = 1 == this.axisDefinition_.dataDirection && !this.isVertical_;
  if (goog.isDefAndNotNull(startValue)) {
    var startPixel = this.axisDefinition_.position.fromValue(startValue);
    startIsMin ? minPixel = Math.max(startPixel, minPixel) : maxPixel = Math.min(startPixel, maxPixel);
  }
  if (goog.isDefAndNotNull(endValue)) {
    var endPixel = this.axisDefinition_.position.fromValue(endValue);
    startIsMin ? maxPixel = Math.min(endPixel, maxPixel) : minPixel = Math.max(endPixel, minPixel);
  }
  return{minPixel:minPixel, maxPixel:maxPixel};
};
google.visualization.RangeSelector.prototype.getRange = function() {
  var range = this.state_.range;
  goog.asserts.assert(goog.isDefAndNotNull(range));
  var minValue = this.axisDefinition_.position.toValue(range.minPixel), maxValue = this.axisDefinition_.position.toValue(range.maxPixel), startIsMin = 1 == this.axisDefinition_.dataDirection && !this.isVertical_;
  return{start:startIsMin ? minValue : maxValue, end:startIsMin ? maxValue : minValue};
};
google.visualization.RangeSelector.prototype.setRange = function(startValue, endValue) {
  if (!this.chartDrawContext_.alive) {
    return!1;
  }
  var range = this.state_.range;
  goog.asserts.assert(goog.isDefAndNotNull(range));
  if (!goog.isDefAndNotNull(range.minPixel) || !goog.isDefAndNotNull(range.maxPixel)) {
    return!1;
  }
  var validPixelRange = this.getValidPixelRange_(startValue, endValue), rangeChanged = this.setRangeByPixel_(validPixelRange.minPixel, validPixelRange.maxPixel, google.visualization.RangeSelector.DragElement_.BOTH);
  this.state_.inDrag = null;
  return rangeChanged;
};
google.visualization.RangeSelector.prototype.setRangeByPixel_ = function(minPixel, maxPixel, dragElement) {
  goog.asserts.assert(minPixel <= maxPixel);
  var range = this.state_.range;
  if (range.minPixel == minPixel && range.maxPixel == maxPixel) {
    return!1;
  }
  this.state_.range = {minPixel:minPixel, maxPixel:maxPixel};
  this.updateUI_(dragElement);
  return!0;
};
google.visualization.RangeSelector.prototype.updateUI_ = function(dragElement) {
  var handleDefinition = google.visualization.RangeSelector.HandleDefinition_, thumbWidth = this.isVertical_ ? handleDefinition.thumbSize.height : handleDefinition.thumbSize.width, thumbHeight = this.isVertical_ ? handleDefinition.thumbSize.width : handleDefinition.thumbSize.height, ids = google.visualization.RangeSelector.ElementIds_;
  if (dragElement != google.visualization.RangeSelector.DragElement_.MAX) {
    var minRect = this.getMinScreenRect_(), minScreenElement = this.idToElementMapping_[ids.SCREEN_MIN], minHandleElement = this.idToElementMapping_[ids.HANDLE_MIN];
    if (this.isVertical_) {
      var top = this.adjustToHalfPixel_(minRect.top + minRect.height - .5 * thumbHeight);
      this.renderer_.setOffset(minHandleElement, 0, top);
      this.renderer_.setTopPosition(minScreenElement, minRect.top);
      this.renderer_.setHeight(minScreenElement, minRect.height);
    } else {
      var left = this.adjustToHalfPixel_(minRect.left + minRect.width - .5 * thumbWidth);
      this.renderer_.setOffset(minHandleElement, left, 0);
      this.renderer_.setLeftPosition(minScreenElement, minRect.left);
      this.renderer_.setWidth(minScreenElement, minRect.width);
    }
  }
  if (dragElement != google.visualization.RangeSelector.DragElement_.MIN) {
    var maxRect = this.getMaxScreenRect_(), maxScreenElement = this.idToElementMapping_[ids.SCREEN_MAX], maxHandleElement = this.idToElementMapping_[ids.HANDLE_MAX];
    this.isVertical_ ? (top = this.adjustToHalfPixel_(maxRect.top - .5 * thumbHeight), this.renderer_.setOffset(maxHandleElement, 0, top), this.renderer_.setTopPosition(maxScreenElement, maxRect.top), this.renderer_.setHeight(maxScreenElement, maxRect.height)) : (left = this.adjustToHalfPixel_(maxRect.left - .5 * thumbWidth), this.renderer_.setOffset(maxHandleElement, left, 0), this.renderer_.setLeftPosition(maxScreenElement, maxRect.left), this.renderer_.setWidth(maxScreenElement, maxRect.width));
  }
};
google.visualization.RangeSelector.prototype.updateUIAccordingToState_ = function() {
  this.updateUI_(this.state_.inDrag);
};
google.visualization.RangeSelector.prototype.calcAutoPanningRatio_ = function() {
  var axisLength = this.axisRange_.pixel.max - this.axisRange_.pixel.min, dataDirection = this.axisDefinition_.dataDirection, minHandleRatio = (this.state_.range.minPixel - this.axisRange_.pixel.min) / axisLength;
  if (.1 > minHandleRatio) {
    return{direction:-1 * dataDirection, ratio:minHandleRatio / .1};
  }
  var maxHandleRatio = (this.axisRange_.pixel.max - this.state_.range.maxPixel) / axisLength;
  return.1 > maxHandleRatio ? {direction:1 * dataDirection, ratio:maxHandleRatio / .1} : null;
};
google.visualization.RangeSelector.prototype.startStopAutoPanning_ = function() {
  if (this.zoomAroundSelection_) {
    var doAutoPanning = !1;
    if (this.state_.inDrag == google.visualization.RangeSelector.DragElement_.BOTH) {
      var autoPanningRatio = this.calcAutoPanningRatio_();
      autoPanningRatio && (doAutoPanning = !0);
    }
    doAutoPanning && !this.autoPanningTimer_ ? (this.autoPanningTimer_ = new goog.Timer(this.rangeChangeEventFiringRate_), this.eventHandler_.listen(this.autoPanningTimer_, goog.Timer.TICK, goog.bind(this.handleAutoPanning_, this)), this.autoPanningTimer_.start()) : !doAutoPanning && this.autoPanningTimer_ && (goog.dispose(this.autoPanningTimer_), this.autoPanningTimer_ = null);
  }
};
google.visualization.RangeSelector.prototype.handleAutoPanning_ = function() {
  if (this.autoPanningTimer_) {
    var autoPanningRatio = this.calcAutoPanningRatio_();
    goog.asserts.assert(autoPanningRatio);
    var timeForFullScroll = goog.math.lerp(1E3, 6E4, autoPanningRatio.ratio), moveRatio = this.rangeChangeEventFiringRate_ / timeForFullScroll, minDomainDataNumber = this.valueNumberConverter_.toNumber(this.minDomainDataValue_), maxDomainDataNumber = this.valueNumberConverter_.toNumber(this.maxDomainDataValue_), domainMoveNumber = (maxDomainDataNumber - minDomainDataNumber) * moveRatio, domainAxis = this.chartOptions_.domainAxis, domainViewWindow = domainAxis.viewWindow, domainViewWindowMinValue = 
    domainViewWindow.min, domainViewWindowMaxValue = domainViewWindow.max, domainViewWindowMinNumber = this.valueNumberConverter_.toNumber(domainViewWindowMinValue), domainViewWindowMaxNumber = this.valueNumberConverter_.toNumber(domainViewWindowMaxValue), newDomainViewWindowMinNumber, newDomainViewWindowMaxNumber;
    if (0 > autoPanningRatio.direction) {
      newDomainViewWindowMinNumber = Math.max(domainViewWindowMinNumber - domainMoveNumber, minDomainDataNumber);
      var actualDomainMoveNumber = domainViewWindowMinNumber - newDomainViewWindowMinNumber;
      newDomainViewWindowMaxNumber = domainViewWindowMaxNumber - actualDomainMoveNumber;
    } else {
      goog.asserts.assert(0 < autoPanningRatio.direction), newDomainViewWindowMaxNumber = Math.min(domainViewWindowMaxNumber + domainMoveNumber, maxDomainDataNumber), actualDomainMoveNumber = newDomainViewWindowMaxNumber - domainViewWindowMaxNumber, newDomainViewWindowMinNumber = domainViewWindowMinNumber + actualDomainMoveNumber;
    }
    var newDomainViewWindowMinValue = this.valueNumberConverter_.fromNumber(newDomainViewWindowMinNumber), newDomainViewWindowMaxValue = this.valueNumberConverter_.fromNumber(newDomainViewWindowMaxNumber);
    domainViewWindow.min = newDomainViewWindowMinValue;
    domainViewWindow.max = newDomainViewWindowMaxValue;
    google.visualization.events.addListener(this.chart_, gviz.ChartEventType.READY, goog.bind(this.onChartReready_, this, null));
    this.chart_.draw(this.dataTable_, this.chartOptions_);
    this.triggerRangeChange_(!0);
  }
};
google.visualization.RangeSelector.prototype.handleSelectorMouseMove_ = function(chartDrawContext, domEvent) {
  chartDrawContext.alive && goog.isDefAndNotNull(this.state_.inDrag) && (this.containerIsSelectorsAncestor_ || this.handleDrag_(domEvent), domEvent.target.style.cursor = "move");
};
google.visualization.RangeSelector.prototype.handleDocumentMouseMove_ = function(chartDrawContext, domEvent) {
  chartDrawContext.alive && goog.isDefAndNotNull(this.state_.inDrag) && this.handleDrag_(domEvent);
};
google.visualization.RangeSelector.prototype.handleDrag_ = function(domEvent) {
  var state = this.state_;
  state.range && goog.isDefAndNotNull(state.range.minPixel) && goog.isDefAndNotNull(state.range.maxPixel) || (state.range = {minPixel:this.axisRange_.pixel.min, maxPixel:this.axisRange_.pixel.max});
  var currentMousePos = goog.style.getClientPosition(domEvent), dragToPixel = this.isVertical_ ? currentMousePos.y : currentMousePos.x, deltaDragged = this.getValidDrag_(dragToPixel - state.draggedPixel);
  state.draggedPixel += deltaDragged;
  state.inDrag != google.visualization.RangeSelector.DragElement_.MAX && (state.range.minPixel += deltaDragged);
  state.inDrag != google.visualization.RangeSelector.DragElement_.MIN && (state.range.maxPixel += deltaDragged);
  this.startStopAutoPanning_();
  this.refreshScheduler_.updateCountdown(this.rangeChangeEventFiringRate_);
  this.eventFiringScheduler_.updateCountdown(this.rangeChangeEventFiringRate_);
};
google.visualization.RangeSelector.prototype.getValidDrag_ = function(deltaDragged) {
  var handle = this.state_.range, axis = this.axisRange_.pixel, validMinDrag, validMaxDrag, inDrag = this.state_.inDrag;
  switch(inDrag) {
    case google.visualization.RangeSelector.DragElement_.BOTH:
      validMinDrag = axis.min - handle.minPixel;
      validMaxDrag = axis.max - handle.maxPixel;
      break;
    case google.visualization.RangeSelector.DragElement_.MIN:
      validMinDrag = axis.min - handle.minPixel;
      validMaxDrag = handle.maxPixel - this.minRangeSizePixel_ - handle.minPixel;
      break;
    case google.visualization.RangeSelector.DragElement_.MAX:
      validMinDrag = handle.minPixel + this.minRangeSizePixel_ - handle.maxPixel;
      validMaxDrag = axis.max - handle.maxPixel;
      break;
    default:
      goog.asserts.fail('Invalid drag state "' + inDrag + '"');
  }
  return goog.math.clamp(deltaDragged, validMinDrag, validMaxDrag);
};
google.visualization.RangeSelector.prototype.handleMouseDown_ = function(chartDrawContext, eventData, domEvent) {
  if (chartDrawContext.alive && domEvent.isMouseActionButton()) {
    var currentMousePos = goog.style.getClientPosition(domEvent), state = this.state_;
    state.draggedPixel = this.isVertical_ ? currentMousePos.y : currentMousePos.x;
    state.inDrag = eventData.inDrag;
    this.startStopAutoPanning_();
    domEvent.preventDefault();
  }
};
google.visualization.RangeSelector.prototype.handleMouseUp_ = function(chartDrawContext) {
  if (chartDrawContext.alive) {
    var state = this.state_;
    if (!goog.isNull(state.inDrag)) {
      goog.asserts.assert(goog.isDefAndNotNull(state.range));
      if (this.snapToData_) {
        var axisPixels = this.axisPixels_, rangeMinPixel = state.range.minPixel, rangeMaxPixel = state.range.maxPixel, snappedMinPixel = gviz.util.findClosestValue(axisPixels, rangeMinPixel), snappedMaxPixel = gviz.util.findClosestValue(axisPixels, rangeMaxPixel);
        this.setRangeByPixel_(snappedMinPixel, snappedMaxPixel, state.inDrag);
      } else {
        if (this.centerSelectionAroundData_) {
          var range = new goog.math.Range(state.range.minPixel, state.range.maxPixel), rangeSize = range.end - range.start, axisRange = this.axisRange_.pixel, axisRangeSize = axisRange.max - axisRange.min;
          goog.asserts.assert(axisRangeSize > rangeSize || gviz.util.roughlyEquals(axisRangeSize, rangeSize, 1E-5));
          var axisPixels = this.axisPixels_, centeredRange = this.centerRangeAroundPoints_(range, axisPixels);
          centeredRange.start = Math.max(centeredRange.start, axisRange.min);
          centeredRange.end = centeredRange.start + rangeSize;
          centeredRange.end = Math.min(centeredRange.end, axisRange.max);
          centeredRange.start = centeredRange.end - rangeSize;
          this.setRangeByPixel_(centeredRange.start, centeredRange.end, state.inDrag);
        } else {
          if (this.zoomAroundSelection_ && state.inDrag != google.visualization.RangeSelector.DragElement_.BOTH) {
            var domainAxis = this.chartOptions_.domainAxis, domainViewWindow = domainAxis.viewWindow, valueRange = this.getRange();
            this.adjustZoomAroundSelection_(domainViewWindow, valueRange);
            var valueState = {range:valueRange};
            google.visualization.events.addListener(this.chart_, gviz.ChartEventType.READY, goog.bind(this.onChartReready_, this, valueState));
            this.chart_.draw(this.dataTable_, this.chartOptions_);
          }
        }
      }
      this.triggerRangeChange_(!1);
      state.inDrag = null;
      this.startStopAutoPanning_();
    }
  }
};
google.visualization.RangeSelector.prototype.centerRangeAroundPoints_ = function(range, points) {
  var isInsideRange = goog.bind(goog.math.Range.containsPoint, null, range), minPointInsideRange = goog.array.find(points, isInsideRange), maxPointInsideRange = goog.array.findRight(points, isInsideRange);
  if (goog.isNull(minPointInsideRange) || goog.isNull(maxPointInsideRange)) {
    var pointNearestMin = gviz.util.findClosestValue(points, range.start), pointNearestMax = gviz.util.findClosestValue(points, range.end), distFromMin = Math.abs(range.start - pointNearestMin), distFromMax = Math.abs(range.end - pointNearestMax), nearestPoint = distFromMin <= distFromMax ? pointNearestMin : pointNearestMax, maxPointInsideRange = minPointInsideRange = nearestPoint
  }
  var rangeSize = range.end - range.start, centeredRangeStart = goog.math.average(minPointInsideRange, maxPointInsideRange) - rangeSize / 2, centeredRangeEnd = centeredRangeStart + rangeSize, centeredRangeSize = centeredRangeEnd - centeredRangeStart;
  goog.asserts.assert(gviz.util.roughlyEquals(centeredRangeSize, rangeSize, 1E-5));
  return new goog.math.Range(centeredRangeStart, centeredRangeEnd);
};
google.visualization.RangeSelector.prototype.adjustZoomAroundSelection_ = function(domainViewWindow, selectedRangeValues) {
  var domainViewWindowMinValue = domainViewWindow.min, domainViewWindowMaxValue = domainViewWindow.max, domainViewWindowMinNumber = this.valueNumberConverter_.toNumber(domainViewWindowMinValue), domainViewWindowMaxNumber = this.valueNumberConverter_.toNumber(domainViewWindowMaxValue), domainViewWindowWidthNumber = domainViewWindowMaxNumber - domainViewWindowMinNumber;
  0 === domainViewWindowWidthNumber && (domainViewWindowMinNumber -= 1, domainViewWindowMaxNumber += 1, domainViewWindowWidthNumber = 2);
  var selectedMinValue = selectedRangeValues.start, selectedMaxValue = selectedRangeValues.end;
  if (goog.isDefAndNotNull(selectedMinValue) && goog.isDefAndNotNull(selectedMaxValue)) {
    var selectedMinNumber = this.valueNumberConverter_.toNumber(selectedMinValue), selectedMaxNumber = this.valueNumberConverter_.toNumber(selectedMaxValue), selectedWidthNumber = selectedMaxNumber - selectedMinNumber, minThreshold = .1 * domainViewWindowWidthNumber, maxThreshold = .6 * domainViewWindowWidthNumber;
    if (!(selectedWidthNumber >= minThreshold && selectedWidthNumber <= maxThreshold)) {
      var newSelectedWidthNumber;
      newSelectedWidthNumber = selectedWidthNumber < minThreshold ? .9 * maxThreshold : 1.1 * minThreshold;
      goog.asserts.assert(0 !== newSelectedWidthNumber, "Range too small");
      var selectedMiddleNumber = (selectedMinNumber + selectedMaxNumber) / 2, ratio = newSelectedWidthNumber / selectedWidthNumber, newDomainViewWindowWidthNumber = domainViewWindowWidthNumber / ratio, newDomainViewWindowNumber = new goog.math.Range(selectedMiddleNumber - newDomainViewWindowWidthNumber / 2, selectedMiddleNumber + newDomainViewWindowWidthNumber / 2);
      if (selectedWidthNumber < minThreshold) {
        this.positionRangeWithinBoundaries_(newDomainViewWindowNumber, new goog.math.Range(domainViewWindowMinNumber, domainViewWindowMaxNumber));
      } else {
        var minDomainDataNumber = this.valueNumberConverter_.toNumber(this.minDomainDataValue_), maxDomainDataNumber = this.valueNumberConverter_.toNumber(this.maxDomainDataValue_);
        this.positionRangeWithinBoundaries_(newDomainViewWindowNumber, new goog.math.Range(minDomainDataNumber, maxDomainDataNumber));
      }
      var newDomainViewWindowMinValue = this.valueNumberConverter_.fromNumber(newDomainViewWindowNumber.start), newDomainViewWindowMaxValue = this.valueNumberConverter_.fromNumber(newDomainViewWindowNumber.end);
      domainViewWindow.min = newDomainViewWindowMinValue;
      domainViewWindow.max = newDomainViewWindowMaxValue;
    }
  }
};
google.visualization.RangeSelector.prototype.positionRangeWithinBoundaries_ = function(range, boundaries) {
  range.start < boundaries.start && (range.end += boundaries.start - range.start, range.start = boundaries.start);
  range.end > boundaries.end && (range.start -= range.end - boundaries.end, range.end = boundaries.end);
  range.start < boundaries.start && (range.start = boundaries.start);
};
google.visualization.RangeSelector.prototype.adjustToHalfPixel_ = function(pixel) {
  return Math.floor(pixel) + .5;
};
google.visualization.RangeSelector.prototype.handleMouseHover_ = function(chartDrawContext, eventData, domEvent) {
  chartDrawContext.alive && !this.state_.inDrag && (domEvent.target.style.cursor = eventData.isOver ? "screen" == eventData.type ? "move" : this.isVertical_ ? "row-resize" : "col-resize" : "default");
};
google.visualization.RangeSelector.prototype.triggerRangeChange_ = function(inProgress) {
  var inDrag = this.state_.inDrag, range = this.getRange();
  if (goog.isDefAndNotNull(inDrag) && goog.isDefAndNotNull(range)) {
    var dragElement = google.visualization.RangeSelector.DragElement_, direction = this.axisDefinition_.dataDirection, startElement = 1 == direction ? dragElement.MIN : dragElement.MAX, endElement = 1 == direction ? dragElement.MAX : dragElement.MIN, startChanged = inDrag == startElement || inDrag == dragElement.BOTH, endChanged = inDrag == endElement || inDrag == dragElement.BOTH, eventDetails = {start:range.start, end:range.end, startChanged:startChanged, endChanged:endChanged, inProgress:inProgress};
    google.visualization.events.trigger(this, gviz.ChartEventType.RANGE_CHANGE, eventDetails);
  }
};
google.visualization.RangeSelector.prototype.stopScheduler_ = function(scheduler) {
  goog.dispose(scheduler);
};
google.visualization.RangeSelector.prototype.clearChart = function() {
  this.chart_ && (google.visualization.events.removeAllListeners(this.chart_), this.stopScheduler_(this.refreshScheduler_), this.refreshScheduler_ = null, this.stopScheduler_(this.eventFiringScheduler_), this.eventFiringScheduler_ = null, this.chartDrawContext_.alive = !1, goog.dispose(this.renderer_), this.renderer_ = null, goog.dispose(this.eventHandler_), this.eventHandler_ = null, this.chart_.clearChart(), this.chart_ = null, goog.events.removeAll(this));
};
// INPUT (javascript/gviz/devel/jsapi/fw/interactivity/tooltip-handler.js)
gviz.fw.interactivity.TooltipHandler = function(featureTypes) {
  gviz.fw.interactivity.BaseHandler.call(this, featureTypes, [gviz.fw.interactionEvents.OperationType.HOVER_IN, gviz.fw.interactionEvents.OperationType.HOVER_OUT]);
};
goog.inherits(gviz.fw.interactivity.TooltipHandler, gviz.fw.interactivity.BaseHandler);
gviz.fw.interactivity.TooltipHandler.prototype.changeState = function(featureId, operationType, state) {
  if (operationType == gviz.fw.interactionEvents.OperationType.HOVER_IN) {
    if (!featureId.equals(state.tooltipFeature)) {
      return state.tooltipFeature = featureId, !0;
    }
  } else {
    if (null != state.tooltipFeature) {
      return state.tooltipFeature = null, !0;
    }
  }
  return!1;
};
gviz.fw.interactivity.TooltipHandler.prototype.calcEffects = function(state) {
  return goog.isDefAndNotNull(state.tooltipFeature) ? [new gviz.fw.TargetedEffect(gviz.fw.EffectType.TOOLTIP, state.focusedFeature)] : [];
};
// INPUT (javascript/closure/events/inputhandler.js)
goog.events.InputHandler = function(element) {
  goog.events.EventTarget.call(this);
  this.timer_ = null;
  this.element_ = element;
  var emulateInputEvents = goog.userAgent.IE || goog.userAgent.WEBKIT && !goog.userAgent.isVersionOrHigher("531") && "TEXTAREA" == element.tagName;
  this.eventHandler_ = new goog.events.EventHandler(this);
  this.eventHandler_.listen(this.element_, emulateInputEvents ? ["keydown", "paste", "cut", "drop", "input"] : "input", this);
};
goog.inherits(goog.events.InputHandler, goog.events.EventTarget);
goog.events.InputHandler.EventType = {INPUT:"input"};
goog.events.InputHandler.prototype.handleEvent = function(e) {
  if ("input" == e.type) {
    goog.userAgent.IE && goog.userAgent.isVersionOrHigher(10) && 0 == e.keyCode && 0 == e.charCode || (this.cancelTimerIfSet_(), goog.userAgent.OPERA && this.element_ != goog.dom.getOwnerDocument(this.element_).activeElement || this.dispatchEvent(this.createInputEvent_(e)));
  } else {
    if ("keydown" != e.type || goog.events.KeyCodes.isTextModifyingKeyEvent(e)) {
      var valueBeforeKey = "keydown" == e.type ? this.element_.value : null;
      goog.userAgent.IE && e.keyCode == goog.events.KeyCodes.WIN_IME && (valueBeforeKey = null);
      var inputEvent = this.createInputEvent_(e);
      this.cancelTimerIfSet_();
      this.timer_ = goog.Timer.callOnce(function() {
        this.timer_ = null;
        this.element_.value != valueBeforeKey && this.dispatchEvent(inputEvent);
      }, 0, this);
    }
  }
};
goog.events.InputHandler.prototype.cancelTimerIfSet_ = function() {
  null != this.timer_ && (goog.Timer.clear(this.timer_), this.timer_ = null);
};
goog.events.InputHandler.prototype.createInputEvent_ = function(be) {
  var e = new goog.events.BrowserEvent(be.getBrowserEvent());
  e.type = goog.events.InputHandler.EventType.INPUT;
  return e;
};
goog.events.InputHandler.prototype.disposeInternal = function() {
  goog.events.InputHandler.superClass_.disposeInternal.call(this);
  this.eventHandler_.dispose();
  this.cancelTimerIfSet_();
  delete this.element_;
};
// INPUT (javascript/closure/ui/labelinput.js)
goog.ui.LabelInput = function(opt_label, opt_domHelper) {
  goog.ui.Component.call(this, opt_domHelper);
  this.label_ = opt_label || "";
};
goog.inherits(goog.ui.LabelInput, goog.ui.Component);
goog.tagUnsealableClass(goog.ui.LabelInput);
goog.ui.LabelInput.prototype.ffKeyRestoreValue_ = null;
goog.ui.LabelInput.prototype.labelRestoreDelayMs = 10;
goog.ui.LabelInput.isPlaceholderSupported_ = function() {
  goog.isDefAndNotNull(goog.ui.LabelInput.SUPPORTS_PLACEHOLDER_) || (goog.ui.LabelInput.SUPPORTS_PLACEHOLDER_ = "placeholder" in document.createElement("input"));
  return goog.ui.LabelInput.SUPPORTS_PLACEHOLDER_;
};
goog.ui.LabelInput.prototype.hasFocus_ = !1;
goog.ui.LabelInput.prototype.createDom = function() {
  this.setElementInternal(this.getDomHelper().createDom("input", {type:"text"}));
};
goog.ui.LabelInput.prototype.decorateInternal = function(element) {
  goog.ui.LabelInput.superClass_.decorateInternal.call(this, element);
  this.label_ || (this.label_ = element.getAttribute("label") || "");
  if (goog.dom.getActiveElement(goog.dom.getOwnerDocument(element)) == element) {
    this.hasFocus_ = !0;
    var el = this.getElement();
    goog.asserts.assert(el);
    goog.dom.classlist.remove(el, this.LABEL_CLASS_NAME);
  }
  goog.ui.LabelInput.isPlaceholderSupported_() && (this.getElement().placeholder = this.label_);
  var labelInputElement = this.getElement();
  goog.asserts.assert(labelInputElement, "The label input element cannot be null.");
  goog.a11y.aria.setState(labelInputElement, goog.a11y.aria.State.LABEL, this.label_);
};
goog.ui.LabelInput.prototype.enterDocument = function() {
  goog.ui.LabelInput.superClass_.enterDocument.call(this);
  this.attachEvents_();
  this.check_();
  this.getElement().labelInput_ = this;
};
goog.ui.LabelInput.prototype.exitDocument = function() {
  goog.ui.LabelInput.superClass_.exitDocument.call(this);
  this.detachEvents_();
  this.getElement().labelInput_ = null;
};
goog.ui.LabelInput.prototype.attachEvents_ = function() {
  var eh = new goog.events.EventHandler(this);
  eh.listen(this.getElement(), goog.events.EventType.FOCUS, this.handleFocus_);
  eh.listen(this.getElement(), goog.events.EventType.BLUR, this.handleBlur_);
  if (goog.ui.LabelInput.isPlaceholderSupported_()) {
    this.eventHandler_ = eh;
  } else {
    goog.userAgent.GECKO && eh.listen(this.getElement(), [goog.events.EventType.KEYPRESS, goog.events.EventType.KEYDOWN, goog.events.EventType.KEYUP], this.handleEscapeKeys_);
    var d = goog.dom.getOwnerDocument(this.getElement()), w = goog.dom.getWindow(d);
    eh.listen(w, goog.events.EventType.LOAD, this.handleWindowLoad_);
    this.eventHandler_ = eh;
    this.attachEventsToForm_();
  }
};
goog.ui.LabelInput.prototype.attachEventsToForm_ = function() {
  !this.formAttached_ && this.eventHandler_ && this.getElement().form && (this.eventHandler_.listen(this.getElement().form, goog.events.EventType.SUBMIT, this.handleFormSubmit_), this.formAttached_ = !0);
};
goog.ui.LabelInput.prototype.detachEvents_ = function() {
  this.eventHandler_ && (this.eventHandler_.dispose(), this.eventHandler_ = null);
};
goog.ui.LabelInput.prototype.disposeInternal = function() {
  goog.ui.LabelInput.superClass_.disposeInternal.call(this);
  this.detachEvents_();
};
goog.ui.LabelInput.prototype.LABEL_CLASS_NAME = "label-input-label";
goog.ui.LabelInput.prototype.handleFocus_ = function() {
  this.hasFocus_ = !0;
  var el = this.getElement();
  goog.asserts.assert(el);
  goog.dom.classlist.remove(el, this.LABEL_CLASS_NAME);
  if (!goog.ui.LabelInput.isPlaceholderSupported_() && !this.hasChanged() && !this.inFocusAndSelect_) {
    var me = this, clearValue = function() {
      me.getElement() && (me.getElement().value = "");
    };
    goog.userAgent.IE ? goog.Timer.callOnce(clearValue, 10) : clearValue();
  }
};
goog.ui.LabelInput.prototype.handleBlur_ = function() {
  goog.ui.LabelInput.isPlaceholderSupported_() || (this.eventHandler_.unlisten(this.getElement(), goog.events.EventType.CLICK, this.handleFocus_), this.ffKeyRestoreValue_ = null);
  this.hasFocus_ = !1;
  this.check_();
};
goog.ui.LabelInput.prototype.handleEscapeKeys_ = function(e) {
  27 == e.keyCode && (e.type == goog.events.EventType.KEYDOWN ? this.ffKeyRestoreValue_ = this.getElement().value : e.type == goog.events.EventType.KEYPRESS ? this.getElement().value = this.ffKeyRestoreValue_ : e.type == goog.events.EventType.KEYUP && (this.ffKeyRestoreValue_ = null), e.preventDefault());
};
goog.ui.LabelInput.prototype.handleFormSubmit_ = function() {
  this.hasChanged() || (this.getElement().value = "", goog.Timer.callOnce(this.handleAfterSubmit_, 10, this));
};
goog.ui.LabelInput.prototype.handleAfterSubmit_ = function() {
  this.hasChanged() || (this.getElement().value = this.label_);
};
goog.ui.LabelInput.prototype.handleWindowLoad_ = function() {
  this.check_();
};
goog.ui.LabelInput.prototype.hasFocus = function() {
  return this.hasFocus_;
};
goog.ui.LabelInput.prototype.hasChanged = function() {
  return!!this.getElement() && "" != this.getElement().value && this.getElement().value != this.label_;
};
goog.ui.LabelInput.prototype.clear = function() {
  this.getElement().value = "";
  null != this.ffKeyRestoreValue_ && (this.ffKeyRestoreValue_ = "");
};
goog.ui.LabelInput.prototype.reset = function() {
  this.hasChanged() && (this.clear(), this.check_());
};
goog.ui.LabelInput.prototype.setValue = function(s) {
  null != this.ffKeyRestoreValue_ && (this.ffKeyRestoreValue_ = s);
  this.getElement().value = s;
  this.check_();
};
goog.ui.LabelInput.prototype.getValue = function() {
  return null != this.ffKeyRestoreValue_ ? this.ffKeyRestoreValue_ : this.hasChanged() ? this.getElement().value : "";
};
goog.ui.LabelInput.prototype.setLabel = function(label) {
  var labelInputElement = this.getElement();
  goog.ui.LabelInput.isPlaceholderSupported_() ? (labelInputElement && (labelInputElement.placeholder = label), this.label_ = label) : this.hasChanged() || (labelInputElement && (labelInputElement.value = ""), this.label_ = label, this.restoreLabel_());
  labelInputElement && goog.a11y.aria.setState(labelInputElement, goog.a11y.aria.State.LABEL, this.label_);
};
goog.ui.LabelInput.prototype.getLabel = function() {
  return this.label_;
};
goog.ui.LabelInput.prototype.check_ = function() {
  var labelInputElement = this.getElement();
  goog.asserts.assert(labelInputElement, "The label input element cannot be null.");
  goog.ui.LabelInput.isPlaceholderSupported_() ? this.getElement().placeholder != this.label_ && (this.getElement().placeholder = this.label_) : this.attachEventsToForm_();
  goog.a11y.aria.setState(labelInputElement, goog.a11y.aria.State.LABEL, this.label_);
  if (this.hasChanged()) {
    el = this.getElement(), goog.asserts.assert(el), goog.dom.classlist.remove(el, this.LABEL_CLASS_NAME);
  } else {
    if (!this.inFocusAndSelect_ && !this.hasFocus_) {
      var el = this.getElement();
      goog.asserts.assert(el);
      goog.dom.classlist.add(el, this.LABEL_CLASS_NAME);
    }
    goog.ui.LabelInput.isPlaceholderSupported_() || goog.Timer.callOnce(this.restoreLabel_, this.labelRestoreDelayMs, this);
  }
};
goog.ui.LabelInput.prototype.setEnabled = function(enabled) {
  this.getElement().disabled = !enabled;
  var el = this.getElement();
  goog.asserts.assert(el);
  goog.dom.classlist.enable(el, this.LABEL_CLASS_NAME + "-disabled", !enabled);
};
goog.ui.LabelInput.prototype.isEnabled = function() {
  return!this.getElement().disabled;
};
goog.ui.LabelInput.prototype.restoreLabel_ = function() {
  !this.getElement() || this.hasChanged() || this.hasFocus_ || (this.getElement().value = this.label_);
};
// INPUT (javascript/closure/net/jsonp.js)
goog.net.Jsonp = function(uri, opt_callbackParamName) {
  this.uri_ = new goog.Uri(uri);
  this.callbackParamName_ = opt_callbackParamName ? opt_callbackParamName : "callback";
  this.timeout_ = 5E3;
};
goog.net.Jsonp.CALLBACKS = "_callbacks_";
goog.net.Jsonp.scriptCounter_ = 0;
goog.net.Jsonp.prototype.setRequestTimeout = function(timeout) {
  this.timeout_ = timeout;
};
goog.net.Jsonp.prototype.send = function(opt_payload, opt_replyCallback, opt_errorCallback, opt_callbackParamValue) {
  var payload = opt_payload || null, id = opt_callbackParamValue || "_" + (goog.net.Jsonp.scriptCounter_++).toString(36) + goog.now().toString(36);
  goog.global[goog.net.Jsonp.CALLBACKS] || (goog.global[goog.net.Jsonp.CALLBACKS] = {});
  var uri = this.uri_.clone();
  payload && goog.net.Jsonp.addPayloadToUri_(payload, uri);
  if (opt_replyCallback) {
    var reply = goog.net.Jsonp.newReplyHandler_(id, opt_replyCallback);
    goog.global[goog.net.Jsonp.CALLBACKS][id] = reply;
    uri.setParameterValues(this.callbackParamName_, goog.net.Jsonp.CALLBACKS + "." + id);
  }
  var deferred = goog.net.jsloader.load(uri.toString(), {timeout:this.timeout_, cleanupWhenDone:!0}), error = goog.net.Jsonp.newErrorHandler_(id, payload, opt_errorCallback);
  deferred.addErrback(error);
  return{id_:id, deferred_:deferred};
};
goog.net.Jsonp.prototype.cancel = function(request) {
  request && (request.deferred_ && request.deferred_.cancel(), request.id_ && goog.net.Jsonp.cleanup_(request.id_, !1));
};
goog.net.Jsonp.newErrorHandler_ = function(id, payload, opt_errorCallback) {
  return function() {
    goog.net.Jsonp.cleanup_(id, !1);
    opt_errorCallback && opt_errorCallback(payload);
  };
};
goog.net.Jsonp.newReplyHandler_ = function(id, replyCallback) {
  return function(var_args) {
    goog.net.Jsonp.cleanup_(id, !0);
    replyCallback.apply(void 0, arguments);
  };
};
goog.net.Jsonp.cleanup_ = function(id, deleteReplyHandler) {
  goog.global[goog.net.Jsonp.CALLBACKS][id] && (deleteReplyHandler ? delete goog.global[goog.net.Jsonp.CALLBACKS][id] : goog.global[goog.net.Jsonp.CALLBACKS][id] = goog.nullFunction);
};
goog.net.Jsonp.addPayloadToUri_ = function(payload, uri) {
  for (var name in payload) {
    payload.hasOwnProperty && !payload.hasOwnProperty(name) || uri.setParameterValues(name, payload[name]);
  }
  return uri;
};
;window.google&&window.google.loader&&window.google.loader.eval&&window.google.loader.eval.visualization&&(window.google.loader.eval.visualization=function(){eval(arguments[0])});
});
/*jsl:END*/
